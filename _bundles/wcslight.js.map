{"version":3,"file":"wcslight.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,WAAY,GAAIH,GACG,iBAAZC,QACdA,QAAkB,SAAID,IAEtBD,EAAe,SAAIC,GACpB,CATD,CASGK,MAAM,I,UCTLC,EACAC,E,eCAAC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaV,QAGrB,IAAIC,EAASM,EAAyBE,GAAY,CAGjDT,QAAS,CAAC,GAOX,OAHAY,EAAoBH,GAAUI,KAAKZ,EAAOD,QAASC,EAAQA,EAAOD,QAASQ,GAGpEP,EAAOD,OACf,CAGAQ,EAAoBM,EAAIF,ECxBxBJ,EAAoBO,EAAI,CAACf,EAASgB,KACjC,IAAI,IAAIC,KAAOD,EACXR,EAAoBU,EAAEF,EAAYC,KAAST,EAAoBU,EAAElB,EAASiB,IAC5EE,OAAOC,eAAepB,EAASiB,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDT,EAAoBe,EAAI,CAAC,EAGzBf,EAAoBgB,EAAKC,GACjBC,QAAQC,IAAIR,OAAOS,KAAKpB,EAAoBe,GAAGM,QAAO,CAACC,EAAUb,KACvET,EAAoBe,EAAEN,GAAKQ,EAASK,GAC7BA,IACL,KCNJtB,EAAoBuB,EAAKN,GAEZA,EAAU,MCHvBjB,EAAoBwB,EAAI,WACvB,GAA0B,iBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOC,MAAQ,IAAIC,SAAS,cAAb,EAChB,CAAE,MAAOX,GACR,GAAsB,iBAAXY,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxB5B,EAAoBU,EAAI,CAACmB,EAAKC,IAAUnB,OAAOoB,UAAUC,eAAe3B,KAAKwB,EAAKC,GNA9EjC,EAAa,CAAC,EACdC,EAAoB,YAExBE,EAAoBiC,EAAI,CAACC,EAAKC,EAAM1B,EAAKQ,KACxC,GAAGpB,EAAWqC,GAAQrC,EAAWqC,GAAKE,KAAKD,OAA3C,CACA,IAAIE,EAAQC,EACZ,QAAWnC,IAARM,EAEF,IADA,IAAI8B,EAAUC,SAASC,qBAAqB,UACpCC,EAAI,EAAGA,EAAIH,EAAQI,OAAQD,IAAK,CACvC,IAAIE,EAAIL,EAAQG,GAChB,GAAGE,EAAEC,aAAa,QAAUX,GAAOU,EAAEC,aAAa,iBAAmB/C,EAAoBW,EAAK,CAAE4B,EAASO,EAAG,KAAO,CACpH,CAEGP,IACHC,GAAa,GACbD,EAASG,SAASM,cAAc,WAEzBC,QAAU,QACjBV,EAAOW,QAAU,IACbhD,EAAoBiD,IACvBZ,EAAOa,aAAa,QAASlD,EAAoBiD,IAElDZ,EAAOa,aAAa,eAAgBpD,EAAoBW,GAExD4B,EAAOc,IAAMjB,GAEdrC,EAAWqC,GAAO,CAACC,GACnB,IAAIiB,EAAmB,CAACC,EAAMC,KAE7BjB,EAAOkB,QAAUlB,EAAOmB,OAAS,KACjCC,aAAaT,GACb,IAAIU,EAAU7D,EAAWqC,GAIzB,UAHOrC,EAAWqC,GAClBG,EAAOsB,YAActB,EAAOsB,WAAWC,YAAYvB,GACnDqB,GAAWA,EAAQG,SAASC,GAAQA,EAAGR,KACpCD,EAAM,OAAOA,EAAKC,EAAM,EAExBN,EAAUe,WAAWX,EAAiBY,KAAK,UAAM7D,EAAW,CAAE8D,KAAM,UAAWC,OAAQ7B,IAAW,MACtGA,EAAOkB,QAAUH,EAAiBY,KAAK,KAAM3B,EAAOkB,SACpDlB,EAAOmB,OAASJ,EAAiBY,KAAK,KAAM3B,EAAOmB,QACnDlB,GAAcE,SAAS2B,KAAKC,YAAY/B,EApCkB,CAoCX,EOvChDrC,EAAoBqE,EAAK7E,IACH,oBAAX8E,QAA0BA,OAAOC,aAC1C5D,OAAOC,eAAepB,EAAS8E,OAAOC,YAAa,CAAEC,MAAO,WAE7D7D,OAAOC,eAAepB,EAAS,aAAc,CAAEgF,OAAO,GAAO,E,MCL9D,IAAIC,EACAzE,EAAoBwB,EAAEkD,gBAAeD,EAAYzE,EAAoBwB,EAAEmD,SAAW,IACtF,IAAInC,EAAWxC,EAAoBwB,EAAEgB,SACrC,IAAKiC,GAAajC,IACbA,EAASoC,gBACZH,EAAYjC,EAASoC,cAAczB,MAC/BsB,GAAW,CACf,IAAIlC,EAAUC,EAASC,qBAAqB,UAC5C,GAAGF,EAAQI,OAEV,IADA,IAAID,EAAIH,EAAQI,OAAS,EAClBD,GAAK,KAAO+B,IAAc,aAAaI,KAAKJ,KAAaA,EAAYlC,EAAQG,KAAKS,GAE3F,CAID,IAAKsB,EAAW,MAAM,IAAIK,MAAM,yDAChCL,EAAYA,EAAUM,QAAQ,OAAQ,IAAIA,QAAQ,QAAS,IAAIA,QAAQ,YAAa,KACpF/E,EAAoBgF,EAAIP,C,WCbxB,IAAIQ,EAAkB,CACrB,IAAK,EACL,IAAK,GAGNjF,EAAoBe,EAAEmE,EAAI,CAACjE,EAASK,KAElC,IAAI6D,EAAqBnF,EAAoBU,EAAEuE,EAAiBhE,GAAWgE,EAAgBhE,QAAWd,EACtG,GAA0B,IAAvBgF,EAGF,GAAGA,EACF7D,EAASc,KAAK+C,EAAmB,QAC3B,CAGL,IAAIC,EAAU,IAAIlE,SAAQ,CAACmE,EAASC,IAAYH,EAAqBF,EAAgBhE,GAAW,CAACoE,EAASC,KAC1GhE,EAASc,KAAK+C,EAAmB,GAAKC,GAGtC,IAAIlD,EAAMlC,EAAoBgF,EAAIhF,EAAoBuB,EAAEN,GAEpDsE,EAAQ,IAAIT,MAgBhB9E,EAAoBiC,EAAEC,GAfFoB,IACnB,GAAGtD,EAAoBU,EAAEuE,EAAiBhE,KAEf,KAD1BkE,EAAqBF,EAAgBhE,MACRgE,EAAgBhE,QAAWd,GACrDgF,GAAoB,CACtB,IAAIK,EAAYlC,IAAyB,SAAfA,EAAMW,KAAkB,UAAYX,EAAMW,MAChEwB,EAAUnC,GAASA,EAAMY,QAAUZ,EAAMY,OAAOf,IACpDoC,EAAMG,QAAU,iBAAmBzE,EAAU,cAAgBuE,EAAY,KAAOC,EAAU,IAC1FF,EAAMI,KAAO,iBACbJ,EAAMtB,KAAOuB,EACbD,EAAMK,QAAUH,EAChBN,EAAmB,GAAGI,EACvB,CACD,GAEwC,SAAWtE,EAASA,EAE/D,CACD,EAcF,IAAI4E,EAAuB,CAACC,EAA4BC,KACvD,IAGI9F,EAAUgB,GAHT+E,EAAUC,EAAaC,GAAWH,EAGhBrD,EAAI,EAC3B,GAAGsD,EAASG,MAAMC,GAAgC,IAAxBnB,EAAgBmB,KAAa,CACtD,IAAInG,KAAYgG,EACZjG,EAAoBU,EAAEuF,EAAahG,KACrCD,EAAoBM,EAAEL,GAAYgG,EAAYhG,IAG7CiG,GAAsBA,EAAQlG,EAClC,CAEA,IADG8F,GAA4BA,EAA2BC,GACrDrD,EAAIsD,EAASrD,OAAQD,IACzBzB,EAAU+E,EAAStD,GAChB1C,EAAoBU,EAAEuE,EAAiBhE,IAAYgE,EAAgBhE,IACrEgE,EAAgBhE,GAAS,KAE1BgE,EAAgBhE,GAAW,CAC5B,EAIGoF,EAAqBzG,KAA2B,qBAAIA,KAA2B,sBAAK,GACxFyG,EAAmBxC,QAAQgC,EAAqB7B,KAAK,KAAM,IAC3DqC,EAAmBjE,KAAOyD,EAAqB7B,KAAK,KAAMqC,EAAmBjE,KAAK4B,KAAKqC,G,mcC9EhF,MAAMC,EACT,WAAAC,CAAY9F,EAAK+D,EAAOgC,GACpB9E,KAAK+E,UAAetG,IAARM,EAAoBA,OAAMN,EACtCuB,KAAKgF,YAAmBvG,IAAVqE,EAAsBA,OAAQrE,EAC5CuB,KAAKiF,cAAuBxG,IAAZqG,EAAwBA,OAAUrG,CACtD,CACA,OAAIM,GACA,OAAOiB,KAAK+E,IAChB,CACA,WAAID,GACA,OAAO9E,KAAKiF,QAChB,CACA,SAAInC,GACA,OAAO9C,KAAKgF,MAChB,ECbG,MAAME,UAAmBC,IAC5B,WAAAN,GACIO,QACApF,KAAKqF,aAAU5G,EACfuB,KAAKsF,OAAS,EAClB,CACA,UAAIC,CAAOA,GACPvF,KAAKqF,QAAUE,CACnB,CACA,UAAIA,GACA,OAAOvF,KAAKqF,OAChB,CACA,WAAAG,GACI,OAAOxF,KAAKsF,MAChB,CACA,aAAAG,CAAc1G,GACV,MAAM2G,EAAM,GACZ,IAAK,IAAI1E,EAAI,EAAGA,EAAIhB,KAAKsF,OAAOrE,OAAQD,IAAK,CACzC,MAAM2E,EAAO3F,KAAKsF,OAAOtE,GACrB2E,EAAK5G,KAAOA,GACZ2G,EAAIhF,KAAKiF,EAEjB,CACA,OAAOD,CACX,CACA,qBAAAE,CAAsBD,QACDlH,IAAbkH,EAAK5G,KACD,CACA,SACA,SACA,QACA,SACA,SACA,QACA,QACA,SACA,UACA,UACA,OACA,QACA,SACA,SACA,SACA,SACA,SACA,UACF8G,SAASF,EAAK5G,MACZiB,KAAK8F,IAAIH,EAAK5G,IAAK4G,EAAK7C,OAGhC,MAAMiD,EAAc,CAACJ,GAAMK,OAAOhG,KAAKsF,QACvCtF,KAAKsF,OAASS,CAClB,CACA,OAAAE,CAAQN,QACalH,IAAbkH,EAAK5G,KACD,CACA,SACA,SACA,QACA,SACA,SACA,QACA,QACA,SACA,UACA,UACA,OACA,QACA,SACA,SACA,SACA,SACA,SACA,UACF8G,SAASF,EAAK5G,MACZiB,KAAK8F,IAAIH,EAAK5G,IAAK4G,EAAK7C,OAGhC9C,KAAKsF,OAAO5E,KAAKiF,EACrB,CACA,UAAAO,GACI,OAAOlG,KAAKsF,OAAOrE,MACvB,ECnFG,MAAMkF,EACT,kBAAOC,CAAY/B,EAAMkB,EAAQtE,GAC7B,MAAMoF,EAAQ,GACd,IAAK,IAAIrF,EAAIuE,EAAQ/B,EAAI,EAAGxC,EAAIuE,EAAStE,EAAQD,IAAKwC,IAClD6C,EAAM7C,GAAK8C,OAAOC,aAAkC,IAArBlC,EAAKmC,WAAWxF,IAEnD,OAAOqF,EAAMI,KAAK,GACtB,CACA,iBAAOC,CAAWC,GACd,GAAIA,EAAI,GAAKA,EAAI,KAAOA,EAAI,GAAM,EAC9B,MAAM,IAAIvD,MAAMuD,EAAI,2BAExB,OAAQ,YAAcA,EAAEC,SAAS,IAAIC,QAAQ,EACjD,CACA,6CAAOC,CAAuCC,EAAOC,EAAOC,EAAOC,GAC/D,IAAIC,KAAYJ,GAAS,GAAKC,GAAU,GAAKC,GAAU,GAAKC,EAK5D,OAJIC,EAAO,IACPA,GAAQ,aACG,GAAc,QAAPA,GAAqB,SACvCC,KAAKC,IAAI,IAAY,WAAPF,IAAsB,IAAM,IAElD,CACA,0BAAOG,CAAoBC,EAAOC,GAC9B,IAAIC,EAAML,KAAKM,IAAIH,GAAOX,SAAS,GACnC,KAAOa,EAAIxG,OAAS,EAAIuG,GACpBC,GAAO,IAEX,MAAME,EAAS,IAAIC,YAAYJ,GACzBK,EAAQ,IAAIC,WAAWH,GAC7B,IAAK,IAAI3G,EAAI,EAAGA,EAAIwG,EAAQxG,IACxB6G,EAAM7G,GAAK+G,SAASN,EAAIZ,OAAO,EAAI7F,EAAG,GAAKA,EAAI,IAAK,GAExD,OAAO6G,CACX,CAEA,+BAAOG,CAAyBC,EAAOC,EAAOC,GAE1C,MAAMC,EAAO,GACb,IAAK,IAAIpH,EAAIiH,EAAMhH,OAAQD,EAAGA,GAAK,EAAG,CAClC,IAAIqH,EAAOJ,EAAMjH,EAAI,GACrB,IAAK,IAAIwC,EAAI,EAAGA,EAAGA,GAAK,EACpB4E,EAAK1H,KAAK2H,EAAO,EAAI,EAAI,GACzBA,IAAe,CAEvB,CACAD,EAAKE,UACL,MAAMb,EAAMW,EAAK3B,KAAK,IAEhB8B,GAAQ,GAAML,EAAQ,GAAM,EAC5BhH,EAAI6G,SAASN,EAAIe,UAAU,EAAG,GAAI,IAAM,EAAI,EAC5ClJ,EAAIyI,SAASN,EAAIe,UAAU,EAAG,EAAIN,GAAQ,GAC1C7I,EAAI0I,SAASN,EAAIe,UAAU,EAAIN,GAAQ,GAE7C,OAAI5I,KAAO,GAAK4I,GAAS,EACR,IAAN7I,OAAUZ,EAAYyC,GAAIuH,KAE5BnJ,EAAI,EACF4B,EAAIkG,KAAKC,IAAI,EAAG/H,EAAIiJ,IAAS,EAAIlJ,EAAI+H,KAAKC,IAAI,EAAGc,IAE7C,IAAN9I,EACE6B,EAAIkG,KAAKC,IAAI,IAAKkB,EAAO,KAAOlJ,EAAI+H,KAAKC,IAAI,EAAGc,IAG5C,EAAJjH,CAEf,CACA,gCAAOwH,CAA0BC,GAC7B,MAAM,IAAIC,UAAU,sBAAwBD,EAChD,CACA,6BAAOE,CAAuB9B,EAAOC,GACjC,MAAM8B,EAAY/B,GAAS,EAAKC,EAChC,OAAe,MAAX8B,EACkB,WAAXA,EAGAA,CAEf,CACA,6BAAOC,CAAuBhC,EAAOC,EAAOC,EAAOC,GAC/C,MAAM4B,EAAY/B,GAAS,GAAOC,GAAS,GAAOC,GAAS,EAAKC,EAEhE,IAAIxB,EAAiB,WAAXoD,EACV,OAFsB,WAAXA,IAA0B,IAGjCpD,EAAiC,GAAd,YAAXoD,IACA,EAAIpD,GAETA,CACX,CAOA,gBAAOsD,CAAU3E,EAAMkB,GAEnB,OAA8C,IAAvClB,EAAKmC,WAAWjB,EADJ,EAEvB,CACA,wBAAO0D,CAAkB1D,EAAQ0C,EAAOiB,GACpC,IAAIC,EAEJ,GAAc,GAAVD,EACAC,EAASlB,EAAM,QAEd,GAAc,IAAViB,EAELC,EAAShD,EAAW0C,uBAAuBZ,EAAM1C,GAAS0C,EAAM1C,EAAS,SAExE,GAAc,IAAV2D,EAELC,EAAShD,EAAW4C,uBAAuBd,EAAM1C,GAAS0C,EAAM1C,EAAS,GAAI0C,EAAM1C,EAAS,GAAI0C,EAAM1C,EAAS,SAE9G,IAAe,IAAX2D,EAGLC,EAAShD,EAAW6B,yBAAyBC,EAAMmB,MAAM7D,EAAQA,EAAS,GAAI,EAAG,QAEhF,IAAc,IAAV2D,EAEL,MAAM,IAAI9F,MAAM,yEAEA,IAAX8F,IAGLC,EAAShD,EAAW6B,yBAAyBC,EAAMmB,MAAM7D,EAAQA,EAAS,GAAI,GAAI,IACtF,CACA,OAAO4D,CACX,EChHG,MAAME,EACT,WAAAxE,GACI7E,KAAKsJ,aAAe,IAAIxB,WACxB9H,KAAKuJ,cAAgB,IAAIC,MACzBxJ,KAAKyJ,UAAY,IAAI3B,UACzB,CACA,GAAA4B,CAAIC,EAAQC,GACR5J,KAAK6J,cAAcF,GACnB3J,KAAKuJ,cAAgBK,EACrB5J,KAAK8J,aACT,CACA,aAAAD,CAAcE,GACV,MAAMpE,EAAO,IAAIf,EAAe,OAChCmF,EAAc9D,QAAQN,GACtB,IAAI8B,EAAM,GACV,IAAK,IAAIzG,EAAI,EAAGA,EAAI+I,EAAcvE,cAAcvE,OAAQD,IAAK,CACzD,MAAM2E,EAAOoE,EAAcvE,cAAcxE,GACzC,IAAIE,EAAIlB,KAAKgK,iBAAiBrE,QACpBlH,IAANyC,IACAuG,GAAOvG,EAEf,CACA,MAAM+I,GAAa,IAAIC,aAAcC,OAAO1C,GAAKxG,OAE3CsE,EAAgB,KADT6B,KAAKgD,KAAKH,EAAa,MAEpC,IAAK,IAAIzG,EAAI,EAAGA,EAAI+B,EAAS0E,EAAYzG,IACrCiE,GAAO,IAEX,MAAM4C,EAAK,IAAIzC,YAAYH,EAAIxG,QAE/BjB,KAAKsJ,aAAe,IAAIxB,WAAWuC,GACnC,IAAK,IAAIrJ,EAAI,EAAGA,EAAIyG,EAAIxG,OAAQD,IAC5BhB,KAAKsJ,aAAatI,GAAKmF,EAAW6C,UAAUvB,EAAKzG,EAEzD,CAEA,gBAAAgJ,CAAiBrE,GACb,IAAI8B,EACA6C,EAAU3E,EAAK5G,IACf+D,EAAQ6C,EAAK7C,MACbgC,EAAUa,EAAKb,QACnB,GAAIwF,QAA2C,CAE3C,GADA7C,EAAM6C,EACS,OAAXA,EAAkB,CAClB,IAAK,IAAI9G,EAAI,GAAIA,EAAI8G,EAAQrJ,OAAQuC,IACjCiE,GAAO,IAEX,OAAOA,CACX,CACA,GAAe,WAAX6C,GAAmC,WAAXA,EAAsB,CAC9C,IAAK,IAAItJ,EAAI,EAAGA,EAAI,GAAKsJ,EAAQrJ,OAAQD,IACrCyG,GAAO,IAEXA,GAAO3E,EACP,MAAMyH,EAAM9C,EAAIxG,OAChB,IAAK,IAAIuC,EAAI,GAAIA,EAAI+G,EAAK/G,IACtBiE,GAAO,IAEX,OAAOA,CACX,CACA,IAAK,IAAIzG,EAAI,EAAGA,EAAI,EAAIsJ,EAAQrJ,OAAQD,IACpCyG,GAAO,IAGX,GADAA,GAAO,KACH3E,QAAuC,CAEvC2E,GAAO3E,EACHgC,UACA2C,GAAO3C,GAEX,MAAMyF,EAAM9C,EAAIxG,OAChB,IAAK,IAAIuC,EAAI,GAAIA,EAAI+G,EAAK/G,IACtBiE,GAAO,GAEf,KACK,CACG3C,UACA2C,GAAO3C,GAEX,MAAMyF,EAAM9C,EAAIxG,OAChB,IAAK,IAAIuC,EAAI,GAAIA,EAAI+G,EAAK/G,IACtBiE,GAAO,GAEf,CACJ,KACK,CAEDA,EAAM,GACN,IAAK,IAAIjE,EAAI,EAAGA,EAAI,GAAIA,IACpBiE,GAAO,IAEX,GAAI3C,QAA2C,CAC3C2C,GAAO3C,EACP,MAAMyF,EAAM9C,EAAIxG,OAChB,IAAK,IAAIuC,EAAI,GAAIA,EAAI+G,EAAK/G,IACtBiE,GAAO,GAEf,KACK,CACDA,EAAM,GACN,IAAK,IAAIjE,EAAI,GAAIA,EAAI,EAAGA,IACpBiE,GAAO,GAEf,CACJ,CACA,OAAOA,CACX,CACA,WAAAqC,GACI,MAAM7B,EAAQ,IAAIH,WAAW9H,KAAKsJ,aAAarI,OAC3CjB,KAAKuJ,cAAc,GAAGtI,OAASjB,KAAKuJ,cAActI,QACtDgH,EAAMnC,IAAI9F,KAAKsJ,aAAc,GAC7B,IAAK,IAAItI,EAAI,EAAGA,EAAIhB,KAAKuJ,cAActI,OAAQD,IAAK,CAChD,MAAM6G,EAAQ7H,KAAKuJ,cAAcvI,GACjCiH,EAAMnC,IAAI+B,EAAO7H,KAAKsJ,aAAarI,OAASD,EAAI6G,EAAM5G,OAC1D,CACAjB,KAAKyJ,UAAYxB,CACrB,CAWA,eAAAuC,GACI,MAAMC,EAAI,IAAIC,KAAK,CAAC1K,KAAKyJ,WAAY,CAAElH,KAAM,qBAE7C,OAAOoI,IAAIC,gBAAgBH,EAC/B,EChJG,MAAMI,EACT,WAAAhG,CAAYiG,EAAYlB,GACpB5J,KAAK+K,QAAU,IAAIjD,WACnB9H,KAAKgL,YAASvM,EACduB,KAAKiL,aAAUxM,EACfuB,KAAKkL,YAASzM,EACduB,KAAKmL,aAAU1M,EACfuB,KAAKoL,aAAU3M,EACfuB,KAAKqL,aAAU5M,EACfuB,KAAKsL,cAAW7M,EAChBuB,KAAKuL,cAAW9M,EAChBuB,KAAKwL,oBAAiB/M,EACtB,MAAMkJ,EAASiC,EAAQR,MAAM0B,EAAWvF,QACxCvF,KAAK+K,QAAU,IAAIjD,WAAWH,GAC9B3H,KAAKyL,KAAKX,EACd,CACA,IAAAW,CAAKX,GAiBD,GAhBA9K,KAAKgL,OAASF,EAAW1L,IAAI,cACTX,IAAhBuB,KAAKgL,SACLhL,KAAKgL,OAAS,GAElBhL,KAAKiL,QAAUH,EAAW1L,IAAI,eACTX,IAAjBuB,KAAKiL,UACLjL,KAAKiL,QAAU,GAEnBjL,KAAKkL,OAASJ,EAAW1L,IAAI,SAE7BY,KAAKmL,QAAUL,EAAW1L,IAAI,UAC9BY,KAAKoL,QAAUN,EAAW1L,IAAI,UAC9BY,KAAKqL,QAAUP,EAAW1L,IAAI,UAC9BY,KAAKsL,SAAWR,EAAW1L,IAAI,WAC/BY,KAAKuL,SAAWT,EAAW1L,IAAI,WAC/BY,KAAKwL,oBAAiB/M,OACAA,IAAlBuB,KAAKuL,eAA4C9M,IAAlBuB,KAAKsL,SAAwB,CAC5D,MAAOI,EAAKC,GAAO3L,KAAK4L,2BACxB5L,KAAKuL,SAAWI,EAChB3L,KAAKsL,SAAWI,EAChB,MAAMG,EAAU,IAAIjH,EAAe,UAAW+G,EAAK,+BAC7CG,EAAU,IAAIlH,EAAe,UAAW8G,EAAK,+BACnDZ,EAAW7E,QAAQ4F,GACnBf,EAAW7E,QAAQ6F,EAGvB,CAGJ,CACA,wBAAAF,GACI,IAAI5K,EAAI,EACR,QAAqBvC,IAAjBuB,KAAKmL,QACL,MAAM,IAAI/H,MAAM,yBAEpB,MAAM2I,EAAa3E,KAAKM,IAAI1H,KAAKmL,QAAU,GACrCa,EAAWhM,KAAK+K,QAAQkB,WAAaF,EAC3C,IAAI5C,EAAQ+C,EACRR,EACAC,EAIJ,SAHoBlN,IAAhBuB,KAAKkL,SACLlL,KAAKwL,eAAiBxL,KAAKmM,oBAAoBnM,KAAKkL,SAEjDlK,EAAIgL,GAEP7C,EAASnJ,KAAKiJ,kBAAkB8C,EAAa/K,QAC9BvC,IAAX0K,GAIJ+C,EAASlM,KAAKmM,oBAAoBhD,QACtB1K,IAARiN,IACAA,EAAMQ,QAEEzN,IAARkN,IACAA,EAAMO,QAGkBzN,IAAxBuB,KAAKwL,gBAAgCxL,KAAKwL,iBAAmBU,SAC9CzN,IAAXyN,IAAyBA,EAASR,QAAejN,IAARiN,KACzCA,EAAMQ,QAEKzN,IAAXyN,IAAyBA,EAASP,QAAelN,IAARkN,KACzCA,EAAMO,IAGdlL,KAnBIA,IAqBR,MAAO,CAAC0K,EAAKC,EACjB,CACA,KAAAS,GAGI,QAAqB3N,IAAjBuB,KAAKmL,QACL,MAAM,IAAI/H,MAAM,uBAEpB,QAAqB3E,IAAjBuB,KAAKoL,QACL,MAAM,IAAIhI,MAAM,uBAEpB,QAAqB3E,IAAjBuB,KAAKqL,QACL,MAAM,IAAIjI,MAAM,uBAEpB,MAAM2I,EAAa3E,KAAKM,IAAI1H,KAAKmL,QAAU,GAC3C,IAAIa,EAAWhM,KAAK+K,QAAQkB,WAAaF,EACzCC,EAAWhM,KAAKoL,QAAUpL,KAAKqL,QAC/B,IACIgB,EAAG1J,EADH2J,EAAI,EAER,MAAMC,EAAc,GAEpB,KAAOD,EAAIN,GAAU,CACjBrJ,EAAIyE,KAAKoF,MAAMF,EAAItM,KAAKoL,SACxBiB,GAAKC,EAAI3J,EAAI3C,KAAKoL,SAAWW,EACnB,IAANM,IACAE,EAAY5J,GAAK,IAAImF,WAAW9H,KAAKoL,QAAUW,IAMnD,IAAK,IAAI/K,EAAI,EAAGA,EAAI+K,EAAY/K,IAC5BuL,EAAY5J,GAAG0J,EAAIrL,GAAKhB,KAAK+K,QAAQuB,EAAIP,EAAa/K,GAM1DsL,GACJ,CACA,OAAOC,CACX,CAEA,iBAAAtD,CAAkB1D,GACd,IAAI4D,EACJ,GAAoB,IAAhBnJ,KAAKmL,QAELhC,EAAShD,EAAW0C,uBAAuB7I,KAAK+K,QAAQxF,GAASvF,KAAK+K,QAAQxF,EAAS,SAEtF,GAAoB,IAAhBvF,KAAKmL,QAEVhC,EAAShD,EAAW4C,uBAAuB/I,KAAK+K,QAAQxF,GAASvF,KAAK+K,QAAQxF,EAAS,GAAIvF,KAAK+K,QAAQxF,EAAS,GAAIvF,KAAK+K,QAAQxF,EAAS,SAE1I,IAAqB,IAAjBvF,KAAKmL,QAGVhC,EAAShD,EAAW6B,yBAAyBhI,KAAK+K,QAAQ3B,MAAM7D,EAAQA,EAAS,GAAI,EAAG,QAEvF,IAAoB,IAAhBvF,KAAKmL,QAEV,MAAM,IAAI/H,MAAM,yEAEM,IAAjBpD,KAAKmL,UAGVhC,EAAShD,EAAW6B,yBAAyBhI,KAAK+K,QAAQ3B,MAAM7D,EAAQA,EAAS,GAAI,GAAI,IAC7F,CACA,OAAO4D,CACX,CACA,mBAAAgD,CAAoBM,GAChB,QAAoBhO,IAAhBuB,KAAKgL,aAAyCvM,IAAjBuB,KAAKiL,QAClC,MAAM,IAAI7H,MAAM,uCAEpB,OAAOpD,KAAKgL,OAAShL,KAAKiL,QAAUwB,CACxC,EC/JG,MAAMC,EACT,YAAON,CAAMxC,GAIT,MAAM+C,EAAc,IAAIC,YAAY,cAC9BjD,EAAS,IAAIzE,EACnB,IAEIyD,EACAkE,EACAC,EACAC,EACAC,EAEArH,EACAsH,EATAC,EAAQ,EACRnO,EAAM,GAUV,IADA4G,EAAO,KACQ,QAAR5G,GAAiB6K,EAAQ3I,OAAS,GAAG,CAexC,GAbA4L,EAAS,IAAI/E,WAAW8B,EAAQR,MAAc,GAAR8D,EAAoB,GAARA,EAAa,KAC/DA,IAEAJ,EAAQ,IAAIhF,WAAW+E,EAAOzD,MAAM,EAAG,IACvCrK,EAAM4N,EAAYQ,OAAOL,GAAOM,OAEhCJ,EAAQ,IAAIlF,WAAW+E,EAAOzD,MAAM,EAAG,KAGvC2D,EAAQ,IAAIjF,WAAW+E,EAAOzD,MAAM,GAAI,KACxCT,EAAMgE,EAAYQ,OAAOJ,GAAOK,OAGhB,IAAZJ,EAAM,IAAwB,IAAZA,EAAM,GAAU,CAClC,IAAIK,EAAY,GAChB,IAAK,IAAIrM,EAAI,EAAGA,EAAI+L,EAAM9L,OAAQD,IAC9B,GAAgB,IAAZ+L,EAAM/L,GAAU,CAChBqM,EAAYN,EAAM/L,GAClB,KACJ,CAGa,IAAbqM,GAAoBC,OAAO3E,GAQV,IAAb0E,GAAgC,IAAbA,EAEnBJ,EAAWP,EAAYa,kBAAkBR,IAGzCpE,EAAMgE,EAAYQ,OAAOJ,GAAOK,OAE5BH,EADAtE,EAAI9C,SAAS,KACF6G,EAAYc,gBAAgBT,GAG5BL,EAAYe,cAAcV,IAf7CE,EAAWP,EAAYa,kBAAkBR,GAmB7CpH,EAAO,IAAIf,EAAe7F,EAAKkO,EAAStE,IAAKsE,EAASnI,QAC1D,MAEI,GAAW,WAAP/F,GAA2B,WAAPA,EACpB4G,EAAO,IAAIf,EAAe7F,OAAKN,EAAWkK,OAEzC,CACD,IAAI0E,EAAY,GAChB,IAAK,IAAIrM,EAAI,EAAGA,EAAI+L,EAAM9L,OAAQD,IAC9B,GAAgB,IAAZ+L,EAAM/L,GAAU,CAChBqM,EAAYN,EAAM/L,GAClB,KACJ,CAEa,IAAbqM,EAEA1H,EAAO,IAAIf,OAAenG,OAAWA,EAAWkK,GAE9B,IAAb0E,IAEL1H,EAAO,IAAIf,OAAenG,OAAWA,OAAWA,GAExD,CAEQ,MAARkH,GACAgE,EAAO1D,QAAQN,EAEvB,CACAA,EAAO,IAAIf,EAAe,UAAW,0CAAsCnG,GAC3EkL,EAAO1D,QAAQN,GACf,MAAM+H,EAAM,IAAIC,KAChBhI,EAAO,IAAIf,EAAe,UAAW8I,EAAI9G,YACzC+C,EAAO1D,QAAQN,GACf,MACMJ,EAAkB,KADT6B,KAAKgD,KAAK8C,EAAQ,IAGjC,OADAvD,EAAOpE,OAASA,EACToE,CACX,CACA,uBAAOiE,CAAiBC,GACpB,MACMC,EADc,IAAIlB,YAAY,cACRO,OAAOU,GAAUT,OACvCW,EAAMD,EAAQE,YAAY,KAMhC,MAAO,CACHrF,IANQmF,EAAQtF,UAAU,EAAGuF,GAO7BjJ,QANUgJ,EAAQtF,UAAUuF,GAQpC,CACA,wBAAOR,CAAkBM,GACrB,MAEMI,EAFc,IAAIrB,YAAY,cACZO,OAAOU,GAAUT,OACtBc,MAAM,KACzB,YAAkBzP,IAAdwP,EAAO,GACA,CACHtF,IAAKsF,EAAO,GAAGb,OACftI,aAASrG,GAGV,CACHkK,IAAKsF,EAAO,GAAGb,OACftI,QAAS,KAAOmJ,EAAO,GAE/B,CACA,oBAAOR,CAAcI,GACjB,MAEMI,EAFc,IAAIrB,YAAY,cACZO,OAAOU,GAAUT,OACtBc,MAAM,KACzB,YAAkBzP,IAAdwP,EAAO,GACA,CACHtF,IAAKZ,SAASkG,EAAO,GAAGb,QACxBtI,aAASrG,GAGV,CACHkK,IAAKZ,SAASkG,EAAO,GAAGb,QACxBtI,QAAS,KAAOmJ,EAAO,GAE/B,CACA,sBAAOT,CAAgBK,GACnB,MAEMI,EAFc,IAAIrB,YAAY,cACZO,OAAOU,GAAUT,OACtBc,MAAM,KACzB,YAAkBzP,IAAdwP,EAAO,GACA,CACHtF,IAAKwF,WAAWF,EAAO,GAAGb,QAC1BtI,aAASrG,GAGV,CACHkK,IAAKwF,WAAWF,EAAO,GAAGb,QAC1BtI,QAAS,KAAOmJ,EAAO,GAE/B,ECrKJ,ICLYG,ECOAC,EFFRC,EAAwC,SAAUC,EAASC,EAAYC,EAAGC,GAE1E,OAAO,IAAKD,IAAMA,EAAIjP,WAAU,SAAUmE,EAASC,GAC/C,SAAS+K,EAAU7L,GAAS,IAAM8L,EAAKF,EAAUG,KAAK/L,GAAS,CAAE,MAAOxD,GAAKsE,EAAOtE,EAAI,CAAE,CAC1F,SAASwP,EAAShM,GAAS,IAAM8L,EAAKF,EAAiB,MAAE5L,GAAS,CAAE,MAAOxD,GAAKsE,EAAOtE,EAAI,CAAE,CAC7F,SAASsP,EAAKG,GAJlB,IAAejM,EAIaiM,EAAOtO,KAAOkD,EAAQoL,EAAOjM,QAJ1CA,EAIyDiM,EAAOjM,MAJhDA,aAAiB2L,EAAI3L,EAAQ,IAAI2L,GAAE,SAAU9K,GAAWA,EAAQb,EAAQ,KAIjBkM,KAAKL,EAAWG,EAAW,CAC7GF,GAAMF,EAAYA,EAAUO,MAAMV,EAASC,GAAc,KAAKK,OAClE,GACJ,EAMO,MAAMK,EACT,WAAArK,CAAYrE,GACRR,KAAKmP,KAAO3O,CAChB,CACA,QAAA4O,GACI,OAAOd,EAAUtO,UAAM,OAAQ,GAAQ,YACnC,OAAOA,KAAKqP,QAAQrP,KAAKmP,MACpBH,MAAMpF,IACP,GAAgB,OAAZA,GAAoBA,EAAQqC,WAAa,EAAG,CAC5C,MAAMpE,EAAQ,IAAIC,WAAW8B,GAE7B,OADa5J,KAAKsP,YAAYzH,EAElC,CACA,OAAO,IAAI,IAEV0H,OAAO1L,IACR,IAAI2L,EAAIC,EACR,GAAgI,QAA3HA,EAA6E,QAAvED,EAAK3L,aAAqC,EAASA,EAAM6L,gBAA6B,IAAPF,OAAgB,EAASA,EAAGnL,YAAyB,IAAPoL,OAAgB,EAASA,EAAGzL,QAChK,MAAM,IAAIZ,MAAM,0BAA4BS,EAAM6L,SAASrL,KAAKL,SAEpE,MAAMH,CAAK,GAEnB,GACJ,CACA,WAAAyL,CAAY1F,GACR,MAAMD,EAAS+C,EAAYN,MAAMxC,GAQjC,MAAO,CACHD,OAAQA,EACRtF,KATkB,IAAIwG,EAAalB,EAAQC,GACbwC,QAUtC,CACA,mBAAOuD,CAAahG,EAAQC,GACxB,MAAMgG,EAAS,IAAIvG,EAEnB,OADAuG,EAAOlG,IAAIC,EAAQC,GACZgG,EAAOpF,iBAClB,CACA,OAAA6E,CAAQQ,GACJ,OAAOvB,EAAUtO,UAAM,OAAQ,GAAQ,YAEnC,GAAK6P,EAAIrH,UAAU,EAAG,GAAGsH,cAAcjK,SAAS,QAO5C,aADc,8BACLwJ,QAAQQ,GAAKb,MAAM3K,GACjBA,IACRkL,OAAOQ,GAEC,OAX0C,CACrD,IAAIzM,QAAU,2BAEd,aAAaA,EAAE0M,aAAaH,EAChC,CAeJ,GACJ,EG1EG,MAAMI,EAKT,WAAApL,CAAa7D,EAAY,KAAMwC,EAAY,KAAM0M,EAAiB,MAC9DlQ,KAAKmQ,GAAKnP,EACVhB,KAAKoQ,GAAK5M,EACVxD,KAAKqQ,QAAUH,CACnB,CAEA,IAAAI,GACI,OAAOtQ,KAAKmQ,EAChB,CAEA,IAAAI,GACI,OAAOvQ,KAAKoQ,EAChB,CAEA,UAAIF,GACA,OAAOlQ,KAAKqQ,OAChB,EChBG,SAASG,EAAqBC,GACpC,IAAIC,GAiH4BjG,EAjHVgG,GAiHVE,EAjHKF,GAkHRG,EAAInG,EAAEmG,EAAID,EAAEE,EAAIpG,EAAEoG,EAAIF,EAAEG,EAAIrG,EAAEqG,GADxC,IAAaH,EAAoBlG,EAhHhC,IAAI9H,EAAIyE,KAAK2J,KAAKL,GACdM,EAAW5J,KAAK6J,KAAKR,EAAI,GAAG9N,GAC5BuO,EAAWC,EAASH,GAEpBI,EAAShK,KAAKiK,MAAMZ,EAAI,GAAGA,EAAI,IAC/Ba,EAASH,EAASC,GAKtB,OAHIE,EAAS,IACZA,GAAU,KAEJ,CACNA,OAAQA,EACRJ,SAAUA,EACVE,OAAOA,EACPJ,SAAUA,EAEZ,CAEO,SAASO,EAAiBC,GAChC,IAAIC,EACAC,EAQJ,OANAD,EAAQD,EAASF,OACbG,EAAQ,IACXA,GAAS,KAEVC,EAAS,GAAKF,EAASN,SAEhB,CACN,MAASO,EACT,OAAUC,EACV,MAASC,EAASF,GAClB,OAAUE,EAASD,GAGrB,CAEO,SAASE,EAAiBC,GAEhC,IAAIP,EACAJ,EASJ,OAPAI,EAASO,EAAMJ,MACXH,EAAS,IACZA,GAAU,KAGXJ,EAAW,GAAKW,EAAMH,OAEf,CACN,OAAUJ,EACV,SAAYJ,EACZ,OAAUS,EAASL,GACnB,SAAYK,EAAST,GAEvB,CAEO,SAASY,EAAqBN,EAA2B7O,GAM/D,MAAO,CACN,GANDA,EAAUlE,MAALkE,EAAkB,EAAIA,GACfyE,KAAK2K,IAAIP,EAASR,UAAY5J,KAAK4K,IAAIR,EAASJ,QAM3D,EALOzO,EAAIyE,KAAK2K,IAAIP,EAASR,UAAY5J,KAAK2K,IAAIP,EAASJ,QAM3D,EALOzO,EAAIyE,KAAK4K,IAAIR,EAASR,UAO/B,CAEO,SAASiB,EAAUC,EAAYC,EAAaC,GAClD,OAAIA,GAAQhE,EAAWiE,QACf,CACN,MAASH,EACT,OAAUC,EACV,MAASR,EAASO,GAClB,OAAUP,EAASQ,IAEVC,GAAQhE,EAAWkE,QACtB,CACN,MAASJ,EACT,OAAUC,EACV,MAAShB,EAASe,GAClB,OAAUf,EAASgB,SAGpBI,QAAQ1O,MAAM,+BAAiCuO,EAAO,iBAGxD,CAGO,SAASI,EAAcC,EAAaC,EAAeN,GACzD,OAAIA,GAAQhE,EAAWiE,QACf,CACN,OAAUI,EACV,SAAYC,EACZ,OAAUf,EAASc,GACnB,SAAYd,EAASe,IAEZN,GAAQhE,EAAWkE,QACtB,CACN,OAAUnB,EAASsB,GACnB,SAAYtB,EAASuB,GACrB,OAAUD,EACV,SAAYC,QAGbH,QAAQ1O,MAAM,+BAAiCuO,EAAO,iBAExD,CAyBO,SAAST,EAASgB,GACxB,OAAQA,EAAU,IAAQvL,KAAKwL,EAChC,CAEO,SAASzB,EAAS0B,GACxB,OAAiB,IAAVA,EAAgBzL,KAAKwL,EAC7B,EH/JA,SAAYxE,GACR,yBACA,yBACA,yBACA,iBACA,gBACH,CAND,CAAYA,IAAAA,EAAU,KCOtB,SAAYC,GACV,wBACA,wBACA,eACD,CAJD,CAAYA,IAAAA,EAAU,K,8pBGMf,MAAMyE,EASZ,WAAAjO,CAAYkO,EAAqBX,KAAqBY,GAPtD,mBAIA,mBACA,mBAIKD,GAAW1E,EAAW4E,WACzB,EAAAjT,KAAI,OAAY4Q,EAAIzC,WAAW6E,EAAO,GAAGE,QAAQ,EAAApT,EAAOqT,eACxD,EAAAnT,KAAI,OAAY6Q,EAAI1C,WAAW6E,EAAO,GAAGE,QAAQ,EAAApT,EAAOqT,eACxD,EAAAnT,KAAI,OAAY8Q,EAAI3C,WAAW6E,EAAO,GAAGE,QAAQ,EAAApT,EAAOqT,eACxD,EAAAnT,KAAI,EAAcwQ,EAAqB,EAAAxQ,KAAI,QAAY,KAEvD,EAAAA,KAAI,EAAUuR,EAAiB,EAAAvR,KAAI,QAAY,MAErC+S,GAAW1E,EAAW+E,OAChC,EAAApT,KAAI,EAAUiS,EAAUe,EAAO,GAAKA,EAAO,GAAIZ,GAAK,KACpD,EAAApS,KAAI,EAAc4R,EAAiB,EAAA5R,KAAI,QAAQ,KAC/C,EAAAA,KAAI,EAAc8R,EAAqB,EAAA9R,KAAI,OAAa,GAAI,MAElD+S,GAAW1E,EAAWgF,WAChC,EAAArT,KAAI,EAAcwS,EAAcQ,EAAO,GAAKA,EAAO,GAAIZ,GAAK,KAC5D,EAAApS,KAAI,EAAc8R,EAAqB,EAAA9R,KAAI,OAAa,GAAI,KAC5D,EAAAA,KAAI,EAAUuR,EAAiB,EAAAvR,KAAI,QAAY,MAG/CuS,QAAQ1O,MAAM,cAAckP,EAAQ,oBAEjC,EAAA/S,KAAI,OAAYsR,OAAS,MAC5B,EAAAtR,KAAI,OAAYsR,QAAU,KAEvB,EAAAtR,KAAI,OAAQyR,MAAQ,MACvB,EAAAzR,KAAI,OAAQyR,OAAS,IAEvB,CA8CA,aAAI6B,GACH,OAAO,EAAAtT,KAAI,MACZ,CAEA,SAAIuT,GACH,OAAO,EAAAvT,KAAI,MACZ,CAEA,aAAIwT,GACH,OAAO,EAAAxT,KAAI,MACZ,E,2VCjFM,MAAMyT,EAuBT,WAAA5O,GAEI7E,KAAK0T,SAAW,MAChB1T,KAAK2T,QAAU,WACf3T,KAAK4T,QAAU,WACf5T,KAAK6T,UAAY,IAAI1O,IACrBnF,KAAK8T,YAAc,IAAItK,KAC3B,CAGM,YAAAuK,CAAaC,G,yCAEf,IAAIC,EAAK,IAAI/E,EAAW8E,GACxBhU,KAAKkU,QAAUF,EACfhU,KAAKmU,UAAUzT,KAAKsT,GAEpB,IAAItQ,EAAUuQ,EAAG7E,WAAWJ,MAAKoF,IAG7BpU,KAAK6T,UAAU/N,IAAI,EAAGsO,EAAK/P,MAC3BrE,KAAK8T,YAAY,GAAKM,EAAKzK,OAC3B3J,KAAKqU,QAAUD,EAAKzK,OAAOvK,IAAI,UAC/BY,KAAKsU,QAAUF,EAAKzK,OAAOvK,IAAI,UAC/BY,KAAKuU,QAAUH,EAAKzK,OAAOlE,cAAc,UAAU,GAAG3C,MACtD9C,KAAKwU,SAAWJ,EAAKzK,OAAOlE,cAAc,UAAU,GAAG3C,MAQvD,MAAM2R,EAAUzU,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GAAG3C,MACzD4R,EAAU1U,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GAAG3C,MAC/D,GAAI2R,IAAYC,QAAuBjW,IAAZgW,QAAqChW,IAAZiW,EAChD,MAAM,IAAItR,MAAM,mCAapB,OAVApD,KAAK2U,QAAUF,EAGfzU,KAAK4U,OAAS5U,KAAKuU,QAAUvU,KAAK2U,QAAU3U,KAAKqU,QAAU,EACvDrU,KAAK4U,OAAS,IACd5U,KAAK4U,QAAU,KAGnB5U,KAAK6U,QAAU7U,KAAKwU,SAAWxU,KAAK2U,QAAU3U,KAAKsU,QAAU,EAEtDF,CAAI,IAGf,aADM1Q,EACCA,CACX,G,CAEA,qBAAAoR,CAAsBV,GAElB,IAAIW,EAAQX,EAAKzK,OAAOvK,IAAI,SACxB4V,EAASZ,EAAKzK,OAAOvK,IAAI,UACzB6V,EAASb,EAAKzK,OAAOvK,IAAI,UACzB8V,EAASd,EAAKzK,OAAOvK,IAAI,UACzB8J,EAASkL,EAAKzK,OAAOvK,IAAI,UACzB2M,EAAa3E,KAAKM,IAAIwB,EAAS,GAG/BiM,GAFahP,EAAWmB,oBAAoB8M,EAAKzK,OAAOvK,IAAI,SAAU2M,GAEzC,IAAIvC,MAAgB0L,IAErD,IAAK,IAAIE,EAAK,EAAGA,EAAKF,EAAQE,IAAM,CAChCD,EAAeC,GAAM,IAAI5L,MAAcyL,GACvC,IAAK,IAAII,EAAK,EAAGA,EAAKJ,EAAQI,IAAM,CAChC,IACIC,EAAcP,EAAQC,EADb7O,EAAW8C,kBAAkB,EAAGmL,EAAK/P,KAAK+Q,GAAIhM,MAAMiM,EAAKtJ,GAAasJ,EAAK,GAAKtJ,GAAa7C,GAE1GiM,EAAeC,GAAIC,GAAMC,C,EAGjC,OAAOH,CAGX,CAEA,iBAAAI,CAAkBC,GAEdxV,KAAK8T,YAAY,GAAK,IAAI5O,EAE1BlF,KAAK8T,YAAY,GAAGlO,sBAAsB,IAAIhB,EAAe,SAAU5E,KAAKqU,UAC5ErU,KAAK8T,YAAY,GAAGlO,sBAAsB,IAAIhB,EAAe,SAAU5E,KAAKsU,UAC5EtU,KAAK8T,YAAY,GAAGlO,sBAAsB,IAAIhB,EAAe,QAAS,IACtE5E,KAAK8T,YAAY,GAAGlO,sBAAsB,IAAIhB,EAAe,SAAU4Q,EAAiBpW,IAAI,YAC5FY,KAAK8T,YAAY,GAAGlO,sBAAsB,IAAIhB,EAAe,SAAU4Q,EAAiBpW,IAAI,iBAMtDX,IAAlC+W,EAAiBpW,IAAI,UACrBY,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,QAAS4Q,EAAiBpW,IAAI,WAGjF,IAAI4V,EAAS,OAC0BvW,IAAnC+W,EAAiBpW,IAAI,YACrB4V,EAASQ,EAAiBpW,IAAI,WAElCY,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAUoQ,IAEzD,IAAID,EAAQ,OAC0BtW,IAAlC+W,EAAiBpW,IAAI,WACrB2V,EAAQS,EAAiBpW,IAAI,UAEjCY,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,QAASmQ,IAExD/U,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU,IAAI5E,KAAK2T,QAAQ,MAC1E3T,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU,IAAI5E,KAAK4T,QAAQ,MAE1E5T,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAK2U,UAC9D3U,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAK2U,UAC9D3U,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKqU,QAAU,IACxErU,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKsU,QAAU,IACxEtU,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKuU,UAC9DvU,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKwU,WAE9D,IAAI9I,EAAMqJ,EAAQC,EAAShV,KAAKyV,gBAC5B9J,EAAMoJ,EAAQC,EAAShV,KAAK0V,gBAShC,OARA1V,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,UAAW8G,IAC1D1L,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,UAAW+G,IAG1D3L,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU,qBACzD5E,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,UAAW,4DAC1D5E,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,QAExC5E,KAAK8T,WAEhB,CACA,aAAA6B,GACI,OAAO3V,KAAK8T,WAChB,CAEA,yBAAA8B,GACI,IAAIjM,EAAS,IAAIzE,EACjB,IAAK,MAAOnG,EAAK+D,KAAU9C,KAAK8T,YAAY,GAEpC,CAAC,SAAU,SAAU,SAAU,QAAS,QAAS,SAAUjO,SAAS9G,IAEpE4K,EAAO1D,QAAQ,IAAIrB,EAAe7F,EAAK+D,IAI/C,OAAO6G,CACX,CAEA,YAAIkM,GACN,OAAO7V,KAAKmU,SACb,CAES,YAAA2B,CAAaC,G,yCAsCf,OApCc,IAAIvW,SAAoB,CAACmE,EAASC,KAC5C,IACI,IAAImI,EAAa3E,KAAKM,IAAI1H,KAAK8T,YAAY,GAAG1U,IAAI,UAAY,GAC1D4W,EAAa7P,EAAWmB,oBAAoBtH,KAAK8T,YAAY,GAAG1U,IAAI,SAAU2M,GAC9EkK,EAAWF,EAAgB9U,OAE3BiV,EAAS,IAAIpO,WAAWmO,EAAWlK,GAEvC,IAAK,IAAIzI,EAAI,EAAGA,EAAI2S,EAAU3S,IAAK,CAE/B,IAAI6S,EAAQJ,EAAgBzS,GAG5B,GAAK6S,EAAQ,GAAI,GAAMA,EAAQ,IAAKnW,KAAKsU,SACpC6B,EAAQ,GAAI,GAAMA,EAAQ,IAAKnW,KAAKqU,QACrC,IAAK,IAAI5J,EAAI,EAAGA,EAAIsB,EAAYtB,IAC5ByL,EAAO5S,EAAIyI,EAAatB,GAAKuL,EAAWvL,OAEzC,CACH,IAAI2L,EAAKpW,KAAK6T,UAAUzU,IAAI,GAC5B,QAAWX,IAAP2X,EAEA,IAAK,IAAI3L,EAAI,EAAGA,EAAIsB,EAAYtB,IAE5ByL,EAAO5S,EAAIyI,EAAatB,GAAK2L,EAAGD,EAAM/F,IAAK+F,EAAQ,GAAIpK,EAAatB,E,EAMpF9G,EAAQuS,E,CACV,MAAOnG,GACLnM,EAAO,+BAAiCmM,E,IAMpD,G,CAGA,mBAAAsG,CAAoBxX,EAAWyX,GAE3BtW,KAAKqU,QAAUjN,KAAKgD,KAAKvL,EAAIyX,GAC7BtW,KAAKsU,QAAUtU,KAAKqU,QACpBrU,KAAK2U,QAAU2B,CACnB,CAIA,WAAAC,CAAYL,EAAoBV,GAE5B,IAAIzJ,EAAa3E,KAAKM,IAAI8N,EAAiBpW,IAAI,UAAY,GACvDoX,EAAUrQ,EAAW8C,kBAAkB,EAAGiN,EAAO9M,MAAM,EAAG2C,GAAayJ,EAAiBpW,IAAI,WAC5FqX,EAAUD,EAEVxB,OAA6CvW,IAAnC+W,EAAiBpW,IAAI,UAA2BoW,EAAiBpW,IAAI,UAAY,EAC3F2V,OAA2CtW,IAAlC+W,EAAiBpW,IAAI,SAA0BoW,EAAiBpW,IAAI,SAAW,EAE5FY,KAAKyV,gBAAkBV,EAAQC,EAASwB,EACxCxW,KAAK0V,gBAAkBX,EAAQC,EAASyB,EAQxCzW,KAAK6T,UAAU/N,IAAI,EAAG,IAAI0D,MAAkBxJ,KAAKsU,UACjD,IAAI8B,EAAKpW,KAAK6T,UAAUzU,IAAI,GAC5B,QAAWX,IAAP2X,EAAkB,CAClB,IAAK,IAAIzT,EAAI,EAAGA,EAAI3C,KAAKsU,QAAS3R,IAC9ByT,EAAGzT,GAAK,IAAImF,WAAW9H,KAAKqU,QAAUtI,GAG1C,IAAIpJ,EACA0J,EACA5B,EACJ,IAAK,IAAInH,EAAI,EAAIA,EAAIyI,EAAcmK,EAAOjV,OAAQqC,IAG9C,IAII,IAHAX,EAAIyE,KAAKoF,MAAMlJ,EAAItD,KAAKqU,SACxBhI,GAAK/I,EAAIX,EAAI3C,KAAKqU,SAAWtI,EAExBtB,EAAI,EAAGA,EAAIsB,EAAYtB,IACxB2L,EAAGzT,GAAG0J,EAAI5B,GAAKyL,EAAO5S,EAAIyI,EAAatB,GAI3C,IACIiM,EAAc3B,EAAQC,EADZ7O,EAAW8C,kBAAkB,EAAGiN,EAAO9M,MAAM9F,EAAIyI,EAAazI,EAAIyI,EAAcA,GAAayJ,EAAiBpW,IAAI,WAG5HsX,EAAc1W,KAAKyV,iBAAmBkB,MAAM3W,KAAKyV,iBACjDzV,KAAKyV,gBAAkBiB,GAChBA,EAAc1W,KAAK0V,iBAAmBiB,MAAM3W,KAAK0V,oBACxD1V,KAAK0V,gBAAkBgB,E,CAE7B,MAAO3G,GACLwC,QAAQqE,IAAI7G,GACZwC,QAAQqE,IAAI,KAAOtT,GACnBiP,QAAQqE,IAAI,gBAAkBjU,EAAG0J,EAAG5B,GACpC8H,QAAQqE,IAAI,4BAA8BR,EAAGzT,GAAG0J,EAAI5B,IACpD8H,QAAQqE,IAAI,8BAAgCV,EAAO5S,EAAIyI,EAAatB,G,EAOhF,OADAzK,KAAKuV,kBAAkBC,GAChBxV,KAAK6T,SAEhB,CAIA,iBAAAgD,CAAkBC,EAAeC,EAAgBC,GAG7ChX,KAAKqW,oBAAoB,EAAIU,EAAQC,GACrChX,KAAK2U,QAAUqC,EACfhX,KAAK4U,OAASkC,EAAOvD,MAAM9B,MAAQsF,EAC/B/W,KAAK4U,OAAS,IACd5U,KAAK4U,QAAU,KAEnB5U,KAAK6U,QAAUiC,EAAOvD,MAAM7B,OAASqF,EAErC,IAAIE,EAAqC,IAAIzN,MAE7C,IAAK,IAAI3K,EAAI,EAAGA,EAAImB,KAAKsU,QAASzV,IAC9B,IAAK,IAAI8D,EAAI,EAAGA,EAAI3C,KAAKqU,QAAS1R,IAC9BsU,EAAUvW,KAAK,CAACV,KAAK4U,OAAUjS,EAAI3C,KAAK2U,QAAU3U,KAAK6U,QAAWhW,EAAImB,KAAK2U,UAInF,IAAIuC,EAAQlX,KAAKsU,QAAU,EAAMtU,KAAKqU,QAAUrU,KAAKqU,QAAU,EAY/D,OAXIrU,KAAKqU,QAAU,GAAK,IACpB6C,EAAO9P,KAAKoF,MAAMyK,EAAUhW,OAAS,IAOzCjB,KAAKuU,QAAU0C,EAAUC,GAAM,GAC/BlX,KAAKwU,SAAWyC,EAAUC,GAAM,GAEzBD,CAGX,CAiCA,SAAAE,CAAUnW,EAAWwC,GAEjB,IAAI0O,EACAC,EAMJ,OAHAD,EAAKlR,EAAIhB,KAAK2U,QAAU3U,KAAK4U,OAC7BzC,EAAM3O,EAAIxD,KAAK2U,QAAU3U,KAAK6U,QACtB,IAAI/B,EAAMzE,EAAW+E,MAAOhF,EAAWiE,QAASH,EAAIC,EAIhE,CAwBA,SAAAiF,CAAUH,GAEN,IAAII,EAA0B,GAE9B,IAAK,IAAIC,KAAaL,EAAW,CAC7B,IAAI/E,EAAKoF,EAAU,GACfnF,EAAMmF,EAAU,GAGhBtW,EAAIoG,KAAKoF,OAAO0F,EAAKlS,KAAK4U,QAAU5U,KAAK2U,SACzCnR,EAAI4D,KAAKoF,OAAO2F,EAAMnS,KAAK6U,SAAW7U,KAAK2U,SAC/C0C,EAAU3W,KAAK,IAAIuP,EAAWjP,EAAGwC,G,CAGrC,OAAO6T,CAEX,ECvbG,MAAME,GAGbA,EAAUC,OAAS,mBACnBD,EAAUE,WAAa,EAAKrQ,KAAKwL,GAEjC2E,EAAUG,MAAQ,EAAItQ,KAAKwL,GAC3B2E,EAAUI,UAAY,GAAM,EAAIvQ,KAAKwL,ICP9B,MAAMgF,EAET,WAAA/S,CAAYgT,EAAIC,GACZ9X,KAAK8Q,EAAI+G,EACT7X,KAAKyS,IAAMqF,CACf,ECHG,MAAMC,EACT,WAAAlT,CAAYmT,GACRD,EAAME,MAAQ,kBACdF,EAAMG,MAAQ,qBACdH,EAAMI,MAAQ,qBACdJ,EAAMK,OAAS,kBACXJ,IACAhY,KAAKqY,IAAM,EACXrY,KAAKsY,UAAW,EAChBtY,KAAK8Q,EAAIiH,EAAM/F,IAAIgG,EAAItF,OACvB1S,KAAKuY,KAAOP,EAAIvF,IACZrL,KAAKM,IAAI1H,KAAK8Q,GAAK,MACnB9Q,KAAKqY,IAAMN,EAAMhG,IAAIiG,EAAItF,OACzB1S,KAAKsY,UAAW,GAG5B,CACA,IAAAE,CAAK1H,GACD9Q,KAAK8Q,EAAIA,CACb,CAEA,OAAI2B,GACA,OAAOzS,KAAKuY,IAChB,CAEA,OAAI9F,CAAIA,GACJzS,KAAKuY,KAAO9F,CAChB,CAEA,MAAAgG,CAAOJ,GACHrY,KAAKqY,IAAMA,CACf,CAEA,MAAAK,GACI,IAAIC,EAAK3Y,KAAKsY,SAAWtY,KAAKqY,IAAMjR,KAAK2J,MAAM,EAAM/Q,KAAK8Q,IAAM,EAAM9Q,KAAK8Q,IAG3E,OADa,IAAI8H,EAAKD,EAAKvR,KAAK4K,IAAIhS,KAAKyS,KAAMkG,EAAKvR,KAAK2K,IAAI/R,KAAKyS,KAAMzS,KAAK8Q,EAEjF,CAEA,MAAA+H,GACI,OAAO,IAAIjB,EAAK5X,KAAK8Q,EAAG9Q,KAAKyS,IACjC,CACA,UAAOV,CAAIlT,GACP,IAAIgB,EAAIhB,EAAIkZ,EAAMK,OACdU,EAAI1R,KAAKoF,MAAM3M,EAAI,EAAIA,EAAI,GAAMA,EAAI,IACrC+Q,EAAI,EAAMkI,EAOd,OANAja,GAAK+R,EAAImH,EAAME,MACfpZ,GAAK+R,EAAImH,EAAMG,MACfrZ,GAAK+R,EAAImH,EAAMI,MACN,EAAJW,IACDja,GAAKA,GAEFmB,KAAK+Y,aAAala,EAC7B,CAEA,UAAOmT,CAAInT,GAEP,IAAIgB,EAAIhB,EAAIkZ,EAAMK,OAAS,GAEvBU,EAAI,EAAI,EAAI1R,KAAKoF,MAAM3M,EAAI,EAAIA,EAAI,GAAMA,EAAI,IAC7C+Q,EAAI,EAAMkI,EAQd,OANAja,GADQ+R,EAAImH,EAAME,MAElBpZ,GAAK+R,EAAImH,EAAMG,MACfrZ,GAAK+R,EAAImH,EAAMI,MACN,EAAJW,IACDja,GAAKA,GAEFkZ,EAAMgB,aAAala,EAC9B,CAEA,mBAAOka,CAAala,GAChB,IAAIqC,EAAIrC,EAAIA,EACRgB,GAAK,qBAST,OARAA,EAAIA,EAAIqB,EAAI,qBACZrB,EAAIA,EAAIqB,EAAI,qBACZrB,EAAIA,EAAIqB,EAAI,sBACZrB,EAAIA,EAAIqB,EAAI,sBACZrB,EAAIA,EAAIqB,EAAI,sBACZrB,EAAIA,EAAIqB,EAAI,sBACZrB,EAAIA,EAAIqB,EAAI,mBACZrB,EAAIA,EAAIqB,EAAI,mBACLA,EAAIrB,EAAIhB,EAAIA,CACvB,CAKA,WAAOma,CAAKna,GACR,OAAOkZ,EAAMkB,QAAQlB,EAAMmB,OAAO9R,KAAKM,IAAI7I,GAAIuI,KAAK2J,MAAM,EAAIlS,IAAM,EAAIA,KAAMA,EAClF,CAKA,WAAOoS,CAAKpS,GACR,OAAOkZ,EAAMkB,QAAQlB,EAAMmB,OAAO9R,KAAK2J,MAAM,EAAIlS,IAAM,EAAIA,IAAKuI,KAAKM,IAAI7I,IAAKA,IAAMA,EAAI,EAAIuI,KAAKwL,GAAK,EAC1G,CAEA,cAAOqG,CAAQrI,EAAGC,GAEd,OADWkH,EAAMoB,SAAS,EAAGtI,GACfD,CAClB,CAEA,eAAOuI,CAASC,EAAWC,GACvB,OAAOA,EAAO,GAAKjS,KAAKM,IAAI0R,GAAahS,KAAKM,IAAI0R,EAUtD,CACA,iBAAOE,CAAWpY,GACd,IAAIqY,EAAIrY,EAAIA,EACRrB,GAAK,qBAmBT,OAlBAA,EAAIA,EAAI0Z,EAAI,sBACZ1Z,EAAIA,EAAI0Z,EAAM,qBACd1Z,EAAIA,EAAI0Z,EAAI,oBACZ1Z,EAAIA,EAAI0Z,EAAM,oBACd1Z,EAAIA,EAAI0Z,EAAI,oBACZ1Z,EAAIA,EAAI0Z,EAAM,oBACd1Z,EAAIA,EAAI0Z,EAAI,mBACZ1Z,EAAIA,EAAI0Z,EAAM,mBACd1Z,EAAIA,EAAI0Z,EAAI,mBACZ1Z,EAAIA,EAAI0Z,EAAM,oBACd1Z,EAAIA,EAAI0Z,EAAI,mBACZ1Z,EAAIA,EAAI0Z,EAAM,mBACd1Z,EAAIA,EAAI0Z,EAAI,mBACZ1Z,EAAIA,EAAI0Z,EAAM,mBACd1Z,EAAIA,EAAI0Z,EAAI,mBACZ1Z,EAAIA,EAAI0Z,EAAM,kBACd1Z,EAAIA,EAAI0Z,EAAI,mBACZ1Z,EAAIA,EAAI0Z,EAAM,kBACP1Z,EAAI0Z,EAAIrY,EAAIA,CACvB,CAEA,aAAOgY,CAAOrI,EAAGD,GACb,IAAIkI,EAAI,EAKR,GAJIlI,EAAI,IACJA,GAAKA,EACLkI,GAAK,GAELjI,EAAID,EAAG,CACP,IAAI2I,EAAI3I,EACRA,EAAIC,EACJA,GAAK0I,EACLT,GAAK,CACT,CACA,OAAOf,EAAMuB,WAAWzI,EAAID,GAAKkI,GAAK1R,KAAKwL,GAAK,EACpD,CAKA,YAAOvB,CAAMR,EAAGD,GACZ,IAAIjO,EAAIoV,EAAMmB,OAAO9R,KAAKM,IAAImJ,GAAID,GAWlC,OAVAjO,EAAIoV,EAAMkB,QAAQtW,EAAGiO,IACjBmH,EAAMyB,MAAM5I,IAAW,GAALA,KAClBjO,EAAIyE,KAAKwL,GAAK,GAAKmF,EAAMyB,MAAM5I,GAAMmH,EAAMoB,SAAS,EAAGvI,IAAMxJ,KAAKwL,GAAK,GAAM,IAE7EmF,EAAMyB,MAAM3I,KACZlO,EAAIyE,KAAKwL,GAAK,GAAKmF,EAAMyB,MAAM5I,GAAMmH,EAAMoB,SAAS,EAAGvI,IAAgB,EAAVxJ,KAAKwL,GAAS,GAAM,IAE5E,GAAL/B,IACAlO,GAA8B,GAAzBoV,EAAMoB,SAAS,EAAGvI,GAAWxJ,KAAKwL,GAAK,GAEzCmF,EAAM0B,MAAM7I,IAAMmH,EAAM0B,MAAM5I,GAAK6I,IAAM3B,EAAMkB,QAAQtW,EAAGkO,EACrE,CAGA,YAAO4I,CAAM5a,GACT,OAAOA,GAAKA,CAChB,CAGA,YAAO2a,CAAM3a,GACT,OAAOuI,KAAKM,IAAI7I,KAAO,GAC3B,EAGJkZ,EAAME,MAAQ,kBACdF,EAAMG,MAAQ,qBACdH,EAAMI,MAAQ,qBACdJ,EAAMK,OAAS,kBC7LR,MAAMuB,EAQT,WAAA9U,CAAY+U,EAAMC,EAAQC,EAAUC,GACpB,MAARH,GACA5Z,KAAK0S,MAAQqF,EAAM1G,MAAMjK,KAAK2J,KAAK6I,EAAKhJ,EAAIgJ,EAAKhJ,EAAIgJ,EAAK/I,EAAI+I,EAAK/I,GAAI+I,EAAK9I,GAExE9Q,KAAKyS,IADLoH,GACY9B,EAAM1G,MAAMuI,EAAK/I,EAAG+I,EAAKhJ,GAG1BmH,EAAM1G,MAAMuI,EAAK/I,EAAG+I,EAAKhJ,GAEpC5Q,KAAKyS,IAAM,IACXzS,KAAKyS,IAAMzS,KAAKyS,IAAM,EAAIrL,KAAKwL,IAE/B5S,KAAKyS,KAAO,EAAIrL,KAAKwL,KACrB5S,KAAKyS,IAAMzS,KAAKyS,IAAM,EAAIrL,KAAKwL,MAInC5S,KAAK0S,MAAQoH,EACb9Z,KAAKyS,IAAMsH,EAEnB,ECxBG,MAAMnB,EACT,WAAA/T,CAAYmV,EAAMC,EAAMC,GACpB,GAAIF,aAAgBL,EAAU,CAC1B,IAAI3B,EAAMgC,EACN3B,EAAMN,EAAMhG,IAAIiG,EAAItF,OACxB1S,KAAK4Q,EAAIyH,EAAMN,EAAM/F,IAAIgG,EAAIvF,KAC7BzS,KAAK6Q,EAAIwH,EAAMN,EAAMhG,IAAIiG,EAAIvF,KAC7BzS,KAAK8Q,EAAIiH,EAAM/F,IAAIgG,EAAItF,MAC3B,MAEI1S,KAAK4Q,EAAIoJ,EACTha,KAAK6Q,EAAIoJ,EACTja,KAAK8Q,EAAIoJ,CAEjB,CACA,IAAAC,GACI,OAAOna,KAAK4Q,CAChB,CAEA,IAAAwJ,GACI,OAAOpa,KAAK6Q,CAChB,CAEA,IAAAwJ,GACI,OAAOra,KAAK8Q,CAChB,CAIA,KAAAwJ,CAAM3T,GACF3G,KAAK4Q,GAAKjK,EACV3G,KAAK6Q,GAAKlK,EACV3G,KAAK8Q,GAAKnK,CACd,CAKA,KAAA4T,CAAMC,GACF,OAAO,IAAI5B,EAAK5Y,KAAK6Q,EAAI2J,EAAE1J,EAAI0J,EAAE3J,EAAI7Q,KAAK8Q,EAAG9Q,KAAK8Q,EAAI0J,EAAE5J,EAAI4J,EAAE1J,EAAI9Q,KAAK4Q,EAAG5Q,KAAK4Q,EAAI4J,EAAE3J,EAAI2J,EAAE5J,EAAI5Q,KAAK6Q,EACxG,CAKA,GAAA4J,CAAID,GACA,OAAO,IAAI5B,EAAK5Y,KAAK4Q,EAAI4J,EAAE5J,EAAG5Q,KAAK6Q,EAAI2J,EAAE3J,EAAG7Q,KAAK8Q,EAAI0J,EAAE1J,EAC3D,CAGA,SAAA4J,GACI,IAAI7b,EAAI,EAAKmB,KAAKiB,SAClBjB,KAAK4Q,GAAK/R,EACVmB,KAAK6Q,GAAKhS,EACVmB,KAAK8Q,GAAKjS,CACd,CAGA,IAAA8b,GACI,IAAI9b,EAAI,EAAKmB,KAAKiB,SAClB,OAAO,IAAI2X,EAAK5Y,KAAK4Q,EAAI/R,EAAGmB,KAAK6Q,EAAIhS,EAAGmB,KAAK8Q,EAAIjS,EACrD,CAIA,MAAAoC,GACI,OAAOmG,KAAK2J,KAAK/Q,KAAK4a,gBAC1B,CAIA,aAAAA,GACI,OAAO5a,KAAK4Q,EAAI5Q,KAAK4Q,EAAI5Q,KAAK6Q,EAAI7Q,KAAK6Q,EAAI7Q,KAAK8Q,EAAI9Q,KAAK8Q,CAC7D,CAKA,GAAA+J,CAAIC,GACA,OAAO9a,KAAK4Q,EAAIkK,EAAGlK,EAAI5Q,KAAK6Q,EAAIiK,EAAGjK,EAAI7Q,KAAK8Q,EAAIgK,EAAGhK,CACvD,CAKA,GAAAiK,CAAIP,GACA,OAAO,IAAI5B,EAAK5Y,KAAK4Q,EAAI4J,EAAE5J,EAAG5Q,KAAK6Q,EAAI2J,EAAE3J,EAAG7Q,KAAK8Q,EAAI0J,EAAE1J,EAC3D,CAMA,KAAAkK,CAAMF,GACF,OAAO/C,EAAM1G,MAAMrR,KAAKua,MAAMO,GAAI7Z,SAAUjB,KAAK6a,IAAIC,GACzD,CAEA,IAAAG,GACIjb,KAAK4Q,IAAM,EACX5Q,KAAK6Q,IAAM,EACX7Q,KAAK8Q,IAAM,CACf,CACA,oBAAOoK,CAAcC,GACjB,IAAI9C,EAAMN,EAAMhG,IAAIoJ,EAASzI,OACzB9B,EAAIyH,EAAMN,EAAM/F,IAAImJ,EAAS1I,KAC7B5B,EAAIwH,EAAMN,EAAMhG,IAAIoJ,EAAS1I,KAC7B3B,EAAIiH,EAAM/F,IAAImJ,EAASzI,OAC3B,OAAO,IAAIkG,EAAKhI,EAAGC,EAAGC,EAC1B,EChHG,MAAMsK,EAIT,WAAAvW,CAAYwW,GACR,IAAIC,EAAKD,EAAMpa,OAEf,GAAMqa,GAAM,EAAZ,CAIAtb,KAAK8W,OAASuE,EAAM,GAAGZ,IAAIY,EAAM,IACjCrb,KAAK8W,OAAO4D,YACZ1a,KAAKub,OAASF,EAAM,GAAGR,IAAI7a,KAAK8W,QAChC,IAAK,IAAI9V,EAAI,EAAGA,EAAIsa,IAAMta,EAClBqa,EAAMra,GAAG6Z,IAAI7a,KAAK8W,QAAU9W,KAAKub,QACjCvb,KAAKwb,UAAUH,EAAOra,EAN9B,MAFIuR,QAAQqE,IAAI,iBAWpB,CAMA,SAAA4E,CAAUH,EAAOvC,GACb9Y,KAAK8W,OAASuE,EAAM,GAAGZ,IAAIY,EAAMvC,IACjC9Y,KAAK8W,OAAO4D,YACZ1a,KAAKub,OAASF,EAAM,GAAGR,IAAI7a,KAAK8W,QAChC,IAAK,IAAI9V,EAAI,EAAGA,EAAI8X,IAAK9X,EACjBqa,EAAMra,GAAG6Z,IAAI7a,KAAK8W,QAAU9W,KAAKub,QACjCvb,KAAKyb,WAAWJ,EAAOra,EAAG8X,EAGtC,CAOA,UAAA2C,CAAWJ,EAAOK,EAAIC,GAClB3b,KAAK8W,OAASuE,EAAMK,GAAIjB,IAAIY,EAAMM,IAClC3b,KAAK8W,OAAO4D,YACZ1a,KAAKub,OAASF,EAAMK,GAAIb,IAAI7a,KAAK8W,QACjC,IAAK,IAAI9V,EAAI,EAAGA,EAAI0a,IAAM1a,EAClBqa,EAAMra,GAAG6Z,IAAI7a,KAAK8W,QAAU9W,KAAKub,SACjCvb,KAAK8W,OAAUuE,EAAMK,GAAIX,IAAIM,EAAMra,IAAKuZ,MAAMc,EAAMM,GAAIZ,IAAIM,EAAMra,KAClEhB,KAAK8W,OAAO4D,YACZ1a,KAAKub,OAASF,EAAMra,GAAG6Z,IAAI7a,KAAK8W,QAC5B9W,KAAKub,OAAS,IACdvb,KAAK8W,OAAOmE,OACZjb,KAAKub,QAAUvb,KAAKub,QAIpC,CAEA,SAAAK,GACI,OAAO,IAAIhD,EAAK5Y,KAAK8W,OAAOlG,EAAG5Q,KAAK8W,OAAOjG,EAAG7Q,KAAK8W,OAAOhG,EAC9D,CACA,SAAA+K,GACI,OAAO7b,KAAKub,MAChB,EC5DG,MAAMO,EACT,WAAAjX,CAAY+L,EAAGC,EAAGxR,GACdW,KAAK+b,GAAKnL,EACV5Q,KAAKgc,GAAKnL,EACV7Q,KAAKic,KAAO5c,EAEZW,KAAKkc,KAAO,IAAIpU,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC7D9H,KAAKmc,KAAO,IAAIrU,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC7D9H,KAAKwX,OAASpQ,KAAKwL,GAAK,CAC5B,CACA,OAAAwJ,GACI,IAEIC,EAFAC,EAAM,IAAIvE,EACVwE,EAAKvc,KAAKkc,KAAKlc,KAAKic,MAAQjc,KAAK+b,GAAK/b,KAAKgc,GAE/C,GAAIO,EAAK,EAAG,CACRF,EAAKE,EACL,IAAIC,EAAMH,EAAKA,EAAK,EACpBC,EAAIxL,EAAI,EAAI0L,EACRF,EAAIxL,EAAI,MACRwL,EAAIjE,IAAMjR,KAAK2J,KAAKyL,GAAO,EAAMA,IACjCF,EAAIhE,UAAW,EAEvB,MACK,GAAIiE,EAAK,EAAG,CACbF,EAAK,EAAIE,EACT,IAAIC,EAAMH,EAAKA,EAAK,EACpBC,EAAIxL,EAAI0L,EAAM,EACVF,EAAIxL,GAAK,MACTwL,EAAIjE,IAAMjR,KAAK2J,KAAKyL,GAAO,EAAMA,IACjCF,EAAIhE,UAAW,EAEvB,MAEI+D,EAAK,EACLC,EAAIxL,EAAe,GAAV,EAAIyL,GAAY,EAE7B,IAAIC,EAAMxc,KAAKmc,KAAKnc,KAAKic,MAAQI,EAAKrc,KAAK+b,GAAK/b,KAAKgc,GAQrD,OAPIQ,EAAM,IACNA,GAAO,GAEPA,GAAO,IACPA,GAAO,GAEXF,EAAI7J,IAAO4J,EAAK,MAAS,EAAK,GAAMrc,KAAKwX,OAASgF,EAAOH,EAClDC,CACX,CAEA,MAAA5D,GACI,OAAO1Y,KAAKoc,UAAU1D,QAC1B,ECrDG,MAAM+D,EAET,WAAA5X,CAAY6X,GACR1c,KAAKsD,EAAI,IAAIkG,MAAMkT,GACnB1c,KAAKhB,EAAI,IAAI2d,WAAWD,GACxB1c,KAAKkB,EAAI,EACTlB,KAAKpB,EAAI,CACb,CAMA,IAAA8B,CAAKkc,EAAIC,GACL7c,KAAKsD,EAAEtD,KAAKkB,GAAK0b,EACjB5c,KAAKhB,EAAEgB,KAAKkB,GAAK2b,IACf7c,KAAKkB,CACX,CAEA,GAAA4b,KACM9c,KAAKkB,CACX,CAEA,SAAA6b,GACI/c,KAAKkB,EAAIlB,KAAKpB,CAClB,CAEA,IAAAoe,GACI,OAAOhd,KAAKkB,CAChB,CAEA,IAAA+b,GACIjd,KAAKpB,EAAIoB,KAAKkB,CAClB,CAEA,IAAAgc,GACI,OAAOld,KAAKhB,EAAEgB,KAAKkB,EAAI,EAC3B,CAEA,IAAAic,GACI,OAAOnd,KAAKsD,EAAEtD,KAAKkB,EAAI,EAC3B,ECzCG,MAAMkc,EAIT,WAAAvY,CAAYwY,GACJA,EAAM,GACN9K,QAAQ1O,MAAM,6BAClB7D,KAAK2C,EAAI,IAAIga,WAAWU,GAAO,GAC/Brd,KAAK0c,GAAK,CACd,CAIA,MAAAY,CAAO3U,GACH3I,KAAKud,QAAQ5U,EAAKA,EAAM,EAC5B,CAKA,OAAA4U,CAAQ5M,EAAGlG,GACP,GAAIkG,GAAKlG,EACL,OACJ,GAAKzK,KAAK0c,GAAK,GAAO/L,GAAK3Q,KAAK2C,EAAE3C,KAAK0c,GAAK,GAKxC,OAJI/L,EAAI3Q,KAAK2C,EAAE3C,KAAK0c,GAAK,IACrBnK,QAAQ1O,MAAM,6BACd4G,EAAIzK,KAAK2C,EAAE3C,KAAK0c,GAAK,KACrB1c,KAAK2C,EAAE3C,KAAK0c,GAAK,GAAKjS,IAI9B,IAAI4S,EAAMrd,KAAK0c,GAAK,EACpB,GAAI1c,KAAK2C,EAAE1B,OAASoc,EAAK,CACrB,IAAIG,EAAUpW,KAAKuE,IAAI,EAAI3L,KAAK2C,EAAE1B,OAAQoc,GACtCI,EAAO,IAAId,WAAWa,GAC1BC,EAAK3X,IAAI9F,KAAK2C,GACd3C,KAAK2C,EAAI8a,CACb,CACAzd,KAAK2C,EAAE3C,KAAK0c,IAAM/L,EAClB3Q,KAAK2C,EAAE3C,KAAK0c,GAAK,GAAKjS,EACtBzK,KAAK0c,IAAM,CACf,CAKA,cAAAgB,CAAeL,GACPrd,KAAK2C,EAAE1B,OAASoc,GAChBrd,KAAK2d,OAAOvW,KAAKuE,IAAI,EAAI3L,KAAK2C,EAAE1B,OAAQoc,GAChD,CAKA,MAAAM,CAAOH,GAGH,GAFIA,EAAUxd,KAAK0c,IACfnK,QAAQ1O,MAAM,kCACd2Z,GAAWxd,KAAK2C,EAAE1B,OAClB,OACO,IAAI0b,WAAWa,GAA1B,IACII,EAAS5d,KAAK2C,EAAEyG,MAAM,EAAGpJ,KAAK0c,GAAK,GAEvC1c,KAAK2C,EAAIib,CACb,EC5DG,MAAMC,EACT,WAAAhZ,CAAY+L,EAAGC,EAAGxR,GACdW,KAAK8d,GAAKlN,EACV5Q,KAAK+d,GAAKlN,EACV7Q,KAAKic,KAAO5c,CAChB,ECgBG,MAAM2e,EACT,WAAAnZ,CAAYoZ,GACRje,KAAKke,UAAY,GACjBle,KAAKyX,WAAa,EAAMrQ,KAAKwL,GAC7B5S,KAAKme,SAAW,EAAM,EAGtBne,KAAKoe,OAAShX,KAAKC,IAAI,EAAGrH,KAAKke,WAC/Ble,KAAKqe,KAAO,IAAIC,YAAY,CACxB,EAAG,EAAG,IAAK,IAAK,EAAG,EAAG,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,EAAG,EAAG,IAAK,IAAK,EAAG,EAAG,IAC9F,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACvF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,EAAG,EAAG,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IACxF,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC3F,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACvF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,OAEtEte,KAAKue,KAAO,IAAID,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACxH,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,MACtF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACpF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACpF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACpF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACpF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACpF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACpF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACpF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACpF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACpF,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,QACrDte,KAAKkc,KAAO,IAAIsC,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC7Dxe,KAAKmc,KAAO,IAAIqC,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC7Dxe,KAAKye,QAAU,IAAID,WAAW,EAAE,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IACvDxe,KAAK0e,QAAU,IAAIF,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,IACvDxe,KAAK2e,UAAY,CACb,IAAIH,WAAW,CAAC,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,IACzD,IAAIA,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IACrD,IAAIA,WAAW,EAAE,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,IACzD,IAAIA,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,KACpD,IAAIA,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,KAClD,IAAIA,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IACjD,IAAIA,WAAW,EAAE,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,IACzD,IAAIA,WAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IACjD,IAAIA,WAAW,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,KAGzDxe,KAAK4e,UAAY,CACb,IAAIJ,WAAW,CAAC,EAAG,EAAG,IACtB,IAAIA,WAAW,CAAC,EAAG,EAAG,IACtB,IAAIA,WAAW,CAAC,EAAG,EAAG,IACtB,IAAIA,WAAW,CAAC,EAAG,EAAG,IACtB,IAAIA,WAAW,CAAC,EAAG,EAAG,IACtB,IAAIA,WAAW,CAAC,EAAG,EAAG,IACtB,IAAIA,WAAW,CAAC,EAAG,EAAG,IACtB,IAAIA,WAAW,CAAC,EAAG,EAAG,IACtB,IAAIA,WAAW,CAAC,EAAG,EAAG,KAEtBP,GAAYje,KAAKoe,QAAUH,EAAW,IACtCje,KAAK6e,MAAQZ,EACbje,KAAK8e,OAAS9e,KAAK6e,MAAQ7e,KAAK6e,MAChC7e,KAAK+e,KAAO,GAAK/e,KAAK8e,OACtB9e,KAAKgf,MAAQhf,KAAKif,YAAYjf,KAAK6e,OACnC7e,KAAKkf,IAAM,EAAIlf,KAAK6e,MACpB7e,KAAKmf,IAAM,EAAInf,KAAK6e,MACpB7e,KAAKof,IAAM,EAAIpf,KAAK6e,MACpB7e,KAAKqf,MAAQ,EAAMrf,KAAK+e,KACxB/e,KAAKsf,OAAStf,KAAK6e,OAAS,GAAK7e,KAAKqf,MACtCrf,KAAKuf,KAAO,EAAIvf,KAAK6e,OAAS7e,KAAK6e,MAAQ,IAI/C7e,KAAKwf,GAAK,GACVxf,KAAKyf,IAAM,GACXzf,KAAK0f,KAAO,GACZ1f,KAAK2f,KAAO,EAgBhB,CACA,SAAAC,GACI,IAAK,IAAI5e,EAAI,EAAGA,GAAKhB,KAAKke,YAAald,EACnChB,KAAKwf,GAAGxe,GAAK,IAAIgd,EAAQ,GAAKhd,GAC9BhB,KAAKyf,IAAIze,GAAKhB,KAAKwf,GAAGxe,GAAG6e,YACzB7f,KAAK0f,KAAK1e,GAAK+W,EAAM/F,IAAIhS,KAAKyf,IAAIze,IAClChB,KAAK2f,KAAK3e,GAAK+W,EAAMhG,IAAI/R,KAAKyf,IAAIze,GAE1C,CACA,OAAA8e,GACI,OAAO9f,KAAK+e,IAChB,CAEA,aAAAgB,CAAcC,GACV,IAAIC,EAAS,IAAIzW,MACb0W,EAAMlgB,KAAKmgB,SAASH,GAGpBI,EAAK,GAAMpgB,KAAK6e,MAChBwB,GAAMH,EAAIpC,GAAK,IAAO9d,KAAK6e,MAC3ByB,GAAMJ,EAAInC,GAAK,IAAO/d,KAAK6e,MAqB/B,OAfAoB,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SACjDuH,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SACjDuH,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SACjDuH,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SAY1CuH,CACX,CAWA,qBAAAM,CAAsBP,EAAKpR,GAEvB,IAAIqR,EAAS,IAAIzW,MACb0W,EAAMlgB,KAAKmgB,SAASH,GACpBI,EAAK,GAAMpgB,KAAK6e,MAChBwB,GAAMH,EAAIpC,GAAK,IAAO9d,KAAK6e,MAC3ByB,GAAMJ,EAAInC,GAAK,IAAO/d,KAAK6e,MAC3BhgB,EAAI,GAAOmB,KAAK6e,MAAQjQ,GAC5B,IAAK,IAAI5N,EAAI,EAAGA,EAAI4N,EAAM5N,IACtBif,EAAOjf,GAAK,IAAI8a,EAAKuE,EAAKD,EAAKpf,EAAInC,EAAGyhB,EAAKF,EAAIF,EAAIjE,MAAMvD,SACzDuH,EAAOjf,EAAI4N,GAAQ,IAAIkN,EAAKuE,EAAKD,EAAIE,EAAKF,EAAKpf,EAAInC,EAAGqhB,EAAIjE,MAAMvD,SAChEuH,EAAOjf,EAAI,EAAI4N,GAAQ,IAAIkN,EAAKuE,EAAKD,EAAKpf,EAAInC,EAAGyhB,EAAKF,EAAIF,EAAIjE,MAAMvD,SACpEuH,EAAOjf,EAAI,EAAI4N,GAAQ,IAAIkN,EAAKuE,EAAKD,EAAIE,EAAKF,EAAKpf,EAAInC,EAAGqhB,EAAIjE,MAAMvD,SAExE,OAAOuH,CACX,CAEA,qBAAAO,CAAsB5P,EAAGC,EAAGoL,GACxB,IAAI4C,EAAQzX,KAAKC,IAAI,EAAGrH,KAAKgf,OACzBiB,EAAS,IAAIzW,MACb0W,EAAM,IAAIrC,EAAIjN,EAAGC,EAAGoL,GACpBmE,EAAK,GAAMvB,EACXwB,GAAMH,EAAIpC,GAAK,IAAOe,EACtByB,GAAMJ,EAAInC,GAAK,IAAOc,EAK1B,OAJAoB,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SACjDuH,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SACjDuH,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SACjDuH,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SAC1CuH,CACX,CACA,eAAAQ,CAAgB7P,EAAGC,EAAGjC,EAAMqN,GACxB,IAAI4C,EAAQjQ,EAAOxH,KAAKC,IAAI,EAAGrH,KAAKgf,OAChCiB,EAAS,IAAIzW,MACb0W,EAAM,IAAIrC,EAAIjN,EAAGC,EAAGoL,GACpBmE,EAAK,GAAMvB,EACXwB,GAAMH,EAAIpC,GAAK,IAAOe,EACtByB,GAAMJ,EAAInC,GAAK,IAAOc,EAK1B,OAJAoB,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SACjDuH,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SACjDuH,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SACjDuH,EAAO,GAAK,IAAInE,EAAKuE,EAAKD,EAAIE,EAAKF,EAAIF,EAAIjE,MAAMvD,SAC1CuH,CACX,CAUA,UAAAS,CAAWC,GACP,IAAI5R,EAAS,IAAI4N,WAAW,GACxBuD,EAAMlgB,KAAKmgB,SAASQ,GACpB7C,EAAKoC,EAAIpC,GACTC,EAAKmC,EAAInC,GACT6C,EAAWV,EAAIjE,KACnB,IAAI4E,EAAO7gB,KAAK6e,MAAQ,EACxB,GAAKf,EAAK,GAAOA,EAAK+C,GAAU9C,EAAK,GAAOA,EAAK8C,EAAO,CACpD,IAAIC,EAAO1Z,KAAKoF,MAAMoU,GAAa,EAAI5gB,KAAKgf,OACxC+B,EAAM/gB,KAAKghB,YAAYlD,GACvBmD,EAAMjhB,KAAKghB,YAAYjD,IAAO,EAC9BmD,EAAMlhB,KAAKghB,YAAYlD,EAAK,GAC5BqD,EAAMnhB,KAAKghB,YAAYjD,EAAK,IAAM,EAClCqD,EAAMphB,KAAKghB,YAAYlD,EAAK,GAC5BuD,EAAMrhB,KAAKghB,YAAYjD,EAAK,IAAM,EACtChP,EAAO,GAAK+R,EAAOM,EAAMH,EACzBlS,EAAO,GAAK+R,EAAOM,EAAMD,EACzBpS,EAAO,GAAK+R,EAAOC,EAAMI,EACzBpS,EAAO,GAAK+R,EAAOI,EAAMC,EACzBpS,EAAO,GAAK+R,EAAOI,EAAMD,EACzBlS,EAAO,GAAK+R,EAAOI,EAAMG,EACzBtS,EAAO,GAAK+R,EAAOC,EAAMM,EACzBtS,EAAO,GAAK+R,EAAOM,EAAMC,CAC7B,MAEI,IAAK,IAAIrgB,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACxB,IAAI4P,EAAIkN,EAAK9d,KAAKye,QAAQzd,GACtB6P,EAAIkN,EAAK/d,KAAK0e,QAAQ1d,GACtBsgB,EAAQ,EACR1Q,EAAI,GACJA,GAAK5Q,KAAK6e,MACVyC,GAAS,GAEJ1Q,GAAK5Q,KAAK6e,QACfjO,GAAK5Q,KAAK6e,MACVyC,GAAS,GAETzQ,EAAI,GACJA,GAAK7Q,KAAK6e,MACVyC,GAAS,GAEJzQ,GAAK7Q,KAAK6e,QACfhO,GAAK7Q,KAAK6e,MACVyC,GAAS,GAEb,IAAIjiB,EAAIW,KAAK2e,UAAU2C,GAAOV,GAC9B,GAAIvhB,GAAK,EAAG,CACR,IAAI+I,EAAOpI,KAAK4e,UAAU0C,GAAOV,IAAa,GAO9C,IANY,EAAPxY,GAAY,IACbwI,EAAIxJ,KAAKoF,MAAMxM,KAAK6e,MAAQjO,EAAI,KAExB,EAAPxI,GAAY,IACbyI,EAAIzJ,KAAKoF,MAAMxM,KAAK6e,MAAQhO,EAAI,KAExB,EAAPzI,GAAY,EAAG,CAChB,IAAImZ,EAAO3Q,EACXA,EAAIC,EACJA,EAAI0Q,CACR,CACAxS,EAAO/N,GAAKhB,KAAKwhB,SAAS5Q,EAAGC,EAAGxR,EACpC,MAEI0P,EAAO/N,IAAM,CAErB,CAEJ,OAAO+N,CACX,CAEA,WAAAkQ,CAAYJ,GACR,OAASA,EAASA,EAAQ,GAAa,EAAIzX,KAAKqa,KAAK5C,EACzD,CAEA,QAAAsB,CAASQ,GACL,IAAIX,EAAM5Y,KAAKoF,MAAMmU,EAAQ3gB,KAAK8e,OAAS,GAE3C,OADU,IAAIjB,EAAI7d,KAAK0hB,cAAc1B,GAAMhgB,KAAK0hB,cAAc1B,GAAO,GAAI5Y,KAAKoF,MAAOmU,GAAS,EAAI3gB,KAAKgf,OAE3G,CAEA,QAAAwC,CAAS1D,EAAIC,EAAI6C,GACb,OAAOxZ,KAAKoF,MAAMoU,GAAa,EAAI5gB,KAAKgf,OAClChf,KAAKghB,YAAYlD,IAAO9d,KAAKghB,YAAYjD,IAAO,EAC1D,CAEA,OAAA4D,CAAQC,GACJ,IAIIC,EAJA/Q,EAAI8Q,EAAM9Q,EACV2B,EAAMmP,EAAMnP,IACZqP,EAAK1a,KAAKM,IAAIoJ,GACdiR,EAAK/hB,KAAKgiB,QAASvP,EAAMzS,KAAKyX,WAAa,GAE/C,GAAIqK,GAAM9hB,KAAKme,SAAU,CACrB,IAAI8D,EAAQjiB,KAAK6e,OAAS,GAAMkD,GAC5BG,EAAQliB,KAAK6e,OAAa,IAAJ/N,GACtBqR,EAAK/a,KAAKoF,MAAMyV,EAAQC,GACxBE,EAAKhb,KAAKoF,MAAMyV,EAAQC,GACxBG,EAAMjb,KAAKoF,MAAM2V,IAAOniB,KAAKgf,OAC7BsD,EAAMlb,KAAKoF,MAAM4V,IAAOpiB,KAAKgf,OAC7B4B,EAAWxZ,KAAKoF,MAAO6V,GAAOC,EAAc,EAAND,EAAaA,EAAMC,EAAOD,EAAOC,EAAM,GAC7ExE,EAAK1W,KAAKoF,MAAM4V,EAAMpiB,KAAK6e,MAAQ,GACnCd,EAAK3W,KAAKoF,MAAMxM,KAAK6e,OAASsD,EAAMniB,KAAK6e,MAAQ,GAAM,GAC3DgD,EAAQ7hB,KAAKwhB,SAAS1D,EAAIC,EAAI6C,EAClC,KACK,CACD,IAAI2B,EAAMnb,KAAKsE,IAAI,EAAGtE,KAAKoF,MAAMuV,IAC7BS,EAAKT,EAAKQ,EACV/F,EAAQsF,EAAK,MAAWF,EAAMtJ,SAC9BtY,KAAK6e,MAAQzX,KAAK2J,KAAK,GAAK,EAAI+Q,IAChC9hB,KAAK6e,MAAQ+C,EAAMvJ,IAAMjR,KAAK2J,MAAM,EAAM+Q,GAAM,GAChDK,EAAK/a,KAAKoF,MAAMgW,EAAKhG,GACrB4F,EAAKhb,KAAKoF,OAAO,EAAMgW,GAAMhG,GAC7B2F,GAAMniB,KAAK6e,QACXsD,EAAKniB,KAAK6e,MAAQ,GAElBuD,GAAMpiB,KAAK6e,QACXuD,EAAKpiB,KAAK6e,MAAQ,GAGlBgD,EADA/Q,GAAK,EACG9Q,KAAKwhB,SAASpa,KAAKoF,MAAMxM,KAAK6e,MAAQuD,EAAK,GAAIhb,KAAKoF,MAAMxM,KAAK6e,MAAQsD,EAAK,GAAII,GAGhFviB,KAAKwhB,SAASpa,KAAKoF,MAAM2V,GAAK/a,KAAKoF,MAAM4V,GAAKG,EAAM,EAEpE,CACA,OAAOV,CACX,CAMA,OAAAY,CAAQzC,GACJ,OAAOhgB,KAAK0iB,QAAQ1C,GAAKtH,QAC7B,CAKA,QAAAiK,CAAS3C,GACL,OAAOhgB,KAAK0iB,QAAQ1C,GAAKnH,QAC7B,CAKA,OAAA6J,CAAQ1C,GACJ,IAGI3D,EAHAC,EAAM,IAAIvE,OAAMtZ,GAChByhB,EAAMlgB,KAAKmgB,SAASH,GACpBzD,GAAOvc,KAAKkc,KAAKgE,EAAIjE,OAAUjc,KAAKgf,OAASkB,EAAIpC,GAAKoC,EAAInC,GAAK,EAEnE,GAAIxB,EAAKvc,KAAK6e,MAAO,CACjBxC,EAAKE,EACL,IAAIC,EAAOH,EAAKA,EAAMrc,KAAKqf,MAC3B/C,EAAIxL,EAAI,EAAI0L,EACRF,EAAIxL,EAAI,MACRwL,EAAIjE,IAAMjR,KAAK2J,KAAKyL,GAAO,EAAKA,IAChCF,EAAIhE,UAAW,EAEvB,MACK,GAAIiE,EAAKvc,KAAKmf,IAAK,CACpB9C,EAAKrc,KAAKof,IAAM7C,EAChB,IAAIC,EAAOH,EAAKA,EAAMrc,KAAKqf,MAC3B/C,EAAIxL,EAAI0L,EAAM,EACVF,EAAIxL,GAAK,MACTwL,EAAIjE,IAAMjR,KAAK2J,KAAKyL,GAAO,EAAKA,IAChCF,EAAIhE,UAAW,EAEvB,MAEI+D,EAAKrc,KAAK6e,MACVvC,EAAIxL,GAAK9Q,KAAKkf,IAAM3C,GAAMvc,KAAKsf,MAEnC,IAAI9C,EAAOxc,KAAKmc,KAAK+D,EAAIjE,MAASI,EAAK6D,EAAIpC,GAAKoC,EAAInC,GAOpD,OALIvB,EAAM,IACNA,GAAO,EAAIH,GAEfC,EAAI7J,IAAO4J,GAAMrc,KAAK6e,MAAS,IAAOtH,EAAUC,OAASgF,EAAMxc,KAAKsf,MAAS,GAAM/H,EAAUC,OAASgF,EAAOH,EAEtGC,CACX,CAEA,OAAAsG,CAAQ5K,EAAK6B,GACT,OAAO7Z,KAAK2hB,QAAQ,IAAI5J,EAAMC,GAClC,CAEA,OAAAgK,CAAQlH,EAAI+H,GACR,GAAI/H,GAAM,EACN,OAAQA,EAAK+H,EAAM/H,EAAKA,EAAK+H,EAEjC,IAAIrG,EAAM1B,EAAK+H,EAAKA,EACpB,OAAQrG,IAAQqG,EAAM,EAAMrG,CAChC,CAEA,aAAAkF,CAAclH,GACV,IAAIsI,EAAM1b,KAAKoF,MAAW,MAAJgO,GAAepT,KAAKoF,OAAY,WAAJgO,KAAoB,IAEtE,OADiBxa,KAAKqe,KAAW,IAANyE,GAAe9iB,KAAKqe,KAAKyE,IAAQ,IAAM,CAEtE,CAEA,WAAA9B,CAAYxG,GACR,OAAOpT,KAAKoF,MAAMxM,KAAKue,KAAS,IAAJ/D,IAAapT,KAAKoF,MAAOxM,KAAKue,KAAM/D,IAAM,EAAK,MAAS,IAC9EpT,KAAKoF,MAAOxM,KAAKue,KAAM/D,IAAM,GAAM,MAAS,IAAOpT,KAAKoF,MAAOxM,KAAKue,KAAM/D,IAAM,GAAM,MAAS,GACzG,CAsBA,qBAAAuI,CAAsBC,EAAQC,GAC1B,IAAIC,EAAqB,GAARD,EACbE,EAAKH,EAAO/hB,OAEhB,KAAMkiB,GAAM,GAER,YADA5Q,QAAQqE,IAAI,kCAGhB,IAAIwM,EAAK,IAAI5Z,MACb,IAAK,IAAIxI,EAAI,EAAGA,EAAImiB,IAAMniB,EACtBoiB,EAAGpiB,GAAK4X,EAAKsC,cAAc8H,EAAOhiB,IAEtC,IAAIqiB,EAAS,IAAI7Z,MACbyR,EAAO,EACPqI,EAAQ,EACRC,GAAO,EACX,KAAOD,EAAQF,EAAGniB,QAAQ,CACtB,IAAIuiB,EAAQJ,EAAGE,GACXG,EAAS,KACTC,EAAO,KACPJ,GAASF,EAAGniB,OAAS,GACrByiB,EAAON,EAAG,GACVK,EAASL,EAAG,IAEPE,GAASF,EAAGniB,OAAS,GAC1ByiB,EAAON,EAAG,GACVK,EAASL,EAAGE,EAAQ,KAGpBG,EAASL,EAAGE,EAAQ,GACpBI,EAAON,EAAGE,EAAQ,IAEtBD,EAAOC,GAASE,EAAMjJ,MAAMkJ,GAAQ9I,OACpC,IAAIgJ,EAAMN,EAAOC,GAAOzI,IAAI6I,GAC5B,GAAa,GAATJ,EACArI,EAAQ0I,EAAM,GAAO,EAAI,EACf,IAAIhK,EAAS6J,GACvBD,GAAO,MAEN,CAED,GADetI,EAAO0I,EACP,EAAG,CACJ,IAAIhK,EAAS8J,GACvBL,EAAGQ,OAAON,EAAQ,EAAG,GACrBD,EAAOO,OAAON,EAAO,GACrBC,GAAO,EACPD,GAAS,EACT,QACJ,CAEc,IAAI3J,EAAS6J,GACvBD,GAAO,CAEf,CACAF,EAAOC,GAAOhJ,MAAMW,GACpBqI,GAAS,CACb,CACAH,EAAKC,EAAGniB,OACR,IACI4iB,EAAM,IAAIra,MADF0Z,EAAYC,EAAK,EAAIA,GAMjC,GAJAU,EAAMA,EAAIC,KAAKvM,EAAUC,QAIrB0L,EAAW,CACX,IAAIa,EAAK,IAAI3I,EAAagI,GAC1BC,EAAOF,GAAMY,EAAGnI,YAChBiI,EAAIV,GAAMpL,EAAM9G,KAAK8S,EAAGlI,YAC5B,CACA,OAAO7b,KAAKgkB,eAAeX,EAAQQ,EAAKZ,EAC5C,CAgBA,cAAAe,CAAerJ,EAAMkJ,EAAKZ,GACtBjjB,KAAK4f,YACL,IAAIsD,EAAqB,GAARD,EACbE,EAAKxI,EAAK1Z,OAEd,GAAMkiB,GAAMU,EAAI5iB,OAEZ,YADAsR,QAAQ1O,MAAM,6BAGlB,IAAI6B,EAAM,IAAI0X,EAAS,GAEnB6G,EAAQ,EACRf,IACM9b,KAAKC,IAAI,EAAGrH,KAAKke,UAAYle,KAAKgf,QAAUiE,GAC9C1Q,QAAQ1O,MAAM,+BAEXof,EAAQA,EAAO,GAClB1Q,QAAQ1O,MAAM,4CAElBogB,EAAQjkB,KAAKkkB,MAAMjB,IAEvB,IAIIjkB,EACAgC,EALAmjB,EAAOnkB,KAAKgf,MAAQiF,EAGpBG,EAAU,IAAI5a,MAAM2a,EAAO,GAG/B,IAAKnlB,EAAI,EAAGA,GAAKmlB,IAAQnlB,EAAG,CACxBolB,EAAQplB,GAAK,IAAIwK,MAAM2Z,GACvB,IAAIkB,EAAKrkB,KAAKwf,GAAGxgB,GAAG6gB,YACpB,IAAK7e,EAAI,EAAGA,EAAImiB,IAAMniB,EAClBojB,EAAQplB,GAAGgC,GAAK,IAAIsjB,aAAa,GACjCF,EAAQplB,GAAGgC,GAAG,GAAM6iB,EAAI7iB,GAAKqjB,EAAKjd,KAAKwL,IAAO,EAAImF,EAAM/F,IAAI6R,EAAI7iB,GAAKqjB,GACrED,EAAQplB,GAAGgC,GAAG,GAAW,GAALhC,EAAU+Y,EAAM/F,IAAI6R,EAAI7iB,IAAMojB,EAAQ,GAAGpjB,GAAG,GAChEojB,EAAQplB,GAAGgC,GAAG,GAAM6iB,EAAI7iB,GAAKqjB,EAAK,EAAM,EAAKtM,EAAM/F,IAAI6R,EAAI7iB,GAAKqjB,EAExE,CACA,IAAIE,EAAM,IAAI9H,EAAO,GAAK,EAAI0H,GAC9B,IAAK,IAAInjB,EAAI,EAAGA,EAAI,GAAIA,IAEpBujB,EAAI7jB,KAAK,GAAKM,EAAG,GAErB,KAAOujB,EAAIvH,OAAS,GAAG,CAEnB,IAAIgD,EAAMuE,EAAIpH,OACVne,EAAIulB,EAAIrH,OACZqH,EAAIzH,MACJ,IAAI1G,EAAKpW,KAAKwf,GAAGxgB,GAAGyjB,QAAQzC,GACxBwE,EAAO,EACX,IAAK,IAAIxjB,EAAI,EAAIA,EAAImiB,GAAQqB,EAAO,IAAMxjB,EAAG,CACzC,IAAIyjB,EAAOrO,EAAGyE,IAAIF,EAAK3Z,IACvB,IAAK,IAAI0jB,EAAK,EAAGA,EAAKF,IAAQE,EACtBD,EAAOL,EAAQplB,GAAGgC,GAAG0jB,KACrBF,EAAOE,EAGnB,CACIF,EAAO,GACPxkB,KAAK2kB,YAAY3lB,EAAGmlB,EAAMK,EAAM9e,EAAKsa,EAAKuE,EAAKrB,EAEvD,CACA,OAAOxd,CACX,CAMA,KAAAwe,CAAMU,GACF,IAAIjZ,EAAMvE,KAAKuE,IAAIiZ,EAAK,GACxB,OAAO,GAAKxd,KAAKyd,MAAMlZ,EAC3B,CAIA,YAAAmZ,CAAaC,EAAIC,EAAMC,EAAIC,GACvB,OAAOH,EAAKE,EAAKlN,EAAM/F,IAAIgT,EAAOE,GAAQ9d,KAAK2J,MAAM,EAAMgU,EAAKA,IAAO,EAAME,EAAKA,GACtF,CAUA,WAAAN,CAAY3lB,EAAGmlB,EAAMK,EAAMW,EAAQnF,EAAKuE,EAAKrB,GACzC,GAAY,GAARsB,EAEJ,GAAIxlB,EAAIgB,KAAKgf,MACT,GAAIwF,GAAQ,EAAG,CACX,IAAIY,EAAQ,GAAKplB,KAAKgf,MAAQhgB,GAC9BmmB,EAAO5H,QAAQyC,GAAOoF,EAASpF,EAAM,GAAMoF,EAC/C,MAEI,IAAK,IAAIpkB,EAAI,EAAGA,EAAI,IAAKA,EACrBujB,EAAI7jB,KAAK,EAAIsf,EAAM,EAAIhf,EAAGhC,EAAI,QAIrC,GAAIA,EAAIgB,KAAKgf,MACd,GAAIwF,GAAQ,EACRW,EAAO7H,OAAO0C,IAAS,GAAKhhB,EAAIgB,KAAKgf,QACrCuF,EAAIxH,iBAGJ,GAAI/d,EAAImlB,EACJ,IAAK,IAAInjB,EAAI,EAAGA,EAAI,IAAKA,EACrBujB,EAAI7jB,KAAK,EAAIsf,EAAM,EAAIhf,EAAGhC,EAAI,QAIlCmmB,EAAO7H,OAAO0C,IAAS,GAAKhhB,EAAIgB,KAAKgf,QACrCuF,EAAIxH,iBAKZ,GAAIyH,GAAQ,EACRW,EAAO7H,OAAO0C,QAEb,GAAIkD,EACL,GAAIljB,KAAKgf,MAAQmF,EAAM,CACnBI,EAAItH,OACJ,IAAK,IAAIjc,EAAI,EAAGA,EAAI,IAAKA,EACrBujB,EAAI7jB,KAAK,EAAIsf,EAAM,EAAIhf,EAAGhC,EAAI,EAEtC,MAEImmB,EAAO7H,OAAO0C,EAI9B,CAKA,SAAAH,GACI,IAAIwF,EAAQ,IAAIzN,EAAK,EAAK,EAAIxQ,KAAKwL,GAAK5S,KAAKof,KACzCkG,EAAOtlB,KAAKulB,gBAAgBF,GAC5BG,EAAK,IAAI5M,EAAK0M,EAAK,GAAIA,EAAK,GAAIA,EAAK,IACrCG,EAAK,EAAK,EAAKzlB,KAAK6e,MACxB4G,GAAMA,EACN,IAAIC,EAAQ,IAAI9N,EAAK,EAAI6N,EAAK,EAAG,GAC7BE,EAAO3lB,KAAKulB,gBAAgBG,GAC5BE,EAAK,IAAIhN,EAAK+M,EAAK,GAAIA,EAAK,GAAIA,EAAK,IACzC,OAAOH,EAAGxK,MAAM4K,EACpB,CAKA,eAAAL,CAAgBM,GACZ,IAAIxN,EAAMjR,KAAK2J,MAAM,EAAM8U,EAAK/U,IAAM,EAAM+U,EAAK/U,IAIjD,MAAO,CAHCuH,EAAMN,EAAM/F,IAAI6T,EAAKpT,KACrB4F,EAAMN,EAAMhG,IAAI8T,EAAKpT,KACrBoT,EAAK/U,EAEjB,CAaA,kBAAAgV,CAAmB9N,EAAKjB,EAAQkM,GAC5BjjB,KAAK4f,YACL,IAAIsD,EAAqB,GAARD,EACbkC,EAAS,IAAI/H,EACjB,GAAIrG,GAAU3P,KAAKwL,GAEf,OADAuS,EAAO5H,QAAQ,EAAGvd,KAAK+e,MAChBoG,EAEX,IAAIlB,EAAQ,EACRf,IAEOD,EAAQA,EAAO,GAClB1Q,QAAQ1O,MAAM,4CAElBogB,EAAQjkB,KAAKkkB,MAAMjB,IAEvB,IAAIkB,EAAO/c,KAAKsE,IAAI1L,KAAKke,UAAWle,KAAKgf,MAAQiF,GAC7C8B,EAAOnN,EAAKsC,cAAclD,GAC1BgO,EAAQ,IAAIxc,MAAM2a,EAAO,GACzB8B,EAAQ,IAAIzc,MAAM2a,EAAO,GACzB5I,EAASxD,EAAM/F,IAAI+E,GACnBmP,EAASnO,EAAMhG,IAAIgF,GACvB,IAAK,IAAI/X,EAAI,EAAGA,GAAKmlB,EAAMnlB,IAAK,CAC5B,IAAIqlB,EAAKrkB,KAAKyf,IAAIzgB,GACdmnB,EAAMnmB,KAAK0f,KAAK1gB,GAChBonB,EAAMpmB,KAAK2f,KAAK3gB,GACpBgnB,EAAMhnB,GAAM+X,EAASsN,EAAKjd,KAAKwL,IAAO,EAAK2I,EAAS4K,EAAMD,EAASE,EACnEH,EAAMjnB,GAAM+X,EAASsN,EAAK,EAAM,EAAK9I,EAAS4K,EAAMD,EAASE,CACjE,CACA,IAAI7B,EAAM,IAAI9H,EAAO,GAAK,EAAI0H,GAC9B,IAAK,IAAInjB,EAAI,EAAGA,EAAI,GAAIA,IACpBujB,EAAI7jB,KAAK,GAAKM,EAAG,GAErB,KAAOujB,EAAIvH,OAAS,GAAG,CAEnB,IAAIgD,EAAMuE,EAAIpH,OACVkJ,EAAQ9B,EAAIrH,OAChBqH,EAAIzH,MACJ,IAAIwJ,EAAMtmB,KAAKwf,GAAG6G,GAAO1D,SAAS3C,GAE9BuG,EAAWvmB,KAAK8kB,aAAaiB,EAAKjV,EAAGkH,EAAIvF,IAAK6T,EAAIxV,EAAGwV,EAAI7T,KAC7D,GAAI8T,EAAWP,EAAMK,GAAQ,CACzB,IAAI7B,EAAQ+B,EAAWhL,EAAU,EAAMgL,GAAYN,EAAMI,GAAU,EAAI,EACvErmB,KAAK2kB,YAAY0B,EAAOlC,EAAMK,EAAMW,EAAQnF,EAAKuE,EAAKrB,EAC1D,CACJ,CACA,OAAOiC,CACX,ECnuBG,MAAMqB,EAqBZ,uBAAOC,CAAiBzP,EAAgB0P,GAyBvC,IAAIpa,EAAIlF,KAAKqa,KAAO+E,EAAWG,YAAcD,EAAW1P,GAUxD,OATA1K,EAAIlF,KAAKwf,MAAMta,GASRA,CAER,CAOA,oBAAOua,CAAc7H,EAAe0H,GAInC,OADa,GAAKA,EAAU,WAAK1H,IAAS5X,KAAK2J,KAAK3J,KAAKwL,GAAK,EAE/D,CAuDA,kBAAOkU,CAAYzL,EAAc1Y,GAEhC,IAAIokB,EAAO,GAMX,OALAA,EAAKrmB,KAAK,IAAIiZ,EAAS,MAAM,EAAO0B,EAAM/H,UAAUtC,SAAWrO,EAAG0Y,EAAM/H,UAAUlC,OAASzO,IAC3FokB,EAAKrmB,KAAK,IAAIiZ,EAAS,MAAM,EAAO0B,EAAM/H,UAAUtC,SAAWrO,EAAG0Y,EAAM/H,UAAUlC,OAASzO,IAC3FokB,EAAKrmB,KAAK,IAAIiZ,EAAS,MAAM,EAAO0B,EAAM/H,UAAUtC,SAAWrO,EAAG0Y,EAAM/H,UAAUlC,OAASzO,IAC3FokB,EAAKrmB,KAAK,IAAIiZ,EAAS,MAAM,EAAO0B,EAAM/H,UAAUtC,SAAWrO,EAAG0Y,EAAM/H,UAAUlC,OAASzO,IAEpFokB,CACR,CAEA,kBAAOC,CAAY9W,EAAgB+W,GAElC,IAAIC,EAA6B,CAChC,MAASxN,IACT,MAASA,IACT,MAASA,IACT,MAASA,IACT,cAAiB,IAIdyN,EAAcF,EAAG1G,sBAAsBrQ,EAAQ,GAC/CkX,EAAY,GAEhB,IAAK,IAAIpmB,EAAI,EAAGA,EAAImmB,EAAYlmB,OAAQD,IAEvC,GADAomB,EAAUpmB,GAAK,IAAI2Y,EAASwN,EAAYnmB,IACpCA,GAAK,EAAG,CACX,IAAI2P,EAAIyW,EAAUpmB,EAAI,GAAGyR,IACrBhI,EAAI2c,EAAUpmB,GAAGyR,IAEjBrL,KAAKM,IAAIiJ,EAAIlG,GAAKrD,KAAKwL,KACtBwU,EAAUpmB,EAAI,GAAGyR,IAAM2U,EAAUpmB,GAAGyR,IACvC2U,EAAUpmB,EAAI,GAAGyR,KAAO,EAAIrL,KAAKwL,GAEjCwU,EAAUpmB,GAAGyR,KAAO,EAAIrL,KAAKwL,G,CAMjC,IAAK,IAAIpP,EAAI,EAAGA,EAAI4jB,EAAUnmB,OAAQuC,IAAK,CAC1C,IAAI6jB,EAAaD,EAAU5jB,GAAGkP,MAG1B4U,EAASlgB,KAAKwL,GAAK,EAAIyU,EAEvBE,EAAQH,EAAU5jB,GAAGiP,IAGrBnP,EAAI,IAAIwP,EAAMzE,EAAW+E,MAAOhF,EAAWkE,QAASiV,EAAOD,GAC3DE,EAAQhB,EAAWiB,mBAAmBnkB,EAAEiQ,OAC5C2T,EAAWQ,cAAkB,EAAJlkB,GAASgkB,EAAM,GACxCN,EAAWQ,cAAkB,EAAJlkB,EAAQ,GAAKgkB,EAAM,IAExC7Q,MAAMuQ,EAAWS,QAAUH,EAAM,GAAKN,EAAWS,SACpDT,EAAWS,MAAQH,EAAM,KAEtB7Q,MAAMuQ,EAAWU,QAAUJ,EAAM,GAAKN,EAAWU,SACpDV,EAAWU,MAAQJ,EAAM,KAEtB7Q,MAAMuQ,EAAWW,QAAUL,EAAM,GAAKN,EAAWW,SACpDX,EAAWW,MAAQL,EAAM,KAEtB7Q,MAAMuQ,EAAWY,QAAUN,EAAM,GAAKN,EAAWY,SACpDZ,EAAWY,MAAQN,EAAM,G,CAI3B,OAAON,CACR,CAEA,yBAAOO,CAAmBM,GAEzB,IAAIC,EACAC,EAEJ,GAAI7gB,KAAKM,IAAIqgB,EAAGT,SAAWd,EAAW0B,OACrCF,EAASD,EAAGtW,MAEZwW,EAASlQ,EAAMhG,IAAIgW,EAAGT,QAAUd,EAAW2B,EAAI,GAAK3B,EAAW4B,OAGzD,GAAIhhB,KAAKM,IAAIqgB,EAAGT,QAAUd,EAAW0B,OAAQ,CAEnD,IAAIzW,EAAQsW,EAAGtW,MAEX4W,EAAI,GACJ7B,EAAW2B,EAAI,GAAM,GAAKJ,EAAGT,OAAS,KACzCe,EAAI,GAGL,IAAIC,EAAQlhB,KAAK2J,KAAKyV,EAAW2B,GAAK,EAAI/gB,KAAKM,IAAIqQ,EAAMhG,IAAIgW,EAAGT,WAC5DiB,GAAiB,EAAInhB,KAAKoF,OAAQub,EAAGtW,MAAQ,KAAO+U,EAAW4B,EAAI,KAAS,EAAIC,GAAK,GAAMA,IAAM,IAAM7B,EAAW4B,GAAxG,IAEdJ,EAASO,GAAS9W,EAAQ8W,GAASD,EACnCL,EAAU,IAAMzB,EAAW4B,IAAQ5B,EAAW2B,EAAI,GAAK,EAAKG,GAExDP,EAAGT,OAAS,IACfW,IAAW,E,CAIb,MAAO,CAACD,EAAQC,EAEjB,CAoCA,uBAAOO,CAAiB5X,EAAWC,EAAWqW,EAA4BR,GACzE,IAGI+B,EACAC,EAJAC,EAAYvhB,KAAKM,IAAIwf,EAAWW,MAAQX,EAAWY,OACnDc,EAAYxhB,KAAKM,IAAIwf,EAAWS,MAAQT,EAAWU,OAKtDa,GADIvB,EAAWY,MAAQ,KAAOZ,EAAWW,MAAQ,MAAQjX,EAAIsW,EAAWY,OAC9DlX,EAAI,IAAMsW,EAAWY,OAASa,GAE9B/X,EAAIsW,EAAWY,OAASa,EAEnCD,GAAU7X,EAAIqW,EAAWU,OAASgB,EAGlC,IAAI5nB,EAAI,IAAOynB,EAASC,GACpBllB,EAAKilB,EAASC,EAAU,GAU5B,OAFA1nB,EAAIoG,KAAKoF,MAAMxL,EAAI0lB,GACnBljB,EAAI4D,KAAKoF,MAAMhJ,EAAIkjB,GACZ,CAAC1lB,EAAG0lB,EAAUljB,EAAI,EAI1B,CAGA,uBAAOqlB,CAAiB7nB,EAAWwC,EAAW0jB,EAA4BjS,EAAgBC,GAczF,IAAI4T,EAAU7T,EACV8T,EAAU7T,EACVD,IACH6T,EAAU7T,GAEPC,IACH6T,EAAU7T,GAEX,IAAIuT,GAAUznB,EAAI,IAAO8nB,EACrBJ,GAAUllB,EAAI,IAAOulB,EAErBJ,EAAYvhB,KAAKM,IAAIwf,EAAWW,MAAQX,EAAWY,OAAS,EAC5Dc,EAAYxhB,KAAKM,IAAIwf,EAAWS,MAAQT,EAAWU,OAAS,EAC5DoB,GAAS9B,EAAWS,MAAQT,EAAWU,OAAS,EAMpD,MAAO,CAHCV,EAAWW,MAAQc,GAAaF,EAASC,GACzCM,EAAQJ,GAAaF,EAASD,GAGvC,CAGA,yBAAOQ,CAAmBrY,EAAWC,GAEpC,IAAIS,EACAJ,EACAgY,EAAK,IAAM1C,EAAW2B,EAAI,GAAK3B,EAAW4B,EAI9C,GAAIhhB,KAAKM,IAAImJ,IAAMqY,EAElB5X,EAASV,EACTM,EAAWC,EAAS/J,KAAK4R,KAAMnI,EAAI2V,EAAW4B,GAAM,GAAK5B,EAAW2B,UAE9D,GAAI/gB,KAAKM,IAAImJ,GAAKqY,EAAI,CAE5B,IAAIZ,GAAS9B,EAAW2B,EAAI,GAAK,EAAI/gB,KAAKM,IAAImJ,EAAI2V,EAAW4B,GAAK,IAC9DpX,EAAW+G,EAAMiB,KAAK,EAAKsP,EAAQA,EAAS9B,EAAW2B,GACvDE,EAAI,GACJ7B,EAAW2B,EAAI,GAAM,GAAKnX,EAAW,KACxCqX,EAAI,GAEL,IAAIc,GAAc,EAAI/hB,KAAKoF,OAAOoE,EAAI,KAAO4V,EAAW4B,EAAI,KAAO,EAAIC,GAAK,GAAKA,IAAM,IAAM7B,EAAW4B,GAA7F,IACX9W,EAAS6X,GAAOvY,EAAIuY,GAAOb,EAC3BpX,EAAWC,EAASH,GAChBH,GAAK,IACRK,IAAa,E,CAQf,OAFQ,IAAI4B,EAAMzE,EAAW+E,MAAOhF,EAAWiE,QAASf,EAAQJ,EAIjE,EA9WO,EAAAkY,iBAA2B,IAE3B,EAAAzC,YAAsB,KACtB,EAAAyB,EAAY,EACZ,EAAAD,EAAY,EACZ,EAAAD,OAAiBnQ,EAAMiB,MAAMwN,EAAW2B,EAAI,GAAK3B,EAAW2B,G,0SCG7D,MAAMkB,EA8CZ,WAAAxkB,GA1CA,KAAAykB,aAAuB,EAiBvB,KAAAnV,UAAsB,GA2BrBnU,KAAK0T,SAAW,MAChB1T,KAAK2T,QAAU,WACf3T,KAAK4T,QAAU,WAEf5T,KAAK6T,UAAY,IAAI1O,IACrBnF,KAAKupB,gBAAkB,IAAI/f,MAC3BxJ,KAAKwpB,WAAa,IAAIhgB,KAEvB,CAEM,mBAAAigB,CAAoBC,G,yCACzB,MAEMhmB,EAFK,IAAIwL,EAAW,MAEPG,QAAQqa,EAAU,eAAe1a,MAAM2a,IACzD,IAAIvpB,EAGHA,EAFGupB,aAAoB/hB,YACH,IAAIgF,YAAY,cACjBO,OAAO,IAAIrF,WAAW6hB,IAElCA,EAAS/iB,SAAS,QAS1B,MAAMgjB,EAASxpB,EAAK8N,MAAM,MAC1BlO,KAAK6pB,iBAAmB,IACxB,IAAK,IAAIC,KAAQF,EAAQ,CACxB,IAAKE,EAAKjkB,SAAS,KAClB,SAGD,MAAMoI,EAAS6b,EAAK5b,MAAM,KAC1B,QAAkBzP,IAAdwP,EAAO,GACV,SAED,MAAMlP,EAAMkP,EAAO,GAAGb,OAChBzE,EAAMsF,EAAO,GAAGb,OAEX,cAAPrO,GACHiB,KAAK+pB,gBAAkBhiB,SAASY,GAChC4J,QAAQqE,IAAI,cAAc5W,KAAK+pB,kBACd,mBAAPhrB,GACViB,KAAK6pB,iBAAmB9hB,SAASY,GACjC3I,KAAKqU,QAAUrU,KAAK6pB,iBACpB7pB,KAAKsU,QAAUtU,KAAK6pB,iBACpBtX,QAAQqE,IAAI,mBAAmB5W,KAAK6pB,mBACnB,cAAP9qB,GAA8B,YAAP4J,IACjC3I,KAAKspB,aAAc,E,CAIrB,OAAOK,CAAQ,IAIhB,aADMjmB,EACCA,CACR,G,CAEM,YAAAqQ,CAAaiW,G,yCAClB,IAEItmB,EAFK,IAAIwL,EAAW8a,GAEP5a,WAAWJ,MAAKoF,IAChCpU,KAAK6T,UAAU/N,IAAI,EAAGsO,EAAK/P,MAC3BrE,KAAKupB,gBAAgB,GAAKnV,EAAKzK,OAE/B,IAAIqV,EAAQ5K,EAAKzK,OAAOvK,IAAI,SAU5B,OATAY,KAAKyL,KAAKuT,GAEVhf,KAAKqU,QAAUD,EAAKzK,OAAOvK,IAAI,UAC/BY,KAAKsU,QAAUF,EAAKzK,OAAOvK,IAAI,UAC/BY,KAAK6pB,iBAAmB7pB,KAAKqU,QAE7BrU,KAAKiqB,OAAS7V,EAAKzK,OAAOvK,IAAI,QAE9BY,KAAKkqB,YAAc1D,EAAWQ,YAAYhnB,KAAKiqB,OAAQjqB,KAAKmqB,KACrD/V,CAAI,IAGZ,aADM1Q,EACCA,CACR,G,CAIM,6BAAA0mB,CAA8BV,EAAiB1S,G,yCACpDhX,KAAKqqB,aAAeX,EACpB1pB,KAAK2U,QAAUqC,OACevY,IAA1BuB,KAAK6pB,yBACF7pB,KAAKypB,oBAAoBC,IAEhC,IAAI1K,EAAQwH,EAAWC,iBAAiBzP,EAAQhX,KAAK6pB,kBACjD7K,EAAQhf,KAAK+pB,kBAChB/K,EAAQhf,KAAK+pB,iBAEd/pB,KAAKyL,KAAKuT,EACX,G,CAEM,4BAAAsL,CAA6BZ,EAAiB1K,G,yCACnDhf,KAAKqqB,aAAeX,OACUjrB,IAA1BuB,KAAK6pB,yBACF7pB,KAAKypB,oBAAoBC,IAE5B1K,EAAQhf,KAAK+pB,kBAChB/K,EAAQhf,KAAK+pB,iBAEd/pB,KAAK2U,QAAU6R,EAAWK,cAAc7H,EAAOhf,KAAK6pB,kBACpD7pB,KAAKyL,KAAKuT,EACX,G,CAEA,IAAAvT,CAAKuT,GACJhf,KAAKuqB,QAAUvL,EACfhf,KAAKwqB,OAAS,WAAKxL,GACnBhf,KAAKmqB,IAAM,IAAInM,EAAQhe,KAAKwqB,OAC7B,CAEA,iBAAAjV,CAAkBC,GACjB,IAAK,IAAI7L,KAAU3J,KAAKupB,gBAAiB,CAExC5f,EAAO/D,sBAAsB,IAAIhB,EAAe,SAAU4Q,EAAiBpW,IAAI,YAC/EuK,EAAO/D,sBAAsB,IAAIhB,EAAe,SAAU4Q,EAAiBpW,IAAI,iBAEzCX,IAAlC+W,EAAiBpW,IAAI,UACxBuK,EAAO1D,QAAQ,IAAIrB,EAAe,QAAS4Q,EAAiBpW,IAAI,WAEjE,IAAI4V,EAAS,OAC0BvW,IAAnC+W,EAAiBpW,IAAI,YACxB4V,EAASQ,EAAiBpW,IAAI,UAC9BuK,EAAO1D,QAAQ,IAAIrB,EAAe,SAAUoQ,KAI7C,IAAID,EAAQ,OAC0BtW,IAAlC+W,EAAiBpW,IAAI,WACxB2V,EAAQS,EAAiBpW,IAAI,SAC7BuK,EAAO1D,QAAQ,IAAIrB,EAAe,QAASmQ,KAG5CpL,EAAO1D,QAAQ,IAAIrB,EAAe,QAAS,IAC3C+E,EAAO1D,QAAQ,IAAIrB,EAAe,SAAU4hB,EAAW4C,mBACvDzf,EAAO1D,QAAQ,IAAIrB,EAAe,SAAU4hB,EAAW4C,mBAEvDzf,EAAO1D,QAAQ,IAAIrB,EAAe,QAAS5E,KAAKuqB,UAEhD5gB,EAAO1D,QAAQ,IAAIrB,EAAe,SAAU5E,KAAK2T,UACjDhK,EAAO1D,QAAQ,IAAIrB,EAAe,SAAU5E,KAAK4T,UAKjDjK,EAAO1D,QAAQ,IAAIrB,EAAe,SAAU,mBAC5C+E,EAAO1D,QAAQ,IAAIrB,EAAe,UAAW,yD,CAG9C,OAAO5E,KAAKupB,eACb,CAGA,aAAA5T,GACC,OAAO3V,KAAKupB,eACb,CAEA,yBAAA3T,GACC,OAAO5V,KAAKyqB,UACb,CAEA,qBAAA3V,CAAsBV,GAErB,IAAIW,EAAQX,EAAKzK,OAAOvK,IAAI,SACxB4V,EAASZ,EAAKzK,OAAOvK,IAAI,UACzB6V,EAASb,EAAKzK,OAAOvK,IAAI,UACzB8V,EAASd,EAAKzK,OAAOvK,IAAI,UACzB8J,EAASkL,EAAKzK,OAAOvK,IAAI,UACzB2M,EAAa3E,KAAKM,IAAIwB,EAAS,GAG/BiM,GAFahP,EAAWmB,oBAAoB8M,EAAKzK,OAAOvK,IAAI,SAAU2M,GAEzC,IAAIvC,MAAgB0L,IAErD,IAAK,IAAIE,EAAK,EAAGA,EAAKF,EAAQE,IAAM,CACnCD,EAAeC,GAAM,IAAI5L,MAAcyL,GACvC,IAAK,IAAII,EAAK,EAAGA,EAAKJ,EAAQI,IAAM,CACnC,IACIC,EAAcP,EAAQC,EADb7O,EAAW8C,kBAAkB,EAAGmL,EAAK/P,KAAK+Q,GAAIhM,MAAMiM,EAAKtJ,GAAasJ,EAAK,GAAKtJ,GAAa7C,GAE1GiM,EAAeC,GAAIC,GAAMC,C,EAG3B,OAAOH,CAER,CAEM,YAAAuV,CAAa3U,EAA+B4U,G,yCAEjD,MAAMC,EAAqB,IAAIzlB,IAC/B,IAAIvF,EAAW,GACXirB,EAAW,IAAIC,IACnB/U,EAAgB5T,SAASgU,IACxB0U,EAASpQ,IAAItE,EAAMjG,OAAO,IAE3B,IAAK,IAAI6a,KAAcF,EAAU,CAChC,IAAI3a,EAAS6a,EACTC,EAAmC,IAA7B5jB,KAAKoF,MAAM0D,EAAS,KAC1B+a,EAAUjrB,KAAKqqB,aAAe,UAAYrqB,KAAKuqB,QAAU,OAASS,EAAM,QAAU9a,EAAS,QAC3F+D,EAAK,IAAI/E,EAAW+b,GAGxBrrB,EAASc,KAAKuT,EAAG7E,WAAWJ,MAAMoF,IACjC,GAAa,OAATA,EAAe,CAClB,IAAI8W,OAAqCzsB,IAA5B2V,EAAKzK,OAAOvK,IAAI,QAAyBgV,EAAKzK,OAAOvK,IAAI,QAAU8Q,EAGhF0a,EAAmB9kB,IAAI6kB,EAAW,QAAUO,EAAQ,QAAS9W,E,MAKhE,aADM5U,QAAQC,IAAIG,GACXgrB,CACR,G,CAGA,YAAI/U,GACH,OAAO7V,KAAKmU,SACb,CAEM,YAAA2B,CAAaC,G,yCAElB,IAAI8U,EAAW,IAAIC,IACnB/U,EAAgB5T,SAASgU,IACxB0U,EAASpQ,IAAItE,EAAMjG,OAAO,IAG3B,IACIgG,EADAD,EAAWF,EAAgB9U,OAE3BkqB,EAA6C,GAC7CvrB,EAAW,GAEX1B,EAAO8B,KACX,IAAK,IAAI+qB,KAAcF,EAAU,CAEhC,IAAIG,EAAuC,IAAjC5jB,KAAKoF,MAAMue,EAAa,KAC9BE,EAAUjrB,KAAKqqB,aAAe,UAAYrqB,KAAKuqB,QAAU,OAASS,EAAM,QAAUD,EAAa,QACnGxY,QAAQqE,IAAI,0BAA0BqU,KACtC,IAAIhX,EAAK,IAAI/E,EAAW+b,GACxBrrB,EAASc,KAAKuT,EAAG7E,WAAWJ,MAAMoF,IAEjC,GAAa,OAATA,EACH+W,EAAezqB,UAAKjC,OACd,CACNP,EAAKiW,UAAUzT,KAAKuqB,GAEpB,IAAIlf,EAAa3E,KAAKM,IAAI0M,EAAKzK,OAAOvK,IAAI,UAAY,GACrC+G,EAAWmB,oBAAoB8M,EAAKzK,OAAOvK,IAAI,SAAU2M,QAC3DtN,IAAXyX,IACHA,EAAS,IAAIpO,WAAWmO,EAAWlK,IAIpCof,EAAezqB,KAAK0T,EAAKzK,QAEzB,IAAK,IAAIrG,EAAI,EAAGA,EAAI2S,EAAU3S,IAAK,CAClC,IAAI6S,EAAQJ,EAAgBzS,GAE5B,GAAI6S,EAAMjG,SAAW6a,GAIhB5U,EAAM/F,GAAKgE,EAAKzK,OAAOvK,IAAI,WAAa+W,EAAMhG,GAAKiE,EAAKzK,OAAOvK,IAAI,UACtE,IAAK,IAAIqL,EAAI,EAAGA,EAAIsB,EAAYtB,IAC/ByL,EAAO5S,EAAIyI,EAAatB,GAAK2J,EAAK/P,KAAK8R,EAAM/F,IAAI+F,EAAMhG,GAAKpE,EAAatB,E,OAiBhF,aALMjL,QAAQC,IAAIG,QACKnB,IAAnB0sB,GACHnrB,KAAKorB,oBAAoBD,GAGnBjV,CACR,G,CAEA,mBAAAG,CAAoBxX,EAAWyX,GAE9BtW,KAAKqU,QAAUjN,KAAKgD,KAAKvL,EAAIyX,GAC7BtW,KAAKsU,QAAUtU,KAAKqU,QACpBrU,KAAK2U,QAAU2B,CAChB,CAEA,mBAAA8U,CAAoBD,GACnB,QAAuB1sB,IAAnB0sB,EAAJ,CAGKnrB,KAAKyqB,aACTzqB,KAAKyqB,WAAa,IAAIvlB,GAGvB,IAAK,IAAIlE,EAAI,EAAGA,EAAImqB,EAAelqB,OAAQD,IAAK,CAC/C,IAAI2I,EAASwhB,EAAenqB,GAC5B,QAAevC,IAAXkL,EAEH,IAAK,IAAIhE,KAAQgE,EAAOnE,cACvB,GAAI,CAAC,SAAU,SAAU,SAAU,QAAS,QAAS,SAASK,SAASF,EAAK5G,KAC3E,GAAKiB,KAAKyqB,WAAWhlB,cAAcE,EAAK5G,KAAK,IAEtC,GAAIiB,KAAKyqB,WAAWhlB,cAAcE,EAAK5G,KAAK,GAAG+D,QAAU6C,EAAK7C,MACpE,MAAM,IAAIM,MAAM,0BAA4BuC,EAAK5G,IAAM,QAAUiB,KAAKyqB,WAAWhlB,cAAcE,EAAK5G,KAAK,GAAK,eAAiB4G,EAAK7C,YAFpI9C,KAAKyqB,WAAWxkB,QAAQ,IAAIrB,EAAee,EAAK5G,IAAK4G,EAAK7C,O,EAWhE,CAWA,WAAAyT,CAAYL,EAAoBV,GAK/B,IAAIzJ,EAAa3E,KAAKM,IAAI8N,EAAiBpW,IAAI,UAAY,GACvD4V,OAA6CvW,IAAnC+W,EAAiBpW,IAAI,UAA2BoW,EAAiBpW,IAAI,UAAY,EAC3F2V,OAA2CtW,IAAlC+W,EAAiBpW,IAAI,SAA0BoW,EAAiBpW,IAAI,SAAW,EAE5F,QAAmBX,IAAfsN,QAAuCtN,IAAXuW,QAAkCvW,IAAVsW,EACvD,MAAM,IAAI3R,MAAM,yCAKjB,IAuBI8O,EACAC,EACAkZ,EACAC,EA1BAC,EAAY,IAAIpmB,IAChBqmB,EAAS,IAAIrmB,IAIjBnF,KAAKyrB,WAAWtpB,SAAS+N,IAIxBlQ,KAAK6T,UAAU/N,IAAIoK,EAAQ,IAAI1G,MAAMxJ,KAAK6pB,mBAC1C,IAAK,IAAIyB,EAAM,EAAGA,EAAMtrB,KAAK6pB,iBAAkByB,IAC9C,GAAItrB,KAAK6T,UAAU6X,IAAIxb,GAAS,CAC/B,IAAI5M,EAAItD,KAAK6T,UAAUzU,IAAI8Q,QACjBzR,IAAN6E,IAEHA,EAAEgoB,GAAO,IAAIxjB,WAAW9H,KAAK6pB,iBAAmB9d,G,CAKnDwf,EAAUzlB,IAAI,GAAKoK,EAAa,IAAI1G,MAAM,IAC1CgiB,EAAO1lB,IAAI,GAAKoK,GAAa,EAAK,IAOnC,IAAK,IAAIyb,EAAQ,EAAGA,EAAQ3rB,KAAKwpB,WAAWvoB,OAAQ0qB,IAAS,EAC3DzZ,EAAIC,GAAOnS,KAAKwpB,WAAWmC,GAC5B,IAAI5D,EAAK9V,EAAUC,EAAIC,EAAK/D,EAAWiE,SACnCuZ,EAAKha,EAAiBmW,GACtB/P,EAAM,IAAI2B,EAAS,MAAM,EAAOiS,EAAG5a,SAAU4a,EAAGxa,QAChDya,EAAoB7rB,KAAKmqB,IAAIvH,QAAQ5K,GAErCkP,EAAaV,EAAWQ,YAAY6E,EAAW7rB,KAAKmqB,KAIpD2B,EAAKtF,EAAWiB,mBAAmBM,GACvC,QAA8BtpB,IAA1BuB,KAAK6pB,iBACR,MAAM,IAAIzmB,MAAM,mCAEjB,IAAI2oB,EAAKvF,EAAWgC,iBAAiBsD,EAAG,GAAIA,EAAG,GAAI5E,EAAYlnB,KAAK6pB,kBACpEwB,EAAMU,EAAG,GACTT,EAAMS,EAAG,GAET,IAAK,IAAIthB,EAAI,EAAGA,EAAIsB,EAAYtB,IAAK,CACpC,IAAIpC,EAAO6N,EAAOyV,EAAQ5f,EAAatB,GAEvC,GAAIzK,KAAK6T,UAAU6X,IAAIG,GAAY,CAClC,IAAIvoB,EAAItD,KAAK6T,UAAUzU,IAAIysB,QACjBptB,IAAN6E,IACHA,EAAEgoB,GAAKD,EAAMtf,EAAatB,GAAKpC,E,CAG7BmjB,EAAOpsB,IAAI,GAAKysB,IACP,GAARxjB,GACHmjB,EAAO1lB,IAAI,GAAK+lB,GAAgB,E,CAMnC,IAAIngB,EAAM6f,EAAUnsB,IAAI,GAAKysB,GAAgB,GACzClgB,EAAM4f,EAAUnsB,IAAI,GAAKysB,GAAgB,GAE7C,GAAI7rB,KAAK6T,UAAU6X,IAAIG,GAAY,CAClC,IAAIvoB,EAAItD,KAAK6T,UAAUzU,IAAIysB,GAC3B,QAAUptB,IAAN6E,EAAiB,CACpB,IACIoT,EAAc3B,EAAQC,EADZ7O,EAAW8C,kBAAkB,EAAG3F,EAAEgoB,GAAKliB,MAAMiiB,EAAMtf,EAAYsf,EAAMtf,EAAaA,GAAayJ,EAAiBpW,IAAI,WAE9HsX,EAAchL,GAAOiL,MAAMjL,GAC9B6f,EAAUnsB,IAAI,GAAKysB,GAAgB,GAAKnV,GAC9BA,EAAc/K,GAAOgL,MAAMhL,MACrC4f,EAAUnsB,IAAI,GAAKysB,GAAgB,GAAKnV,E,GAwC5C,OA/BelN,MAAMwiB,KAAKhsB,KAAK6T,UAAUnU,QAElCyC,SAAS+N,IACf,GAAoC,GAAhCsb,EAAOpsB,IAAI,GAAK8Q,GAAuB,CAE1C,IAAIvG,EAAS,IAAIzE,EACjByE,EAAO7D,IAAI,OAAQoK,GAInBvG,EAAO1D,QAAQ,IAAIrB,EAAe,UAAW2mB,EAAUnsB,IAAI,GAAK8Q,GAAa,KAC7EvG,EAAO1D,QAAQ,IAAIrB,EAAe,UAAW2mB,EAAUnsB,IAAI,GAAK8Q,GAAa,KAC7EvG,EAAO1D,QAAQ,IAAIrB,EAAe,OAAQsL,IAE1C,IAAI0J,EAAO5Z,KAAKmqB,IAAI1H,QAAQvS,GACxB8H,EAAM,IAAI2B,EAASC,GACnBqS,EAAS9a,EAAS6G,EAAIvF,KACtByZ,EAAS,GAAK/a,EAAS6G,EAAItF,OAE/B/I,EAAO1D,QAAQ,IAAIrB,EAAe,SAAUqnB,IAC5CtiB,EAAO1D,QAAQ,IAAIrB,EAAe,SAAUsnB,IAE5ClsB,KAAKupB,gBAAgB7oB,KAAKiJ,E,MAG1B3J,KAAK6T,UAAUsY,OAAOjc,E,IAKxBlQ,KAAKuV,kBAAkBC,GAChBxV,KAAK6T,SAEb,CAEA,iBAAAgD,CAAkBC,EAAesV,GAEhC,IAAIpU,EAAM,IAAI2B,EAAS,MAAM,EAAO7C,EAAOxD,UAAUtC,SAAU8F,EAAOxD,UAAUlC,QAC5Eib,EAAa1a,EAASya,GAGtBE,EAAWtsB,KAAKmqB,IAAIrE,mBAAmB9N,EAAKqU,EAAY,GAE5DrsB,KAAKyrB,WAAa,GAClB,IAAK,IAAInoB,EAAI,EAAGA,EAAIgpB,EAAS3pB,EAAE1B,OAAQqC,IAEjCtD,KAAKyrB,WAAW5lB,SAASymB,EAAS3pB,EAAEW,KAAwB,GAAjBgpB,EAAS3pB,EAAEW,IAC1DtD,KAAKyrB,WAAW/qB,KAAK4rB,EAAS3pB,EAAEW,IAKlC,IAAIipB,EAAOvsB,KAAKmqB,IAAIvH,QAAQ5K,GACvBhY,KAAKyrB,WAAW5lB,SAAS0mB,IAC7BvsB,KAAKyrB,WAAW/qB,KAAK6rB,GAItB,IAAIC,EAAQ1V,EAAOvD,MAAM9B,MAAQ2a,EAC7BK,EAAQ3V,EAAOvD,MAAM9B,MAAQ2a,EAC7BM,EAAS5V,EAAOvD,MAAM7B,OAAS0a,EAC/BO,EAAS7V,EAAOvD,MAAM7B,OAAS0a,EAiBnC,OAfApsB,KAAKyrB,WAAWtpB,SAAS+N,IACxBlQ,KAAKkqB,YAAc1D,EAAWQ,YAAY9W,EAAQlQ,KAAKmqB,KAGvD,IAAK,IAAI3mB,EAAI,EAAGA,EAAIxD,KAAK6pB,iBAAkBrmB,IAC1C,IAAK,IAAIxC,EAAI,EAAGA,EAAIhB,KAAK6pB,iBAAkB7oB,IAAK,CAC/C,IAAIsC,EAAItD,KAAKmX,UAAUnW,EAAGwC,GACtBF,EAAEiQ,MAAM9B,MAAQ+a,GAASlpB,EAAEiQ,MAAM9B,MAAQgb,GAC5CnpB,EAAEiQ,MAAM7B,OAASgb,GAAUppB,EAAEiQ,MAAM7B,OAASib,GAG7C3sB,KAAKwpB,WAAW9oB,KAAK,CAAC4C,EAAEiQ,MAAM9B,MAAOnO,EAAEiQ,MAAM7B,Q,KAIzC1R,KAAKwpB,UAGb,CAGA,SAAArS,CAAUnW,EAAWwC,GAEpB,IAAIsoB,EAAKtF,EAAWqC,iBAAiB7nB,EAAGwC,EAAGxD,KAAKkqB,YAAalqB,KAAKqU,QAASrU,KAAKsU,SAahF,OAJQkS,EAAWyC,mBAAmB6C,EAAG,GAAIA,EAAG,GAKjD,CAIA,iBAAAc,CAAkB3V,GACjB,IAAI4V,EAA6B,GACjC,MAAMC,EAAU1lB,KAAKwL,GAAK,IACpBma,EAAU,IAAM3lB,KAAKwL,GACrBoa,EAAkB,OAAVF,EACRG,EAAkB,QAAVH,EACRI,EAAkB,SAAVJ,EAkBd,OAjBA7V,EAAU9U,SAAQ,EAAE+P,EAAIC,MACvB,MAAMgb,EAASL,EAAU5a,EACnBkb,EAAUN,EAAU3a,EAEpBkb,EAAQjmB,KAAK2K,IAAIkb,GAAS7lB,KAAK2K,IAAIqb,GACrChmB,KAAK4K,IAAIib,GAAS7lB,KAAK4K,IAAIob,GAAWhmB,KAAK4K,IAAImb,EAASD,GAEtDI,EADIlmB,KAAK4R,KAAKqU,GACFN,EAGZQ,EAAenmB,KAAKomB,KAASpmB,KAAK4K,IAAIob,GAAWhmB,KAAK2K,IAAIob,EAASD,IACpE9lB,KAAK2K,IAAIqb,GAAWhmB,KAAK4K,IAAIib,GAAS7lB,KAAK4K,IAAIob,GAAWhmB,KAAK2K,IAAIkb,GAAS7lB,KAAK4K,IAAImb,EAASD,KAE7FO,GADIT,EAAQO,GACAR,EAElBF,EAAensB,KAAK,CAAC+sB,EAAOH,GAAO,IAE7BT,CACR,CAEA,SAAAzV,CAAUH,GAGT,IACI/G,EACAwd,EAFArW,EAA0B,GAoC9B,OA3BIrX,KAAKspB,cAERrS,EADqBjX,KAAK4sB,kBAAkB3V,IAI7CA,EAAU9U,SAAQ,EAAE+P,EAAIC,MAEvB,IAAI7O,EAAI,IAAIwP,EAAMzE,EAAW+E,MAAOhF,EAAWiE,QAASH,EAAIC,GAExD6F,EAAM,IAAI2B,EAAS,MAAM,EAAOrW,EAAEgQ,UAAUtC,SAAU1N,EAAEgQ,UAAUlC,QAEtElB,EAASlQ,KAAKmqB,IAAIvH,QAAQ5K,GACtB0V,IAAexd,QAAyBzR,IAAfivB,IAC5B1tB,KAAKkqB,YAAc1D,EAAWQ,YAAY9W,EAAQlQ,KAAKmqB,KACvDuD,EAAaxd,GAId,IAAI4b,EAAKtF,EAAWiB,mBAAmBnkB,EAAEiQ,OACzC,QAA8B9U,IAA1BuB,KAAK6pB,iBACR,MAAM,IAAIzmB,MAAM,mCAEjB,IAAI2oB,EAAKvF,EAAWgC,iBAAiBsD,EAAG,GAAIA,EAAG,GAAI9rB,KAAKkqB,YAAalqB,KAAK6pB,kBAE1ExS,EAAU3W,KAAK,IAAIuP,EAAW8b,EAAG,GAAIA,EAAG,GAAI7b,GAAQ,IAG9CmH,CACR,EChqBM,MAAesW,GCPf,MAAMC,UAA0BD,EACnC,YAAW9X,GACP,MAAM,IAAIzS,MAAM,0BACpB,CACO,YAAA2Q,CAAaiW,EAAuB6D,EAAkB7W,EAAiBgI,GAC1E,MAAM,IAAI5b,MAAM,0BACpB,CACO,iBAAAmS,CAAkBC,GACrB,MAAM,IAAIpS,MAAM,0BACpB,CACO,aAAAuS,GACH,MAAM,IAAIvS,MAAM,0BACpB,CACO,yBAAAwS,GACH,MAAM,IAAIxS,MAAM,0BACpB,CACO,qBAAA0R,CAAsBV,GACzB,MAAM,IAAIhR,MAAM,0BACpB,CACO,YAAA0S,CAAaC,GAChB,MAAM,IAAI3S,MAAM,0BACpB,CACO,mBAAAiT,CAAoBxX,EAAWyX,GAClC,MAAM,IAAIlT,MAAM,0BACpB,CACO,WAAAmT,CAAYL,EAAoBV,GACnC,MAAM,IAAIpS,MAAM,0BACpB,CACO,iBAAAyT,CAAkBC,EAAeC,EAAgBC,GACpD,MAAM,IAAI5T,MAAM,0BACpB,CACO,SAAA+T,CAAUnW,EAAWwC,GACxB,MAAM,IAAIJ,MAAM,0BACpB,CACO,SAAAgU,CAAUH,GACb,MAAM,IAAI7T,MAAM,0BACpB,E,0SCvBG,MAAM0qB,UAA2BH,EAwBpC,WAAA9oB,CAAYmP,GACR5O,QACApF,KAAK2T,QAAU,WACf3T,KAAK4T,QAAU,WAEXI,IACAhU,KAAK+tB,QAAU/Z,EAEvB,CA/BA,YAAW6B,GACP,MAAM,IAAIzS,MAAM,0BACpB,CA+BM,YAAA2Q,CAAaC,G,yCAEf,IAEItQ,EAFK,IAAIwL,EAAW8E,GAEP5E,WAAWJ,MAAKoF,IAG7BpU,KAAK6T,UAAU/N,IAAI,EAAGsO,EAAK/P,MAC3BrE,KAAK8T,YAAY,GAAKM,EAAKzK,OAC3B3J,KAAKqU,QAAUD,EAAKzK,OAAOvK,IAAI,UAC/BY,KAAKsU,QAAUF,EAAKzK,OAAOvK,IAAI,UAC/BY,KAAKuU,QAAUH,EAAKzK,OAAOlE,cAAc,UAAU,GAAG3C,MACtD9C,KAAKwU,SAAWJ,EAAKzK,OAAOlE,cAAc,UAAU,GAAG3C,MAKvD9C,KAAKguB,SAAWhuB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GAAG3C,MAC/D9C,KAAKiuB,SAAWjuB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GAAG3C,MAE/D9C,KAAK4U,OAAS5U,KAAKuU,QAAUvU,KAAKguB,SAAWhuB,KAAKqU,QAAU,EACxDrU,KAAK4U,OAAS,IACd5U,KAAK4U,QAAU,KAEnB5U,KAAK6U,QAAU7U,KAAKwU,SAAWxU,KAAKiuB,SAAWjuB,KAAKsU,QAAU,EAEvDF,KAIX,aADM1Q,EACCA,CACX,G,CAEA,qBAAAoR,CAAsBV,GAElB,IAAIW,EAAQX,EAAKzK,OAAOvK,IAAI,SACxB4V,EAASZ,EAAKzK,OAAOvK,IAAI,UACzB6V,EAASb,EAAKzK,OAAOvK,IAAI,UACzB8V,EAASd,EAAKzK,OAAOvK,IAAI,UACzB8J,EAASkL,EAAKzK,OAAOvK,IAAI,UACzB2M,EAAa3E,KAAKM,IAAIwB,EAAS,GAG/BiM,GAFahP,EAAWmB,oBAAoB8M,EAAKzK,OAAOvK,IAAI,SAAU2M,GAEzC,IAAIvC,MAAgB0L,IAErD,IAAK,IAAIE,EAAK,EAAGA,EAAKF,EAAQE,IAAM,CAChCD,EAAeC,GAAM,IAAI5L,MAAcyL,GACvC,IAAK,IAAII,EAAK,EAAGA,EAAKJ,EAAQI,IAAM,CAChC,IACIC,EAAcP,EAAQC,EADb7O,EAAW8C,kBAAkB,EAAGmL,EAAK/P,KAAK+Q,GAAIhM,MAAMiM,EAAKtJ,GAAasJ,EAAK,GAAKtJ,GAAa7C,GAE1GiM,EAAeC,GAAIC,GAAMC,C,EAGjC,OAAOH,CAGX,CAEA,iBAAAI,CAAkBC,GAEdxV,KAAK8T,YAAY,GAAK,IAAI5O,EAG1BlF,KAAK8T,YAAY,GAAGlO,sBAAsB,IAAIhB,EAAe,SAAU4Q,EAAiBpW,IAAI,YAC5FY,KAAK8T,YAAY,GAAGlO,sBAAsB,IAAIhB,EAAe,SAAU4Q,EAAiBpW,IAAI,iBAEtDX,IAAlC+W,EAAiBpW,IAAI,UACrBY,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,QAAS4Q,EAAiBpW,IAAI,WAGjF,IAAI4V,EAAS,OAC0BvW,IAAnC+W,EAAiBpW,IAAI,YACrB4V,EAASQ,EAAiBpW,IAAI,WAElCY,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAUoQ,IAEzD,IAAID,EAAQ,OAC0BtW,IAAlC+W,EAAiBpW,IAAI,WACrB2V,EAAQS,EAAiBpW,IAAI,UAEjCY,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,QAASmQ,IAGxD/U,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,QAAS,IACxD5E,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKqU,UAC9DrU,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKsU,UAE9DtU,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAK2T,UAC9D3T,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAK4T,UAE9D5T,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAK2U,UAC9D3U,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAK2U,UAC9D3U,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKqU,QAAU,IACxErU,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKsU,QAAU,IACxEtU,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKuU,UAC9DvU,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU5E,KAAKwU,WAE9D,IAAI9I,EAAMqJ,EAAQC,EAAShV,KAAKyV,gBAC5B9J,EAAMoJ,EAAQC,EAAShV,KAAK0V,gBAShC,OARA1V,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,UAAW8G,IAC1D1L,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,UAAW+G,IAG1D3L,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,SAAU,mBACzD5E,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,UAAW,0DAC1D5E,KAAK8T,YAAY,GAAG7N,QAAQ,IAAIrB,EAAe,QAExC5E,KAAK8T,WAEhB,CAEA,aAAA6B,GACI,OAAO3V,KAAK8T,WAChB,CAEA,yBAAA8B,GACI,IAAIjM,EAAS,IAAIzE,EACjB,IAAK,MAAOnG,EAAK+D,KAAU9C,KAAK8T,YAAY,GAEpC,CAAC,SAAU,SAAU,SAAU,QAAS,QAAS,SAAUjO,SAAS9G,IAGpE4K,EAAO1D,QAAQ,IAAIrB,EAAe7F,EAAK+D,IAI/C,OAAO6G,CACX,CAEM,YAAAmM,CAAaC,G,yCAiCf,OA/Bc,IAAIvW,SAAoB,CAACmE,EAASC,KAC5C,IACI,IAAImI,EAAa3E,KAAKM,IAAI1H,KAAK8T,YAAY,GAAG1U,IAAI,UAAY,GAC1D4W,EAAa7P,EAAWmB,oBAAoBtH,KAAK8T,YAAY,GAAG1U,IAAI,SAAU2M,GAC9EkK,EAAWF,EAAgB9U,OAE3BiV,EAAS,IAAIpO,WAAWmO,EAAWlK,GAEvC,IAAK,IAAIzI,EAAI,EAAGA,EAAI2S,EAAU3S,IAAK,CAE/B,IAAI6S,EAAQJ,EAAgBzS,GAG5B,GAAK6S,EAAQ,GAAI,GAAMA,EAAQ,IAAKnW,KAAKsU,SACpC6B,EAAQ,GAAI,GAAMA,EAAQ,IAAKnW,KAAKqU,QACrC,IAAK,IAAI5J,EAAI,EAAGA,EAAIsB,EAAYtB,IAC5ByL,EAAO5S,EAAIyI,EAAatB,GAAKuL,EAAWvL,QAG5C,IAAK,IAAIA,EAAI,EAAGA,EAAIsB,EAAYtB,IAC5ByL,EAAO5S,EAAIyI,EAAatB,GAAMzK,KAAK6T,UAAUzU,IAAI,GAAI+W,EAAM/F,IAAK+F,EAAQ,GAAIpK,EAAatB,E,CAKrG9G,EAAQuS,E,CACV,MAAOnG,GACLnM,EAAO,+BAAiCmM,E,IAMpD,G,CAEA,mBAAAsG,CAAoBxX,EAAWyX,GAE3BtW,KAAKqU,QAAUjN,KAAKgD,KAAKvL,EAAIyX,GAC7BtW,KAAKsU,QAAUtU,KAAKqU,QACpBrU,KAAK2U,QAAU2B,CACnB,CAEA,WAAAC,CAAYL,EAAoBV,GAgB5B,OAAO,IACX,CAEA,iBAAAqB,CAAkBC,EAAeC,EAAgBC,GAoD7C,OAAO,IAEX,CAEA,SAAAG,CAAUnW,EAAWwC,GAGjB,IAAIoN,EAAGC,EACHqd,EAASluB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GACrD0oB,EAASnuB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GACrD2oB,EAAQpuB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACnD4oB,EAAQruB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACnD6oB,EAAQtuB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACnD8oB,EAAQvuB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GAEnD+oB,EAAQxuB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACnDgpB,EAAQzuB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACnDipB,EAAQ1uB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACnDkpB,EAAQ3uB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GAEnDmpB,EAAS5uB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GACrDopB,EAAS7uB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GA4BzD,YAzBehH,IAAXyvB,QAAmCzvB,IAAX0vB,QACd1vB,IAAV2vB,QAAiC3vB,IAAV4vB,QACb5vB,IAAV6vB,QAAiC7vB,IAAV8vB,GAEvB3d,EAAIsd,GAAUE,GAASptB,EAAI4tB,GAAUP,GAAS7qB,EAAIqrB,IAClDhe,EAAIsd,GAAUG,GAASttB,EAAI4tB,GAAUL,GAAS/qB,EAAIqrB,MAElDje,EAAI4d,GAASxtB,EAAI4tB,GAAUH,GAASjrB,EAAIqrB,GACxChe,EAAI6d,GAAS1tB,EAAI4tB,GAAUD,GAASnrB,EAAIqrB,IAiBrC,IACX,CAEA,SAAAzX,CAAUH,GA0CN,OAtCcjX,KAAK8T,YAAY,GAAGrO,cAAc,UAAUxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GACtGzF,KAAK8T,YAAY,GAAGrO,cAAc,UAAUxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GACvGzF,KAAK8T,YAAY,GAAGrO,cAAc,SAASxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACpGzF,KAAK8T,YAAY,GAAGrO,cAAc,SAASxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACpGzF,KAAK8T,YAAY,GAAGrO,cAAc,SAASxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACpGzF,KAAK8T,YAAY,GAAGrO,cAAc,SAASxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GAEpGzF,KAAK8T,YAAY,GAAGrO,cAAc,SAASxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACpGzF,KAAK8T,YAAY,GAAGrO,cAAc,SAASxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACpGzF,KAAK8T,YAAY,GAAGrO,cAAc,SAASxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GACpGzF,KAAK8T,YAAY,GAAGrO,cAAc,SAASxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,SAAS,GAEnGzF,KAAK8T,YAAY,GAAGrO,cAAc,UAAUxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GACtGzF,KAAK8T,YAAY,GAAGrO,cAAc,UAAUxE,OAAS,GAAKjB,KAAK8T,YAAY,GAAGrO,cAAc,UAAU,GAEpHwR,EAAU9U,SAAQ,EAAE+P,EAAIC,MAAN,IAjBY,EA0ClC,ECxXG,MAAM2c,EAGT,WAAAjqB,GAAgB,CAEhB,aAAakqB,CAAOjY,EAAeC,EAC/BC,EAAgBgY,EAA4BC,G,qCAE5C,MAAMC,EAAqCD,EAAQpY,kBAAkBC,EAAQC,EAAQC,GACrF,GAA2B,GAAvBkY,EAAajuB,OAQb,MAP0B,CACtB6J,WAAY,KACZqkB,SAAU,KACVH,OAAQA,EACRC,QAASA,EACTG,SAAUJ,EAAOnZ,UAIzB,MAAME,EAAkBiZ,EAAO5X,UAAU8X,GACzC,IAEI,MAAMG,QAAiBL,EAAOlZ,aAAaC,GACrCP,EAAmBwZ,EAAOpZ,4BAChC,QAAiBnX,IAAb4wB,EAAwB,CACxB,MAAMF,EAAWF,EAAQ1Y,YAAY8Y,EAAU7Z,GAU/C,MAP0B,CACtB1K,WAHemkB,EAAQtZ,gBAIvBwZ,SAAUA,EACVH,OAAQA,EACRC,QAASA,EACTG,SAAUJ,EAAOnZ,S,CAWrB,MAP0B,CACtB/K,WAAY,KACZqkB,SAAU,KACVH,OAAQA,EACRC,QAASA,EACTG,SAAUJ,EAAOnZ,S,CAK3B,MAAO9F,GAEL,OADAwC,QAAQ1O,MAAM,qBAAuBkM,GAC9B,I,CAGf,E,+RAQA,mBAAOJ,CAAa7E,EAAiBqkB,GAEjC,OADgBjgB,EAAWS,aAAa7E,EAAYqkB,EAExD,CAKA,uBAAOG,CAAiBC,EAAUC,GAElC,CAGA,oBAAOC,CAAcC,GACjB,MAAuB,aAAnBA,EACO,IAAIjc,EACe,SAAnBic,EACA,IAAIrG,EACe,YAAnBqG,EACA,IAAI9B,EACe,aAAnB8B,EACA,IAAI5B,EAEJ,IAGf,CAEA,+BAAO6B,GACH,MAAO,CAAC,WAAY,OAAQ,UAChC,EC3FG,MAAMC,EAmBT,WAAA/qB,GACI7E,KAAK0T,SAAW,MAChB1T,KAAK2T,QAAU,WACf3T,KAAK4T,QAAU,WACf5T,KAAK6T,UAAY,IAAI1O,IACV,IAAID,EACJ,IAAIgK,EAAW,kBACd,IAAItK,EAAe,QAAS,UAAW,YAGvD,CACA,YAAWiR,GACP,MAAM,IAAIzS,MAAM,0BACpB,CAEO,YAAA2Q,CAAaiW,EAAuB6D,EAAkB7W,EAAiBgI,GAC1E,MAAM,IAAI5b,MAAM,0BACpB,CACO,iBAAAmS,CAAkBC,GACrB,MAAM,IAAIpS,MAAM,0BACpB,CACO,aAAAuS,GACH,MAAM,IAAIvS,MAAM,0BACpB,CACO,yBAAAwS,GACH,MAAM,IAAIxS,MAAM,0BACpB,CACO,qBAAA0R,CAAsBV,GACzB,MAAM,IAAIhR,MAAM,0BACpB,CACO,YAAA0S,CAAaC,GAChB,MAAM,IAAI3S,MAAM,0BACpB,CACO,mBAAAiT,CAAoBxX,EAAWyX,GAClC,MAAM,IAAIlT,MAAM,0BACpB,CACO,WAAAmT,CAAYL,EAAoBV,GACnC,MAAM,IAAIpS,MAAM,0BACpB,CACO,iBAAAyT,CAAkBC,EAAeC,EAAgBC,GACpD,MAAM,IAAI5T,MAAM,0BACpB,CACO,SAAA+T,CAAUnW,EAAWwC,GACxB,MAAM,IAAIJ,MAAM,0BACpB,CACO,SAAAgU,CAAUH,GACb,MAAM,IAAI7T,MAAM,0BACpB,E","sources":["webpack://wcslight/webpack/universalModuleDefinition","webpack://wcslight/webpack/runtime/load script","webpack://wcslight/webpack/bootstrap","webpack://wcslight/webpack/runtime/define property getters","webpack://wcslight/webpack/runtime/ensure chunk","webpack://wcslight/webpack/runtime/get javascript chunk filename","webpack://wcslight/webpack/runtime/global","webpack://wcslight/webpack/runtime/hasOwnProperty shorthand","webpack://wcslight/webpack/runtime/make namespace object","webpack://wcslight/webpack/runtime/publicPath","webpack://wcslight/webpack/runtime/jsonp chunk loading","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseUtils.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSWriter.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParsePayload.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSParser.js","webpack://wcslight/./src/model/NumberType.ts","webpack://wcslight/./src/model/CoordsType.ts","webpack://wcslight/./src/model/ImagePixel.ts","webpack://wcslight/./src/model/Utils.ts","webpack://wcslight/./src/model/Point.ts","webpack://wcslight/./src/projections/MercatorProjection.ts","webpack://wcslight/./node_modules/healpixjs/lib-esm/Constants.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Zphi.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Hploc.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Pointing.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Vec3.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/CircleFinder.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Fxyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/pstack.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/RangeSet.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Xyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Healpix.js","webpack://wcslight/./src/projections/HiPSHelper.ts","webpack://wcslight/./src/projections/HiPSProjection.ts","webpack://wcslight/./src/projections/AbstractProjection.ts","webpack://wcslight/./src/projections/HEALPixProjection.ts","webpack://wcslight/./src/projections/GnomonicProjection.ts","webpack://wcslight/./src/WCSLight.ts","webpack://wcslight/./src/projections/TestProj.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"wcslight\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wcslight\"] = factory();\n\telse\n\t\troot[\"wcslight\"] = factory();\n})(self, () => {\nreturn ","var inProgress = {};\nvar dataWebpackPrefix = \"wcslight:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t992: 0,\n\t434: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkwcslight\"] = self[\"webpackChunkwcslight\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class FITSHeaderItem {\n    constructor(key, value, comment) {\n        this._key = key !== undefined ? key : undefined;\n        this._value = value !== undefined ? value : undefined;\n        this._comment = comment !== undefined ? comment : undefined;\n    }\n    get key() {\n        return this._key;\n    }\n    get comment() {\n        return this._comment;\n    }\n    get value() {\n        return this._value;\n    }\n}\n//# sourceMappingURL=FITSHeaderItem.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n// reference FTIS standard doc https://heasarc.gsfc.nasa.gov/docs/fcg/standard_dict.html\nexport class FITSHeader extends Map {\n    constructor() {\n        super();\n        this._offset = undefined;\n        this._items = [];\n    }\n    set offset(offset) {\n        this._offset = offset;\n    }\n    get offset() {\n        return this._offset;\n    }\n    getItemList() {\n        return this._items;\n    }\n    getItemListOf(key) {\n        const res = [];\n        for (let i = 0; i < this._items.length; i++) {\n            const item = this._items[i];\n            if (item.key == key) {\n                res.push(item);\n            }\n        }\n        return res;\n    }\n    addItemAtTheBeginning(item) {\n        if (item.key !== undefined) {\n            if ([\n                \"SIMPLE\",\n                \"BITPIX\",\n                \"NAXIS\",\n                \"NAXIS1\",\n                \"NAXIS2\",\n                \"BLANK\",\n                \"BZERO\",\n                \"BSCALE\",\n                \"DATAMIN\",\n                \"DATAMAX\",\n                \"NPIX\",\n                \"ORDER\",\n                \"CRPIX1\",\n                \"CRPIX2\",\n                \"CDELT1\",\n                \"CDELT2\",\n                \"CRVAL1\",\n                \"CRVAL2\",\n            ].includes(item.key)) {\n                this.set(item.key, item.value);\n            }\n        }\n        const newitemlist = [item].concat(this._items);\n        this._items = newitemlist;\n    }\n    addItem(item) {\n        if (item.key !== undefined) {\n            if ([\n                \"SIMPLE\",\n                \"BITPIX\",\n                \"NAXIS\",\n                \"NAXIS1\",\n                \"NAXIS2\",\n                \"BLANK\",\n                \"BZERO\",\n                \"BSCALE\",\n                \"DATAMIN\",\n                \"DATAMAX\",\n                \"NPIX\",\n                \"ORDER\",\n                \"CRPIX1\",\n                \"CRPIX2\",\n                \"CDELT1\",\n                \"CDELT2\",\n                \"CRVAL1\",\n                \"CRVAL2\",\n            ].includes(item.key)) {\n                this.set(item.key, item.value);\n            }\n        }\n        this._items.push(item);\n    }\n    getNumRows() {\n        return this._items.length;\n    }\n}\n//# sourceMappingURL=FITSHeader.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseUtils {\n    static getStringAt(data, offset, length) {\n        const chars = [];\n        for (let i = offset, j = 0; i < offset + length; i++, j++) {\n            chars[j] = String.fromCharCode(data.charCodeAt(i) & 0xff);\n        }\n        return chars.join(\"\");\n    }\n    static byteString(n) {\n        if (n < 0 || n > 255 || n % 1 !== 0) {\n            throw new Error(n + \" does not fit in a byte\");\n        }\n        return (\"000000000\" + n.toString(2)).substr(-8);\n    }\n    static parse32bitSinglePrecisionFloatingPoint(byte1, byte2, byte3, byte4) {\n        let long = (((((byte1 << 8) + byte2) << 8) + byte3) << 8) + byte4;\n        if (long < 0)\n            long += 4294967296;\n        const float = (1.0 + (long & 0x007fffff) / 0x0800000) *\n            Math.pow(2, ((long & 0x7f800000) >> 23) - 127);\n        return float;\n    }\n    static convertBlankToBytes(blank, nbytes) {\n        let str = Math.abs(blank).toString(2);\n        while (str.length / 8 < nbytes) {\n            str += \"0\";\n        }\n        const buffer = new ArrayBuffer(nbytes);\n        const uint8 = new Uint8Array(buffer);\n        for (let i = 0; i < nbytes; i++) {\n            uint8[i] = parseInt(str.substr(8 * i, 8 * (i + 1)), 2);\n        }\n        return uint8;\n    }\n    /** https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac */\n    static parseFloatingPointFormat(bytes, ebits, fbits) {\n        // Bytes to bits\n        const bits = [];\n        for (let i = bytes.length; i; i -= 1) {\n            let byte = bytes[i - 1];\n            for (let j = 8; j; j -= 1) {\n                bits.push(byte % 2 ? 1 : 0);\n                byte = byte >> 1;\n            }\n        }\n        bits.reverse();\n        const str = bits.join(\"\");\n        // Unpack sign, exponent, fraction\n        const bias = (1 << (ebits - 1)) - 1;\n        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n        const e = parseInt(str.substring(1, 1 + ebits), 2);\n        const f = parseInt(str.substring(1 + ebits), 2);\n        // Produce number\n        if (e === (1 << ebits) - 1) {\n            return f !== 0 ? undefined : s * Infinity;\n        }\n        else if (e > 0) {\n            return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));\n        }\n        else if (f !== 0) {\n            return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));\n        }\n        else {\n            return s * 0;\n        }\n    }\n    static generate16bit2sComplement(val) {\n        throw new TypeError(\"not implemented yet\" + val);\n    }\n    static parse16bit2sComplement(byte1, byte2) {\n        const unsigned = (byte1 << 8) | byte2;\n        if (unsigned & 0x8000) {\n            return unsigned | 0xffff0000;\n        }\n        else {\n            return unsigned;\n        }\n    }\n    static parse32bit2sComplement(byte1, byte2, byte3, byte4) {\n        const unsigned = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;\n        const s = (unsigned & 0x80000000) >> 31;\n        let res = unsigned & 0xffffffff;\n        if (s) {\n            res = (~unsigned & 0xffffffff) + 1;\n            return -1 * res;\n        }\n        return res;\n    }\n    /**\n     *\n     * @param {*} data string?\n     * @param {*} offset offset in the data\n     * @returns returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index.\n     */\n    static getByteAt(data, offset) {\n        const dataOffset = 0;\n        return data.charCodeAt(offset + dataOffset) & 0xff;\n    }\n    static extractPixelValue(offset, bytes, bitpix) {\n        let px_val = undefined; // pixel value\n        // let px_val1, px_val2, px_val3, px_val4;\n        if (bitpix == 8) {\n            px_val = bytes[0];\n        }\n        else if (bitpix == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(bytes[offset], bytes[offset + 1]);\n        }\n        else if (bitpix == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]);\n        }\n        else if (bitpix == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 8, 23);\n        }\n        else if (bitpix == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (bitpix == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n// export default ParseUtils;\n//# sourceMappingURL=ParseUtils.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/fitsontheweb\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n * import GnomonicProjection from './GnomonicProjection';\n * BITPIX definition from https://archive.stsci.edu/fits/fits_standard/node39.html\n * and \"Definition of the Flexible Image Transport System (FITS)\" standard document\n * defined by FITS Working Group from the International Astronomical Union\n * http://fits.gsfc.nasa.gov/iaufwg/\n * 8\t8-bit Character or unsigned binary integer\n * 16\t16-bit twos-complement binary integer\n * 32\t32-bit twos-complement binary integer\n * -32\t32-bit IEEE single precision floating point\n * -64\t64-bit IEEE double precision floating point\n *\n */\n// import { Blob } from 'blob-polyfill';\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\n// import fs from 'node:fs/promises';\nexport class FITSWriter {\n    constructor() {\n        this._headerArray = new Uint8Array();\n        this._payloadArray = new Array();\n        this._fitsData = new Uint8Array();\n    }\n    run(header, rawdata) {\n        this.prepareHeader(header);\n        this._payloadArray = rawdata;\n        this.prepareFITS();\n    }\n    prepareHeader(headerDetails) {\n        const item = new FITSHeaderItem(\"END\");\n        headerDetails.addItem(item);\n        let str = \"\";\n        for (let i = 0; i < headerDetails.getItemList().length; i++) {\n            const item = headerDetails.getItemList()[i];\n            let s = this.formatHeaderLine(item);\n            if (s !== undefined) {\n                str += s;\n            }\n        }\n        const strBytelen = new TextEncoder().encode(str).length;\n        const nhdu = Math.ceil(strBytelen / 2880);\n        const offset = nhdu * 2880;\n        for (let j = 0; j < offset - strBytelen; j++) {\n            str += \" \";\n        }\n        const ab = new ArrayBuffer(str.length);\n        // Javascript character occupies 2 16-bit -> reducing it to 1 byte\n        this._headerArray = new Uint8Array(ab);\n        for (let i = 0; i < str.length; i++) {\n            this._headerArray[i] = ParseUtils.getByteAt(str, i);\n        }\n    }\n    // formatHeaderLine(item: string | undefined, value: string | number, comment: string) {\n    formatHeaderLine(item) {\n        let str;\n        let keyword = item.key;\n        let value = item.value;\n        let comment = item.comment;\n        if (keyword !== null && keyword !== undefined) {\n            str = keyword;\n            if (keyword == \"END\") {\n                for (let j = 80; j > keyword.length; j--) {\n                    str += \" \";\n                }\n                return str;\n            }\n            if (keyword == \"COMMENT\" || keyword == \"HISTORY\") {\n                for (let i = 0; i < 10 - keyword.length; i++) {\n                    str += \" \";\n                }\n                str += value;\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n                return str;\n            }\n            for (let i = 0; i < 8 - keyword.length; i++) {\n                str += \" \";\n            }\n            str += \"= \";\n            if (value !== null && value !== undefined) {\n                // value\n                str += value;\n                if (comment !== null && comment !== undefined) {\n                    str += comment;\n                }\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n            else {\n                if (comment !== null && comment !== undefined) {\n                    str += comment;\n                }\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n        }\n        else {\n            // keyword null\n            str = \"\";\n            for (let j = 0; j < 18; j++) {\n                str += \" \";\n            }\n            if (comment !== null && comment !== undefined) {\n                str += comment;\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n            else {\n                str = \"\";\n                for (let j = 80; j > 0; j--) {\n                    str += \" \";\n                }\n            }\n        }\n        return str;\n    }\n    prepareFITS() {\n        const bytes = new Uint8Array(this._headerArray.length +\n            this._payloadArray[0].length * this._payloadArray.length);\n        bytes.set(this._headerArray, 0);\n        for (let i = 0; i < this._payloadArray.length; i++) {\n            const uint8 = this._payloadArray[i];\n            bytes.set(uint8, this._headerArray.length + i * uint8.length);\n        }\n        this._fitsData = bytes;\n    }\n    // writeFITS(fileuri: string) {\n    //   // const dirname = path.dirname(fileuri);\n    //   // fs.mkdir(dirname, { recursive: true });\n    //   fs.writeFile(fileuri, this._fitsData);\n    //   // if (fs.existsSync(dirname)) {\n    //   //   fs.writeFileSync(fileuri, this._fitsData);\n    //   // } else {\n    //   //   console.error(dirname + \" doesn't exist\");\n    //   // }\n    // }\n    typedArrayToURL() {\n        const b = new Blob([this._fitsData], { type: \"application/fits\" });\n        // console.log(`<html><body><img src='${URL.createObjectURL(b)}'</body></html>`);\n        return URL.createObjectURL(b);\n    }\n}\n//# sourceMappingURL=FITSWriter.js.map","// \"use strict\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\n// let colorsMap = new Map();\n// colorsMap.set(\"grayscale\",\"grayscale\");\n// colorsMap.set(\"planck\",\"planck\");\n// colorsMap.set(\"eosb\",\"eosb\");\n// colorsMap.set(\"rainbow\",\"rainbow\");\n// colorsMap.set(\"cmb\",\"cmb\");\n// colorsMap.set(\"cubehelix\",\"cubehelix\");\nexport class ParsePayload {\n    constructor(fitsheader, rawdata) {\n        this._u8data = new Uint8Array();\n        this._BZERO = undefined;\n        this._BSCALE = undefined;\n        this._BLANK = undefined;\n        this._BITPIX = undefined;\n        this._NAXIS1 = undefined;\n        this._NAXIS2 = undefined;\n        this._DATAMIN = undefined;\n        this._DATAMAX = undefined;\n        this._physicalblank = undefined;\n        const buffer = rawdata.slice(fitsheader.offset);\n        this._u8data = new Uint8Array(buffer);\n        this.init(fitsheader);\n    }\n    init(fitsheader) {\n        this._BZERO = fitsheader.get(\"BZERO\");\n        if (this._BZERO === undefined) {\n            this._BZERO = 0;\n        }\n        this._BSCALE = fitsheader.get(\"BSCALE\");\n        if (this._BSCALE === undefined) {\n            this._BSCALE = 1;\n        }\n        this._BLANK = fitsheader.get(\"BLANK\"); // undefined in case it's not present in the header\n        // this._BLANK_pv = this._BZERO + this._BSCALE * this._BLANK || undefined;\n        this._BITPIX = fitsheader.get(\"BITPIX\");\n        this._NAXIS1 = fitsheader.get(\"NAXIS1\");\n        this._NAXIS2 = fitsheader.get(\"NAXIS2\");\n        this._DATAMIN = fitsheader.get(\"DATAMIN\");\n        this._DATAMAX = fitsheader.get(\"DATAMAX\");\n        this._physicalblank = undefined;\n        if (this._DATAMAX === undefined || this._DATAMIN === undefined) {\n            const [min, max] = this.computePhysicalMinAndMax();\n            this._DATAMAX = max;\n            this._DATAMIN = min;\n            const maxitem = new FITSHeaderItem(\"DATAMAX\", max, \" / computed with FITSParser\");\n            const minitem = new FITSHeaderItem(\"DATAMIN\", min, \" / computed with FITSParser\");\n            fitsheader.addItem(maxitem);\n            fitsheader.addItem(minitem);\n            // fitsheader.set(\"DATAMAX\", max);\n            // fitsheader.set(\"DATAMIN\", min);\n        }\n        // let item = new FITSHeaderItem(\"END\", null, null);\n        // fitsheader.addItem(item);\n    }\n    computePhysicalMinAndMax() {\n        let i = 0;\n        if (this._BITPIX === undefined) {\n            throw new Error(\"BITPIX is not defined\");\n        }\n        const bytesXelem = Math.abs(this._BITPIX / 8);\n        const pxLength = this._u8data.byteLength / bytesXelem;\n        let px_val, ph_val;\n        let min = undefined;\n        let max = undefined;\n        if (this._BLANK !== undefined) {\n            this._physicalblank = this.pixel2physicalValue(this._BLANK);\n        }\n        while (i < pxLength) {\n            // px_val = this.extractPixelValue(bytesXelem*i);\n            px_val = this.extractPixelValue(bytesXelem * i);\n            if (px_val === undefined) {\n                i++;\n                continue;\n            }\n            ph_val = this.pixel2physicalValue(px_val);\n            if (min === undefined) {\n                min = ph_val;\n            }\n            if (max === undefined) {\n                max = ph_val;\n            }\n            //TODO check below if\n            if (this._physicalblank === undefined || this._physicalblank !== ph_val) {\n                if (ph_val !== undefined && (ph_val < min || min === undefined)) {\n                    min = ph_val;\n                }\n                if (ph_val !== undefined && (ph_val > max || max === undefined)) {\n                    max = ph_val;\n                }\n            }\n            i++;\n        }\n        return [min, max];\n    }\n    parse() {\n        // let px_val; // pixel array value\n        // let ph_val = undefined; // pixel physical value\n        if (this._BITPIX === undefined) {\n            throw new Error(\"BITPIX is undefined\");\n        }\n        if (this._NAXIS1 === undefined) {\n            throw new Error(\"NAXIS1 is undefined\");\n        }\n        if (this._NAXIS2 === undefined) {\n            throw new Error(\"NAXIS2 is undefined\");\n        }\n        const bytesXelem = Math.abs(this._BITPIX / 8);\n        let pxLength = this._u8data.byteLength / bytesXelem;\n        pxLength = this._NAXIS1 * this._NAXIS2;\n        let k = 0;\n        let c, r;\n        const pixelvalues = [];\n        //  let pixv, pv;\n        while (k < pxLength) {\n            r = Math.floor(k / this._NAXIS1); // row\n            c = (k - r * this._NAXIS1) * bytesXelem; // col\n            if (c === 0) {\n                pixelvalues[r] = new Uint8Array(this._NAXIS1 * bytesXelem);\n            }\n            // px_val = this.extractPixelValue(bytesXelem * k);\n            // ph_val = this.pixel2physicalValue(px_val);\n            // TODO check if ph_val == blank\n            // if not then use ph_val to compute datamin and datamax\n            for (let i = 0; i < bytesXelem; i++) {\n                pixelvalues[r][c + i] = this._u8data[k * bytesXelem + i];\n            }\n            // if (k == 232) {\n            // \tpixv = this.extractPixelValue(k * bytesXelem);\n            // \tpv = this._BZERO + this._BSCALE * pixv;\n            // }\n            k++;\n        }\n        return pixelvalues;\n    }\n    /** this can be deleted */\n    extractPixelValue(offset) {\n        let px_val = undefined; // pixel value\n        if (this._BITPIX == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(this._u8data[offset], this._u8data[offset + 1]);\n        }\n        else if (this._BITPIX == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(this._u8data[offset], this._u8data[offset + 1], this._u8data[offset + 2], this._u8data[offset + 3]);\n        }\n        else if (this._BITPIX == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 4), 8, 23);\n        }\n        else if (this._BITPIX == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (this._BITPIX == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n    pixel2physicalValue(pxval) {\n        if (this._BZERO === undefined || this._BSCALE === undefined) {\n            throw new Error(\"Either BZERO or BSCALE is undefined\");\n        }\n        return this._BZERO + this._BSCALE * pxval;\n    }\n}\n//# sourceMappingURL=ParsePayload.js.map","import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseHeader {\n    static parse(rawdata) {\n        // only one header block (2880) allowed atm.\n        // TODO handle multiple header blocks\n        // let headerByteData = new Uint8Array(rawdata, 0, 2880);\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const header = new FITSHeader();\n        let nline = 0;\n        let key = \"\";\n        let val;\n        let u8line;\n        let u8key;\n        let u8val;\n        let u8ind;\n        // let ind: string;\n        let item;\n        let fitsLine;\n        item = null;\n        while (key !== \"END\" && rawdata.length > 0) {\n            // line 80 characters\n            u8line = new Uint8Array(rawdata.slice(nline * 80, nline * 80 + 80));\n            nline++;\n            // key\n            u8key = new Uint8Array(u8line.slice(0, 8));\n            key = textDecoder.decode(u8key).trim();\n            // value indicator\n            u8ind = new Uint8Array(u8line.slice(8, 10));\n            // ind = textDecoder.decode(u8ind);\n            // reading value\n            u8val = new Uint8Array(u8line.slice(10, 80));\n            val = textDecoder.decode(u8val).trim();\n            // ascii 61 -> =\n            // ascii 32 -> [space]\n            if (u8ind[0] == 61 && u8ind[1] == 32) {\n                let firstchar = 32;\n                for (let i = 0; i < u8val.length; i++) {\n                    if (u8val[i] != 32) {\n                        firstchar = u8val[i];\n                        break;\n                    }\n                }\n                // ascii 39 -> '\n                if (firstchar == 39 || !Number(val)) {\n                    // [ival, icomment]\n                    // fitsLine = ParseHeader.parseStringValue(u8val);\n                    fitsLine = ParseHeader.parseLogicalValue(u8val);\n                }\n                else {\n                    // ascii 84 -> T\n                    // ascii 70 -> F\n                    if (firstchar == 84 || firstchar == 70) {\n                        // T or F\n                        fitsLine = ParseHeader.parseLogicalValue(u8val);\n                    }\n                    else {\n                        val = textDecoder.decode(u8val).trim();\n                        if (val.includes(\".\")) {\n                            fitsLine = ParseHeader.parseFloatValue(u8val);\n                        }\n                        else {\n                            fitsLine = ParseHeader.parseIntValue(u8val);\n                        }\n                    }\n                }\n                item = new FITSHeaderItem(key, fitsLine.val, fitsLine.comment);\n            }\n            else {\n                if (key == \"COMMENT\" || key == \"HISTORY\") {\n                    item = new FITSHeaderItem(key, undefined, val);\n                }\n                else {\n                    let firstchar = 32;\n                    for (let i = 0; i < u8val.length; i++) {\n                        if (u8val[i] != 32) {\n                            firstchar = u8val[i];\n                            break;\n                        }\n                    }\n                    if (firstchar == 47) {\n                        // single / this is the case when no key nor value indicator is defined\n                        item = new FITSHeaderItem(undefined, undefined, val);\n                    }\n                    else if (firstchar == 32) {\n                        // case when there's a line with only spaces\n                        item = new FITSHeaderItem(undefined, undefined, undefined);\n                    }\n                }\n            }\n            if (item != null) {\n                header.addItem(item);\n            }\n        }\n        item = new FITSHeaderItem(\"COMMENT\", \"FITS generated with FITSParser on \", undefined);\n        header.addItem(item);\n        const now = new Date();\n        item = new FITSHeaderItem(\"COMMENT\", now.toString());\n        header.addItem(item);\n        const nblock = Math.ceil(nline / 36);\n        const offset = nblock * 2880;\n        header.offset = offset;\n        return header;\n    }\n    static parseStringValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const decoded = textDecoder.decode(u8buffer).trim();\n        const idx = decoded.lastIndexOf(\"/\");\n        const val = decoded.substring(0, idx);\n        let comment = decoded.substring(idx);\n        // if (comment === undefined) {\n        //   comment = null;\n        // }\n        return {\n            val: val,\n            comment: comment,\n        };\n    }\n    static parseLogicalValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: tokens[0].trim(),\n                comment: undefined,\n            };\n        }\n        return {\n            val: tokens[0].trim(),\n            comment: \" /\" + tokens[1],\n        };\n    }\n    static parseIntValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: parseInt(tokens[0].trim()),\n                comment: undefined,\n            };\n        }\n        return {\n            val: parseInt(tokens[0].trim()),\n            comment: \" /\" + tokens[1],\n        };\n    }\n    static parseFloatValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: parseFloat(tokens[0].trim()),\n                comment: undefined,\n            };\n        }\n        return {\n            val: parseFloat(tokens[0].trim()),\n            comment: \" /\" + tokens[1],\n        };\n    }\n}\n//# sourceMappingURL=ParseHeader.js.map","/**\n\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FITSWriter } from \"./FITSWriter.js\";\nimport { ParsePayload } from \"./ParsePayload.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\n// import fetch from 'cross-fetch';\n// import { readFile } from \"node:fs/promises\";\nexport class FITSParser {\n    constructor(url) {\n        this._url = url;\n    }\n    loadFITS() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getFile(this._url)\n                .then((rawdata) => {\n                if (rawdata !== null && rawdata.byteLength > 0) {\n                    const uint8 = new Uint8Array(rawdata);\n                    const fits = this.processFits(uint8);\n                    return fits;\n                }\n                return null;\n            })\n                .catch((error) => {\n                var _a, _b;\n                if ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) {\n                    throw new Error(\"[FITSParser->loadFITS] \" + error.response.data.message);\n                }\n                throw error;\n            });\n        });\n    }\n    processFits(rawdata) {\n        const header = ParseHeader.parse(rawdata);\n        const payloadParser = new ParsePayload(header, rawdata);\n        const pixelvalues = payloadParser.parse();\n        // if (rawdata.length > (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length))) {\n        // let leftover = rawdata.length - (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length));\n        // \tthrow new Error(\"[FITSParser->processFits] It seems that there's at least one more HDU since there are \" + leftover + \" bytes not processed.\");\n        // \tconsole.warn(\"It seems that there's at least one more HDU since there are \" + leftover + \" bytes not processed.\")\n        // }\n        return {\n            header: header,\n            data: pixelvalues,\n        };\n    }\n    static generateFITS(header, rawdata) {\n        const writer = new FITSWriter();\n        writer.run(header, rawdata);\n        return writer.typedArrayToURL();\n    }\n    getFile(uri) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let data;\n            if (!uri.substring(0, 5).toLowerCase().includes(\"http\")) {\n                let p = yield import('./getLocalFile.js');\n                // data = await p.getLocalFile(uri);\n                return yield p.getLocalFile(uri);\n            }\n            else {\n                let p = yield import('./getFile.js');\n                return p.getFile(uri).then((data) => {\n                    return data;\n                }).catch((err) => {\n                    // console.error(\"Error in FITSParser getFile \", uri, err);\n                    return null;\n                });\n                // data = await p.getFile(uri);\n                // return await p.getFile(uri).catch((err) => {\n                //   console.error(err);\n                // });\n            }\n            // return data;\n        });\n    }\n}\n//# sourceMappingURL=FITSParser.js.map","export enum NumberType {\n    DEGREES,\n    RADIANS,\n    DECIMAL,\n    HMS,\n    DMS\n}","/**\n * @author Fabrizio Giordano (Fab77)\n * Enum for coordinate types.\n * @readonly\n * @enum {{name: string, hex: string}}\n */\n\nexport enum CoordsType {\n  CARTESIAN = \"cartesian\",\n  SPHERICAL = \"spherical\",\n  ASTRO = \"astro\"\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\n\nexport class ImagePixel {\n    _i: number;     // int i of input projection\n    _j: number;     // int j of input projection\n    _tileno: number;// int\n    \n    constructor (i: number = null, j: number = null, tileno: number = null) {\n        this._i = i;\n        this._j = j;\n        this._tileno = tileno;\n    }\n\n    geti() {\n        return this._i;\n    }\n\n    getj() {\n        return this._j;\n    }\n\n    get tileno() {\n        return this._tileno\n    }\n}\n","/**\n * @author Fabrizio Giordano (Fab)\n */\n// import vec3 from 'gl-matrix';\n\nimport { AstroCoords } from \"./AstroCoords.js\";\nimport { CartesianCoords } from \"./CartesianCoords.js\";\nimport { HMSCoords } from \"./HMSCoords.js\";\nimport { NumberType } from \"./NumberType.js\";\nimport { SexagesimalCoords } from \"./SexagesimalCoords.js\";\nimport { SphericalCoords } from \"./SphericalCoords.js\";\n\nfunction Utils(){\n\t\n}\n\nexport function cartesianToSpherical(xyz: CartesianCoords): SphericalCoords{\n\tlet dotXYZ = dot(xyz, xyz);\n\tlet r = Math.sqrt(dotXYZ);\t\n\tlet thetaRad = Math.acos(xyz[2]/r);\n\tlet thetaDeg = radToDeg(thetaRad);\n\t// NB: in atan(y/x) is written with params switched atan2(x, y)\n\tlet phiRad = Math.atan2(xyz[1],xyz[0]);\n\tlet phiDeg = radToDeg(phiRad);\n\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\treturn {\n\t\tphiDeg: phiDeg, \n\t\tthetaDeg: thetaDeg,\n\t\tphiRad:phiRad,\n\t\tthetaRad: thetaRad\n\t};\n};\n\nexport function sphericalToAstro(phiTheta: SphericalCoords): AstroCoords{\n\tlet raDeg: number;\n\tlet decDeg: number;\n\n\traDeg = phiTheta.phiDeg;\n\tif (raDeg < 0){\n\t\traDeg += 360;\n\t}\n\tdecDeg = 90 - phiTheta.thetaDeg;\n\t\n\treturn {\n\t\t\"raDeg\": raDeg,\n\t\t\"decDeg\": decDeg,\n\t\t\"raRad\": degToRad(raDeg),\n\t\t\"decRad\": degToRad(decDeg)\n\n\t};\n}\n\nexport function astroToSpherical(raDec: AstroCoords): SphericalCoords{\n\t\n\tlet phiDeg: number;\n\tlet thetaDeg: number;\n\n\tphiDeg = raDec.raDeg;\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\t\n\tthetaDeg = 90 - raDec.decDeg;\n\t\n\treturn {\n\t\t\"phiDeg\": phiDeg,\n\t\t\"thetaDeg\": thetaDeg,\n\t\t\"phiRad\": degToRad(phiDeg),\n\t\t\"thetaRad\": degToRad(thetaDeg),\n\t};\n}\n\nexport function sphericalToCartesian(phiTheta: SphericalCoords, r: number): CartesianCoords{\n\tr = (r == undefined) ? 1 : r;\n\tvar x = r * Math.sin(phiTheta.thetaRad) * Math.cos(phiTheta.phiRad);\n\tvar y = r * Math.sin(phiTheta.thetaRad) * Math.sin(phiTheta.phiRad);\n\tvar z = r * Math.cos(phiTheta.thetaRad);\n\n\treturn {\n\t\t\"x\": x, \n\t\t\"y\": y, \n\t\t\"z\": z\n\t};\n};\n\nexport function fillAstro(ra: number, dec: number, unit: NumberType): AstroCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"raDeg\": ra,\n\t\t\t\"decDeg\": dec,\n\t\t\t\"raRad\": degToRad(ra),\n\t\t\t\"decRad\": degToRad(dec)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"raRad\": ra,\n\t\t\t\"decRad\": dec,\n\t\t\t\"raDeg\": radToDeg(ra),\n\t\t\t\"decDeg\": radToDeg(dec)\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n\t\n}\n\n\nexport function fillSpherical(phi: number, theta: number, unit: NumberType):  SphericalCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"phiDeg\": phi,\n\t\t\t\"thetaDeg\": theta,\n\t\t\t\"phiRad\": degToRad(phi),\n\t\t\t\"thetaRad\": degToRad(theta)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"phiDeg\": radToDeg(phi),\n\t\t\t\"thetaDeg\": radToDeg(theta),\n\t\t\t\"phiRad\": phi,\n\t\t\t\"thetaRad\": theta\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n}\n\nfunction dot(a: CartesianCoords, b: CartesianCoords) : number{\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n\nexport function colorHex2RGB(hexColor: string): [number, number, number] {\n\n//\tconsole.log(hexColor);\n\tvar hex1 = hexColor.substring(1,3);\n\tvar hex2 = hexColor.substring(3,5);\n\tvar hex3 = hexColor.substring(5,7);\n\t\n\tvar dec1 = parseInt(hex1, 16);\n\tvar dec2 = parseInt(hex2, 16);\n\tvar dec3 = parseInt(hex3, 16);\n\t\n\tvar rgb1 = (dec1 / 255).toFixed(2);\n\tvar rgb2 = (dec2 / 255).toFixed(2);\n\tvar rgb3 = (dec3 / 255).toFixed(2);\n\t\n\treturn [parseFloat(rgb1), parseFloat(rgb2), parseFloat(rgb3)];\n\n}\n\nexport function degToRad(degrees: number) : number{\n\treturn (degrees / 180 ) * Math.PI ;\n}\n\nexport function radToDeg(radians: number) : number{\n\treturn radians * 180 / Math.PI;\n}\n\nexport function raDegToHMS(raDeg: number): HMSCoords{\n\t\n\tvar h = Math.floor(raDeg/15);\n\tvar m = Math.floor((raDeg/15 - h) * 60);\n\tvar s = (raDeg/15 - h - m/60) * 3600;\n\t\n\treturn {\n\t\th: h, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nexport function decDegToDMS(decDeg: number): SexagesimalCoords{\n\tvar sign = 1;\n\tif (decDeg < 0){\n\t\tsign = -1;\n\t}\n\t\n\tvar decDeg_abs = Math.abs(decDeg);\n\tvar d = Math.trunc(decDeg_abs);\n\t\n\tvar m = Math.trunc( (decDeg_abs - d) * 60);\n\t\n\tvar s = (decDeg_abs - d - m/60) * 3600;\n\td = d * sign;\n\t\n\treturn {\n\t\td: d, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nfunction dms2DecDeg(decDMS: SexagesimalCoords){\n\tvar sign = Math.sign(decDMS.d);\n\tvar deg = (decDMS.d) + sign * (decDMS.m / 60) + sign * (decDMS.s/3600);\n\treturn deg;\n}\n\nfunction hms2RaDeg(raHMS: HMSCoords){\n\tvar sign = Math.sign(raHMS.h);\n\tvar deg = (raHMS.h + sign * (raHMS.m / 60) + sign * (raHMS.s/3600)) * 15;\n\treturn deg;\n}\n\nfunction worldToModel(xy: [number, number], radius: number): [number, number, number]{\n\tvar x = xy[0];\n\tvar y = xy[1];\n\tvar z = Math.sqrt(radius*radius - xy[0]*xy[0] - xy[1]*xy[1]);\n\treturn [x, y, z];\n}\n\n","/**\n * @author Fabrizio Giordano (Fab77)\n */\n\nimport {sphericalToCartesian, cartesianToSpherical, sphericalToAstro, astroToSpherical, fillSpherical, fillAstro} from './Utils.js';\nimport { CartesianCoords } from './CartesianCoords.js';\nimport { AstroCoords} from './AstroCoords.js';\nimport { CoordsType } from './CoordsType.js';\nimport { SphericalCoords } from './SphericalCoords.js';\nimport { NumberType } from './NumberType.js';\nimport { EquatorialCoords } from './EquatorialCoords.js';\nimport { GalacticCoords } from './GalacticCoords.js';\n\nexport class Point{\n\n\t#astro: AstroCoords;\n\t// #equatorial: EquatorialCoords;\n\t// #galactic: GalacticCoords;\n\n\t#spherical: SphericalCoords;\n\t#cartesian: CartesianCoords;\n\n\tconstructor(in_type: CoordsType, unit: NumberType, ...coords: Array<number>) {\n\n\t\tif (in_type == CoordsType.CARTESIAN){\n\t\t\tthis.#cartesian.x = parseFloat(coords[0].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.y = parseFloat(coords[1].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.z = parseFloat(coords[2].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t\t} else if (in_type == CoordsType.ASTRO){\n\t\t\tthis.#astro = fillAstro(coords[0],  coords[1], unit);\n\t\t\tthis.#spherical = astroToSpherical(this.#astro);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\n\t\t} else if (in_type == CoordsType.SPHERICAL){\n\t\t\tthis.#spherical = fillSpherical(coords[0],  coords[1], unit);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\n\t\t} else{\n\t\t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t\t}\n\t\tif (this.#spherical.phiDeg > 360) {\n\t\t\tthis.#spherical.phiDeg -= 360;\n\t\t}\n\t\tif (this.#astro.raDeg > 360) {\n\t\t\tthis.#astro.raDeg -= 360;\n\t\t}\n\t}\n\n\n\t// constructor(in_options: ICoordsFormat, in_type: CoordsType){\n\t\t\n\t// \tif (in_type == CoordsType.CARTESIAN){\n\n\t// \t\tthis.#cartesian.x = parseFloat((in_options as CartesianCoords).x.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.y = parseFloat((in_options as CartesianCoords).y.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.z = parseFloat((in_options as CartesianCoords).z.toFixed(global.MAX_DECIMALS));\n\n\t// \t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else if (in_type == CoordsType.ASTRO){\n\t\t\t\n\t// \t\tif ((in_options as AstroCoords).raDeg && (in_options as AstroCoords).decDeg) {\n\t// \t\t\tthis.#astro = radegDecdegToAstro((in_options as AstroCoords).raDeg,  (in_options as AstroCoords).decDeg );\n\t// \t\t} else if ((in_options as AstroCoords).raRad && (in_options as AstroCoords).decRad) {\n\t// \t\t\tthis.#astro = raradDecradToAstro((in_options as AstroCoords).raRad,  (in_options as AstroCoords).decRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"AstroCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\t// \t\tthis.#spherical = astroToSpherical(this.#astro);\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\t\n\t// \t}else if (in_type == CoordsType.SPHERICAL){\n\n\t// \t\tif ((in_options as SphericalCoords).phiDeg && (in_options as SphericalCoords).thetaDeg) {\n\t// \t\t\tthis.#spherical = phidegThetadegToSpherical((in_options as SphericalCoords).phiDeg,  (in_options as SphericalCoords).thetaDeg );\n\t// \t\t} else if ((in_options as SphericalCoords).phiRad && (in_options as SphericalCoords).thetaRad) {\n\t// \t\t\tthis.#spherical = phiradThetaradToSpherical((in_options as SphericalCoords).phiRad,  (in_options as SphericalCoords).thetaRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"SphericalCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else{\n\t// \t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t// \t}\n\t// }\n\n\tget spherical() {\n\t\treturn this.#spherical;\n\t}\n\n\tget astro() {\n\t\treturn this.#astro;\n\t}\n\n\tget cartesian() {\n\t\treturn this.#cartesian;\n\t}\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// /** Scale the vector by a given factor\n    // @param n the scale factor */\n\t// scale(n: number): Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*n, this.y*n, this.z*n);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// dot(v: Point): number{ \n\t// \treturn this.x*v.x + this.y*v.y + this.z*v.z; \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// cross(v: Point): Point{ \n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.y*v.z - v.y*this.z, this.z*v.x - v.z*this.x, this.x*v.y - v.x*this.y);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// norm() : Point{\n\t// \tlet d = 1./this.length();\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*d, this.y*d, this.z*d);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// length(): number{ \n\t// \treturn Math.sqrt(this.lengthSquared()); \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// lengthSquared(): number{ \n\t// \treturn this.x*this.x + this.y*this.y + this.z*this.z; \n  \t// };\n\n\t// subtract(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x - v.x, this.y - v.y, this.z - v.z);\n\t// }\n\n\t// add(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x + v.x, this.y + v.y, this.z + v.z);\n\t// }\n\t\n\n\t// get x(){\n\t// \treturn this._x;\n\t// }\n\t\n\t// get y(){\n\t// \treturn this._y;\n\t// }\n\t\n\t// get z(){\n\t// \treturn this._z;\n\t// }\n\t\n\t// get xyz(){\n    //     return this._xyz;\n    // }\n\t\n    // get raDeg(){\n    //     return this._raDeg;\n    // }\n    \n    // get decDeg(){\n    //     return this._decDeg;\n    // }\n    \n    // get raDecDeg(){\n    //     return this._raDecDeg;\n    // }\n    \n    // toADQL(){\n    // \treturn this._raDecDeg[0]+\",\"+this._raDecDeg[1];\n    // }\n    \n    // toString(){\n    // \treturn \"(raDeg, decDeg) => (\"+this._raDecDeg[0]+\",\"+this._raDecDeg[1]+\") (x, y,z) => (\"+this._xyz[0]+\",\"+this._xyz[1]+\",\"+this._xyz[2]+\")\";\n    // }\n}\n\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n \n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\n\n\nexport class MercatorProjection implements AbstractProjection {\n\n    _minra!: number;\n    _mindec!: number;\n    _naxis1!: number;\n    _naxis2!: number;\n    \n    _fitsheader: FITSHeader[];\n    _infile!: string;\n    _ctype1: string; // TODO should be RA ENUM\n    _ctype2: string; // TODO should be Dec ENUM\n    _craDeg!: number;\n    _cdecDeg!: number;\n\n    _pxsize!: number;\n    _pxsize1!: number;\n    _pxsize2!: number;\n\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval!: number;\n    _maxphysicalval!: number;\n    _wcsname: string;\n    _fitsUsed: String[];\n    constructor() {\n\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this._ctype1 = \"RA---MER\";\n        this._ctype2 = \"DEC--MER\";\n        this._pxvalues = new Map<number, Array<Uint8Array>>();\n        this._fitsheader = new Array<FITSHeader>();\n    }\n\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n        \n        let fp = new FITSParser(infile);\n        this._infile = infile;\n        this._fitsUsed.push(infile)\n\n        let promise = fp.loadFITS().then(fits => {\n            \n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            this._naxis1 = fits.header.get(\"NAXIS1\");\n            this._naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value as number;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value as number;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            // this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            // this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n\n            const pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            const pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n            if (pxsize1 !== pxsize2 || pxsize1 === undefined || pxsize2 === undefined) {\n                throw new Error(\"pxsize1 is not equal to pxsize2\")\n                exit;\n            }\n            this._pxsize = pxsize1;\n\n            // this._minra = this._craDeg - this._pxsize1 * this._naxis1 / 2;\n            this._minra = this._craDeg - this._pxsize * this._naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            // this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n            this._mindec = this._cdecDeg - this._pxsize * this._naxis2 / 2;\n\n            return fits;\n        });\n        await promise;\n        return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\n        this._fitsheader[0] = new FITSHeader();\n\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"NAXIS1\", this._naxis1));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"NAXIS2\", this._naxis2));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        \n        \n        \n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE1\", \"'\"+this._ctype1+\"'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE2\", \"'\"+this._ctype2+\"'\"));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT1\", this._pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT2\", this._pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX1\", this._naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX2\", this._naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"ORIGIN\", \"'WCSLight v.0.x'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"COMMENT\", \"'WCSLight v0.x developed by F.Giordano and Y.Ascasibar'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n    getFITSHeader(): FITSHeader[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeader {\n        let header = new FITSHeader();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                header.addItem(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    get fitsUsed(): String[]{\n\t\treturn this._fitsUsed;\n\t}\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= this._naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= this._naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        let pv = this._pxvalues.get(0);\n                        if (pv !== undefined) {\n\n                            for (let b = 0; b < bytesXelem; b++) {\n\n                                values[p * bytesXelem + b] = pv[imgpx._j][(imgpx._i) * bytesXelem + b];\n                            }\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n\n    computeSquaredNaxes(d: number, ps: number): void {\n        // first approximation to be checked\n        this._naxis1 = Math.ceil(d / ps);\n        this._naxis2 = this._naxis1;\n        this._pxsize = ps;\n    }\n\n\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n\n        let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        let maxpixb = minpixb;\n\n        let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        this._minphysicalval = bzero + bscale * minpixb;\n        this._maxphysicalval = bzero + bscale * maxpixb;\n\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n        // this._pxvalues.set(0, new Uint8Array[this._naxis2][this._naxis1 * bytesXelem]);\n\n        this._pxvalues.set(0, new Array<Uint8Array>(this._naxis2));\n        let pv = this._pxvalues.get(0);\n        if (pv !== undefined) {\n            for (let r = 0; r < this._naxis2; r++) {\n                pv[r] = new Uint8Array(this._naxis1 * bytesXelem);\n            }\n\n            let r!: number;\n            let c!: number;\n            let b!: number;\n            for (let p = 0; (p * bytesXelem) < values.length; p++) {\n                // console.log(\"processing \"+p + \" of \"+ (values.length / bytesXelem));\n\n                try {\n                    r = Math.floor(p / this._naxis1);\n                    c = (p - r * this._naxis1) * bytesXelem;\n\n                    for (b = 0; b < bytesXelem; b++) {\n                        pv[r][c + b] = values[p * bytesXelem + b];\n                    }\n\n\n                    let valpixb = ParseUtils.extractPixelValue(0, values.slice(p * bytesXelem, (p * bytesXelem) + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n                    let valphysical = bzero + bscale * valpixb;\n\n                    if (valphysical < this._minphysicalval || isNaN(this._minphysicalval)) {\n                        this._minphysicalval = valphysical;\n                    } else if (valphysical > this._maxphysicalval || isNaN(this._maxphysicalval)) {\n                        this._maxphysicalval = valphysical;\n                    }\n                } catch (err) {\n                    console.log(err)\n                    console.log(\"p \" + p)\n                    console.log(\"r %, c %, b %\" + r, c, b)\n                    console.log(\"this._pxvalues[r][c + b] \" + pv[r][c + b])\n                    console.log(\"values[p * bytesXelem + b] \" + values[p * bytesXelem + b])\n                }\n\n            }\n        }\n\n        this.prepareFITSHeader(fitsHeaderParams);\n        return this._pxvalues;\n\n    }\n\n\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n\n\n        this.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n        this._pxsize = pxsize;\n        this._minra = center.astro.raDeg - radius;\n        if (this._minra < 0) {\n            this._minra += 360;\n        }\n        this._mindec = center.astro.decDeg - radius;\n\n        let radeclist: Array<[number, number]> = new Array<[number, number]>();\n\n        for (let d = 0; d < this._naxis2; d++) {\n            for (let r = 0; r < this._naxis1; r++) {\n                radeclist.push([this._minra + (r * this._pxsize), this._mindec + (d * this._pxsize)]);\n            }\n        }\n\n        let cidx = (this._naxis2 / 2 ) * this._naxis1 + this._naxis1 / 2;\n        if (this._naxis1 % 2 != 0) {\n            cidx = Math.floor(radeclist.length / 2);\n        }\n\n        // let cidx2 = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        \n        // let cidx = Math.ceil(radeclist.length / 2);\n        // let cidx = Math.floor(radeclist.length / 2);\n        this._craDeg = radeclist[cidx][0];\n        this._cdecDeg = radeclist[cidx][1];\n\n        return radeclist;\n\n\n    }\n\n\n    // getImageRADecList(center: AstroCoords, radius: number, pxsize: number): Promise<number[][]> {\n\n    //     let promise = new Promise<[]> ( (resolve, reject) => {\n    //         this.computeSquaredNaxes (2 * radius, pxsize); // compute naxis[1, 2]\n    //         this._pxsize = pxsize;\n    //         this._minra = center.raDeg - radius;\n    //         if (this._minra < 0) {\n    //             this._minra += 360;\n    //         }\n    //         this._mindec = center.decDeg - radius;\n\n    //         let radeclist:number[][] = new Array<Array<number>>();\n\n    //         for (let d = 0; d < this._naxis2; d++) {\n    //             for (let r = 0; r < this._naxis1; r++) {\n    //                 radeclist.push([ this._minra + (r * this._pxsize), this._mindec + (d * this._pxsize)]);\n    //             }    \n    //         }\n\n    //         let cidx = (this._naxis2/2 - 1) * this._naxis1 +  this._naxis1/2;\n    //         this._craDeg = radeclist[ cidx ][0];\n    //         this._cdecDeg = radeclist[ cidx ][1];\n\n    //         resolve(radeclist);\n    //     });\n    //     return promise;\n\n    // }\n\n    /** TODO !!! check and handle RA passing through 360-0 */\n    pix2world(i: number, j: number): Point {\n\n        let ra: number;\n        let dec: number;\n        // ra = i * this._stepra + this._minra;\n        // dec = j * this._stepdec + this._mindec;\n        ra = i * this._pxsize + this._minra;\n        dec = j * this._pxsize + this._mindec;\n        let p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n        return p;\n        // return [ra, dec];\n\n    }\n\n    // world2pix (radeclist: number[][]): Promise<ImagePixel[]> {\n\n    //     let promise = new Promise<ImagePixel[]> ( (resolve, reject) => {\n\n    //         this.initFromFile(this._infile).then( (data) => {\n    //             let imgpxlist = [];\n\n    //             for (let radecItem of radeclist) {\n    //                 let ra = radecItem[0];\n    //                 let dec = radecItem[1];\n    //                 let i = Math.floor((ra - this._minra) / this._pxsize1);\n    //                 let j = Math.floor((dec - this._mindec) / this._pxsize2);\n    //                 imgpxlist.push(new ImagePixel(i, j));\n    //             }\n\n    //             resolve(imgpxlist);\n    //         });\n\n    //     });\n    //     return promise;\n    // }\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        for (let radecItem of radeclist) {\n            let ra = radecItem[0];\n            let dec = radecItem[1];\n            // let i = Math.floor((ra - this._minra) / this._pxsize1);\n            // let j = Math.floor((dec - this._mindec) / this._pxsize2);\n            let i = Math.floor((ra - this._minra) / this._pxsize);\n            let j = Math.floor((dec - this._mindec) / this._pxsize);\n            imgpxlist.push(new ImagePixel(i, j));\n        }\n\n        return imgpxlist;\n\n    }\n\n    // getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n    // \tlet canvas2d =  new Canvas2D(this._pxvalues, this._fitsheader, this, tfunction, colormap, inverse);\n    // \treturn canvas2d;\n    // }\n\n\n}\n","export class Constants {\n}\n//\tstatic halfpi = Math.PI/2.;\nConstants.halfpi = 1.5707963267948966;\nConstants.inv_halfpi = 2. / Math.PI;\n/** The Constant twopi. */\nConstants.twopi = 2 * Math.PI;\nConstants.inv_twopi = 1. / (2 * Math.PI);\n//# sourceMappingURL=Constants.js.map","export class Zphi {\n    /** Creation from individual components */\n    constructor(z_, phi_) {\n        this.z = z_;\n        this.phi = phi_;\n    }\n    ;\n}\n//# sourceMappingURL=Zphi.js.map","import { Vec3 } from './Vec3.js';\nimport { Zphi } from './Zphi.js';\nexport class Hploc {\n    constructor(ptg) {\n        Hploc.PI4_A = 0.7853981554508209228515625;\n        Hploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\n        Hploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n        Hploc.M_1_PI = 0.3183098861837906715377675267450287;\n        if (ptg) {\n            this.sth = 0.0;\n            this.have_sth = false;\n            this.z = Hploc.cos(ptg.theta);\n            this._phi = ptg.phi;\n            if (Math.abs(this.z) > 0.99) {\n                this.sth = Hploc.sin(ptg.theta);\n                this.have_sth = true;\n            }\n        }\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    ;\n    get phi() {\n        return this._phi;\n    }\n    ;\n    set phi(phi) {\n        this._phi = phi;\n    }\n    ;\n    setSth(sth) {\n        this.sth = sth;\n    }\n    ;\n    toVec3() {\n        var st = this.have_sth ? this.sth : Math.sqrt((1.0 - this.z) * (1.0 + this.z));\n        // var vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);\n        var vector = new Vec3(st * Math.cos(this.phi), st * Math.sin(this.phi), this.z);\n        return vector;\n    }\n    ;\n    toZphi() {\n        return new Zphi(this.z, this.phi);\n    }\n    static sin(d) {\n        let u = d * Hploc.M_1_PI;\n        let q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 4.0 * q;\n        d -= x * Hploc.PI4_A;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 1) != 0) {\n            d = -d;\n        }\n        return this.sincoshelper(d);\n    }\n    ;\n    static cos(d) {\n        //\t\tlet u = d * Hploc.M_1_PI - 0.5;\n        let u = d * Hploc.M_1_PI - 0.5;\n        //\t\tu -= 0.5;\n        let q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 2.0 * q;\n        let t = x * Hploc.PI4_A;\n        d = d - t;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 2) == 0) {\n            d = -d;\n        }\n        return Hploc.sincoshelper(d);\n    }\n    ;\n    static sincoshelper(d) {\n        let s = d * d;\n        let u = -7.97255955009037868891952e-18;\n        u = u * s + 2.81009972710863200091251e-15;\n        u = u * s - 7.64712219118158833288484e-13;\n        u = u * s + 1.60590430605664501629054e-10;\n        u = u * s - 2.50521083763502045810755e-08;\n        u = u * s + 2.75573192239198747630416e-06;\n        u = u * s - 0.000198412698412696162806809;\n        u = u * s + 0.00833333333333332974823815;\n        u = u * s - 0.166666666666666657414808;\n        return s * u * d + d;\n    }\n    ;\n    /** This method calculates the arc sine of x in radians. The return\n    value is in the range [-pi/2, pi/2]. The results may have\n    maximum error of 3 ulps. */\n    static asin(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1 + d) * (1 - d))), d);\n    }\n    ;\n    /** This method calculates the arc cosine of x in radians. The\n        return value is in the range [0, pi]. The results may have\n        maximum error of 3 ulps. */\n    static acos(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.sqrt((1 + d) * (1 - d)), Math.abs(d)), d) + (d < 0 ? Math.PI : 0);\n    }\n    ;\n    static mulsign(x, y) {\n        let sign = Hploc.copySign(1, y);\n        return sign * x;\n    }\n    ;\n    static copySign(magnitude, sign) {\n        return sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);\n        // let finalsign = 1;\n        // if (Object.is(finalsign , -0)){\n        // \tsign = -1;\n        // }else if (Object.is(finalsign , 0)){\n        // \tsign = 1;\n        // }else {\n        // \tsign = Math.sign(finalsign);\n        // }\n        // return finalsign * magnitude;\n    }\n    static atanhelper(s) {\n        let t = s * s;\n        let u = -1.88796008463073496563746e-05;\n        u = u * t + (0.000209850076645816976906797);\n        u = u * t + (-0.00110611831486672482563471);\n        u = u * t + (0.00370026744188713119232403);\n        u = u * t + (-0.00889896195887655491740809);\n        u = u * t + (0.016599329773529201970117);\n        u = u * t + (-0.0254517624932312641616861);\n        u = u * t + (0.0337852580001353069993897);\n        u = u * t + (-0.0407629191276836500001934);\n        u = u * t + (0.0466667150077840625632675);\n        u = u * t + (-0.0523674852303482457616113);\n        u = u * t + (0.0587666392926673580854313);\n        u = u * t + (-0.0666573579361080525984562);\n        u = u * t + (0.0769219538311769618355029);\n        u = u * t + (-0.090908995008245008229153);\n        u = u * t + (0.111111105648261418443745);\n        u = u * t + (-0.14285714266771329383765);\n        u = u * t + (0.199999999996591265594148);\n        u = u * t + (-0.333333333333311110369124);\n        return u * t * s + s;\n    }\n    ;\n    static atan2k(y, x) {\n        let q = 0.;\n        if (x < 0) {\n            x = -x;\n            q = -2.;\n        }\n        if (y > x) {\n            let t = x;\n            x = y;\n            y = -t;\n            q += 1.;\n        }\n        return Hploc.atanhelper(y / x) + q * (Math.PI / 2);\n    }\n    ;\n    /** This method calculates the arc tangent of y/x in radians, using\n    the signs of the two arguments to determine the quadrant of the\n    result. The results may have maximum error of 2 ulps. */\n    static atan2(y, x) {\n        let r = Hploc.atan2k(Math.abs(y), x);\n        r = Hploc.mulsign(r, x);\n        if (Hploc.isinf(x) || x == 0) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI / 2)) : 0);\n        }\n        if (Hploc.isinf(y)) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI * 1 / 4)) : 0);\n        }\n        if (y == 0) {\n            r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);\n        }\n        return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);\n    }\n    ;\n    /** Checks if the argument is a NaN or not. */\n    static isnan(d) {\n        return d != d;\n    }\n    ;\n    /** Checks if the argument is either positive or negative infinity. */\n    static isinf(d) {\n        return Math.abs(d) === +Infinity;\n    }\n    ;\n}\nHploc.PI4_A = 0.7853981554508209228515625;\nHploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\nHploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\nHploc.M_1_PI = 0.3183098861837906715377675267450287;\n//# sourceMappingURL=Hploc.js.map","import { Hploc } from './Hploc.js';\nexport class Pointing {\n    /**\n     *\n     * @param {*} vec3 Vec3.js\n     * @param {*} mirror\n     * @param {*} in_theta radians\n     * @param {*} in_phi radians\n     */\n    constructor(vec3, mirror, in_theta, in_phi) {\n        if (vec3 != null) {\n            this.theta = Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);\n            if (mirror) {\n                this.phi = -Hploc.atan2(vec3.y, vec3.x);\n            }\n            else {\n                this.phi = Hploc.atan2(vec3.y, vec3.x);\n            }\n            if (this.phi < 0.0) {\n                this.phi = this.phi + 2 * Math.PI;\n            }\n            if (this.phi >= 2 * Math.PI) {\n                this.phi = this.phi - 2 * Math.PI;\n            }\n        }\n        else {\n            this.theta = in_theta;\n            this.phi = in_phi;\n        }\n    }\n}\n//# sourceMappingURL=Pointing.js.map","/**\n * Partial porting to Javascript of Vec3.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nimport { Pointing } from './Pointing.js';\nexport class Vec3 {\n    constructor(in_x, in_y, in_z) {\n        if (in_x instanceof Pointing) {\n            let ptg = in_x;\n            let sth = Hploc.sin(ptg.theta);\n            this.x = sth * Hploc.cos(ptg.phi);\n            this.y = sth * Hploc.sin(ptg.phi);\n            this.z = Hploc.cos(ptg.theta);\n        }\n        else {\n            this.x = in_x;\n            this.y = in_y;\n            this.z = in_z;\n        }\n    }\n    getX() {\n        return this.x;\n    }\n    ;\n    getY() {\n        return this.y;\n    }\n    ;\n    getZ() {\n        return this.z;\n    }\n    ;\n    /** Scale the vector by a given factor\n    @param n the scale factor */\n    scale(n) {\n        this.x *= n;\n        this.y *= n;\n        this.z *= n;\n    }\n    ;\n    /** Vector cross product.\n    @param v another vector\n    @return the vector cross product between this vector and {@code v} */\n    cross(v) {\n        return new Vec3(this.y * v.z - v.y * this.z, this.z * v.x - v.z * this.x, this.x * v.y - v.x * this.y);\n    }\n    ;\n    /** Vector addition\n        * @param v the vector to be added\n        * @return addition result */\n    add(v) {\n        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    ;\n    /** Normalize the vector */\n    normalize() {\n        let d = 1. / this.length();\n        this.x *= d;\n        this.y *= d;\n        this.z *= d;\n    }\n    ;\n    /** Return normalized vector */\n    norm() {\n        let d = 1. / this.length();\n        return new Vec3(this.x * d, this.y * d, this.z * d);\n    }\n    ;\n    /** Vector length\n    @return the length of the vector. */\n    length() {\n        return Math.sqrt(this.lengthSquared());\n    }\n    ;\n    /** Squared vector length\n        @return the squared length of the vector. */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    ;\n    /** Computes the dot product of the this vector and {@code v1}.\n     * @param v1 another vector\n     * @return dot product */\n    dot(v1) {\n        return this.x * v1.x + this.y * v1.y + this.z * v1.z;\n    }\n    ;\n    /** Vector subtraction\n     * @param v the vector to be subtracted\n     * @return subtraction result */\n    sub(v) {\n        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    ;\n    /** Angle between two vectors.\n    @param v1 another vector\n    @return the angle in radians between this vector and {@code v1};\n      constrained to the range [0,PI]. */\n    angle(v1) {\n        return Hploc.atan2(this.cross(v1).length(), this.dot(v1));\n    }\n    /** Invert the signs of all components */\n    flip() {\n        this.x *= -1.0;\n        this.y *= -1.0;\n        this.z *= -1.0;\n    }\n    static pointing2Vec3(pointing) {\n        let sth = Hploc.sin(pointing.theta);\n        let x = sth * Hploc.cos(pointing.phi);\n        let y = sth * Hploc.sin(pointing.phi);\n        let z = Hploc.cos(pointing.theta);\n        return new Vec3(x, y, z);\n    }\n    ;\n}\n//# sourceMappingURL=Vec3.js.map","import { Vec3 } from './Vec3.js';\nexport class CircleFinder {\n    /**\n     * @param point: Vec3\n     */\n    constructor(point) {\n        let np = point.length;\n        //HealpixUtils.check(np>=2,\"too few points\");\n        if (!(np >= 2)) {\n            console.log(\"too few points\");\n            return;\n        }\n        this.center = point[0].add(point[1]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 2; i < np; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle(point, i);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q: int\n     */\n    getCircle(point, q) {\n        this.center = point[0].add(point[q]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 1; i < q; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle2(point, i, q);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q1: int\n     * @param q2: int\n     */\n    getCircle2(point, q1, q2) {\n        this.center = point[q1].add(point[q2]);\n        this.center.normalize();\n        this.cosrad = point[q1].dot(this.center);\n        for (let i = 0; i < q1; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.center = (point[q1].sub(point[i])).cross(point[q2].sub(point[i]));\n                this.center.normalize();\n                this.cosrad = point[i].dot(this.center);\n                if (this.cosrad < 0) {\n                    this.center.flip();\n                    this.cosrad = -this.cosrad;\n                }\n            }\n        }\n    }\n    ;\n    getCenter() {\n        return new Vec3(this.center.x, this.center.y, this.center.z);\n    }\n    getCosrad() {\n        return this.cosrad;\n    }\n    ;\n}\n//# sourceMappingURL=CircleFinder.js.map","/**\n * Partial porting to Javascript of Fxyf.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nexport class Fxyf {\n    constructor(x, y, f) {\n        this.fx = x;\n        this.fy = y;\n        this.face = f;\n        // coordinate of the lowest corner of each face\n        this.jrll = new Uint8Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Uint8Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.halfpi = Math.PI / 2.;\n    }\n    toHploc() {\n        let loc = new Hploc();\n        let jr = this.jrll[this.face] - this.fx - this.fy;\n        let nr;\n        if (jr < 1) {\n            nr = jr;\n            let tmp = nr * nr / 3.;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > 3) {\n            nr = 4 - jr;\n            let tmp = nr * nr / 3.;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = 1;\n            loc.z = (2 - jr) * 2.0 / 3.;\n        }\n        let tmp = this.jpll[this.face] * nr + this.fx - this.fy;\n        if (tmp < 0) {\n            tmp += 8;\n        }\n        if (tmp >= 8) {\n            tmp -= 8;\n        }\n        loc.phi = (nr < 1e-15) ? 0 : (0.5 * this.halfpi * tmp) / nr;\n        return loc;\n    }\n    ;\n    toVec3() {\n        return this.toHploc().toVec3();\n    }\n    ;\n}\n//# sourceMappingURL=Fxyf.js.map","export class pstack {\n    /** Creation from individual components */\n    constructor(sz) {\n        this.p = new Array(sz);\n        this.o = new Int32Array(sz);\n        this.s = 0;\n        this.m = 0;\n    }\n    ;\n    /**\n     * @param p long\n     * @param o int\n     */\n    push(p_, o_) {\n        this.p[this.s] = p_;\n        this.o[this.s] = o_;\n        ++this.s;\n    }\n    ;\n    pop() {\n        --this.s;\n    }\n    ;\n    popToMark() {\n        this.s = this.m;\n    }\n    ;\n    size() {\n        return this.s;\n    }\n    ;\n    mark() {\n        this.m = this.s;\n    }\n    ;\n    otop() {\n        return this.o[this.s - 1];\n    }\n    ;\n    ptop() {\n        return this.p[this.s - 1];\n    }\n    ;\n}\n//# sourceMappingURL=pstack.js.map","export class RangeSet {\n    /**\n     * @param int cap: initial capacity\n     */\n    constructor(cap) {\n        if (cap < 0)\n            console.error(\"capacity must be positive\");\n        this.r = new Int32Array(cap << 1);\n        this.sz = 0;\n    }\n    ;\n    /** Append a single-value range to the object.\n    @param val value to append */\n    append(val) {\n        this.append1(val, val + 1);\n    }\n    ;\n    /** Append a range to the object.\n   @param a first long in range\n   @param b one-after-last long in range */\n    append1(a, b) {\n        if (a >= b)\n            return;\n        if ((this.sz > 0) && (a <= this.r[this.sz - 1])) {\n            if (a < this.r[this.sz - 2])\n                console.error(\"bad append operation\");\n            if (b > this.r[this.sz - 1])\n                this.r[this.sz - 1] = b;\n            return;\n        }\n        // this.ensureCapacity(this.sz+2);\n        let cap = this.sz + 2;\n        if (this.r.length < cap) {\n            let newsize = Math.max(2 * this.r.length, cap);\n            let rnew = new Int32Array(newsize);\n            rnew.set(this.r);\n            this.r = rnew;\n        }\n        this.r[this.sz] = a;\n        this.r[this.sz + 1] = b;\n        this.sz += 2;\n    }\n    ;\n    /** Make sure the object can hold at least the given number of entries.\n     * @param cap int\n     * */\n    ensureCapacity(cap) {\n        if (this.r.length < cap)\n            this.resize(Math.max(2 * this.r.length, cap));\n    }\n    ;\n    /**\n     * @param newsize int\n     */\n    resize(newsize) {\n        if (newsize < this.sz)\n            console.error(\"requested array size too small\");\n        if (newsize == this.r.length)\n            return;\n        let rnew = new Int32Array(newsize);\n        let sliced = this.r.slice(0, this.sz + 1);\n        //\t\tthis.arrayCopy(this.r, 0, rnew, 0, this.sz);\n        this.r = sliced;\n    }\n    ;\n}\n//# sourceMappingURL=RangeSet.js.map","/**\n * Partial porting to Javascript of Xyf.java from Healpix3.30\n */\nexport class Xyf {\n    constructor(x, y, f) {\n        this.ix = x;\n        this.iy = y;\n        this.face = f;\n    }\n}\n//# sourceMappingURL=Xyf.js.map","\"use strict\";\nimport { CircleFinder } from \"./CircleFinder.js\";\nimport { Constants } from \"./Constants.js\";\nimport { Fxyf } from \"./Fxyf.js\";\nimport { Hploc } from \"./Hploc.js\";\nimport { Pointing } from \"./Pointing.js\";\nimport { pstack } from \"./pstack.js\";\nimport { RangeSet } from \"./RangeSet.js\";\nimport { Vec3 } from \"./Vec3.js\";\nimport { Xyf } from \"./Xyf.js\";\nimport { Zphi } from \"./Zphi.js\";\n/**\n * Partial porting to Javascript of HealpixBase.java from Healpix3.30\n */\n// import Fxyf from './Fxyf.js';\n// import Hploc from './Hploc.js';\n// import Xyf from './Xyf.js';\n// import Vec3 from './Vec3.js';\n// import Pointing from './Pointing.js';\n// import CircleFinder from './CircleFinder.js';\n// import Zphi from './Zphi.js';\n// import pstack from './pstack.js';\n// import Constants from './Constants.js';\n// import RangeSet from './RangeSet.js';\nexport class Healpix {\n    constructor(nside_in) {\n        this.order_max = 29;\n        this.inv_halfpi = 2.0 / Math.PI;\n        this.twothird = 2.0 / 3.;\n        // console.log(\"twothird \"+this.twothird);\n        // this.ns_max=1L<<order_max;\n        this.ns_max = Math.pow(2, this.order_max);\n        this.ctab = new Uint16Array([\n            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,\n            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,\n            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,\n            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,\n            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,\n            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,\n            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,\n            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,\n            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,\n            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,\n            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,\n            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,\n            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,\n            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,\n            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,\n            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855\n        ]);\n        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,\n            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,\n            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,\n            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,\n            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,\n            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,\n            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,\n            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,\n            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,\n            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,\n            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,\n            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,\n            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,\n            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,\n            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,\n            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,\n            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,\n            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);\n        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);\n        this.facearray = [\n            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),\n            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),\n            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),\n            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]),\n            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),\n            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),\n            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),\n            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),\n            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]) // N\n        ];\n        // questo forse deve essere un UInt8Array. Viene usato da neighbours\n        this.swaparray = [\n            new Int16Array([0, 0, 3]),\n            new Int16Array([0, 0, 6]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([0, 0, 5]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([5, 0, 0]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([6, 0, 0]),\n            new Int16Array([3, 0, 0]) // N\n        ];\n        if (nside_in <= this.ns_max && nside_in > 0) {\n            this.nside = nside_in;\n            this.npface = this.nside * this.nside;\n            this.npix = 12 * this.npface;\n            this.order = this.nside2order(this.nside);\n            this.nl2 = 2 * this.nside;\n            this.nl3 = 3 * this.nside;\n            this.nl4 = 4 * this.nside;\n            this.fact2 = 4.0 / this.npix;\n            this.fact1 = (this.nside << 1) * this.fact2;\n            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap\n            // console.log(\"order: \"+this.order);\n            // console.log(\"nside: \"+this.nside);\n        }\n        this.bn = [];\n        this.mpr = [];\n        this.cmpr = [];\n        this.smpr = [];\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // Uncaught RangeError: Maximum call stack size exceeded\n        // MOVED TO computeBn()\n        //        for (let i=0; i <= this.order_max; ++i) {\n        //        \tthis.bn[i]=new Healpix(1<<i);\n        //        \tthis.mpr[i]=bn[i].maxPixrad();\n        //        \tthis.cmpr[i]=Math.cos(mpr[i]);\n        //        \tthis.smpr[i]=Math.sin(mpr[i]);\n        //        }\n    }\n    computeBn() {\n        for (let i = 0; i <= this.order_max; ++i) {\n            this.bn[i] = new Healpix(1 << i);\n            this.mpr[i] = this.bn[i].maxPixrad();\n            this.cmpr[i] = Hploc.cos(this.mpr[i]);\n            this.smpr[i] = Hploc.sin(this.mpr[i]);\n        }\n    }\n    getNPix() {\n        return this.npix;\n    }\n    ;\n    getBoundaries(pix) {\n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        // console.log(\"PIXEL: \"+pix);\n        // console.log(\"XYF \"+xyf.ix+\" \"+xyf.iy+\" \"+xyf.face);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        // let d = 1.0/(this.nside);\n        // console.log(\"------------------------\");\n        // console.log(\"xc, yc, dc \"+xc+\",\"+ yc+\",\"+ dc);\n        // console.log(\"xc+dc-d, yc+dc, xyf.face, d \"+(xc+dc) +\",\"+ (yc+dc)+\",\"+\n        // xyf.face+\",\"+ d);\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        // console.log(\"Points for npix: \"+pix);\n        // console.log(points);\n        // if (pix > 750){\n        // console.log(\"pix: \"+pix);\n        // console.log(\"dc: \"+dc);\n        // console.log(\"xyf.ix: \"+xyf.ix);\n        // console.log(\"xyf.iy: \"+xyf.iy);\n        // console.log(\"xc: \"+xc);\n        // console.log(\"yc: \"+yc);\n        // console.log(\"d: \"+d);\n        // }\n        return points;\n    }\n    ;\n    /** Returns a set of points along the boundary of the given pixel.\n     * Step 1 gives 4 points on the corners. The first point corresponds\n     * to the northernmost corner, the subsequent points follow the pixel\n     * boundary through west, south and east corners.\n     *\n     * @param pix pixel index number\n     * @param step the number of returned points is 4*step\n     * @return {@link Vec3} for each point\n     */\n    getBoundariesWithStep(pix, step) {\n        // var points = new Array(); \n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        let d = 1.0 / (this.nside * step);\n        for (let i = 0; i < step; i++) {\n            points[i] = new Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();\n            points[i + step] = new Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();\n            points[i + 2 * step] = new Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();\n            points[i + 3 * step] = new Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();\n        }\n        return points;\n    }\n    ;\n    getPointsForXyfNoStep(x, y, face) {\n        let nside = Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    getPointsForXyf(x, y, step, face) {\n        let nside = step * Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    /** Returns the neighboring pixels of ipix.\n    This method works in both RING and NEST schemes, but is\n    considerably faster in the NEST scheme.\n    @param ipix the requested pixel number.\n    @return array with indices of the neighboring pixels.\n      The returned array contains (in this order)\n      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor\n      of ipix. If a neighbor does not exist (this can only happen\n      for the W, N, E and S neighbors), its entry is set to -1. */\n    neighbours(ipix) {\n        let result = new Int32Array(8);\n        let xyf = this.nest2xyf(ipix);\n        let ix = xyf.ix;\n        let iy = xyf.iy;\n        let face_num = xyf.face;\n        var nsm1 = this.nside - 1;\n        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {\n            let fpix = Math.floor(face_num << (2 * this.order));\n            let px0 = this.spread_bits(ix);\n            let py0 = this.spread_bits(iy) << 1;\n            let pxp = this.spread_bits(ix + 1);\n            let pyp = this.spread_bits(iy + 1) << 1;\n            let pxm = this.spread_bits(ix - 1);\n            let pym = this.spread_bits(iy - 1) << 1;\n            result[0] = fpix + pxm + py0;\n            result[1] = fpix + pxm + pyp;\n            result[2] = fpix + px0 + pyp;\n            result[3] = fpix + pxp + pyp;\n            result[4] = fpix + pxp + py0;\n            result[5] = fpix + pxp + pym;\n            result[6] = fpix + px0 + pym;\n            result[7] = fpix + pxm + pym;\n        }\n        else {\n            for (let i = 0; i < 8; ++i) {\n                let x = ix + this.xoffset[i];\n                let y = iy + this.yoffset[i];\n                let nbnum = 4;\n                if (x < 0) {\n                    x += this.nside;\n                    nbnum -= 1;\n                }\n                else if (x >= this.nside) {\n                    x -= this.nside;\n                    nbnum += 1;\n                }\n                if (y < 0) {\n                    y += this.nside;\n                    nbnum -= 3;\n                }\n                else if (y >= this.nside) {\n                    y -= this.nside;\n                    nbnum += 3;\n                }\n                let f = this.facearray[nbnum][face_num];\n                if (f >= 0) {\n                    let bits = this.swaparray[nbnum][face_num >>> 2];\n                    if ((bits & 1) > 0) {\n                        x = Math.floor(this.nside - x - 1);\n                    }\n                    if ((bits & 2) > 0) {\n                        y = Math.floor(this.nside - y - 1);\n                    }\n                    if ((bits & 4) > 0) {\n                        let tint = x;\n                        x = y;\n                        y = tint;\n                    }\n                    result[i] = this.xyf2nest(x, y, f);\n                }\n                else {\n                    result[i] = -1;\n                }\n            }\n        }\n        return result;\n    }\n    ;\n    nside2order(nside) {\n        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);\n    }\n    ;\n    nest2xyf(ipix) {\n        let pix = Math.floor(ipix & (this.npface - 1));\n        let xyf = new Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1), Math.floor((ipix >> (2 * this.order))));\n        return xyf;\n    }\n    ;\n    xyf2nest(ix, iy, face_num) {\n        return Math.floor(face_num << (2 * this.order))\n            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);\n    }\n    ;\n    loc2pix(hploc) {\n        let z = hploc.z;\n        let phi = hploc.phi;\n        let za = Math.abs(z);\n        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0); // in [0,4)\n        let pixNo;\n        if (za <= this.twothird) { // Equatorial region\n            let temp1 = this.nside * (0.5 + tt);\n            let temp2 = this.nside * (z * 0.75);\n            let jp = Math.floor(temp1 - temp2); // index of ascending edge line\n            let jm = Math.floor(temp1 + temp2); // index of descending edge line\n            let ifp = Math.floor(jp >>> this.order); // in {0,4}\n            let ifm = Math.floor(jm >>> this.order);\n            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));\n            let ix = Math.floor(jm & (this.nside - 1));\n            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);\n            pixNo = this.xyf2nest(ix, iy, face_num);\n        }\n        else { // polar region, za > 2/3\n            let ntt = Math.min(3, Math.floor(tt));\n            let tp = tt - ntt;\n            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?\n                this.nside * Math.sqrt(3 * (1 - za)) :\n                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);\n            let jp = Math.floor(tp * tmp); // increasing edge line index\n            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index\n            if (jp >= this.nside) {\n                jp = this.nside - 1; // for points too close to the boundary\n            }\n            if (jm >= this.nside) {\n                jm = this.nside - 1;\n            }\n            if (z >= 0) {\n                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);\n            }\n            else {\n                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);\n            }\n        }\n        return pixNo;\n    }\n    ;\n    /** Returns the normalized 3-vector corresponding to the center of the\n    supplied pixel.\n    @param pix long the requested pixel number.\n    @return the pixel's center coordinates. */\n    pix2vec(pix) {\n        return this.pix2loc(pix).toVec3();\n    }\n    ;\n    /** Returns the Zphi corresponding to the center of the supplied pixel.\n     @param pix the requested pixel number.\n     @return the pixel's center coordinates. */\n    pix2zphi(pix) {\n        return this.pix2loc(pix).toZphi();\n    }\n    /**\n     * @param pix long\n     * @return Hploc\n     */\n    pix2loc(pix) {\n        let loc = new Hploc(undefined);\n        let xyf = this.nest2xyf(pix);\n        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;\n        let nr;\n        if (jr < this.nside) {\n            nr = jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > this.nl3) {\n            nr = this.nl4 - jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = this.nside;\n            loc.z = (this.nl2 - jr) * this.fact1;\n        }\n        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;\n        //      \tassert(tmp<8*nr); // must not happen\n        if (tmp < 0) {\n            tmp += 8 * nr;\n        }\n        loc.phi = (nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp) / nr;\n        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);\n        return loc;\n    }\n    ;\n    ang2pix(ptg, mirror) {\n        return this.loc2pix(new Hploc(ptg));\n    }\n    ;\n    fmodulo(v1, v2) {\n        if (v1 >= 0) {\n            return (v1 < v2) ? v1 : v1 % v2;\n        }\n        var tmp = v1 % v2 + v2;\n        return (tmp === v2) ? 0.0 : tmp;\n    }\n    ;\n    compress_bits(v) {\n        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));\n        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);\n        return compressed;\n    }\n    ;\n    spread_bits(v) {\n        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))\n            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));\n    }\n    ;\n    /**\n     * Returns a range set of pixels that overlap with the convex polygon\n     * defined by the {@code vertex} array.\n     * <p>\n     * This method is more efficient in the RING scheme.\n     * <p>\n     * This method may return some pixels which don't overlap with the polygon\n     * at all. The higher {@code fact} is chosen, the fewer false positives are\n     * returned, at the cost of increased run time.\n     *\n     * @param vertex\n     *            an array containing the vertices of the requested convex\n     *            polygon.\n     * @param fact\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return the requested set of pixel number ranges\n     */\n    queryPolygonInclusive(vertex, fact) {\n        let inclusive = (fact != 0);\n        let nv = vertex.length;\n        //        let ncirc = inclusive ? nv+1 : nv;\n        if (!(nv >= 3)) {\n            console.log(\"not enough vertices in polygon\");\n            return;\n        }\n        let vv = new Array();\n        for (let i = 0; i < nv; ++i) {\n            vv[i] = Vec3.pointing2Vec3(vertex[i]);\n        }\n        let normal = new Array();\n        let flip = 0;\n        let index = 0;\n        let back = false;\n        while (index < vv.length) {\n            let first = vv[index];\n            let medium = null;\n            let last = null;\n            if (index == vv.length - 1) {\n                last = vv[1];\n                medium = vv[0];\n            }\n            else if (index == vv.length - 2) {\n                last = vv[0];\n                medium = vv[index + 1];\n            }\n            else {\n                medium = vv[index + 1];\n                last = vv[index + 2];\n            }\n            normal[index] = first.cross(medium).norm();\n            let hnd = normal[index].dot(last);\n            if (index == 0) {\n                flip = (hnd < 0.) ? -1 : 1;\n                let tmp = new Pointing(first); // TODO not used\n                back = false;\n            }\n            else {\n                let flipThnd = flip * hnd;\n                if (flipThnd < 0) {\n                    let tmp = new Pointing(medium);\n                    vv.splice(index + 1, 1);\n                    normal.splice(index, 1);\n                    back = true;\n                    index -= 1;\n                    continue;\n                }\n                else {\n                    let tmp = new Pointing(first);\n                    back = false;\n                }\n            }\n            normal[index].scale(flip);\n            index += 1;\n        }\n        nv = vv.length;\n        let ncirc = inclusive ? nv + 1 : nv;\n        let rad = new Array(ncirc);\n        rad = rad.fill(Constants.halfpi);\n        //        rad = rad.fill(1.5707963267948966);\n        //        let p = \"1.5707963267948966\";\n        //        rad = rad.fill(parseFloat(p));\n        if (inclusive) {\n            let cf = new CircleFinder(vv);\n            normal[nv] = cf.getCenter();\n            rad[nv] = Hploc.acos(cf.getCosrad());\n        }\n        return this.queryMultiDisc(normal, rad, fact);\n    }\n    ;\n    /**\n     * For NEST schema only\n     *\n     * @param normal:\n     *            Vec3[]\n     * @param rad:\n     *            Float32Array\n     * @param fact:\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return RangeSet the requested set of pixel number ranges\n     */\n    queryMultiDisc(norm, rad, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let nv = norm.length;\n        // HealpixUtils.check(nv==rad.lengt0,\"inconsistent input arrays\");\n        if (!(nv == rad.length)) {\n            console.error(\"inconsistent input arrays\");\n            return;\n        }\n        let res = new RangeSet(4 << 1);\n        // Removed code for Scheme.RING\n        let oplus = 0;\n        if (inclusive) {\n            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {\n                console.error(\"invalid oversampling factor\");\n            }\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = this.order + oplus; // the order up to which we test\n        // TODO: ignore all disks with radius>=pi\n        //        let crlimit = new Float32Array[omax+1][nv][3];\n        let crlimit = new Array(omax + 1);\n        let o;\n        let i;\n        for (o = 0; o <= omax; ++o) { // prepare data at the required orders\n            crlimit[o] = new Array(nv);\n            let dr = this.bn[o].maxPixrad(); // safety distance\n            for (i = 0; i < nv; ++i) {\n                crlimit[o][i] = new Float64Array(3);\n                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Hploc.cos(rad[i] + dr);\n                crlimit[o][i][1] = (o == 0) ? Hploc.cos(rad[i]) : crlimit[0][i][1];\n                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : Hploc.cos(rad[i] - dr);\n            }\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse\n            // order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let o = stk.otop();\n            stk.pop();\n            let pv = this.bn[o].pix2vec(pix);\n            let zone = 3;\n            for (let i = 0; (i < nv) && (zone > 0); ++i) {\n                let crad = pv.dot(norm[i]);\n                for (let iz = 0; iz < zone; ++iz) {\n                    if (crad < crlimit[o][i][iz]) {\n                        zone = iz;\n                    }\n                }\n            }\n            if (zone > 0) {\n                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);\n            }\n        }\n        return res;\n    }\n    ;\n    /** Integer base 2 logarithm.\n    @param arg\n    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.\n    For negative arguments and zero, 0 is returned. */\n    ilog2(arg) {\n        let max = Math.max(arg, 1);\n        return 31 - Math.clz32(max);\n    }\n    ;\n    /** Computes the cosine of the angular distance between two z, phi positions\n      on the unit sphere. */\n    cosdist_zphi(z1, phi1, z2, phi2) {\n        return z1 * z2 + Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));\n    }\n    /**\n     * @param int o\n     * @param int omax\n     * @param int zone\n     * @param RangeSet pixset\n     * @param long pix\n     * @param pstack stk\n     * @param boolean inclusive\n     */\n    check_pixel(o, omax, zone, pixset, pix, stk, inclusive) {\n        if (zone == 0)\n            return;\n        if (o < this.order) {\n            if (zone >= 3) { // output all subpixels\n                let sdist = 2 * (this.order - o); // the \"bit-shift distance\" between map orders\n                pixset.append1(pix << sdist, ((pix + 1) << sdist));\n            }\n            else { // (zone>=1)\n                for (let i = 0; i < 4; ++i) {\n                    stk.push(4 * pix + 3 - i, o + 1); // add children\n                }\n            }\n        }\n        else if (o > this.order) { // this implies that inclusive==true\n            if (zone >= 2) { // pixel center in shape\n                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                stk.popToMark(); // unwind the stack\n            }\n            else { // (zone>=1): pixel center in safety range\n                if (o < omax) { // check sublevels\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                    stk.popToMark(); // unwind the stack\n                }\n            }\n        }\n        else { // o==order\n            if (zone >= 2) {\n                pixset.append(pix);\n            }\n            else if (inclusive) { // and (zone>=1)\n                if (this.order < omax) { // check sublevels\n                    stk.mark(); // remember current stack position\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix); // output the pixel\n                }\n            }\n        }\n    }\n    /** Returns the maximum angular distance between a pixel center and its\n    corners.\n    @return maximum angular distance between a pixel center and its\n      corners. */\n    maxPixrad() {\n        let zphia = new Zphi(2. / 3., Math.PI / this.nl4);\n        let xyz1 = this.convertZphi2xyz(zphia);\n        let va = new Vec3(xyz1[0], xyz1[1], xyz1[2]);\n        let t1 = 1. - 1. / this.nside;\n        t1 *= t1;\n        let zphib = new Zphi(1 - t1 / 3, 0);\n        let xyz2 = this.convertZphi2xyz(zphib);\n        let vb = new Vec3(xyz2[0], xyz2[1], xyz2[2]);\n        return va.angle(vb);\n    }\n    ;\n    /**\n     * this is a workaround replacing the Vec3(Zphi) constructor.\n     */\n    convertZphi2xyz(zphi) {\n        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));\n        let x = sth * Hploc.cos(zphi.phi);\n        let y = sth * Hploc.sin(zphi.phi);\n        let z = zphi.z;\n        return [x, y, z];\n    }\n    ;\n    /** Returns a range set of pixels which overlap with a given disk. <p>\n      This method is more efficient in the RING scheme. <p>\n      This method may return some pixels which don't overlap with\n      the polygon at all. The higher {@code fact} is chosen, the fewer false\n      positives are returned, at the cost of increased run time.\n      @param ptg the angular coordinates of the disk center\n      @param radius the radius (in radians) of the disk\n      @param fact The overlapping test will be done at the resolution\n        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power\n        of 2, else it can be any positive integer. A typical choice would be 4.\n      @return the requested set of pixel number ranges  */\n    queryDiscInclusive(ptg, radius, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let pixset = new RangeSet();\n        if (radius >= Math.PI) { // disk covers the whole sphere\n            pixset.append1(0, this.npix);\n            return pixset;\n        }\n        let oplus = 0;\n        if (inclusive) {\n            // HealpixUtils.check ((1L<<order_max)>=fact,\"invalid oversampling factor\");\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test\n        let vptg = Vec3.pointing2Vec3(ptg);\n        let crpdr = new Array(omax + 1);\n        let crmdr = new Array(omax + 1);\n        let cosrad = Hploc.cos(radius);\n        let sinrad = Hploc.sin(radius);\n        for (let o = 0; o <= omax; o++) { // prepare data at the required orders\n            let dr = this.mpr[o]; // safety distance\n            let cdr = this.cmpr[o];\n            let sdr = this.smpr[o];\n            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;\n            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let curro = stk.otop();\n            stk.pop();\n            let pos = this.bn[curro].pix2zphi(pix);\n            // cosine of angular distance between pixel center and disk center\n            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);\n            if (cangdist > crpdr[curro]) {\n                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);\n                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);\n            }\n        }\n        return pixset;\n    }\n}\n//# sourceMappingURL=Healpix.js.map","\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { Healpix } from 'healpixjs';\nimport { Pointing } from \"healpixjs\";\nimport { Hploc } from \"healpixjs\";\n\nimport { radToDeg } from '../model/Utils.js'; // TODO change package\nimport { CoordsType } from \"../model/CoordsType.js\";\nimport { HEALPixXYSpace } from \"../model/HEALPixXYSpace.js\";\nimport { Point } from \"../model/Point.js\";\nimport { SphericalCoords } from \"../model/SphericalCoords.js\";\nimport { NumberType } from '../model/NumberType.js';\nimport { AstroCoords } from \"../model/AstroCoords.js\";\nimport { EquatorialCoords } from \"../model/EquatorialCoords.js\";\n\nexport class HiPSHelper {\n\n\n\t// static pxXtile: number = 512; // TODO in some cases it is different\n\tstatic DEFAULT_Naxis1_2: number = 512;\n\t// static RES_ORDER_0: number = 58.6 / HiPSHelper.pxXtile;\n\tstatic RES_ORDER_0: number = 58.6;\n\tstatic H: number = 4;\n\tstatic K: number = 3;\n\tstatic THETAX: number = Hploc.asin((HiPSHelper.K - 1) / HiPSHelper.K);\n\t/**\n\t * Table 1 - ref paper HEALPix — a Framework for High Resolution Discretization,\n\t * and Fast Analysis of Data Distributed on the Sphere\n\t * K. M. G´orski1,2, E. Hivon3,4, A. J. Banday5, B. D. Wandelt6,7, F. K. Hansen8, M.\n\t * Reinecke5, M. Bartelman9\n\t */\n\t/**\n\t * \n\t * @param {decimal degrees} pxsize \n\t * @returns {int} nside\n\t */\n\tstatic computeHiPSOrder(pxsize: number, pxXtile: number): number {\n\t\t/**\n\t\t * with same order k (table 1), HIPS angular resolution is higher of order of 512 (2^9) pixels than \n\t\t * the HEALPix. This is because each tile in a HiPS is represented by default by 512x512 pixels.\\\n\t\t * Angular resolution of different HEALPix orders in respect to the order 0, can be calculated this\n\t\t * way:\n\t\t * \n\t\t * \tL(k) = L(0) / 2^k = 58.6 / 2^k\n\t\t * \n\t\t * Therefore, in the case of HiPS we need to take into account the extra resolution given by the \n\t\t * 512x512 (2^9) tiles. In this case the above becomes:\n\t\t * \t\n\t\t * \tL(k) = L(0) / (2^k * 2^9) \n\t\t * \n\t\t * Though, in order to compute the required order starting from the pxsize desired (in input) we\n\t\t * need to perform these steps:\n\t\t * \n\t\t * \tpxsize = L(k) = L(0) / (2^k * 2^9)\n\t\t * \t2^k = L(0) / (pxsize * 2^9)\n\t\t *  k * Log2 2 = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \tk = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \n\t\t */\n\n\n\t\tlet k = Math.log2( (HiPSHelper.RES_ORDER_0 / pxXtile) / pxsize);\n\t\tk = Math.round(k);\n\t\t// let theta0px = HiPSHelper.RES_ORDER_0;\n\t\t// let k = Math.log2(theta0px) - Math.log2(pxsize * 2**9);\n\t\t// k = Match.round(k);\n\t\t// let nside = 2**k;\n\t\t// return {\n\t\t//     \"nside\" : nside,\n\t\t//     \"norder\" : k\n\t\t// };\n\t\treturn k;\n\n\t}\n\n\t/**\n\t * Reference: HiPS – Hierarchical Progressive Survey page 11\n\t * pxsize =~ sqrt[4 * PI / (12 * (512 * 2^order)^2)]\n\t * @param {*} order \n\t */\n\tstatic computePxSize(order: number, pxXtile: number): number {\n\t\t// TODO CHECK IT\n\t\t// let pxsize = 1 / (512 * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\tlet pxsize = 1 / (pxXtile * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\treturn pxsize;\n\t}\n\n\t// /**\n\t//  * \n\t//  * @param {Object {ra, dec}} point  decimal degrees\n\t//  * @returns {Object {phi_rad, theta_rad}} in radians\n\t//  */\n\t// static convert2PhiTheta (point: Point) {\n\t// \tlet phitheta_rad = {};\n\t// \tlet phiTheta_deg = HiPSHelper.astroDegToSpherical(point.ra, point.dec);\n\t// \tphitheta_rad.phi_rad = HiPSHelper.degToRad(phiTheta_deg.phi);\n\t//     phitheta_rad.theta_rad = HiPSHelper.degToRad(phiTheta_deg.theta);\n\t// \treturn phitheta_rad;\n\t// }\n\n\t// static astroDegToSphericalRad(raDeg: number, decDeg: number) {\n\t// \tlet phiThetaDeg = HiPSHelper.astroDegToSpherical(raDeg, decDeg);\n\t// \tlet phiThetaRad = {\n\t// \t\tphi_rad: HiPSHelper.degToRad(phiThetaDeg.phi),\n\t// \t\ttheta_rad: HiPSHelper.degToRad(phiThetaDeg.theta)\n\t// \t}\n\t// \treturn phiThetaRad;\n\t// }\n\n\t// static degToRad(degrees: number): number {\n\t// \treturn (degrees / 180 ) * Math.PI ;\n\t// }\n\n\t// static radToDeg(rad: number): number {\n\t// \treturn (rad / Math.PI ) * 180 ;\n\t// }\n\n\t// static astroDegToSpherical(raDeg: number, decDeg: number): Point{\n\n\t// \tlet phiDeg: number;\n\t// \tlet thetaDeg: number;\n\t// \tphiDeg = raDeg;\n\t// \tif (phiDeg < 0){\n\t// \t\tphiDeg += 360;\n\t// \t}\n\n\t// \tthetaDeg = 90 - decDeg;\n\n\t// \treturn {\n\t// \t\tphi: phiDeg,\n\t// \t\ttheta: thetaDeg\n\t// \t};\n\t// }\n\n\t/**\n\t * \n\t * @param {Object {phi_rad, theta_rad}} phiTheta_rad Center of the circle in radians\n\t * @param {decimal} r Radius of the circle in radians\n\t * @returns \n\t */\n\tstatic computeBbox(point: Point, r: number): number[] {\n\n\t\tlet bbox = [];\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad + r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\n\t\treturn bbox;\n\t}\n\n\tstatic setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n\n\t\tlet xyGridProj: HEALPixXYSpace = {\n\t\t\t\"min_y\": NaN,\n\t\t\t\"max_y\": NaN,\n\t\t\t\"min_x\": NaN,\n\t\t\t\"max_x\": NaN,\n\t\t\t\"gridPointsDeg\": []\n\t\t}\n\n\n\t\tlet cornersVec3 = hp.getBoundariesWithStep(tileno, 1);\n\t\tlet pointings = [];\n\n\t\tfor (let i = 0; i < cornersVec3.length; i++) {\n\t\t\tpointings[i] = new Pointing(cornersVec3[i]);\n\t\t\tif (i >= 1) {\n\t\t\t\tlet a = pointings[i - 1].phi;\n\t\t\t\tlet b = pointings[i].phi;\n\t\t\t\t// case when RA is just crossing the origin (e.g. 357deg - 3deg)\n\t\t\t\tif (Math.abs(a - b) > Math.PI) {\n\t\t\t\t\tif (pointings[i - 1].phi < pointings[i].phi) {\n\t\t\t\t\t\tpointings[i - 1].phi += 2 * Math.PI;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpointings[i].phi += 2 * Math.PI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let j = 0; j < pointings.length; j++) {\n\t\t\tlet coThetaRad = pointings[j].theta;\n\t\t\t// HEALPix works with colatitude (0 North Pole, 180 South Pole)\n\t\t\t// converting the colatitude in latitude (dec)\n\t\t\tlet decRad = Math.PI / 2 - coThetaRad;\n\n\t\t\tlet raRad = pointings[j].phi;\n\n\t\t\t// projection on healpix grid\n\t\t\tlet p = new Point(CoordsType.ASTRO, NumberType.RADIANS, raRad, decRad);\n\t\t\tlet xyDeg = HiPSHelper.world2intermediate(p.astro);\n\t\t\txyGridProj.gridPointsDeg[j * 2] = xyDeg[0];\n\t\t\txyGridProj.gridPointsDeg[j * 2 + 1] = xyDeg[1];\n\n\t\t\tif (isNaN(xyGridProj.max_y) || xyDeg[1] > xyGridProj.max_y) {\n\t\t\t\txyGridProj.max_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_y) || xyDeg[1] < xyGridProj.min_y) {\n\t\t\t\txyGridProj.min_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.max_x) || xyDeg[0] > xyGridProj.max_x) {\n\t\t\t\txyGridProj.max_x = xyDeg[0];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_x) || xyDeg[0] < xyGridProj.min_x) {\n\t\t\t\txyGridProj.min_x = xyDeg[0];\n\t\t\t}\n\n\t\t}\n\t\treturn xyGridProj;\n\t}\n\n\tstatic world2intermediate(ac: AstroCoords): [number, number] {\n\n\t\tlet x_grid: number;\n\t\tlet y_grid: number;\n\n\t\tif (Math.abs(ac.decRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t\t\tx_grid = ac.raDeg;\n\n\t\t\ty_grid = Hploc.sin(ac.decRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t\t} else if (Math.abs(ac.decRad) > HiPSHelper.THETAX) { // polar zones\n\n\t\t\tlet raDeg = ac.raDeg;\n\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\n\t\t\tlet sigma = Math.sqrt(HiPSHelper.K * (1 - Math.abs(Hploc.sin(ac.decRad))));\n\t\t\tlet phi_c = - 180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSHelper.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSHelper.H);\n\n\t\t\tx_grid = phi_c + (raDeg - phi_c) * sigma;\n\t\t\ty_grid = (180 / HiPSHelper.H) * (((HiPSHelper.K + 1) / 2) - sigma);\n\n\t\t\tif (ac.decRad < 0) {\n\t\t\t\ty_grid *= -1;\n\t\t\t}\n\t\t}\n\n\t\treturn [x_grid, y_grid];\n\n\t}\n\n\t// static world2intermediate(sc: SphericalCoords): [number, number] {\n\t//     let x_grid: number;\n\t// \tlet y_grid: number;\n\n\t// \tif ( Math.abs(sc.thetaRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t// \t\tx_grid = sc.phiDeg;\n\n\t// \t\ty_grid = Hploc.sin(sc.thetaRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t// \t} else if ( Math.abs(sc.thetaRad) > HiPSHelper.THETAX) { // polar zones\n\n\t// \t\tlet phiDeg = sc.phiDeg;\n\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || sc.thetaRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\n\t// \t\tlet sigma = Math.sqrt( HiPSHelper.K * (1 - Math.abs(Hploc.sin(sc.thetaRad)) ) );\n\t// \t\tlet phi_c = - 180 + ( 2 * Math.floor( ((sc.phiRad + 180) * HiPSHelper.H/360) + ((1 - w)/2) ) + w ) * ( 180 / HiPSHelper.H );\n\n\t// \t\tx_grid = phi_c + (phiDeg - phi_c) * sigma;\n\t// \t\ty_grid = (180  / HiPSHelper.H) * ( ((HiPSHelper.K + 1)/2) - sigma);\n\n\t// \t\tif (sc.thetaRad < 0) {\n\t// \t\t\ty_grid *= -1;\n\t// \t\t}\n\t// \t}\n\n\t// \treturn [x_grid, y_grid];\n\n\t// }\n\n\tstatic intermediate2pix(x: number, y: number, xyGridProj: HEALPixXYSpace, pxXtile: number): [number, number] {\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);\n\n\t\tlet i_norm: number;\n\t\tlet j_norm: number;\n\t\tif ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {\n\t\t\ti_norm = (x + 360 - xyGridProj.min_x) / xInterval;\n\t\t} else {\n\t\t\ti_norm = (x - xyGridProj.min_x) / xInterval;\n\t\t}\n\t\tj_norm = (y - xyGridProj.min_y) / yInterval;\n\n\n\t\tlet i = 0.5 - (i_norm - j_norm);\n\t\tlet j = (i_norm + j_norm) - 0.5;\n\n\t\t// TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);\n\t\tpxXtile\n\t\t// i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];\n\t\t\n\t\ti = Math.floor(i * pxXtile);\n\t\tj = Math.floor(j * pxXtile);\n\t\treturn [i, pxXtile - j - 1];\n\n\n\n\t}\n\n\n\tstatic pix2intermediate(i: number, j: number, xyGridProj: HEALPixXYSpace, naxis1: number, naxis2: number): [number, number] {\n\t\t/**\n\t\t   * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image\n\t\t * (i_norm,w_pixel) = (1,1) is the upper right corner\n\t\t * dimamond in figure 1 from \"Mapping on the HEalpix grid\" paper\n\t\t * (0,0) leftmost corner\n\t\t * (1,0) upper corner\n\t\t * (0,1) lowest corner\n\t\t * (1,1) rightmost corner\n\t\t * Thanks YAGO! :p\n\t\t */\n\t\t// let cnaxis1 = HiPSHelper.pxXtile;\n\t\t// let cnaxis2 = HiPSHelper.pxXtile;\n\n\t\tlet cnaxis1 = naxis1;\n\t\tlet cnaxis2 = naxis2;\n\t\tif (naxis1) {\n\t\t\tcnaxis1 = naxis1;\n\t\t}\n\t\tif (naxis2) {\n\t\t\tcnaxis2 = naxis2;\n\t\t}\n\t\tlet i_norm = (i + 0.5) / cnaxis1;\n\t\tlet j_norm = (j + 0.5) / cnaxis2;\n\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;\n\t\tlet yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;\n\n\t\t// bi-linear interpolation\n\t\tlet x = xyGridProj.max_x - xInterval * (i_norm + j_norm);\n\t\tlet y = yMean - yInterval * (j_norm - i_norm);\n\n\t\treturn [x, y];\n\t}\n\n\n\tstatic intermediate2world(x: number, y: number): Point {\n\n\t\tlet phiDeg: number;\n\t\tlet thetaDeg: number;\n\t\tlet Yx = 90 * (HiPSHelper.K - 1) / HiPSHelper.H;\n\n\n\n\t\tif (Math.abs(y) <= Yx) { // equatorial belts\n\n\t\t\tphiDeg = x;\n\t\t\tthetaDeg = radToDeg(Math.asin((y * HiPSHelper.H) / (90 * HiPSHelper.K)));\n\n\t\t} else if (Math.abs(y) > Yx) { // polar regions\n\n\t\t\tlet sigma = (HiPSHelper.K + 1) / 2 - Math.abs(y * HiPSHelper.H) / 180;\n\t\t\tlet thetaRad = Hploc.asin(1 - (sigma * sigma) / HiPSHelper.K);\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\t\t\tlet x_c = -180 + (2 * Math.floor((x + 180) * HiPSHelper.H / 360 + (1 - w) / 2) + w) * (180 / HiPSHelper.H);\n\t\t\tphiDeg = x_c + (x - x_c) / sigma;\n\t\t\tthetaDeg = radToDeg(thetaRad);\n\t\t\tif (y <= 0) {\n\t\t\t\tthetaDeg *= -1;\n\t\t\t}\n\t\t}\n\t\t// return [phiDeg, thetaDeg];\n\t\t// TODO CHECK THIS!\n\t\t// let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);\n\t\tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, phiDeg, thetaDeg);\n\n\t\treturn p;\n\n\t}\n\n}\n","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\n\nimport { Healpix } from \"healpixjs\";\nimport { Pointing } from \"healpixjs\";\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { HEALPixXYSpace } from '../model/HEALPixXYSpace.js';\n\nimport { HiPSHelper } from './HiPSHelper.js';\n\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { astroToSpherical, degToRad, fillAstro, radToDeg } from '../model/Utils.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\nimport { INSPECT_MAX_BYTES } from 'buffer';\n\n\n\nexport class HiPSProjection implements AbstractProjection {\n\n\t_naxis1!: number;\n\t_naxis2!: number;\n\t_isGalactic: boolean = false;\n\t_pixno!: number;\n\t_tileslist!: number[];\n\t_hp!: Healpix;\n\t_fh_common!: FITSHeader;\n\t_ctype1: string; // TODO should be RA ENUM\n\t_ctype2: string; // TODO should be Dec ENUM\n\t_wcsname: string;\n\t_hipsBaseURI!: string;\n\t_pxsize!: number;\n\t_fitsheaderlist: FITSHeader[];\n\t_pxvalues: Map<number, Array<Uint8Array>>;\n\t_xyGridProj!: HEALPixXYSpace;\n\t_norder!: number;\n\t_nside!: number;\n\t_radeclist: Array<[number, number]>;\n\t_HIPS_TILE_WIDTH: number;\n\t_fitsUsed: String[] = [];\n\t_HIPS_MAX_ORDER: number;\n\n\t/**\n\t * \n\t * * ex with single local file:\n\t * let hp = new HiPSProjection('/mylocaldir/myfile.fits', null, null, null);\n\t * hp.initFromFile()\n\t * \n\t * * ex with single remote file:\n\t * let hp = new HiPSProjection('http://<hips-server>/Norder7/DirN/NpixXYZ.fits', null, null, null);\n\t * hp.initFromFile()\n\t *\n\t * * ex with HiPS server base local dir:\n\t * let hp = new HiPSProjection(null, <hips-local-root-dir>, pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t * * ex with HiPS server base URL:\n\t * let hp = new HiPSProjection(null, 'http://<hips-server>/<hips-root-dir>', pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t */\n\n\n\t//  constructor(fitsfilepath?: string, hipsBaseURI?: string, pxsize?: number, order?: number) {\n\tconstructor() {\n\n\t\tthis._wcsname = \"HPX\"; // TODO check WCS standard\n\t\tthis._ctype1 = \"RA---HPX\";\n\t\tthis._ctype2 = \"DEC--HPX\";\n\n\t\tthis._pxvalues = new Map<number, Array<Uint8Array>>();\n\t\tthis._fitsheaderlist = new Array<FITSHeader>();\n\t\tthis._radeclist = new Array<[number, number]>();\n\n\t}\n\n\tasync parsePropertiesFile(baseUrl: string): Promise<any> {\n\t\tconst fp = new FITSParser(null);\n\n\t\tconst promise = fp.getFile(baseUrl + \"/properties\").then((propFile: ArrayBuffer | Buffer) => {\n\t\t\tlet prop: string;\n\t\t\tif (propFile instanceof ArrayBuffer) {\n\t\t\t\tconst textDecoder = new TextDecoder(\"iso-8859-1\");\n\t\t\t\tprop = textDecoder.decode(new Uint8Array(propFile));\n\t\t\t} else {\n\t\t\t\tprop = propFile.toString('utf8');\n\t\t\t}\n\t\t\t/**\n\t\t\t \tHiPS – Hierarchical Progressive Survey\n\t\t\t\tVersion 1.0\n\t\t\t\tIVOA Proposed Recommendation\n\t\t\t\t3rd April 2017\n\t\t\t\thttps://www.ivoa.net/documents/HiPS/20170403/PR-HIPS-1.0-20170403.pdf\n\t\t\t */\n\t\t\tconst txtArr = prop.split('\\n');\n\t\t\tthis._HIPS_TILE_WIDTH = 512;\n\t\t\tfor (let line of txtArr) {\n\t\t\t\tif (!line.includes(\"=\")){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst tokens = line.split(\"=\");\n\t\t\t\tif (tokens[1] === undefined){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst key = tokens[0].trim()\n\t\t\t\tconst val = tokens[1].trim()\n\n\t\t\t\tif (key == \"hips_order\") {\n\t\t\t\t\tthis._HIPS_MAX_ORDER = parseInt(val);\n\t\t\t\t\tconsole.log(\"hips_order \"+this._HIPS_MAX_ORDER)\n\t\t\t\t} else if (key == \"hips_tile_width\") {\n\t\t\t\t\tthis._HIPS_TILE_WIDTH = parseInt(val);\n\t\t\t\t\tthis._naxis1 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tthis._naxis2 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tconsole.log(\"hips_tile_width \"+this._HIPS_TILE_WIDTH)\n\t\t\t\t} else if (key == \"hips_frame\" && val == \"galactic\") {\n\t\t\t\t\tthis._isGalactic = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn propFile;\n\t\t});\n\n\t\tawait promise;\n\t\treturn promise;\n\t}\n\n\tasync initFromFile(fitsfilepath: string): Promise<FITSParsed> {\n\t\tlet fp = new FITSParser(fitsfilepath);\n\n\t\tlet promise = fp.loadFITS().then(fits => {\n\t\t\tthis._pxvalues.set(0, fits.data);\n\t\t\tthis._fitsheaderlist[0] = fits.header;\n\n\t\t\tlet order = fits.header.get(\"ORDER\");\n\t\t\tthis.init(order);\n\n\t\t\tthis._naxis1 = fits.header.get(\"NAXIS1\");\n\t\t\tthis._naxis2 = fits.header.get(\"NAXIS2\");\n\t\t\tthis._HIPS_TILE_WIDTH = this._naxis1;\n\n\t\t\tthis._pixno = fits.header.get(\"NPIX\");\n\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(this._pixno, this._hp);\n\t\t\treturn fits;\n\t\t});\n\t\tawait promise;\n\t\treturn promise;\n\t}\n\n\n\n\tasync initFromHiPSLocationAndPxSize(baseUrl: string, pxsize: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tthis._pxsize = pxsize;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\tlet order = HiPSHelper.computeHiPSOrder(pxsize, this._HIPS_TILE_WIDTH);\n\t\tif (order > this._HIPS_MAX_ORDER) {\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tthis.init(order);\n\t}\n\n\tasync initFromHiPSLocationAndOrder(baseUrl: string, order: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\tif (order > this._HIPS_MAX_ORDER){\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tthis._pxsize = HiPSHelper.computePxSize(order, this._HIPS_TILE_WIDTH);\n\t\tthis.init(order);\n\t}\n\n\tinit(order: number) {\n\t\tthis._norder = order;\n\t\tthis._nside = 2 ** order;\n\t\tthis._hp = new Healpix(this._nside);\n\t}\n\n\tprepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\t\tfor (let header of this._fitsheaderlist) {\n\n\t\t\theader.addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n\t\t\theader.addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n\t\t\tif (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n\t\t\t}\n\t\t\tlet bscale = 1.0;\n\t\t\tif (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n\t\t\t\tbscale = fitsHeaderParams.get(\"BSCALE\");\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\t\t\t}\n\n\n\t\t\tlet bzero = 0.0;\n\t\t\tif (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n\t\t\t\tbzero = fitsHeaderParams.get(\"BZERO\");\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\t\t\t}\n\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS\", 2));\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS1\", HiPSHelper.DEFAULT_Naxis1_2));\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS2\", HiPSHelper.DEFAULT_Naxis1_2));\n\n\t\t\theader.addItem(new FITSHeaderItem(\"ORDER\", this._norder));\n\n\t\t\theader.addItem(new FITSHeaderItem(\"CTYPE1\", this._ctype1));\n\t\t\theader.addItem(new FITSHeaderItem(\"CTYPE2\", this._ctype2));\n\n\t\t\t// header.addItem(new FITSHeaderItem(\"CRPIX1\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel i along naxis1\n\t\t\t// header.addItem(new FITSHeaderItem(\"CRPIX2\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel j along naxis2\n\n\t\t\theader.addItem(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n\t\t\theader.addItem(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n\n\t\t}\n\t\treturn this._fitsheaderlist;\n\t}\n\n\n\tgetFITSHeader(): FITSHeader[] {\n\t\treturn this._fitsheaderlist;\n\t}\n\n\tgetCommonFitsHeaderParams(): FITSHeader {\n\t\treturn this._fh_common;\n\t}\n\n\textractPhysicalValues(fits: FITSParsed): number[][] {\n\n\t\tlet bzero = fits.header.get(\"BZERO\");\n\t\tlet bscale = fits.header.get(\"BSCALE\");\n\t\tlet naxis1 = fits.header.get(\"NAXIS1\");\n\t\tlet naxis2 = fits.header.get(\"NAXIS2\");\n\t\tlet bitpix = fits.header.get(\"BITPIX\");\n\t\tlet bytesXelem = Math.abs(bitpix / 8);\n\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n\t\t// let physicalvalues = new Array[naxis2][naxis1];\n\t\tlet physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n\t\tfor (let n2 = 0; n2 < naxis2; n2++) {\n\t\t\tphysicalvalues[n2] = new Array<number>(naxis1);\n\t\t\tfor (let n1 = 0; n1 < naxis1; n1++) {\n\t\t\t\tlet pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n\t\t\t\tlet physicalVal = bzero + bscale * pixval;\n\t\t\t\tphysicalvalues[n2][n1] = physicalVal;\n\t\t\t}\n\t\t}\n\t\treturn physicalvalues;\n\n\t}\n\n\tasync getFITSFiles(inputPixelsList: ImagePixel[], destPath: string): Promise<Map<string, FITSParsed>> {\n\n\t\tconst fitsFilesGenerated = new Map<string, FITSParsed>();\n\t\tlet promises = [];\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\t\tfor (let hipstileno of tilesset) {\n\t\t\tlet tileno = hipstileno;\n\t\t\tlet dir = Math.floor(tileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + tileno + \".fits\";\n\t\t\tlet fp = new FITSParser(fitsurl);\n\n\n\t\t\tpromises.push(fp.loadFITS().then((fits) => {\n\t\t\t\tif (fits !== null) {\n\t\t\t\t\tlet pixno = (fits.header.get(\"NPIX\") !== undefined) ? fits.header.get(\"NPIX\") : tileno;\n\t\t\t\t\t// FITSParser.writeFITS(fits.header, fits.data, destPath+\"/Npix\"+pixno+\".fits\");\n\t\t\t\t\t// fitsFilesGenerated.set(destPath+\"/Npix\"+pixno+\".fits\",FITSParser.generateFITS(fits.header, fits.data) );\n\t\t\t\t\tfitsFilesGenerated.set(destPath + \"/Npix\" + pixno + \".fits\", fits);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\treturn fitsFilesGenerated;\n\t}\n\n\n\tget fitsUsed(): String[] {\n\t\treturn this._fitsUsed;\n\t}\n\n\tasync getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array | undefined> {\n\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\n\t\tlet pixcount = inputPixelsList.length;\n\t\tlet values: Uint8Array | undefined = undefined;\n\t\tlet fitsheaderlist: (FITSHeader | undefined)[] = [];\n\t\tlet promises = [];\n\n\t\tlet self = this;\n\t\tfor (let hipstileno of tilesset) {\n\n\t\t\tlet dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + hipstileno + \".fits\";\n\t\t\tconsole.log(`Identified source file ${fitsurl}`)\n\t\t\tlet fp = new FITSParser(fitsurl);\n\t\t\tpromises.push(fp.loadFITS().then((fits) => {\n\n\t\t\t\tif (fits === null) {\n\t\t\t\t\tfitsheaderlist.push(undefined);\n\t\t\t\t} else {\n\t\t\t\t\tself._fitsUsed.push(fitsurl);\n\n\t\t\t\t\tlet bytesXelem = Math.abs(fits.header.get(\"BITPIX\") / 8);\n\t\t\t\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // => ???????\n\t\t\t\t\tif (values === undefined) {\n\t\t\t\t\t\tvalues = new Uint8Array(pixcount * bytesXelem);\n\t\t\t\t\t}\n\n\t\t\t\t\t// console.log(fitsurl + \" loaded\");\n\t\t\t\t\tfitsheaderlist.push(fits.header);\n\n\t\t\t\t\tfor (let p = 0; p < pixcount; p++) {\n\t\t\t\t\t\tlet imgpx = inputPixelsList[p];\n\n\t\t\t\t\t\tif (imgpx.tileno === hipstileno) {\n\n\n\t\t\t\t\t\t\t// if (imgpx._j < HiPSHelper.DEFAULT_Naxis1_2 && imgpx._i < HiPSHelper.DEFAULT_Naxis1_2) {\n\t\t\t\t\t\t\tif (imgpx._j < fits.header.get(\"NAXIS1\") && imgpx._i < fits.header.get(\"NAXIS2\")) {\n\t\t\t\t\t\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\t\t\t\t\t\tvalues[p * bytesXelem + b] = fits.data[imgpx._j][imgpx._i * bytesXelem + b];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\tif (fitsheaderlist !== undefined) {\n\t\t\tthis.prepareCommonHeader(fitsheaderlist);\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tcomputeSquaredNaxes(d: number, ps: number): void {\n\t\t// first aprroximation to be checked\n\t\tthis._naxis1 = Math.ceil(d / ps);\n\t\tthis._naxis2 = this._naxis1;\n\t\tthis._pxsize = ps;\n\t}\n\n\tprepareCommonHeader(fitsheaderlist: (FITSHeader | undefined)[]): void {\n\t\tif (fitsheaderlist === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fh_common) {\n\t\t\tthis._fh_common = new FITSHeader();\n\t\t}\n\n\t\tfor (let i = 0; i < fitsheaderlist.length; i++) {\n\t\t\tlet header = fitsheaderlist[i];\n\t\t\tif (header !== undefined) {\n\n\t\t\t\tfor (let item of header.getItemList()) {\n\t\t\t\t\tif ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\"].includes(item.key)) {\n\t\t\t\t\t\tif (!this._fh_common.getItemListOf(item.key)[0]) {\n\t\t\t\t\t\t\tthis._fh_common.addItem(new FITSHeaderItem(item.key, item.value));\n\t\t\t\t\t\t} else if (this._fh_common.getItemListOf(item.key)[0].value !== item.value) { // this should not happen \n\t\t\t\t\t\t\tthrow new Error(\"Error parsing headers. \" + item.key + \" was \" + this._fh_common.getItemListOf(item.key)[0] + \" and now is \" + item.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\n\t// // TODO MOVE THIS IN AN UTILITY FILE\n\t// pixel2Physical(value, bzero, bscale) {\n\t// \tlet pval = bzero + bscale * value;\n\t// \treturn pval;\n\t// }\n\n\tsetPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n\n\t\t// let vidx = 0; // <------ ERROR!!!!! pixel are not organized by tile!!!\n\n\t\t// let pxXTile = HiPSHelper.DEFAULT_Naxis1_2 * HiPSHelper.DEFAULT_Naxis1_2;\n\t\tlet bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n\t\tlet bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n\t\tlet bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n\t\tif (bytesXelem === undefined || bscale === undefined || bzero === undefined) {\n\t\t\tthrow new Error(\"BITPIX, BSCALE or BZERO are undefined\");\n\t\t}\n\n\n\t\t// let minmaxmap = new Array();\n\t\tlet minmaxmap = new Map();\n\t\tlet nodata = new Map();\n\n\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\t// this._pxvalues.set(tileno, new Array(HiPSHelper.DEFAULT_Naxis1_2));  // <- bidimensional\n\t\t\t// for (let row = 0; row < HiPSHelper.DEFAULT_Naxis1_2; row++) {\n\n\t\t\tthis._pxvalues.set(tileno, new Array(this._HIPS_TILE_WIDTH));  // <- bidimensional\n\t\t\tfor (let row = 0; row < this._HIPS_TILE_WIDTH; row++) {\n\t\t\t\tif (this._pxvalues.has(tileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(tileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\t// p[row] = new Uint8Array(HiPSHelper.DEFAULT_Naxis1_2 * bytesXelem);\n\t\t\t\t\t\tp[row] = new Uint8Array(this._HIPS_TILE_WIDTH * bytesXelem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tminmaxmap.set(\"\" + tileno + \"\", new Array(2));\n\t\t\tnodata.set(\"\" + tileno + \"\", true);\n\t\t});\n\t\tlet ra: number;\n\t\tlet dec: number;\n\t\tlet col: number;\n\t\tlet row: number;\n\n\t\tfor (let rdidx = 0; rdidx < this._radeclist.length; rdidx++) {\n\t\t\t[ra, dec] = this._radeclist[rdidx];\n\t\t\tlet ac = fillAstro(ra, dec, NumberType.DEGREES);\n\t\t\tlet sc = astroToSpherical(ac);\n\t\t\tlet ptg = new Pointing(null, false, sc.thetaRad, sc.phiRad);\n\t\t\tlet pixtileno: number = this._hp.ang2pix(ptg);\n\n\t\t\tlet xyGridProj = HiPSHelper.setupByTile(pixtileno, this._hp);\n\t\t\t// let rarad = degToRad(ra);\n\t\t\t// let decrad = degToRad(dec);\n\t\t\t// TODO CHECK THIS POINT before it was with ra and dec in radians\n\t\t\tlet xy = HiPSHelper.world2intermediate(ac);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tlet ij = HiPSHelper.intermediate2pix(xy[0], xy[1], xyGridProj, this._HIPS_TILE_WIDTH);\n\t\t\tcol = ij[0];\n\t\t\trow = ij[1];\n\n\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\tlet byte = values[rdidx * bytesXelem + b];\n\t\t\t\t// this._pxvalues.get(pixtileno)[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\tp[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nodata.get(\"\" + pixtileno + \"\")) {\n\t\t\t\t\tif (byte != 0) {\n\t\t\t\t\t\tnodata.set(\"\" + pixtileno + \"\", false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet min = minmaxmap.get(\"\" + pixtileno + \"\")[0];\n\t\t\tlet max = minmaxmap.get(\"\" + pixtileno + \"\")[1];\n\n\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\tif (p !== undefined) {\n\t\t\t\t\tlet valpixb = ParseUtils.extractPixelValue(0, p[row].slice(col * bytesXelem, col * bytesXelem + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n\t\t\t\t\tlet valphysical = bzero + bscale * valpixb;\n\t\t\t\t\tif (valphysical < min || isNaN(min)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[0] = valphysical;\n\t\t\t\t\t} else if (valphysical > max || isNaN(max)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[1] = valphysical;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Object.keys(this._pxvalues.keys()).forEach((tileno) => {\n\t\tconst fhKeys = Array.from(this._pxvalues.keys());\n\n\t\tfhKeys.forEach((tileno) => {\n\t\t\tif (nodata.get(\"\" + tileno + \"\") == false) { // there are data\n\t\t\t\t// tileno = parseInt(tileno);\n\t\t\t\tlet header = new FITSHeader();\n\t\t\t\theader.set(\"NPIX\", tileno);\n\t\t\t\t// TODO CONVERT minval and maxval to physical values!\n\t\t\t\t// header.addItem(new FITSHeaderItem(\"DATAMIN\", minmaxmap[\"\" + tileno + \"\"][0]));\n\t\t\t\t// header.addItem(new FITSHeaderItem(\"DATAMAX\", minmaxmap[\"\" + tileno + \"\"][1]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"DATAMIN\", minmaxmap.get(\"\" + tileno + \"\")[0]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"DATAMAX\", minmaxmap.get(\"\" + tileno + \"\")[1]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"NPIX\", tileno));\n\n\t\t\t\tlet vec3 = this._hp.pix2vec(tileno);\n\t\t\t\tlet ptg = new Pointing(vec3);\n\t\t\t\tlet crval1 = radToDeg(ptg.phi);\n\t\t\t\tlet crval2 = 90 - radToDeg(ptg.theta);\n\n\t\t\t\theader.addItem(new FITSHeaderItem(\"CRVAL1\", crval1));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"CRVAL2\", crval2));\n\n\t\t\t\tthis._fitsheaderlist.push(header);\n\t\t\t} else { // no data\n\t\t\t\t// this._pxvalues.delete(parseInt(tileno));\n\t\t\t\tthis._pxvalues.delete(tileno);\n\t\t\t\t// delete this._pxvalues[\"\" + tileno + \"\"];\n\t\t\t}\n\n\t\t});\n\t\tthis.prepareFITSHeader(fitsHeaderParams);\n\t\treturn this._pxvalues;\n\n\t}\n\n\tgetImageRADecList(center: Point, radiusDeg: number): Array<[number, number]> {\n\n\t\tlet ptg = new Pointing(null, false, center.spherical.thetaRad, center.spherical.phiRad);\n\t\tlet radius_rad = degToRad(radiusDeg);\n\n\t\t// with fact 8 the original Java code starts returning the the ptg pixel. with my JS porting only from fact 16\n\t\tlet rangeset = this._hp.queryDiscInclusive(ptg, radius_rad, 4); // <= check it \n\n\t\tthis._tileslist = [];\n\t\tfor (let p = 0; p < rangeset.r.length; p++) {\n\n\t\t\tif (!this._tileslist.includes(rangeset.r[p]) && rangeset.r[p] != 0) {\n\t\t\t\tthis._tileslist.push(rangeset.r[p]);\n\t\t\t}\n\n\t\t}\n\n\t\tlet cpix = this._hp.ang2pix(ptg);\n\t\tif (!this._tileslist.includes(cpix)) {\n\t\t\tthis._tileslist.push(cpix);\n\t\t}\n\n\n\t\tlet minra = center.astro.raDeg - radiusDeg;\n\t\tlet maxra = center.astro.raDeg + radiusDeg;\n\t\tlet mindec = center.astro.decDeg - radiusDeg;\n\t\tlet maxdec = center.astro.decDeg + radiusDeg;\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t// for (let j = 0; j < HiPSHelper.DEFAULT_Naxis1_2; j++) {\n\t\t\t// \tfor (let i = 0; i < HiPSHelper.DEFAULT_Naxis1_2; i++) {\n\t\t\tfor (let j = 0; j < this._HIPS_TILE_WIDTH; j++) {\n\t\t\t\tfor (let i = 0; i < this._HIPS_TILE_WIDTH; i++) {\n\t\t\t\t\tlet p = this.pix2world(i, j);\n\t\t\t\t\tif (p.astro.raDeg < minra || p.astro.raDeg > maxra ||\n\t\t\t\t\t\tp.astro.decDeg < mindec || p.astro.decDeg > maxdec) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis._radeclist.push([p.astro.raDeg, p.astro.decDeg]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this._radeclist;\n\n\n\t}\n\n\n\tpix2world(i: number, j: number): Point {\n\n\t\tlet xy = HiPSHelper.pix2intermediate(i, j, this._xyGridProj, this._naxis1, this._naxis2);\n\t\t// TODO CHECK BELOW before it was only which is supposed to be wrong since intermediate2world returns SphericalCoords, not AstroCoords\n\t\t/**  \n\t\tlet raDecDeg = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\tif (raDecDeg[0] > 360){\n\t\t\traDecDeg[0] -= 360;\n\t\t}\n\t\treturn raDecDeg;\n\t\t*/\n\t\tlet p = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\t// if (p.spherical.phiDeg > 360){\n\t\t// \tsc.phiDeg -= 360;\n\t\t// }\n\t\treturn p;\n\t}\n\n\n\t// conversion taken from https://astrophysicsandpython.com/2022/03/15/html-js-equatorial-to-galactic-coordinates/\n\tconvertToGalactic(radeclist: number[][]): number[][] {\n\t\tlet finalradeclist: number[][] = [];\n\t\tconst deg2rad = Math.PI / 180\n\t\tconst rad2deg = 180 / Math.PI\n\t\tconst l_NCP = deg2rad * 122.930\n\t\tconst d_NGP = deg2rad * 27.1284\n\t\tconst a_NGP = deg2rad * 192.8595\n\t\tradeclist.forEach(([ra, dec]) => {\n\t\t\tconst ra_rad = deg2rad * ra\n\t\t\tconst dec_rad = deg2rad * dec\n\t\t\t// sin(b)\n\t\t\tconst sin_b = Math.sin(d_NGP) * Math.sin(dec_rad) + \n\t\t\t\t\t\t\tMath.cos(d_NGP) * Math.cos(dec_rad) * Math.cos(ra_rad - a_NGP);\n\t\t\tconst b = Math.asin(sin_b)\n\t\t\tconst b_deg = b * rad2deg\n\n\t\t\t// l_NCP - l\n\t\t\tconst lNCP_minus_l = Math.atan ( ( Math.cos(dec_rad) * Math.sin(ra_rad - a_NGP)) /\n\t\t\t\t\t\t\t(Math.sin(dec_rad) * Math.cos(d_NGP) - Math.cos(dec_rad) * Math.sin(d_NGP) * Math.cos(ra_rad - a_NGP)) );\n\t\t\tconst l = l_NCP - lNCP_minus_l\n\t\t\tconst l_deg = l * rad2deg\n\t\t\t\n\t\t\tfinalradeclist.push([l_deg, b_deg])\n\t\t});\n\t\treturn finalradeclist;\n\t}\n\n\tworld2pix(radeclist: number[][]): ImagePixel[] {\n\n\t\t// let imgpxlist = new ImagePixel[radeclist.length];\n\t\tlet imgpxlist: ImagePixel[] = [];\n\t\tlet tileno: number;\n\t\tlet prevTileno: number | undefined = undefined;\n\t\t// let k = 0;\n\n\t\t/*\n\t\t\tif HiPS in galactic => convert the full list of (RA, Dec) to Galactic  (l, b)\n\t\t*/\n\n\t\tif (this._isGalactic){\n\t\t\tlet finalradeclist = this.convertToGalactic(radeclist);\n\t\t\tradeclist = finalradeclist;\n\t\t}\n\n\t\tradeclist.forEach(([ra, dec]) => {\n\n\t\t\tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n\t\t\t// let phiTheta_rad = HiPSHelper.astroDegToSphericalRad(ra, dec);\n\t\t\tlet ptg = new Pointing(null, false, p.spherical.thetaRad, p.spherical.phiRad);\n\n\t\t\ttileno = this._hp.ang2pix(ptg);\n\t\t\tif (prevTileno !== tileno || prevTileno === undefined) {\n\t\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t\tprevTileno = tileno;\n\t\t\t}\n\t\t\t// let rarad =  HiPSHelper.degToRad(ra);\n\t\t\t// let decrad = HiPSHelper.degToRad(dec);\n\t\t\tlet xy = HiPSHelper.world2intermediate(p.astro);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tlet ij = HiPSHelper.intermediate2pix(xy[0], xy[1], this._xyGridProj, this._HIPS_TILE_WIDTH);\n\n\t\t\timgpxlist.push(new ImagePixel(ij[0], ij[1], tileno));\n\t\t});\n\n\t\treturn imgpxlist;\n\t}\n\n\n\t// getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n\t// \tlet canvaslist = [];\n\t// \tlet i = 0;\n\t// \tObject.keys(this._pxvalues).forEach((tileno) => {\n\t// \t\tlet values = this._pxvalues[\"\" + tileno + \"\"];\n\n\t// \t\t// TODO change this._fitsheaderlist as per this._pxvalues in order to access to the header by \"tileno\"\n\t// \t\tlet header = this._fitsheaderlist[i];\n\n\t// \t\tlet canvas2d = new Canvas2D(values, header, this, tfunction, colormap, inverse);\n\t// \t\tcanvaslist.push(canvas2d);\n\t// \t\ti++;\n\t// \t});\n\n\t// \treturn canvaslist;\n\t// }\n}\n","import { FITSHeader } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\n// import { AstroCoords } from \"src/model/AstroCoords\";\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport {Point} from \"../model/Point.js\";\n\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nexport abstract class AbstractProjection {\n\n    // constructor() { }\n\n    public abstract initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed | undefined>;\n\n    public abstract prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[];\n\n    public abstract getFITSHeader(): FITSHeader[];\n\n    public abstract getCommonFitsHeaderParams(): FITSHeader;\n\n    public abstract extractPhysicalValues(fits: FITSParsed): number[][];\n\n    public abstract getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array | undefined>;\n\n    public abstract computeSquaredNaxes(d: number, ps: number): void;\n\n    // protected abstract prepareCommonHeader(fitsheaderlist: FITSHeader[]): void;\n\n    public abstract setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>>;\n\n    public abstract getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]>;\n\n    public abstract pix2world(i: number, j: number): Point;\n\n    public abstract get fitsUsed(): String[];\n    \n    // public abstract world2pix(radeclist: number[][]): Promise<ImagePixel[]>\n    public abstract world2pix(radeclist: number[][]): ImagePixel[]\n\n}\n","\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport {Point} from \"../model/Point.js\";\nimport {AbstractProjection} from \"./AbstractProjection.js\";\n\n\nexport class HEALPixProjection extends AbstractProjection {\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeader {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    public computeSquaredNaxes(d: number, ps: number): void {\n        throw new Error('Method not implemented.');\n    }\n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n    \n\n}","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\nimport {Point} from '../model/Point.js';\n\n\nexport class GnomonicProjection extends AbstractProjection {\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n\n    _minra: number;\n    _mindec: number;\n    _naxis1: number;\n    _naxis2: number;\n    _pxsize: number;\n    _pxmatrix;\n    _fitsheader: FITSHeader[];\n    _inflie: string;\n    _ctype1: string; // TODO should be RA ENUM\n    _ctype2: string; // TODO should be Dec ENUM\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n\n    constructor(infile?: string) {\n        super();\n        this._ctype1 = \"RA---TAN\";\n        this._ctype2 = \"DEC--TAN\";\n\n        if (infile) {\n            this._inflie = infile;\n        }\n    }\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n\n        let fp = new FITSParser(infile);\n\n        let promise = fp.loadFITS().then(fits => {\n\n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            this._naxis1 = fits.header.get(\"NAXIS1\");\n            this._naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value;\n            this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value;\n\n            this._minra = this._craDeg - this._pxsize1 * this._naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n\n            return fits;\n\n        });\n        await promise;\n        return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\n        this._fitsheader[0] = new FITSHeader();\n\n\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS1\", this._naxis1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS2\", this._naxis2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE1\", this._ctype1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE2\", this._ctype2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT1\", this._pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT2\", this._pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX1\", this._naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX2\", this._naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n\n    getFITSHeader(): FITSHeader[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeader {\n        let header = new FITSHeader();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                // header.set(key, value);\n                header.addItem(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= this._naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= this._naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = (this._pxvalues.get(0))[imgpx._j][(imgpx._i) * bytesXelem + b];\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n    computeSquaredNaxes(d: number, ps: number): void {\n        // first aprroximation to be checked\n        this._naxis1 = Math.ceil(d / ps);\n        this._naxis2 = this._naxis1;\n        this._pxsize = ps;\n    }\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n        // let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        // let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        // let maxpixb = minpixb;\n\n        // let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        // let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        // this._minphysicalval = bzero + bscale * minpixb;\n        // this._maxphysicalval = bzero + bscale * maxpixb;\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n\n        // TODO ...\n        return null;\n    }\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]>{\n\n        // let promise = new Promise((resolve, reject) => {\n        //     this.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n\n        //     this._pxsize = pxsize;\n        //     this._minra = center.ra - radius;\n        //     if (this._minra < 0) {\n        //         this._minra += 360;\n        //     }\n        //     this._mindec = center.dec - radius;\n\n        //     let radeclist = [];\n        //     let pra, pdec;\n\n        // TODO ...\n        /*\n        basing on naxis1 and naxis2 call pix2world!!!\n        */\n\n\n\n        /*\n        \n\n        mindec = center.dec - radius;\n        maxdec = center.dec + radius;\n        below pixel size should  depend on the distance from the center\n        let l =  0;\n        let factor = 1;\n        \n        for (let d = mindec; d < maxdec; d+=pxsize) { <--ERROR the external loop must be over RA\n            factor = 1 + 2**l;\n            rapxsize = pxsize/factor;\n            for (let r = 0; r < 360; r+=rapxsize) {\n                radeclist.push(r, d); \n            }\n            l++;\n        }\n        */\n\n\n\n\n\n        // let cidx = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        // this._cra = radeclist[cidx][0];\n        // this._cdec = radeclist[cidx][1];\n\n        // resolve(radeclist);\n        // });\n        // return promise;\n        return null;\n\n    }\n\n    pix2world(i: number, j: number): Point {\n\n        // TODO ...\n        let x, y;\n        let CDELT1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0];\n        let CDELT2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0];\n        let PC1_1 = this._fitsheader[0].getItemListOf(\"PC1_1\")[0];\n        let PC1_2 = this._fitsheader[0].getItemListOf(\"PC1_2\")[0];\n        let PC2_1 = this._fitsheader[0].getItemListOf(\"PC2_1\")[0];\n        let PC2_2 = this._fitsheader[0].getItemListOf(\"PC2_2\")[0];\n\n        let CD1_1 = this._fitsheader[0].getItemListOf(\"CD1_1\")[0];\n        let CD1_2 = this._fitsheader[0].getItemListOf(\"CD1_2\")[0];\n        let CD2_1 = this._fitsheader[0].getItemListOf(\"CD2_1\")[0];\n        let CD2_2 = this._fitsheader[0].getItemListOf(\"CD2_2\")[0];\n\n        let CRPIX1 = this._fitsheader[0].getItemListOf(\"CRPIX1\")[0];\n        let CRPIX2 = this._fitsheader[0].getItemListOf(\"CRPIX2\")[0];\n\n\n        if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            PC1_1 !== undefined && PC1_2 !== undefined &&\n            PC2_1 !== undefined && PC2_2 !== undefined\n        ) { // if CDELTia and PCi_ja notation\n            x = CDELT1 * (PC1_1 * (i - CRPIX1) + PC1_2 * (j - CRPIX2));\n            y = CDELT2 * (PC2_1 * (i - CRPIX1) + PC2_2 * (j - CRPIX2));\n        } else { // else CDi_ja notation\n            x = CD1_1 * (i - CRPIX1) + CD1_2 * (j - CRPIX2);\n            y = CD2_1 * (i - CRPIX1) + CD2_2 * (j - CRPIX2);\n        }\n\n\n\n\n        // let phi = math.arg(-y / x);\n        // let R_theta = Math.sqrt(x * x + y * y);\n        // let theta = Math.atan2(180 / (Math.PI * R_theta));\n\n        // let ra, dec;\n        // ra = phi;\n        // dec = theta;\n        // // TODO check if phi, theta match with ra, dec or they need to be (linearly) converted \n\n        // return [ra, dec];\n\n        return null;\n    }\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        let CDELT1 = (this._fitsheader[0].getItemListOf(\"CDELT1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT1\")[0] : undefined;\n        let CDELT2 = (this._fitsheader[0].getItemListOf(\"CDELT2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT2\")[0] : undefined;\n        let PC1_1 = (this._fitsheader[0].getItemListOf(\"PC1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_1\")[0] : undefined;\n        let PC1_2 = (this._fitsheader[0].getItemListOf(\"PC1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_2\")[0] : undefined;\n        let PC2_1 = (this._fitsheader[0].getItemListOf(\"PC2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_1\")[0] : undefined;\n        let PC2_2 = (this._fitsheader[0].getItemListOf(\"PC2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_2\")[0] : undefined;\n\n        let CD1_1 = (this._fitsheader[0].getItemListOf(\"CD1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_1\")[0] : undefined;\n        let CD1_2 = (this._fitsheader[0].getItemListOf(\"CD1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_2\")[0] : undefined;\n        let CD2_1 = (this._fitsheader[0].getItemListOf(\"CD2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_1\")[0] : undefined;\n        let CD2_2 = (this._fitsheader[0].getItemListOf(\"CD2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_2\")[0] : undefined;\n\n        let CRPIX1 = (this._fitsheader[0].getItemListOf(\"CRPIX1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX1\")[0] : undefined;\n        let CRPIX2 = (this._fitsheader[0].getItemListOf(\"CRPIX2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX2\")[0] : undefined;\n\n        radeclist.forEach(([ra, dec]) => {\n\n            // TODO ...\n            // let i, j;\n            // // (linearly) convert ra, dec into phi, theta\n            // let theta = dec;\n            // let phi = ra;\n            // let R_theta = (180 / Math.PI) * math.cot(theta);\n            // let x = R_theta * Math.sin(phi);\n            // let y = - R_theta * Math.cos(phi);\n            // if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            //     PC1_1 !== undefined && PC1_2 !== undefined &&\n            //     PC2_1 !== undefined && PC2_2 !== undefined\n            // ) { // if CDELTia and PCi_ja notation\n            //     j = y * CDELT1 * PC1_1 / (CDELT1 * CDELT2 * (PC1_1 * PC2_2 - PC2_1 * PC1_2)) + PC1_1 * CRPIX2 * (PC2_2 - PC2_1) / (PC1_1 * PC2_2 - PC2_1 * PC1_2);\n            //     i = x / (CDELT1 * PC1_1) + CRPIX1 - j * PC1_2 / PC1_1 + CRPIX2 * PC1_2 / PC1_1;\n            // } else { // else CDi_ja notation\n            //     j = y * CD1_1 / (CD1_1 * CD2_2 - CD1_2 * CD2_1) + CRPIX2 * CD1_1 * (CD2_2 - CD2_1) / (CD1_1 * CD2_2 - CD1_2 * CD2_1);\n            //     i = (x + CD1_1 * CRPIX1 - CD1_2 * j + CD1_2 * CRPIX2) / CD1_1;\n            // }\n            // imgpxlist.push(new ImagePixel(i, j));\n\n        });\n        return imgpxlist;\n\n    }\n\n    // getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n    //     let canvas2d = new Canvas2D(this._pxvalues, this._fitsheader, this, tfunction, colormap, inverse);\n    //     return canvas2d;\n    // }\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nimport { FITSParser } from 'jsfitsio';\nimport { MercatorProjection } from './projections/MercatorProjection.js';\nimport { HiPSProjection } from './projections/HiPSProjection.js';\nimport { Point } from './model/Point.js';\nimport { AbstractProjection } from './projections/AbstractProjection.js';\nimport { CutoutResult } from './model/CutoutResult.js';\n\nimport { HEALPixProjection } from './projections/HEALPixProjection.js';\nimport { GnomonicProjection } from './projections/GnomonicProjection.js';\n\nexport class WCSLight {\n\n    /** @constructs WCSLight */\n    constructor() { }\n\n    static async cutout(center: Point, radius: number,\n        pxsize: number, inproj: AbstractProjection, outproj: AbstractProjection): Promise<CutoutResult> {\n\n        const outRADecList: Array<Array<number>> = outproj.getImageRADecList(center, radius, pxsize);\n        if (outRADecList.length == 0) {\n            const res: CutoutResult = {\n                fitsheader: null,\n                fitsdata: null,\n                inproj: inproj,\n                outproj: outproj,\n                fitsused: inproj.fitsUsed\n            };\n            return res;\n        }\n        const inputPixelsList = inproj.world2pix(outRADecList);\n        try {\n\n            const invalues = await inproj.getPixValues(inputPixelsList);\n            const fitsHeaderParams = inproj.getCommonFitsHeaderParams();\n            if (invalues !== undefined) {\n                const fitsdata = outproj.setPxsValue(invalues, fitsHeaderParams);\n                const fitsheader = outproj.getFITSHeader();\n                // let canvas2d = outproj.getCanvas2d();\n                const res: CutoutResult = {\n                    fitsheader: fitsheader,\n                    fitsdata: fitsdata,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            } else {\n                const res: CutoutResult = {\n                    fitsheader: null,\n                    fitsdata: null,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            }\n\n        } catch (err) {\n            console.error(\"[WCSLight] ERROR: \" + err);\n            return null;\n        }\n\n    }\n\n    /**\n     * \n     * @param {*} fitsheader \n     * @param {*} fitsdata \n     * @returns {URL}\n     */\n    static generateFITS(fitsheader: any, fitsdata: any): string {\n        const blobUrl = FITSParser.generateFITS(fitsheader, fitsdata);\n        return blobUrl;\n    }\n\n\n\n\n    static changeProjection(filepath, outprojname) {\n        // TODO\n    }\n\n\n    static getProjection(projectionName: string) {\n        if (projectionName === \"Mercator\") {\n            return new MercatorProjection();\n        } else if (projectionName === \"HiPS\") {\n            return new HiPSProjection();\n        } else if (projectionName === \"HEALPix\") {\n            return new HEALPixProjection();\n        } else if (projectionName === \"Gnomonic\") {\n            return new GnomonicProjection();\n        } else {\n            return null;\n            // throw new ProjectionNotFound(projectionName);\n        }\n    }\n\n    static getAvaillableProjections() {\n        return [\"Mercator\", \"HiPS\", \"HEALPix\"];\n    }\n\n}\n\n","\n\n\n// import { FITSParser } from 'fitsparser/FITSParser-node';\n// import { FITSHeader } from 'fitsparser/model/FITSHeader';\n// import { FITSHeaderItem } from 'fitsparser/model/FITSHeaderItem';\n// import { FITSParsed } from 'fitsparser/model/FITSParsed';\n\n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { AbstractProjection } from './AbstractProjection.js';\nimport {Point} from '../model/Point.js';\n\nexport class TestProj implements AbstractProjection{\n    \n    _minra: number;\n    _mindec: number;\n    _naxis1: number;\n    _naxis2: number;\n    _pxsize: number;\n    _fitsheader: FITSHeader[];\n    _infile: string;\n    _ctype1: string; // TODO should be RA ENUM\n    _ctype2: string; // TODO should be Dec ENUM\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n    constructor() {\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this._ctype1 = \"RA---MER\";\n        this._ctype2 = \"DEC--MER\";\n        this._pxvalues = new Map<number, Array<Uint8Array>>();\n        const fh = new FITSHeader();\n        const fp = new FITSParser(\"./notexistent/\");\n        const fhi = new FITSHeaderItem(\"mykey\", \"myvalue\", \"mycomment\");\n\n\n    }\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    \n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeader {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    public computeSquaredNaxes(d: number, ps: number): void {\n        throw new Error('Method not implemented.');\n    }\n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number):  Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n}"],"names":["root","factory","exports","module","define","amd","self","inProgress","dataWebpackPrefix","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call","m","d","definition","key","o","Object","defineProperty","enumerable","get","f","e","chunkId","Promise","all","keys","reduce","promises","u","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","l","url","done","push","script","needAttach","scripts","document","getElementsByTagName","i","length","s","getAttribute","createElement","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","event","onerror","onload","clearTimeout","doneFns","parentNode","removeChild","forEach","fn","setTimeout","bind","type","target","head","appendChild","r","Symbol","toStringTag","value","scriptUrl","importScripts","location","currentScript","test","Error","replace","p","installedChunks","j","installedChunkData","promise","resolve","reject","error","errorType","realSrc","message","name","request","webpackJsonpCallback","parentChunkLoadingFunction","data","chunkIds","moreModules","runtime","some","id","chunkLoadingGlobal","FITSHeaderItem","constructor","comment","_key","_value","_comment","FITSHeader","Map","super","_offset","_items","offset","getItemList","getItemListOf","res","item","addItemAtTheBeginning","includes","set","newitemlist","concat","addItem","getNumRows","ParseUtils","getStringAt","chars","String","fromCharCode","charCodeAt","join","byteString","n","toString","substr","parse32bitSinglePrecisionFloatingPoint","byte1","byte2","byte3","byte4","long","Math","pow","convertBlankToBytes","blank","nbytes","str","abs","buffer","ArrayBuffer","uint8","Uint8Array","parseInt","parseFloatingPointFormat","bytes","ebits","fbits","bits","byte","reverse","bias","substring","Infinity","generate16bit2sComplement","val","TypeError","parse16bit2sComplement","unsigned","parse32bit2sComplement","getByteAt","extractPixelValue","bitpix","px_val","slice","FITSWriter","_headerArray","_payloadArray","Array","_fitsData","run","header","rawdata","prepareHeader","prepareFITS","headerDetails","formatHeaderLine","strBytelen","TextEncoder","encode","ceil","ab","keyword","len","typedArrayToURL","b","Blob","URL","createObjectURL","ParsePayload","fitsheader","_u8data","_BZERO","_BSCALE","_BLANK","_BITPIX","_NAXIS1","_NAXIS2","_DATAMIN","_DATAMAX","_physicalblank","init","min","max","computePhysicalMinAndMax","maxitem","minitem","bytesXelem","pxLength","byteLength","ph_val","pixel2physicalValue","parse","c","k","pixelvalues","floor","pxval","ParseHeader","textDecoder","TextDecoder","u8line","u8key","u8val","u8ind","fitsLine","nline","decode","trim","firstchar","Number","parseLogicalValue","parseFloatValue","parseIntValue","now","Date","parseStringValue","u8buffer","decoded","idx","lastIndexOf","tokens","split","parseFloat","NumberType","CoordsType","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","result","then","apply","FITSParser","_url","loadFITS","getFile","processFits","catch","_a","_b","response","generateFITS","writer","uri","toLowerCase","err","getLocalFile","ImagePixel","tileno","_i","_j","_tileno","geti","getj","cartesianToSpherical","xyz","dotXYZ","a","x","y","z","sqrt","thetaRad","acos","thetaDeg","radToDeg","phiRad","atan2","phiDeg","sphericalToAstro","phiTheta","raDeg","decDeg","degToRad","astroToSpherical","raDec","sphericalToCartesian","sin","cos","fillAstro","ra","dec","unit","DEGREES","RADIANS","console","fillSpherical","phi","theta","degrees","PI","radians","Point","in_type","coords","CARTESIAN","toFixed","MAX_DECIMALS","ASTRO","SPHERICAL","spherical","astro","cartesian","MercatorProjection","_wcsname","_ctype1","_ctype2","_pxvalues","_fitsheader","initFromFile","infile","fp","_infile","_fitsUsed","fits","_naxis1","_naxis2","_craDeg","_cdecDeg","pxsize1","pxsize2","_pxsize","_minra","_mindec","extractPhysicalValues","bzero","bscale","naxis1","naxis2","physicalvalues","n2","n1","physicalVal","prepareFITSHeader","fitsHeaderParams","_minphysicalval","_maxphysicalval","getFITSHeader","getCommonFitsHeaderParams","fitsUsed","getPixValues","inputPixelsList","blankBytes","pixcount","values","imgpx","pv","computeSquaredNaxes","ps","setPxsValue","minpixb","maxpixb","valphysical","isNaN","log","getImageRADecList","center","radius","pxsize","radeclist","cidx","pix2world","world2pix","imgpxlist","radecItem","Constants","halfpi","inv_halfpi","twopi","inv_twopi","Zphi","z_","phi_","Hploc","ptg","PI4_A","PI4_B","PI4_C","M_1_PI","sth","have_sth","_phi","setZ","setSth","toVec3","st","Vec3","toZphi","q","sincoshelper","asin","mulsign","atan2k","copySign","magnitude","sign","atanhelper","t","isinf","isnan","NaN","Pointing","vec3","mirror","in_theta","in_phi","in_x","in_y","in_z","getX","getY","getZ","scale","cross","v","add","normalize","norm","lengthSquared","dot","v1","sub","angle","flip","pointing2Vec3","pointing","CircleFinder","point","np","cosrad","getCircle","getCircle2","q1","q2","getCenter","getCosrad","Fxyf","fx","fy","face","jrll","jpll","toHploc","nr","loc","jr","tmp","pstack","sz","Int32Array","p_","o_","pop","popToMark","size","mark","otop","ptop","RangeSet","cap","append","append1","newsize","rnew","ensureCapacity","resize","sliced","Xyf","ix","iy","Healpix","nside_in","order_max","twothird","ns_max","ctab","Uint16Array","utab","Int16Array","xoffset","yoffset","facearray","swaparray","nside","npface","npix","order","nside2order","nl2","nl3","nl4","fact2","fact1","ncap","bn","mpr","cmpr","smpr","computeBn","maxPixrad","getNPix","getBoundaries","pix","points","xyf","nest2xyf","dc","xc","yc","getBoundariesWithStep","getPointsForXyfNoStep","getPointsForXyf","neighbours","ipix","face_num","nsm1","fpix","px0","spread_bits","py0","pxp","pyp","pxm","pym","nbnum","tint","xyf2nest","log2","compress_bits","loc2pix","hploc","pixNo","za","tt","fmodulo","temp1","temp2","jp","jm","ifp","ifm","ntt","tp","pix2vec","pix2loc","pix2zphi","ang2pix","v2","raw","queryPolygonInclusive","vertex","fact","inclusive","nv","vv","normal","index","back","first","medium","last","hnd","splice","rad","fill","cf","queryMultiDisc","oplus","ilog2","omax","crlimit","dr","Float64Array","stk","zone","crad","iz","check_pixel","arg","clz32","cosdist_zphi","z1","phi1","z2","phi2","pixset","sdist","zphia","xyz1","convertZphi2xyz","va","t1","zphib","xyz2","vb","zphi","queryDiscInclusive","vptg","crpdr","crmdr","sinrad","cdr","sdr","curro","pos","cangdist","HiPSHelper","computeHiPSOrder","pxXtile","RES_ORDER_0","round","computePxSize","computeBbox","bbox","setupByTile","hp","xyGridProj","cornersVec3","pointings","coThetaRad","decRad","raRad","xyDeg","world2intermediate","gridPointsDeg","max_y","min_y","max_x","min_x","ac","x_grid","y_grid","THETAX","K","H","w","sigma","phi_c","intermediate2pix","i_norm","j_norm","xInterval","yInterval","pix2intermediate","cnaxis1","cnaxis2","yMean","intermediate2world","Yx","x_c","DEFAULT_Naxis1_2","HiPSProjection","_isGalactic","_fitsheaderlist","_radeclist","parsePropertiesFile","baseUrl","propFile","txtArr","_HIPS_TILE_WIDTH","line","_HIPS_MAX_ORDER","fitsfilepath","_pixno","_xyGridProj","_hp","initFromHiPSLocationAndPxSize","_hipsBaseURI","initFromHiPSLocationAndOrder","_norder","_nside","_fh_common","getFITSFiles","destPath","fitsFilesGenerated","tilesset","Set","hipstileno","dir","fitsurl","pixno","fitsheaderlist","prepareCommonHeader","col","row","minmaxmap","nodata","_tileslist","has","rdidx","sc","pixtileno","xy","ij","from","crval1","crval2","delete","radiusDeg","radius_rad","rangeset","cpix","minra","maxra","mindec","maxdec","convertToGalactic","finalradeclist","deg2rad","rad2deg","l_NCP","d_NGP","a_NGP","ra_rad","dec_rad","sin_b","b_deg","lNCP_minus_l","atan","l_deg","prevTileno","AbstractProjection","HEALPixProjection","hipsURI","GnomonicProjection","_inflie","_pxsize1","_pxsize2","CDELT1","CDELT2","PC1_1","PC1_2","PC2_1","PC2_2","CD1_1","CD1_2","CD2_1","CD2_2","CRPIX1","CRPIX2","WCSLight","cutout","inproj","outproj","outRADecList","fitsdata","fitsused","invalues","changeProjection","filepath","outprojname","getProjection","projectionName","getAvaillableProjections","TestProj"],"sourceRoot":""}