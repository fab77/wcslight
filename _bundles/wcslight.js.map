{"version":3,"file":"wcslight.js","mappings":"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IAAK,IAAK,IAAK,IAAK,IAAK,EAAG,EAAG,IAAK,IAAK,EAAG,EAAG,IAC9F,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACvF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,EAAG,EAAG,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IACxF,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC3F,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACvF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACpF,KAAM,KAAM,KAAM,KAAM,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","sources":["webpack://wcslight/webpack/universalModuleDefinition","webpack://wcslight/webpack/runtime/load script","webpack://wcslight/webpack/bootstrap","webpack://wcslight/webpack/runtime/define property getters","webpack://wcslight/webpack/runtime/ensure chunk","webpack://wcslight/webpack/runtime/get javascript chunk filename","webpack://wcslight/webpack/runtime/global","webpack://wcslight/webpack/runtime/hasOwnProperty shorthand","webpack://wcslight/webpack/runtime/make namespace object","webpack://wcslight/webpack/runtime/publicPath","webpack://wcslight/webpack/runtime/jsonp chunk loading","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseUtils.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSWriter.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParsePayload.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSParser.js","webpack://wcslight/./src/model/NumberType.ts","webpack://wcslight/./src/model/CoordsType.ts","webpack://wcslight/./src/model/FITS.ts","webpack://wcslight/./src/projections/AbstractProjection.ts","webpack://wcslight/./src/model/ImagePixel.ts","webpack://wcslight/./src/model/Utils.ts","webpack://wcslight/./src/model/Point.ts","webpack://wcslight/./src/projections/MercatorProjection.ts","webpack://wcslight/./node_modules/healpixjs/lib-esm/Constants.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Zphi.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Hploc.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Pointing.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Vec3.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/CircleFinder.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Fxyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/pstack.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/RangeSet.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Xyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Healpix.js","webpack://wcslight/./src/projections/HiPSHelper.ts","webpack://wcslight/./src/projections/HiPSProjection.ts","webpack://wcslight/./src/projections/HEALPixProjection.ts","webpack://wcslight/./src/projections/GnomonicProjection.ts","webpack://wcslight/./src/WCSLight.ts","webpack://wcslight/./src/projections/TestProj.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"wcslight\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wcslight\"] = factory();\n\telse\n\t\troot[\"wcslight\"] = factory();\n})(self, () => {\nreturn ","var inProgress = {};\nvar dataWebpackPrefix = \"wcslight:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t992: 0,\n\t434: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkwcslight\"] = self[\"webpackChunkwcslight\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class FITSHeaderItem {\n    constructor(key, value, comment) {\n        this._key = key !== undefined ? key : undefined;\n        this._value = value !== undefined ? value : undefined;\n        this._comment = comment !== undefined ? comment : undefined;\n    }\n    get key() {\n        return this._key;\n    }\n    get comment() {\n        return this._comment;\n    }\n    get value() {\n        return this._value;\n    }\n}\n//# sourceMappingURL=FITSHeaderItem.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n// reference FTIS standard doc https://heasarc.gsfc.nasa.gov/docs/fcg/standard_dict.html\nexport class FITSHeader extends Map {\n    constructor() {\n        super();\n        this._offset = undefined;\n        this._items = [];\n    }\n    set offset(offset) {\n        this._offset = offset;\n    }\n    get offset() {\n        return this._offset;\n    }\n    getItemList() {\n        return this._items;\n    }\n    getItemListOf(key) {\n        const res = [];\n        for (let i = 0; i < this._items.length; i++) {\n            const item = this._items[i];\n            if (item.key == key) {\n                res.push(item);\n            }\n        }\n        return res;\n    }\n    addItemAtTheBeginning(item) {\n        if (item.key !== undefined) {\n            if ([\n                \"SIMPLE\",\n                \"BITPIX\",\n                \"NAXIS\",\n                \"NAXIS1\",\n                \"NAXIS2\",\n                \"BLANK\",\n                \"BZERO\",\n                \"BSCALE\",\n                \"DATAMIN\",\n                \"DATAMAX\",\n                \"NPIX\",\n                \"ORDER\",\n                \"CRPIX1\",\n                \"CRPIX2\",\n                \"CDELT1\",\n                \"CDELT2\",\n                \"CRVAL1\",\n                \"CRVAL2\",\n            ].includes(item.key)) {\n                this.set(item.key, item.value);\n            }\n        }\n        const newitemlist = [item].concat(this._items);\n        this._items = newitemlist;\n    }\n    addItem(item) {\n        if (item.key !== undefined) {\n            if ([\n                \"SIMPLE\",\n                \"BITPIX\",\n                \"NAXIS\",\n                \"NAXIS1\",\n                \"NAXIS2\",\n                \"BLANK\",\n                \"BZERO\",\n                \"BSCALE\",\n                \"DATAMIN\",\n                \"DATAMAX\",\n                \"NPIX\",\n                \"ORDER\",\n                \"CRPIX1\",\n                \"CRPIX2\",\n                \"CDELT1\",\n                \"CDELT2\",\n                \"CRVAL1\",\n                \"CRVAL2\",\n            ].includes(item.key)) {\n                this.set(item.key, item.value);\n            }\n        }\n        this._items.push(item);\n    }\n    getNumRows() {\n        return this._items.length;\n    }\n}\n//# sourceMappingURL=FITSHeader.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseUtils {\n    static getStringAt(data, offset, length) {\n        const chars = [];\n        for (let i = offset, j = 0; i < offset + length; i++, j++) {\n            chars[j] = String.fromCharCode(data.charCodeAt(i) & 0xff);\n        }\n        return chars.join(\"\");\n    }\n    static byteString(n) {\n        if (n < 0 || n > 255 || n % 1 !== 0) {\n            throw new Error(n + \" does not fit in a byte\");\n        }\n        return (\"000000000\" + n.toString(2)).substr(-8);\n    }\n    static parse32bitSinglePrecisionFloatingPoint(byte1, byte2, byte3, byte4) {\n        let long = (((((byte1 << 8) + byte2) << 8) + byte3) << 8) + byte4;\n        if (long < 0)\n            long += 4294967296;\n        const float = (1.0 + (long & 0x007fffff) / 0x0800000) *\n            Math.pow(2, ((long & 0x7f800000) >> 23) - 127);\n        return float;\n    }\n    static convertBlankToBytes(blank, nbytes) {\n        let str = Math.abs(blank).toString(2);\n        while (str.length / 8 < nbytes) {\n            str += \"0\";\n        }\n        const buffer = new ArrayBuffer(nbytes);\n        const uint8 = new Uint8Array(buffer);\n        for (let i = 0; i < nbytes; i++) {\n            uint8[i] = parseInt(str.substr(8 * i, 8 * (i + 1)), 2);\n        }\n        return uint8;\n    }\n    /** https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac */\n    static parseFloatingPointFormat(bytes, ebits, fbits) {\n        // Bytes to bits\n        const bits = [];\n        for (let i = bytes.length; i; i -= 1) {\n            let byte = bytes[i - 1];\n            for (let j = 8; j; j -= 1) {\n                bits.push(byte % 2 ? 1 : 0);\n                byte = byte >> 1;\n            }\n        }\n        bits.reverse();\n        const str = bits.join(\"\");\n        // Unpack sign, exponent, fraction\n        const bias = (1 << (ebits - 1)) - 1;\n        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n        const e = parseInt(str.substring(1, 1 + ebits), 2);\n        const f = parseInt(str.substring(1 + ebits), 2);\n        // Produce number\n        if (e === (1 << ebits) - 1) {\n            return f !== 0 ? undefined : s * Infinity;\n        }\n        else if (e > 0) {\n            return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));\n        }\n        else if (f !== 0) {\n            return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));\n        }\n        else {\n            return s * 0;\n        }\n    }\n    static generate16bit2sComplement(val) {\n        throw new TypeError(\"not implemented yet\" + val);\n    }\n    static parse16bit2sComplement(byte1, byte2) {\n        const unsigned = (byte1 << 8) | byte2;\n        if (unsigned & 0x8000) {\n            return unsigned | 0xffff0000;\n        }\n        else {\n            return unsigned;\n        }\n    }\n    static parse32bit2sComplement(byte1, byte2, byte3, byte4) {\n        const unsigned = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;\n        const s = (unsigned & 0x80000000) >> 31;\n        let res = unsigned & 0xffffffff;\n        if (s) {\n            res = (~unsigned & 0xffffffff) + 1;\n            return -1 * res;\n        }\n        return res;\n    }\n    /**\n     *\n     * @param {*} data string?\n     * @param {*} offset offset in the data\n     * @returns returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index.\n     */\n    static getByteAt(data, offset) {\n        const dataOffset = 0;\n        return data.charCodeAt(offset + dataOffset) & 0xff;\n    }\n    static extractPixelValue(offset, bytes, bitpix) {\n        let px_val = undefined; // pixel value\n        // let px_val1, px_val2, px_val3, px_val4;\n        if (bitpix == 8) {\n            px_val = bytes[0];\n        }\n        else if (bitpix == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(bytes[offset], bytes[offset + 1]);\n        }\n        else if (bitpix == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]);\n        }\n        else if (bitpix == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 8, 23);\n        }\n        else if (bitpix == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (bitpix == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n// export default ParseUtils;\n//# sourceMappingURL=ParseUtils.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/fitsontheweb\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n * import GnomonicProjection from './GnomonicProjection';\n * BITPIX definition from https://archive.stsci.edu/fits/fits_standard/node39.html\n * and \"Definition of the Flexible Image Transport System (FITS)\" standard document\n * defined by FITS Working Group from the International Astronomical Union\n * http://fits.gsfc.nasa.gov/iaufwg/\n * 8\t8-bit Character or unsigned binary integer\n * 16\t16-bit twos-complement binary integer\n * 32\t32-bit twos-complement binary integer\n * -32\t32-bit IEEE single precision floating point\n * -64\t64-bit IEEE double precision floating point\n *\n */\n// import { Blob } from 'blob-polyfill';\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\n// import fs from 'node:fs/promises';\nexport class FITSWriter {\n    constructor() {\n        this._headerArray = new Uint8Array();\n        this._payloadArray = new Array();\n        this._fitsData = new Uint8Array();\n    }\n    run(header, rawdata) {\n        this.prepareHeader(header);\n        this._payloadArray = rawdata;\n        this.prepareFITS();\n    }\n    prepareHeader(headerDetails) {\n        const item = new FITSHeaderItem(\"END\");\n        headerDetails.addItem(item);\n        let str = \"\";\n        for (let i = 0; i < headerDetails.getItemList().length; i++) {\n            const item = headerDetails.getItemList()[i];\n            let s = this.formatHeaderLine(item);\n            if (s !== undefined) {\n                str += s;\n            }\n        }\n        const strBytelen = new TextEncoder().encode(str).length;\n        const nhdu = Math.ceil(strBytelen / 2880);\n        const offset = nhdu * 2880;\n        for (let j = 0; j < offset - strBytelen; j++) {\n            str += \" \";\n        }\n        const ab = new ArrayBuffer(str.length);\n        // Javascript character occupies 2 16-bit -> reducing it to 1 byte\n        this._headerArray = new Uint8Array(ab);\n        for (let i = 0; i < str.length; i++) {\n            this._headerArray[i] = ParseUtils.getByteAt(str, i);\n        }\n    }\n    // formatHeaderLine(item: string | undefined, value: string | number, comment: string) {\n    formatHeaderLine(item) {\n        let str;\n        let keyword = item.key;\n        let value = item.value;\n        let comment = item.comment;\n        if (keyword !== null && keyword !== undefined) {\n            str = keyword;\n            if (keyword == \"END\") {\n                for (let j = 80; j > keyword.length; j--) {\n                    str += \" \";\n                }\n                return str;\n            }\n            if (keyword == \"COMMENT\" || keyword == \"HISTORY\") {\n                for (let i = 0; i < 10 - keyword.length; i++) {\n                    str += \" \";\n                }\n                str += value;\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n                return str;\n            }\n            for (let i = 0; i < 8 - keyword.length; i++) {\n                str += \" \";\n            }\n            str += \"= \";\n            if (value !== null && value !== undefined) {\n                // value\n                str += value;\n                if (comment !== null && comment !== undefined) {\n                    str += comment;\n                }\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n            else {\n                if (comment !== null && comment !== undefined) {\n                    str += comment;\n                }\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n        }\n        else {\n            // keyword null\n            str = \"\";\n            for (let j = 0; j < 18; j++) {\n                str += \" \";\n            }\n            if (comment !== null && comment !== undefined) {\n                str += comment;\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n            else {\n                str = \"\";\n                for (let j = 80; j > 0; j--) {\n                    str += \" \";\n                }\n            }\n        }\n        return str;\n    }\n    prepareFITS() {\n        const bytes = new Uint8Array(this._headerArray.length +\n            this._payloadArray[0].length * this._payloadArray.length);\n        bytes.set(this._headerArray, 0);\n        for (let i = 0; i < this._payloadArray.length; i++) {\n            const uint8 = this._payloadArray[i];\n            bytes.set(uint8, this._headerArray.length + i * uint8.length);\n        }\n        this._fitsData = bytes;\n    }\n    // writeFITS(fileuri: string) {\n    //   // const dirname = path.dirname(fileuri);\n    //   // fs.mkdir(dirname, { recursive: true });\n    //   fs.writeFile(fileuri, this._fitsData);\n    //   // if (fs.existsSync(dirname)) {\n    //   //   fs.writeFileSync(fileuri, this._fitsData);\n    //   // } else {\n    //   //   console.error(dirname + \" doesn't exist\");\n    //   // }\n    // }\n    typedArrayToURL() {\n        const b = new Blob([this._fitsData], { type: \"application/fits\" });\n        // console.log(`<html><body><img src='${URL.createObjectURL(b)}'</body></html>`);\n        return URL.createObjectURL(b);\n    }\n}\n//# sourceMappingURL=FITSWriter.js.map","// \"use strict\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\n// let colorsMap = new Map();\n// colorsMap.set(\"grayscale\",\"grayscale\");\n// colorsMap.set(\"planck\",\"planck\");\n// colorsMap.set(\"eosb\",\"eosb\");\n// colorsMap.set(\"rainbow\",\"rainbow\");\n// colorsMap.set(\"cmb\",\"cmb\");\n// colorsMap.set(\"cubehelix\",\"cubehelix\");\nexport class ParsePayload {\n    constructor(fitsheader, rawdata) {\n        this._u8data = new Uint8Array();\n        this._BZERO = undefined;\n        this._BSCALE = undefined;\n        this._BLANK = undefined;\n        this._BITPIX = undefined;\n        this._NAXIS1 = undefined;\n        this._NAXIS2 = undefined;\n        this._DATAMIN = undefined;\n        this._DATAMAX = undefined;\n        this._physicalblank = undefined;\n        const buffer = rawdata.slice(fitsheader.offset);\n        this._u8data = new Uint8Array(buffer);\n        this.init(fitsheader);\n    }\n    init(fitsheader) {\n        this._BZERO = fitsheader.get(\"BZERO\");\n        if (this._BZERO === undefined) {\n            this._BZERO = 0;\n        }\n        this._BSCALE = fitsheader.get(\"BSCALE\");\n        if (this._BSCALE === undefined) {\n            this._BSCALE = 1;\n        }\n        this._BLANK = fitsheader.get(\"BLANK\"); // undefined in case it's not present in the header\n        // this._BLANK_pv = this._BZERO + this._BSCALE * this._BLANK || undefined;\n        this._BITPIX = fitsheader.get(\"BITPIX\");\n        this._NAXIS1 = fitsheader.get(\"NAXIS1\");\n        this._NAXIS2 = fitsheader.get(\"NAXIS2\");\n        this._DATAMIN = fitsheader.get(\"DATAMIN\");\n        this._DATAMAX = fitsheader.get(\"DATAMAX\");\n        this._physicalblank = undefined;\n        if (this._DATAMAX === undefined || this._DATAMIN === undefined) {\n            const [min, max] = this.computePhysicalMinAndMax();\n            this._DATAMAX = max;\n            this._DATAMIN = min;\n            const maxitem = new FITSHeaderItem(\"DATAMAX\", max, \" / computed with FITSParser\");\n            const minitem = new FITSHeaderItem(\"DATAMIN\", min, \" / computed with FITSParser\");\n            fitsheader.addItem(maxitem);\n            fitsheader.addItem(minitem);\n            // fitsheader.set(\"DATAMAX\", max);\n            // fitsheader.set(\"DATAMIN\", min);\n        }\n        // let item = new FITSHeaderItem(\"END\", null, null);\n        // fitsheader.addItem(item);\n    }\n    computePhysicalMinAndMax() {\n        let i = 0;\n        if (this._BITPIX === undefined) {\n            throw new Error(\"BITPIX is not defined\");\n        }\n        const bytesXelem = Math.abs(this._BITPIX / 8);\n        const pxLength = this._u8data.byteLength / bytesXelem;\n        let px_val, ph_val;\n        let min = undefined;\n        let max = undefined;\n        if (this._BLANK !== undefined) {\n            this._physicalblank = this.pixel2physicalValue(this._BLANK);\n        }\n        while (i < pxLength) {\n            // px_val = this.extractPixelValue(bytesXelem*i);\n            px_val = this.extractPixelValue(bytesXelem * i);\n            if (px_val === undefined) {\n                i++;\n                continue;\n            }\n            ph_val = this.pixel2physicalValue(px_val);\n            if (min === undefined) {\n                min = ph_val;\n            }\n            if (max === undefined) {\n                max = ph_val;\n            }\n            //TODO check below if\n            if (this._physicalblank === undefined || this._physicalblank !== ph_val) {\n                if (ph_val !== undefined && (ph_val < min || min === undefined)) {\n                    min = ph_val;\n                }\n                if (ph_val !== undefined && (ph_val > max || max === undefined)) {\n                    max = ph_val;\n                }\n            }\n            i++;\n        }\n        return [min, max];\n    }\n    parse() {\n        // let px_val; // pixel array value\n        // let ph_val = undefined; // pixel physical value\n        if (this._BITPIX === undefined) {\n            throw new Error(\"BITPIX is undefined\");\n        }\n        if (this._NAXIS1 === undefined) {\n            throw new Error(\"NAXIS1 is undefined\");\n        }\n        if (this._NAXIS2 === undefined) {\n            throw new Error(\"NAXIS2 is undefined\");\n        }\n        const bytesXelem = Math.abs(this._BITPIX / 8);\n        let pxLength = this._u8data.byteLength / bytesXelem;\n        pxLength = this._NAXIS1 * this._NAXIS2;\n        let k = 0;\n        let c, r;\n        const pixelvalues = [];\n        //  let pixv, pv;\n        while (k < pxLength) {\n            r = Math.floor(k / this._NAXIS1); // row\n            c = (k - r * this._NAXIS1) * bytesXelem; // col\n            if (c === 0) {\n                pixelvalues[r] = new Uint8Array(this._NAXIS1 * bytesXelem);\n            }\n            // px_val = this.extractPixelValue(bytesXelem * k);\n            // ph_val = this.pixel2physicalValue(px_val);\n            // TODO check if ph_val == blank\n            // if not then use ph_val to compute datamin and datamax\n            for (let i = 0; i < bytesXelem; i++) {\n                pixelvalues[r][c + i] = this._u8data[k * bytesXelem + i];\n            }\n            // if (k == 232) {\n            // \tpixv = this.extractPixelValue(k * bytesXelem);\n            // \tpv = this._BZERO + this._BSCALE * pixv;\n            // }\n            k++;\n        }\n        return pixelvalues;\n    }\n    /** this can be deleted */\n    extractPixelValue(offset) {\n        let px_val = undefined; // pixel value\n        if (this._BITPIX == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(this._u8data[offset], this._u8data[offset + 1]);\n        }\n        else if (this._BITPIX == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(this._u8data[offset], this._u8data[offset + 1], this._u8data[offset + 2], this._u8data[offset + 3]);\n        }\n        else if (this._BITPIX == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 4), 8, 23);\n        }\n        else if (this._BITPIX == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (this._BITPIX == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n    pixel2physicalValue(pxval) {\n        if (this._BZERO === undefined || this._BSCALE === undefined) {\n            throw new Error(\"Either BZERO or BSCALE is undefined\");\n        }\n        return this._BZERO + this._BSCALE * pxval;\n    }\n}\n//# sourceMappingURL=ParsePayload.js.map","import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseHeader {\n    static parse(rawdata) {\n        // only one header block (2880) allowed atm.\n        // TODO handle multiple header blocks\n        // let headerByteData = new Uint8Array(rawdata, 0, 2880);\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const header = new FITSHeader();\n        let nline = 0;\n        let key = \"\";\n        let val;\n        let u8line;\n        let u8key;\n        let u8val;\n        let u8ind;\n        // let ind: string;\n        let item;\n        let fitsLine;\n        item = null;\n        while (key !== \"END\" && rawdata.length > 0) {\n            // line 80 characters\n            u8line = new Uint8Array(rawdata.slice(nline * 80, nline * 80 + 80));\n            nline++;\n            // key\n            u8key = new Uint8Array(u8line.slice(0, 8));\n            key = textDecoder.decode(u8key).trim();\n            // value indicator\n            u8ind = new Uint8Array(u8line.slice(8, 10));\n            // ind = textDecoder.decode(u8ind);\n            // reading value\n            u8val = new Uint8Array(u8line.slice(10, 80));\n            val = textDecoder.decode(u8val).trim();\n            // ascii 61 -> =\n            // ascii 32 -> [space]\n            if (u8ind[0] == 61 && u8ind[1] == 32) {\n                let firstchar = 32;\n                for (let i = 0; i < u8val.length; i++) {\n                    if (u8val[i] != 32) {\n                        firstchar = u8val[i];\n                        break;\n                    }\n                }\n                // ascii 39 -> '\n                if (firstchar == 39 || !Number(val)) {\n                    // [ival, icomment]\n                    // fitsLine = ParseHeader.parseStringValue(u8val);\n                    fitsLine = ParseHeader.parseLogicalValue(u8val);\n                }\n                else {\n                    // ascii 84 -> T\n                    // ascii 70 -> F\n                    if (firstchar == 84 || firstchar == 70) {\n                        // T or F\n                        fitsLine = ParseHeader.parseLogicalValue(u8val);\n                    }\n                    else {\n                        val = textDecoder.decode(u8val).trim();\n                        if (val.includes(\".\")) {\n                            fitsLine = ParseHeader.parseFloatValue(u8val);\n                        }\n                        else {\n                            fitsLine = ParseHeader.parseIntValue(u8val);\n                        }\n                    }\n                }\n                item = new FITSHeaderItem(key, fitsLine.val, fitsLine.comment);\n            }\n            else {\n                if (key == \"COMMENT\" || key == \"HISTORY\") {\n                    item = new FITSHeaderItem(key, undefined, val);\n                }\n                else {\n                    let firstchar = 32;\n                    for (let i = 0; i < u8val.length; i++) {\n                        if (u8val[i] != 32) {\n                            firstchar = u8val[i];\n                            break;\n                        }\n                    }\n                    if (firstchar == 47) {\n                        // single / this is the case when no key nor value indicator is defined\n                        item = new FITSHeaderItem(undefined, undefined, val);\n                    }\n                    else if (firstchar == 32) {\n                        // case when there's a line with only spaces\n                        item = new FITSHeaderItem(undefined, undefined, undefined);\n                    }\n                }\n            }\n            if (item != null) {\n                header.addItem(item);\n            }\n        }\n        item = new FITSHeaderItem(\"COMMENT\", \"FITS generated with FITSParser on \", undefined);\n        header.addItem(item);\n        const now = new Date();\n        item = new FITSHeaderItem(\"COMMENT\", now.toString());\n        header.addItem(item);\n        const nblock = Math.ceil(nline / 36);\n        const offset = nblock * 2880;\n        header.offset = offset;\n        return header;\n    }\n    static parseStringValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const decoded = textDecoder.decode(u8buffer).trim();\n        const idx = decoded.lastIndexOf(\"/\");\n        const val = decoded.substring(0, idx);\n        let comment = decoded.substring(idx);\n        // if (comment === undefined) {\n        //   comment = null;\n        // }\n        return {\n            val: val,\n            comment: comment,\n        };\n    }\n    static parseLogicalValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: tokens[0].trim(),\n                comment: undefined,\n            };\n        }\n        return {\n            val: tokens[0].trim(),\n            comment: \" /\" + tokens[1],\n        };\n    }\n    static parseIntValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: parseInt(tokens[0].trim()),\n                comment: undefined,\n            };\n        }\n        return {\n            val: parseInt(tokens[0].trim()),\n            comment: \" /\" + tokens[1],\n        };\n    }\n    static parseFloatValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: parseFloat(tokens[0].trim()),\n                comment: undefined,\n            };\n        }\n        return {\n            val: parseFloat(tokens[0].trim()),\n            comment: \" /\" + tokens[1],\n        };\n    }\n}\n//# sourceMappingURL=ParseHeader.js.map","/**\n\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FITSWriter } from \"./FITSWriter.js\";\nimport { ParsePayload } from \"./ParsePayload.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\n// import fetch from 'cross-fetch';\n// import { readFile } from \"node:fs/promises\";\nexport class FITSParser {\n    constructor(url) {\n        this._url = url;\n    }\n    loadFITS() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getFile(this._url)\n                .then((rawdata) => {\n                if (rawdata !== null && rawdata.byteLength > 0) {\n                    const uint8 = new Uint8Array(rawdata);\n                    const fits = this.processFits(uint8);\n                    return fits;\n                }\n                return null;\n            })\n                .catch((error) => {\n                var _a, _b;\n                if ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) {\n                    throw new Error(\"[FITSParser->loadFITS] \" + error.response.data.message);\n                }\n                throw error;\n            });\n        });\n    }\n    processFits(rawdata) {\n        const header = ParseHeader.parse(rawdata);\n        const payloadParser = new ParsePayload(header, rawdata);\n        const pixelvalues = payloadParser.parse();\n        // if (rawdata.length > (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length))) {\n        // let leftover = rawdata.length - (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length));\n        // \tthrow new Error(\"[FITSParser->processFits] It seems that there's at least one more HDU since there are \" + leftover + \" bytes not processed.\");\n        // \tconsole.warn(\"It seems that there's at least one more HDU since there are \" + leftover + \" bytes not processed.\")\n        // }\n        return {\n            header: header,\n            data: pixelvalues,\n        };\n    }\n    static generateFITS(header, rawdata) {\n        const writer = new FITSWriter();\n        writer.run(header, rawdata);\n        return writer.typedArrayToURL();\n    }\n    getFile(uri) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let data;\n            if (!uri.substring(0, 5).toLowerCase().includes(\"http\")) {\n                let p = yield import('./getLocalFile.js');\n                // data = await p.getLocalFile(uri);\n                return yield p.getLocalFile(uri);\n            }\n            else {\n                let p = yield import('./getFile.js');\n                return p.getFile(uri).then((data) => {\n                    return data;\n                }).catch((err) => {\n                    // console.error(\"Error in FITSParser getFile \", uri, err);\n                    return null;\n                });\n                // data = await p.getFile(uri);\n                // return await p.getFile(uri).catch((err) => {\n                //   console.error(err);\n                // });\n            }\n            // return data;\n        });\n    }\n}\n//# sourceMappingURL=FITSParser.js.map","export enum NumberType {\n    DEGREES,\n    RADIANS,\n    DECIMAL,\n    HMS,\n    DMS\n}","/**\n * @author Fabrizio Giordano (Fab77)\n * Enum for coordinate types.\n * @readonly\n * @enum {{name: string, hex: string}}\n */\n\nexport enum CoordsType {\n  CARTESIAN = \"cartesian\",\n  SPHERICAL = \"spherical\",\n  ASTRO = \"astro\"\n}\n","\nimport { FITSHeader } from 'jsfitsio';\n\nexport class FITS {\n    _header: FITSHeader[]\n    _data: Map<number, Array<Uint8Array>>\n\n    constructor(header: FITSHeader[], data: Map<number, Array<Uint8Array>>) {\n        this._header = header\n        this._data = data\n    }\n\n    get header() {\n        return this._header\n    }\n    \n    get data() {\n        return this._data\n    }\n\n}","import { FITSHeader, FITSHeaderItem } from \"jsfitsio\";\nimport { FITSParsed } from \"jsfitsio\";\n// import { AstroCoords } from \"src/model/AstroCoords\";\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport { Point } from \"../model/Point.js\";\nimport { FITS } from \"../model/FITS.js\";\n\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nexport abstract class AbstractProjection {\n  private _naxis1!: number;\n  private _naxis2!: number;\n  private _pxsize: number;\n  private _ctype1: string;\n  private _ctype2: string;\n\n  constructor(\n    ctype1: string,\n    ctype2: string,\n    naxis1 = 0,\n    naxis2 = 0,\n    pxsize = 0\n  ) {\n    this._ctype1 = ctype1;\n    this._ctype2 = ctype2;\n    this._naxis1 = naxis1;\n    this._naxis2 = naxis2;\n    this._pxsize = pxsize;\n  }\n\n  protected get naxis1() {\n    return this._naxis1;\n  }\n\n  protected set naxis1(value: number) {\n    this._naxis1 = value;\n  }\n\n  protected get naxis2() {\n    return this._naxis2;\n  }\n\n  protected set naxis2(value: number) {\n    this._naxis2 = value;\n  }\n\n  protected get pxsize() {\n    return this._pxsize;\n  }\n\n  protected set pxsize(value: number) {\n    this._pxsize = value;\n  }\n\n  protected get ctype1() {\n    return this._ctype1;\n  }\n\n  protected set ctype1(value: string) {\n    this._ctype1 = value;\n  }\n\n  protected get ctype2() {\n    return this._ctype2;\n  }\n\n  protected set ctype2(value: string) {\n    this._ctype2 = value;\n  }\n\n  public abstract initFromFile(\n    fitsfilepath?: string,\n    hipsURI?: string,\n    pxsize?: number,\n    order?: number\n  ): Promise<FITSParsed | undefined>;\n\n  public abstract prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[];\n\n  public abstract getFITSHeader(): FITSHeader[];\n\n  public abstract getCommonFitsHeaderParams(): FITSHeader;\n\n  public abstract extractPhysicalValues(fits: FITSParsed): number[][];\n\n  public abstract getPixValues(\n    inputPixelsList: ImagePixel[]\n  ): Promise<Uint8Array | undefined>;\n\n  public abstract setPxsValue(\n    values: Uint8Array,\n    fitsHeaderParams: FITSHeader\n  ): Map<number, Array<Uint8Array>>;\n\n  public abstract getImageRADecList(\n    center: Point,\n    radius: number,\n    pxsize: number\n  ): Array<[number, number]>;\n\n  public abstract pix2world(i: number, j: number): Point;\n\n  public abstract get fitsUsed(): String[];\n\n  public abstract world2pix(radeclist: number[][]): ImagePixel[];\n\n  // public abstract generateFITSWithNaN(): FITS;\n\n  public generateFITSWithNaN(): FITS {\n    if (!this.naxis1 || !this.naxis2) {\n      throw new Error(\n        \"NAXIS1 and NAXIS2 must be initialized before generating FITS.\"\n      );\n    }\n\n    let fitsheaders: FITSHeader[] = [];\n\n    let fitsheader = new FITSHeader();\n\n    fitsheader.addItemAtTheBeginning(new FITSHeaderItem(\"NAXIS1\", this.naxis1));\n    fitsheader.addItemAtTheBeginning(new FITSHeaderItem(\"NAXIS2\", this.naxis2));\n    fitsheader.addItemAtTheBeginning(new FITSHeaderItem(\"NAXIS\", 2));\n    fitsheader.addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", \"-64\"));\n    fitsheader.addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", \"T\"));\n    fitsheader.addItem(new FITSHeaderItem(\"BSCALE\", 1));\n    fitsheader.addItem(new FITSHeaderItem(\"BZERO\", 0));\n\n    fitsheader.addItem(new FITSHeaderItem(\"CTYPE1\", this.ctype1));\n    fitsheader.addItem(new FITSHeaderItem(\"CTYPE2\", this.ctype2));\n    fitsheader.addItem(new FITSHeaderItem(\"CDELT1\", this.pxsize)); // ??? Pixel spacing along axis 1 ???\n    fitsheader.addItem(new FITSHeaderItem(\"CDELT2\", this.pxsize)); // ??? Pixel spacing along axis 2 ???\n    fitsheader.addItem(new FITSHeaderItem(\"CRPIX1\", this.naxis1 / 2)); // central/reference pixel i along naxis1\n    fitsheader.addItem(new FITSHeaderItem(\"CRPIX2\", this.naxis2 / 2)); // central/reference pixel j along naxis2\n    fitsheader.addItem(new FITSHeaderItem(\"CRVAL1\", NaN)); // central/reference pixel RA\n    fitsheader.addItem(new FITSHeaderItem(\"CRVAL2\", NaN)); // central/reference pixel Dec\n\n    fitsheader.addItem(new FITSHeaderItem(\"ORIGIN\", \"'WCSLight v.0.x'\"));\n    fitsheader.addItem(\n      new FITSHeaderItem(\n        \"COMMENT\",\n        \"'WCSLight v0.x developed by F.Giordano and Y.Ascasibar'\"\n      )\n    );\n    fitsheader.addItem(new FITSHeaderItem(\"END\"));\n\n    fitsheaders.push(fitsheader);\n\n    let bytesXelem = 8;\n    // why not usign a simple arrays?\n    let pv = new Map<number, Array<Uint8Array>>();\n    pv.set(0, new Array<Uint8Array>(this.naxis2))\n    pv.get(0)\n    for (let r = 0; r < this.naxis2; r++) {\n      pv.get(0)[r] = new Uint8Array(this.naxis1 * bytesXelem);\n      pv.get(0)[r].fill(255);\n    }\n\n    const fitsNan: FITS = new FITS(fitsheaders, pv);\n\n    return fitsNan;\n  }\n\n  public computeSquaredNaxes(d: number, ps: number): void {\n    // first approximation to be checked\n    this._naxis1 = Math.ceil(d / ps);\n    this._naxis2 = this._naxis1;\n    this._pxsize = ps;\n  }\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\n\nexport class ImagePixel {\n    _i: number;     // int i of input projection\n    _j: number;     // int j of input projection\n    _tileno: number;// int\n    \n    constructor (i: number = null, j: number = null, tileno: number = null) {\n        this._i = i;\n        this._j = j;\n        this._tileno = tileno;\n    }\n\n    geti() {\n        return this._i;\n    }\n\n    getj() {\n        return this._j;\n    }\n\n    get tileno() {\n        return this._tileno\n    }\n}\n","/**\n * @author Fabrizio Giordano (Fab)\n */\n// import vec3 from 'gl-matrix';\n\nimport { AstroCoords } from \"./AstroCoords.js\";\nimport { CartesianCoords } from \"./CartesianCoords.js\";\nimport { HMSCoords } from \"./HMSCoords.js\";\nimport { NumberType } from \"./NumberType.js\";\nimport { SexagesimalCoords } from \"./SexagesimalCoords.js\";\nimport { SphericalCoords } from \"./SphericalCoords.js\";\n\nfunction Utils(){\n\t\n}\n\nexport function cartesianToSpherical(xyz: CartesianCoords): SphericalCoords{\n\tlet dotXYZ = dot(xyz, xyz);\n\tlet r = Math.sqrt(dotXYZ);\t\n\tlet thetaRad = Math.acos(xyz[2]/r);\n\tlet thetaDeg = radToDeg(thetaRad);\n\t// NB: in atan(y/x) is written with params switched atan2(x, y)\n\tlet phiRad = Math.atan2(xyz[1],xyz[0]);\n\tlet phiDeg = radToDeg(phiRad);\n\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\treturn {\n\t\tphiDeg: phiDeg, \n\t\tthetaDeg: thetaDeg,\n\t\tphiRad:phiRad,\n\t\tthetaRad: thetaRad\n\t};\n};\n\nexport function sphericalToAstro(phiTheta: SphericalCoords): AstroCoords{\n\tlet raDeg: number;\n\tlet decDeg: number;\n\n\traDeg = phiTheta.phiDeg;\n\tif (raDeg < 0){\n\t\traDeg += 360;\n\t}\n\tdecDeg = 90 - phiTheta.thetaDeg;\n\t\n\treturn {\n\t\t\"raDeg\": raDeg,\n\t\t\"decDeg\": decDeg,\n\t\t\"raRad\": degToRad(raDeg),\n\t\t\"decRad\": degToRad(decDeg)\n\n\t};\n}\n\nexport function astroToSpherical(raDec: AstroCoords): SphericalCoords{\n\t\n\tlet phiDeg: number;\n\tlet thetaDeg: number;\n\n\tphiDeg = raDec.raDeg;\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\t\n\tthetaDeg = 90 - raDec.decDeg;\n\t\n\treturn {\n\t\t\"phiDeg\": phiDeg,\n\t\t\"thetaDeg\": thetaDeg,\n\t\t\"phiRad\": degToRad(phiDeg),\n\t\t\"thetaRad\": degToRad(thetaDeg),\n\t};\n}\n\nexport function sphericalToCartesian(phiTheta: SphericalCoords, r: number): CartesianCoords{\n\tr = (r == undefined) ? 1 : r;\n\tvar x = r * Math.sin(phiTheta.thetaRad) * Math.cos(phiTheta.phiRad);\n\tvar y = r * Math.sin(phiTheta.thetaRad) * Math.sin(phiTheta.phiRad);\n\tvar z = r * Math.cos(phiTheta.thetaRad);\n\n\treturn {\n\t\t\"x\": x, \n\t\t\"y\": y, \n\t\t\"z\": z\n\t};\n};\n\nexport function fillAstro(ra: number, dec: number, unit: NumberType): AstroCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"raDeg\": ra,\n\t\t\t\"decDeg\": dec,\n\t\t\t\"raRad\": degToRad(ra),\n\t\t\t\"decRad\": degToRad(dec)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"raRad\": ra,\n\t\t\t\"decRad\": dec,\n\t\t\t\"raDeg\": radToDeg(ra),\n\t\t\t\"decDeg\": radToDeg(dec)\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n\t\n}\n\n\nexport function fillSpherical(phi: number, theta: number, unit: NumberType):  SphericalCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"phiDeg\": phi,\n\t\t\t\"thetaDeg\": theta,\n\t\t\t\"phiRad\": degToRad(phi),\n\t\t\t\"thetaRad\": degToRad(theta)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"phiDeg\": radToDeg(phi),\n\t\t\t\"thetaDeg\": radToDeg(theta),\n\t\t\t\"phiRad\": phi,\n\t\t\t\"thetaRad\": theta\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n}\n\nfunction dot(a: CartesianCoords, b: CartesianCoords) : number{\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n\nexport function colorHex2RGB(hexColor: string): [number, number, number] {\n\n//\tconsole.log(hexColor);\n\tvar hex1 = hexColor.substring(1,3);\n\tvar hex2 = hexColor.substring(3,5);\n\tvar hex3 = hexColor.substring(5,7);\n\t\n\tvar dec1 = parseInt(hex1, 16);\n\tvar dec2 = parseInt(hex2, 16);\n\tvar dec3 = parseInt(hex3, 16);\n\t\n\tvar rgb1 = (dec1 / 255).toFixed(2);\n\tvar rgb2 = (dec2 / 255).toFixed(2);\n\tvar rgb3 = (dec3 / 255).toFixed(2);\n\t\n\treturn [parseFloat(rgb1), parseFloat(rgb2), parseFloat(rgb3)];\n\n}\n\nexport function degToRad(degrees: number) : number{\n\treturn (degrees / 180 ) * Math.PI ;\n}\n\nexport function radToDeg(radians: number) : number{\n\treturn radians * 180 / Math.PI;\n}\n\nexport function raDegToHMS(raDeg: number): HMSCoords{\n\t\n\tvar h = Math.floor(raDeg/15);\n\tvar m = Math.floor((raDeg/15 - h) * 60);\n\tvar s = (raDeg/15 - h - m/60) * 3600;\n\t\n\treturn {\n\t\th: h, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nexport function decDegToDMS(decDeg: number): SexagesimalCoords{\n\tvar sign = 1;\n\tif (decDeg < 0){\n\t\tsign = -1;\n\t}\n\t\n\tvar decDeg_abs = Math.abs(decDeg);\n\tvar d = Math.trunc(decDeg_abs);\n\t\n\tvar m = Math.trunc( (decDeg_abs - d) * 60);\n\t\n\tvar s = (decDeg_abs - d - m/60) * 3600;\n\td = d * sign;\n\t\n\treturn {\n\t\td: d, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nfunction dms2DecDeg(decDMS: SexagesimalCoords){\n\tvar sign = Math.sign(decDMS.d);\n\tvar deg = (decDMS.d) + sign * (decDMS.m / 60) + sign * (decDMS.s/3600);\n\treturn deg;\n}\n\nfunction hms2RaDeg(raHMS: HMSCoords){\n\tvar sign = Math.sign(raHMS.h);\n\tvar deg = (raHMS.h + sign * (raHMS.m / 60) + sign * (raHMS.s/3600)) * 15;\n\treturn deg;\n}\n\nfunction worldToModel(xy: [number, number], radius: number): [number, number, number]{\n\tvar x = xy[0];\n\tvar y = xy[1];\n\tvar z = Math.sqrt(radius*radius - xy[0]*xy[0] - xy[1]*xy[1]);\n\treturn [x, y, z];\n}\n\n","/**\n * @author Fabrizio Giordano (Fab77)\n */\n\nimport {sphericalToCartesian, cartesianToSpherical, sphericalToAstro, astroToSpherical, fillSpherical, fillAstro} from './Utils.js';\nimport { CartesianCoords } from './CartesianCoords.js';\nimport { AstroCoords} from './AstroCoords.js';\nimport { CoordsType } from './CoordsType.js';\nimport { SphericalCoords } from './SphericalCoords.js';\nimport { NumberType } from './NumberType.js';\nimport { EquatorialCoords } from './EquatorialCoords.js';\nimport { GalacticCoords } from './GalacticCoords.js';\n\nexport class Point{\n\n\t#astro: AstroCoords;\n\t// #equatorial: EquatorialCoords;\n\t// #galactic: GalacticCoords;\n\n\t#spherical: SphericalCoords;\n\t#cartesian: CartesianCoords;\n\n\tconstructor(in_type: CoordsType, unit: NumberType, ...coords: Array<number>) {\n\n\t\tif (in_type == CoordsType.CARTESIAN){\n\t\t\tthis.#cartesian.x = parseFloat(coords[0].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.y = parseFloat(coords[1].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.z = parseFloat(coords[2].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t\t} else if (in_type == CoordsType.ASTRO){\n\t\t\tthis.#astro = fillAstro(coords[0],  coords[1], unit);\n\t\t\tthis.#spherical = astroToSpherical(this.#astro);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\n\t\t} else if (in_type == CoordsType.SPHERICAL){\n\t\t\tthis.#spherical = fillSpherical(coords[0],  coords[1], unit);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\n\t\t} else{\n\t\t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t\t}\n\t\tif (this.#spherical.phiDeg > 360) {\n\t\t\tthis.#spherical.phiDeg -= 360;\n\t\t}\n\t\tif (this.#astro.raDeg > 360) {\n\t\t\tthis.#astro.raDeg -= 360;\n\t\t}\n\t}\n\n\n\t// constructor(in_options: ICoordsFormat, in_type: CoordsType){\n\t\t\n\t// \tif (in_type == CoordsType.CARTESIAN){\n\n\t// \t\tthis.#cartesian.x = parseFloat((in_options as CartesianCoords).x.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.y = parseFloat((in_options as CartesianCoords).y.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.z = parseFloat((in_options as CartesianCoords).z.toFixed(global.MAX_DECIMALS));\n\n\t// \t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else if (in_type == CoordsType.ASTRO){\n\t\t\t\n\t// \t\tif ((in_options as AstroCoords).raDeg && (in_options as AstroCoords).decDeg) {\n\t// \t\t\tthis.#astro = radegDecdegToAstro((in_options as AstroCoords).raDeg,  (in_options as AstroCoords).decDeg );\n\t// \t\t} else if ((in_options as AstroCoords).raRad && (in_options as AstroCoords).decRad) {\n\t// \t\t\tthis.#astro = raradDecradToAstro((in_options as AstroCoords).raRad,  (in_options as AstroCoords).decRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"AstroCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\t// \t\tthis.#spherical = astroToSpherical(this.#astro);\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\t\n\t// \t}else if (in_type == CoordsType.SPHERICAL){\n\n\t// \t\tif ((in_options as SphericalCoords).phiDeg && (in_options as SphericalCoords).thetaDeg) {\n\t// \t\t\tthis.#spherical = phidegThetadegToSpherical((in_options as SphericalCoords).phiDeg,  (in_options as SphericalCoords).thetaDeg );\n\t// \t\t} else if ((in_options as SphericalCoords).phiRad && (in_options as SphericalCoords).thetaRad) {\n\t// \t\t\tthis.#spherical = phiradThetaradToSpherical((in_options as SphericalCoords).phiRad,  (in_options as SphericalCoords).thetaRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"SphericalCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else{\n\t// \t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t// \t}\n\t// }\n\n\tget spherical() {\n\t\treturn this.#spherical;\n\t}\n\n\tget astro() {\n\t\treturn this.#astro;\n\t}\n\n\tget cartesian() {\n\t\treturn this.#cartesian;\n\t}\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// /** Scale the vector by a given factor\n    // @param n the scale factor */\n\t// scale(n: number): Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*n, this.y*n, this.z*n);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// dot(v: Point): number{ \n\t// \treturn this.x*v.x + this.y*v.y + this.z*v.z; \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// cross(v: Point): Point{ \n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.y*v.z - v.y*this.z, this.z*v.x - v.z*this.x, this.x*v.y - v.x*this.y);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// norm() : Point{\n\t// \tlet d = 1./this.length();\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*d, this.y*d, this.z*d);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// length(): number{ \n\t// \treturn Math.sqrt(this.lengthSquared()); \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// lengthSquared(): number{ \n\t// \treturn this.x*this.x + this.y*this.y + this.z*this.z; \n  \t// };\n\n\t// subtract(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x - v.x, this.y - v.y, this.z - v.z);\n\t// }\n\n\t// add(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x + v.x, this.y + v.y, this.z + v.z);\n\t// }\n\t\n\n\t// get x(){\n\t// \treturn this._x;\n\t// }\n\t\n\t// get y(){\n\t// \treturn this._y;\n\t// }\n\t\n\t// get z(){\n\t// \treturn this._z;\n\t// }\n\t\n\t// get xyz(){\n    //     return this._xyz;\n    // }\n\t\n    // get raDeg(){\n    //     return this._raDeg;\n    // }\n    \n    // get decDeg(){\n    //     return this._decDeg;\n    // }\n    \n    // get raDecDeg(){\n    //     return this._raDecDeg;\n    // }\n    \n    // toADQL(){\n    // \treturn this._raDecDeg[0]+\",\"+this._raDecDeg[1];\n    // }\n    \n    // toString(){\n    // \treturn \"(raDeg, decDeg) => (\"+this._raDecDeg[0]+\",\"+this._raDecDeg[1]+\") (x, y,z) => (\"+this._xyz[0]+\",\"+this._xyz[1]+\",\"+this._xyz[2]+\")\";\n    // }\n}\n\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n \n\nimport { FITSParser, FITSHeader, FITSHeaderItem, FITSParsed, ParseUtils } from 'jsfitsio';\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\nimport { FITS } from '../model/FITS.js';\n\n\nexport class MercatorProjection extends AbstractProjection {\n    \n    _minra!: number;\n    _mindec!: number;\n    // _naxis1!: number;\n    // _naxis2!: number;\n    \n    _fitsheader: FITSHeader[];\n    _infile!: string;\n    // _ctype1: string; // TODO should be RA ENUM\n    // _ctype2: string; // TODO should be Dec ENUM\n    _craDeg!: number;\n    _cdecDeg!: number;\n\n    // _pxsize!: number;\n    _pxsize1!: number;\n    _pxsize2!: number;\n\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval!: number;\n    _maxphysicalval!: number;\n    _wcsname: string;\n    _fitsUsed: String[];\n    \n    constructor() {\n        super(\"'RA---CAR'\", \"'DEC--CAR'\")\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this._pxvalues = new Map<number, Array<Uint8Array>>();\n        this._fitsheader = new Array<FITSHeader>();\n    }\n\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n        \n        let fp = new FITSParser(infile);\n        this._infile = infile;\n        this._fitsUsed.push(infile)\n\n        let promise = fp.loadFITS().then(fits => {\n            \n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            super.naxis1 = fits.header.get(\"NAXIS1\");\n            super.naxis2 = fits.header.get(\"NAXIS2\");\n            // this._naxis1 = fits.header.get(\"NAXIS1\");\n            // this._naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value as number;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value as number;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            // this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            // this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n\n            const pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            const pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n            if (pxsize1 !== pxsize2 || pxsize1 === undefined || pxsize2 === undefined) {\n                throw new Error(\"pxsize1 is not equal to pxsize2\")\n                exit;\n            }\n            super.pxsize = pxsize1;\n\n            // this._minra = this._craDeg - this._pxsize1 * this._naxis1 / 2;\n            this._minra = this._craDeg - super.pxsize * super.naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            // this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n            this._mindec = this._cdecDeg - super.pxsize * super.naxis2 / 2;\n\n            return fits;\n        });\n        await promise;\n        return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\n        this._fitsheader[0] = new FITSHeader();\n\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"NAXIS1\", super.naxis1));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"NAXIS2\", super.naxis2));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        \n        \n        \n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE1\", super.ctype1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE2\", super.ctype2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT1\", super.pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT2\", super.pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX1\", super.naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX2\", super.naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"ORIGIN\", \"'WCSLight v.0.x'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"COMMENT\", \"'WCSLight v0.x developed by F.Giordano and Y.Ascasibar'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n    getFITSHeader(): FITSHeader[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeader {\n        let header = new FITSHeader();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                header.addItem(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    get fitsUsed(): String[]{\n\t\treturn this._fitsUsed;\n\t}\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= super.naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= super.naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        let pv = this._pxvalues.get(0);\n                        if (pv !== undefined) {\n\n                            for (let b = 0; b < bytesXelem; b++) {\n\n                                values[p * bytesXelem + b] = pv[imgpx._j][(imgpx._i) * bytesXelem + b];\n                            }\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n\n        let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        let maxpixb = minpixb;\n\n        let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        this._minphysicalval = bzero + bscale * minpixb;\n        this._maxphysicalval = bzero + bscale * maxpixb;\n\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n        // this._pxvalues.set(0, new Uint8Array[this._naxis2][this._naxis1 * bytesXelem]);\n\n        this._pxvalues.set(0, new Array<Uint8Array>(super.naxis2));\n        let pv = this._pxvalues.get(0);\n        if (pv !== undefined) {\n            for (let r = 0; r < super.naxis2; r++) {\n                pv[r] = new Uint8Array(super.naxis1 * bytesXelem);\n            }\n\n            let r!: number;\n            let c!: number;\n            let b!: number;\n            for (let p = 0; (p * bytesXelem) < values.length; p++) {\n                // console.log(\"processing \"+p + \" of \"+ (values.length / bytesXelem));\n\n                try {\n                    r = Math.floor(p / super.naxis1);\n                    c = (p - r * super.naxis1) * bytesXelem;\n\n                    for (b = 0; b < bytesXelem; b++) {\n                        pv[r][c + b] = values[p * bytesXelem + b];\n                    }\n\n\n                    let valpixb = ParseUtils.extractPixelValue(0, values.slice(p * bytesXelem, (p * bytesXelem) + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n                    let valphysical = bzero + bscale * valpixb;\n\n                    if (valphysical < this._minphysicalval || isNaN(this._minphysicalval)) {\n                        this._minphysicalval = valphysical;\n                    } else if (valphysical > this._maxphysicalval || isNaN(this._maxphysicalval)) {\n                        this._maxphysicalval = valphysical;\n                    }\n                } catch (err) {\n                    console.log(err)\n                    console.log(\"p \" + p)\n                    console.log(\"r %, c %, b %\" + r, c, b)\n                    console.log(\"this._pxvalues[r][c + b] \" + pv[r][c + b])\n                    console.log(\"values[p * bytesXelem + b] \" + values[p * bytesXelem + b])\n                }\n\n            }\n        }\n\n        this.prepareFITSHeader(fitsHeaderParams);\n        return this._pxvalues;\n\n    }\n\n\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n\n\n        super.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n        super.pxsize = pxsize;\n        this._minra = center.astro.raDeg - radius;\n        if (this._minra < 0) {\n            this._minra += 360;\n        }\n        this._mindec = center.astro.decDeg - radius;\n\n        let radeclist: Array<[number, number]> = new Array<[number, number]>();\n\n        for (let d = 0; d < super.naxis2; d++) {\n            for (let r = 0; r < super.naxis1; r++) {\n                radeclist.push([this._minra + (r * super.pxsize), this._mindec + (d * super.pxsize)]);\n            }\n        }\n\n        let cidx = (super.naxis2 / 2 ) * super.naxis1 + super.naxis1 / 2;\n        if (super.naxis1 % 2 != 0) {\n            cidx = Math.floor(radeclist.length / 2);\n        }\n\n        // let cidx2 = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        \n        // let cidx = Math.ceil(radeclist.length / 2);\n        // let cidx = Math.floor(radeclist.length / 2);\n        this._craDeg = radeclist[cidx][0];\n        this._cdecDeg = radeclist[cidx][1];\n\n        return radeclist;\n\n\n    }\n\n\n\n    /** TODO !!! check and handle RA passing through 360-0 */\n    pix2world(i: number, j: number): Point {\n\n        let ra: number;\n        let dec: number;\n        // ra = i * this._stepra + this._minra;\n        // dec = j * this._stepdec + this._mindec;\n        ra = i * super.pxsize + this._minra;\n        dec = j * super.pxsize + this._mindec;\n        let p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n        return p;\n        // return [ra, dec];\n\n    }\n\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        for (let radecItem of radeclist) {\n            let ra = radecItem[0];\n            let dec = radecItem[1];\n            // let i = Math.floor((ra - this._minra) / this._pxsize1);\n            // let j = Math.floor((dec - this._mindec) / this._pxsize2);\n            let i = Math.floor((ra - this._minra) / super.pxsize);\n            let j = Math.floor((dec - this._mindec) / super.pxsize);\n            imgpxlist.push(new ImagePixel(i, j));\n        }\n\n        return imgpxlist;\n\n    }\n\n}\n","export class Constants {\n}\n//\tstatic halfpi = Math.PI/2.;\nConstants.halfpi = 1.5707963267948966;\nConstants.inv_halfpi = 2. / Math.PI;\n/** The Constant twopi. */\nConstants.twopi = 2 * Math.PI;\nConstants.inv_twopi = 1. / (2 * Math.PI);\n//# sourceMappingURL=Constants.js.map","export class Zphi {\n    /** Creation from individual components */\n    constructor(z_, phi_) {\n        this.z = z_;\n        this.phi = phi_;\n    }\n    ;\n}\n//# sourceMappingURL=Zphi.js.map","import { Vec3 } from './Vec3.js';\nimport { Zphi } from './Zphi.js';\nexport class Hploc {\n    constructor(ptg) {\n        Hploc.PI4_A = 0.7853981554508209228515625;\n        Hploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\n        Hploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n        Hploc.M_1_PI = 0.3183098861837906715377675267450287;\n        if (ptg) {\n            this.sth = 0.0;\n            this.have_sth = false;\n            this.z = Hploc.cos(ptg.theta);\n            this._phi = ptg.phi;\n            if (Math.abs(this.z) > 0.99) {\n                this.sth = Hploc.sin(ptg.theta);\n                this.have_sth = true;\n            }\n        }\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    ;\n    get phi() {\n        return this._phi;\n    }\n    ;\n    set phi(phi) {\n        this._phi = phi;\n    }\n    ;\n    setSth(sth) {\n        this.sth = sth;\n    }\n    ;\n    toVec3() {\n        var st = this.have_sth ? this.sth : Math.sqrt((1.0 - this.z) * (1.0 + this.z));\n        // var vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);\n        var vector = new Vec3(st * Math.cos(this.phi), st * Math.sin(this.phi), this.z);\n        return vector;\n    }\n    ;\n    toZphi() {\n        return new Zphi(this.z, this.phi);\n    }\n    static sin(d) {\n        let u = d * Hploc.M_1_PI;\n        let q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 4.0 * q;\n        d -= x * Hploc.PI4_A;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 1) != 0) {\n            d = -d;\n        }\n        return this.sincoshelper(d);\n    }\n    ;\n    static cos(d) {\n        //\t\tlet u = d * Hploc.M_1_PI - 0.5;\n        let u = d * Hploc.M_1_PI - 0.5;\n        //\t\tu -= 0.5;\n        let q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 2.0 * q;\n        let t = x * Hploc.PI4_A;\n        d = d - t;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 2) == 0) {\n            d = -d;\n        }\n        return Hploc.sincoshelper(d);\n    }\n    ;\n    static sincoshelper(d) {\n        let s = d * d;\n        let u = -7.97255955009037868891952e-18;\n        u = u * s + 2.81009972710863200091251e-15;\n        u = u * s - 7.64712219118158833288484e-13;\n        u = u * s + 1.60590430605664501629054e-10;\n        u = u * s - 2.50521083763502045810755e-08;\n        u = u * s + 2.75573192239198747630416e-06;\n        u = u * s - 0.000198412698412696162806809;\n        u = u * s + 0.00833333333333332974823815;\n        u = u * s - 0.166666666666666657414808;\n        return s * u * d + d;\n    }\n    ;\n    /** This method calculates the arc sine of x in radians. The return\n    value is in the range [-pi/2, pi/2]. The results may have\n    maximum error of 3 ulps. */\n    static asin(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1 + d) * (1 - d))), d);\n    }\n    ;\n    /** This method calculates the arc cosine of x in radians. The\n        return value is in the range [0, pi]. The results may have\n        maximum error of 3 ulps. */\n    static acos(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.sqrt((1 + d) * (1 - d)), Math.abs(d)), d) + (d < 0 ? Math.PI : 0);\n    }\n    ;\n    static mulsign(x, y) {\n        let sign = Hploc.copySign(1, y);\n        return sign * x;\n    }\n    ;\n    static copySign(magnitude, sign) {\n        return sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);\n        // let finalsign = 1;\n        // if (Object.is(finalsign , -0)){\n        // \tsign = -1;\n        // }else if (Object.is(finalsign , 0)){\n        // \tsign = 1;\n        // }else {\n        // \tsign = Math.sign(finalsign);\n        // }\n        // return finalsign * magnitude;\n    }\n    static atanhelper(s) {\n        let t = s * s;\n        let u = -1.88796008463073496563746e-05;\n        u = u * t + (0.000209850076645816976906797);\n        u = u * t + (-0.00110611831486672482563471);\n        u = u * t + (0.00370026744188713119232403);\n        u = u * t + (-0.00889896195887655491740809);\n        u = u * t + (0.016599329773529201970117);\n        u = u * t + (-0.0254517624932312641616861);\n        u = u * t + (0.0337852580001353069993897);\n        u = u * t + (-0.0407629191276836500001934);\n        u = u * t + (0.0466667150077840625632675);\n        u = u * t + (-0.0523674852303482457616113);\n        u = u * t + (0.0587666392926673580854313);\n        u = u * t + (-0.0666573579361080525984562);\n        u = u * t + (0.0769219538311769618355029);\n        u = u * t + (-0.090908995008245008229153);\n        u = u * t + (0.111111105648261418443745);\n        u = u * t + (-0.14285714266771329383765);\n        u = u * t + (0.199999999996591265594148);\n        u = u * t + (-0.333333333333311110369124);\n        return u * t * s + s;\n    }\n    ;\n    static atan2k(y, x) {\n        let q = 0.;\n        if (x < 0) {\n            x = -x;\n            q = -2.;\n        }\n        if (y > x) {\n            let t = x;\n            x = y;\n            y = -t;\n            q += 1.;\n        }\n        return Hploc.atanhelper(y / x) + q * (Math.PI / 2);\n    }\n    ;\n    /** This method calculates the arc tangent of y/x in radians, using\n    the signs of the two arguments to determine the quadrant of the\n    result. The results may have maximum error of 2 ulps. */\n    static atan2(y, x) {\n        let r = Hploc.atan2k(Math.abs(y), x);\n        r = Hploc.mulsign(r, x);\n        if (Hploc.isinf(x) || x == 0) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI / 2)) : 0);\n        }\n        if (Hploc.isinf(y)) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI * 1 / 4)) : 0);\n        }\n        if (y == 0) {\n            r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);\n        }\n        return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);\n    }\n    ;\n    /** Checks if the argument is a NaN or not. */\n    static isnan(d) {\n        return d != d;\n    }\n    ;\n    /** Checks if the argument is either positive or negative infinity. */\n    static isinf(d) {\n        return Math.abs(d) === +Infinity;\n    }\n    ;\n}\nHploc.PI4_A = 0.7853981554508209228515625;\nHploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\nHploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\nHploc.M_1_PI = 0.3183098861837906715377675267450287;\n//# sourceMappingURL=Hploc.js.map","import { Hploc } from './Hploc.js';\nexport class Pointing {\n    /**\n     *\n     * @param {*} vec3 Vec3.js\n     * @param {*} mirror\n     * @param {*} in_theta radians\n     * @param {*} in_phi radians\n     */\n    constructor(vec3, mirror, in_theta, in_phi) {\n        if (vec3 != null) {\n            this.theta = Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);\n            if (mirror) {\n                this.phi = -Hploc.atan2(vec3.y, vec3.x);\n            }\n            else {\n                this.phi = Hploc.atan2(vec3.y, vec3.x);\n            }\n            if (this.phi < 0.0) {\n                this.phi = this.phi + 2 * Math.PI;\n            }\n            if (this.phi >= 2 * Math.PI) {\n                this.phi = this.phi - 2 * Math.PI;\n            }\n        }\n        else {\n            this.theta = in_theta;\n            this.phi = in_phi;\n        }\n    }\n}\n//# sourceMappingURL=Pointing.js.map","/**\n * Partial porting to Javascript of Vec3.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nimport { Pointing } from './Pointing.js';\nexport class Vec3 {\n    constructor(in_x, in_y, in_z) {\n        if (in_x instanceof Pointing) {\n            let ptg = in_x;\n            let sth = Hploc.sin(ptg.theta);\n            this.x = sth * Hploc.cos(ptg.phi);\n            this.y = sth * Hploc.sin(ptg.phi);\n            this.z = Hploc.cos(ptg.theta);\n        }\n        else {\n            this.x = in_x;\n            this.y = in_y;\n            this.z = in_z;\n        }\n    }\n    getX() {\n        return this.x;\n    }\n    ;\n    getY() {\n        return this.y;\n    }\n    ;\n    getZ() {\n        return this.z;\n    }\n    ;\n    /** Scale the vector by a given factor\n    @param n the scale factor */\n    scale(n) {\n        this.x *= n;\n        this.y *= n;\n        this.z *= n;\n    }\n    ;\n    /** Vector cross product.\n    @param v another vector\n    @return the vector cross product between this vector and {@code v} */\n    cross(v) {\n        return new Vec3(this.y * v.z - v.y * this.z, this.z * v.x - v.z * this.x, this.x * v.y - v.x * this.y);\n    }\n    ;\n    /** Vector addition\n        * @param v the vector to be added\n        * @return addition result */\n    add(v) {\n        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    ;\n    /** Normalize the vector */\n    normalize() {\n        let d = 1. / this.length();\n        this.x *= d;\n        this.y *= d;\n        this.z *= d;\n    }\n    ;\n    /** Return normalized vector */\n    norm() {\n        let d = 1. / this.length();\n        return new Vec3(this.x * d, this.y * d, this.z * d);\n    }\n    ;\n    /** Vector length\n    @return the length of the vector. */\n    length() {\n        return Math.sqrt(this.lengthSquared());\n    }\n    ;\n    /** Squared vector length\n        @return the squared length of the vector. */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    ;\n    /** Computes the dot product of the this vector and {@code v1}.\n     * @param v1 another vector\n     * @return dot product */\n    dot(v1) {\n        return this.x * v1.x + this.y * v1.y + this.z * v1.z;\n    }\n    ;\n    /** Vector subtraction\n     * @param v the vector to be subtracted\n     * @return subtraction result */\n    sub(v) {\n        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    ;\n    /** Angle between two vectors.\n    @param v1 another vector\n    @return the angle in radians between this vector and {@code v1};\n      constrained to the range [0,PI]. */\n    angle(v1) {\n        return Hploc.atan2(this.cross(v1).length(), this.dot(v1));\n    }\n    /** Invert the signs of all components */\n    flip() {\n        this.x *= -1.0;\n        this.y *= -1.0;\n        this.z *= -1.0;\n    }\n    static pointing2Vec3(pointing) {\n        let sth = Hploc.sin(pointing.theta);\n        let x = sth * Hploc.cos(pointing.phi);\n        let y = sth * Hploc.sin(pointing.phi);\n        let z = Hploc.cos(pointing.theta);\n        return new Vec3(x, y, z);\n    }\n    ;\n}\n//# sourceMappingURL=Vec3.js.map","import { Vec3 } from './Vec3.js';\nexport class CircleFinder {\n    /**\n     * @param point: Vec3\n     */\n    constructor(point) {\n        let np = point.length;\n        //HealpixUtils.check(np>=2,\"too few points\");\n        if (!(np >= 2)) {\n            console.log(\"too few points\");\n            return;\n        }\n        this.center = point[0].add(point[1]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 2; i < np; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle(point, i);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q: int\n     */\n    getCircle(point, q) {\n        this.center = point[0].add(point[q]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 1; i < q; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle2(point, i, q);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q1: int\n     * @param q2: int\n     */\n    getCircle2(point, q1, q2) {\n        this.center = point[q1].add(point[q2]);\n        this.center.normalize();\n        this.cosrad = point[q1].dot(this.center);\n        for (let i = 0; i < q1; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.center = (point[q1].sub(point[i])).cross(point[q2].sub(point[i]));\n                this.center.normalize();\n                this.cosrad = point[i].dot(this.center);\n                if (this.cosrad < 0) {\n                    this.center.flip();\n                    this.cosrad = -this.cosrad;\n                }\n            }\n        }\n    }\n    ;\n    getCenter() {\n        return new Vec3(this.center.x, this.center.y, this.center.z);\n    }\n    getCosrad() {\n        return this.cosrad;\n    }\n    ;\n}\n//# sourceMappingURL=CircleFinder.js.map","/**\n * Partial porting to Javascript of Fxyf.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nexport class Fxyf {\n    constructor(x, y, f) {\n        this.fx = x;\n        this.fy = y;\n        this.face = f;\n        // coordinate of the lowest corner of each face\n        this.jrll = new Uint8Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Uint8Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.halfpi = Math.PI / 2.;\n    }\n    toHploc() {\n        let loc = new Hploc();\n        let jr = this.jrll[this.face] - this.fx - this.fy;\n        let nr;\n        if (jr < 1) {\n            nr = jr;\n            let tmp = nr * nr / 3.;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > 3) {\n            nr = 4 - jr;\n            let tmp = nr * nr / 3.;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = 1;\n            loc.z = (2 - jr) * 2.0 / 3.;\n        }\n        let tmp = this.jpll[this.face] * nr + this.fx - this.fy;\n        if (tmp < 0) {\n            tmp += 8;\n        }\n        if (tmp >= 8) {\n            tmp -= 8;\n        }\n        loc.phi = (nr < 1e-15) ? 0 : (0.5 * this.halfpi * tmp) / nr;\n        return loc;\n    }\n    ;\n    toVec3() {\n        return this.toHploc().toVec3();\n    }\n    ;\n}\n//# sourceMappingURL=Fxyf.js.map","export class pstack {\n    /** Creation from individual components */\n    constructor(sz) {\n        this.p = new Array(sz);\n        this.o = new Int32Array(sz);\n        this.s = 0;\n        this.m = 0;\n    }\n    ;\n    /**\n     * @param p long\n     * @param o int\n     */\n    push(p_, o_) {\n        this.p[this.s] = p_;\n        this.o[this.s] = o_;\n        ++this.s;\n    }\n    ;\n    pop() {\n        --this.s;\n    }\n    ;\n    popToMark() {\n        this.s = this.m;\n    }\n    ;\n    size() {\n        return this.s;\n    }\n    ;\n    mark() {\n        this.m = this.s;\n    }\n    ;\n    otop() {\n        return this.o[this.s - 1];\n    }\n    ;\n    ptop() {\n        return this.p[this.s - 1];\n    }\n    ;\n}\n//# sourceMappingURL=pstack.js.map","export class RangeSet {\n    /**\n     * @param int cap: initial capacity\n     */\n    constructor(cap) {\n        if (cap < 0)\n            console.error(\"capacity must be positive\");\n        this.r = new Int32Array(cap << 1);\n        this.sz = 0;\n    }\n    ;\n    /** Append a single-value range to the object.\n    @param val value to append */\n    append(val) {\n        this.append1(val, val + 1);\n    }\n    ;\n    /** Append a range to the object.\n   @param a first long in range\n   @param b one-after-last long in range */\n    append1(a, b) {\n        if (a >= b)\n            return;\n        if ((this.sz > 0) && (a <= this.r[this.sz - 1])) {\n            if (a < this.r[this.sz - 2])\n                console.error(\"bad append operation\");\n            if (b > this.r[this.sz - 1])\n                this.r[this.sz - 1] = b;\n            return;\n        }\n        // this.ensureCapacity(this.sz+2);\n        let cap = this.sz + 2;\n        if (this.r.length < cap) {\n            let newsize = Math.max(2 * this.r.length, cap);\n            let rnew = new Int32Array(newsize);\n            rnew.set(this.r);\n            this.r = rnew;\n        }\n        this.r[this.sz] = a;\n        this.r[this.sz + 1] = b;\n        this.sz += 2;\n    }\n    ;\n    /** Make sure the object can hold at least the given number of entries.\n     * @param cap int\n     * */\n    ensureCapacity(cap) {\n        if (this.r.length < cap)\n            this.resize(Math.max(2 * this.r.length, cap));\n    }\n    ;\n    /**\n     * @param newsize int\n     */\n    resize(newsize) {\n        if (newsize < this.sz)\n            console.error(\"requested array size too small\");\n        if (newsize == this.r.length)\n            return;\n        let rnew = new Int32Array(newsize);\n        let sliced = this.r.slice(0, this.sz + 1);\n        //\t\tthis.arrayCopy(this.r, 0, rnew, 0, this.sz);\n        this.r = sliced;\n    }\n    ;\n}\n//# sourceMappingURL=RangeSet.js.map","/**\n * Partial porting to Javascript of Xyf.java from Healpix3.30\n */\nexport class Xyf {\n    constructor(x, y, f) {\n        this.ix = x;\n        this.iy = y;\n        this.face = f;\n    }\n}\n//# sourceMappingURL=Xyf.js.map","\"use strict\";\nimport { CircleFinder } from \"./CircleFinder.js\";\nimport { Constants } from \"./Constants.js\";\nimport { Fxyf } from \"./Fxyf.js\";\nimport { Hploc } from \"./Hploc.js\";\nimport { Pointing } from \"./Pointing.js\";\nimport { pstack } from \"./pstack.js\";\nimport { RangeSet } from \"./RangeSet.js\";\nimport { Vec3 } from \"./Vec3.js\";\nimport { Xyf } from \"./Xyf.js\";\nimport { Zphi } from \"./Zphi.js\";\n/**\n * Partial porting to Javascript of HealpixBase.java from Healpix3.30\n */\n// import Fxyf from './Fxyf.js';\n// import Hploc from './Hploc.js';\n// import Xyf from './Xyf.js';\n// import Vec3 from './Vec3.js';\n// import Pointing from './Pointing.js';\n// import CircleFinder from './CircleFinder.js';\n// import Zphi from './Zphi.js';\n// import pstack from './pstack.js';\n// import Constants from './Constants.js';\n// import RangeSet from './RangeSet.js';\nexport class Healpix {\n    constructor(nside_in) {\n        this.order_max = 29;\n        this.inv_halfpi = 2.0 / Math.PI;\n        this.twothird = 2.0 / 3.;\n        // console.log(\"twothird \"+this.twothird);\n        // this.ns_max=1L<<order_max;\n        this.ns_max = Math.pow(2, this.order_max);\n        this.ctab = new Uint16Array([\n            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,\n            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,\n            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,\n            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,\n            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,\n            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,\n            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,\n            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,\n            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,\n            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,\n            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,\n            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,\n            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,\n            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,\n            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,\n            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855\n        ]);\n        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,\n            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,\n            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,\n            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,\n            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,\n            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,\n            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,\n            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,\n            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,\n            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,\n            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,\n            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,\n            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,\n            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,\n            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,\n            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,\n            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,\n            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);\n        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);\n        this.facearray = [\n            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),\n            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),\n            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),\n            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]),\n            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),\n            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),\n            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),\n            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),\n            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]) // N\n        ];\n        // questo forse deve essere un UInt8Array. Viene usato da neighbours\n        this.swaparray = [\n            new Int16Array([0, 0, 3]),\n            new Int16Array([0, 0, 6]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([0, 0, 5]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([5, 0, 0]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([6, 0, 0]),\n            new Int16Array([3, 0, 0]) // N\n        ];\n        if (nside_in <= this.ns_max && nside_in > 0) {\n            this.nside = nside_in;\n            this.npface = this.nside * this.nside;\n            this.npix = 12 * this.npface;\n            this.order = this.nside2order(this.nside);\n            this.nl2 = 2 * this.nside;\n            this.nl3 = 3 * this.nside;\n            this.nl4 = 4 * this.nside;\n            this.fact2 = 4.0 / this.npix;\n            this.fact1 = (this.nside << 1) * this.fact2;\n            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap\n            // console.log(\"order: \"+this.order);\n            // console.log(\"nside: \"+this.nside);\n        }\n        this.bn = [];\n        this.mpr = [];\n        this.cmpr = [];\n        this.smpr = [];\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // Uncaught RangeError: Maximum call stack size exceeded\n        // MOVED TO computeBn()\n        //        for (let i=0; i <= this.order_max; ++i) {\n        //        \tthis.bn[i]=new Healpix(1<<i);\n        //        \tthis.mpr[i]=bn[i].maxPixrad();\n        //        \tthis.cmpr[i]=Math.cos(mpr[i]);\n        //        \tthis.smpr[i]=Math.sin(mpr[i]);\n        //        }\n    }\n    computeBn() {\n        for (let i = 0; i <= this.order_max; ++i) {\n            this.bn[i] = new Healpix(1 << i);\n            this.mpr[i] = this.bn[i].maxPixrad();\n            this.cmpr[i] = Hploc.cos(this.mpr[i]);\n            this.smpr[i] = Hploc.sin(this.mpr[i]);\n        }\n    }\n    getNPix() {\n        return this.npix;\n    }\n    ;\n    getBoundaries(pix) {\n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        // console.log(\"PIXEL: \"+pix);\n        // console.log(\"XYF \"+xyf.ix+\" \"+xyf.iy+\" \"+xyf.face);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        // let d = 1.0/(this.nside);\n        // console.log(\"------------------------\");\n        // console.log(\"xc, yc, dc \"+xc+\",\"+ yc+\",\"+ dc);\n        // console.log(\"xc+dc-d, yc+dc, xyf.face, d \"+(xc+dc) +\",\"+ (yc+dc)+\",\"+\n        // xyf.face+\",\"+ d);\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        // console.log(\"Points for npix: \"+pix);\n        // console.log(points);\n        // if (pix > 750){\n        // console.log(\"pix: \"+pix);\n        // console.log(\"dc: \"+dc);\n        // console.log(\"xyf.ix: \"+xyf.ix);\n        // console.log(\"xyf.iy: \"+xyf.iy);\n        // console.log(\"xc: \"+xc);\n        // console.log(\"yc: \"+yc);\n        // console.log(\"d: \"+d);\n        // }\n        return points;\n    }\n    ;\n    /** Returns a set of points along the boundary of the given pixel.\n     * Step 1 gives 4 points on the corners. The first point corresponds\n     * to the northernmost corner, the subsequent points follow the pixel\n     * boundary through west, south and east corners.\n     *\n     * @param pix pixel index number\n     * @param step the number of returned points is 4*step\n     * @return {@link Vec3} for each point\n     */\n    getBoundariesWithStep(pix, step) {\n        // var points = new Array(); \n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        let d = 1.0 / (this.nside * step);\n        for (let i = 0; i < step; i++) {\n            points[i] = new Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();\n            points[i + step] = new Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();\n            points[i + 2 * step] = new Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();\n            points[i + 3 * step] = new Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();\n        }\n        return points;\n    }\n    ;\n    getPointsForXyfNoStep(x, y, face) {\n        let nside = Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    getPointsForXyf(x, y, step, face) {\n        let nside = step * Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    /** Returns the neighboring pixels of ipix.\n    This method works in both RING and NEST schemes, but is\n    considerably faster in the NEST scheme.\n    @param ipix the requested pixel number.\n    @return array with indices of the neighboring pixels.\n      The returned array contains (in this order)\n      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor\n      of ipix. If a neighbor does not exist (this can only happen\n      for the W, N, E and S neighbors), its entry is set to -1. */\n    neighbours(ipix) {\n        let result = new Int32Array(8);\n        let xyf = this.nest2xyf(ipix);\n        let ix = xyf.ix;\n        let iy = xyf.iy;\n        let face_num = xyf.face;\n        var nsm1 = this.nside - 1;\n        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {\n            let fpix = Math.floor(face_num << (2 * this.order));\n            let px0 = this.spread_bits(ix);\n            let py0 = this.spread_bits(iy) << 1;\n            let pxp = this.spread_bits(ix + 1);\n            let pyp = this.spread_bits(iy + 1) << 1;\n            let pxm = this.spread_bits(ix - 1);\n            let pym = this.spread_bits(iy - 1) << 1;\n            result[0] = fpix + pxm + py0;\n            result[1] = fpix + pxm + pyp;\n            result[2] = fpix + px0 + pyp;\n            result[3] = fpix + pxp + pyp;\n            result[4] = fpix + pxp + py0;\n            result[5] = fpix + pxp + pym;\n            result[6] = fpix + px0 + pym;\n            result[7] = fpix + pxm + pym;\n        }\n        else {\n            for (let i = 0; i < 8; ++i) {\n                let x = ix + this.xoffset[i];\n                let y = iy + this.yoffset[i];\n                let nbnum = 4;\n                if (x < 0) {\n                    x += this.nside;\n                    nbnum -= 1;\n                }\n                else if (x >= this.nside) {\n                    x -= this.nside;\n                    nbnum += 1;\n                }\n                if (y < 0) {\n                    y += this.nside;\n                    nbnum -= 3;\n                }\n                else if (y >= this.nside) {\n                    y -= this.nside;\n                    nbnum += 3;\n                }\n                let f = this.facearray[nbnum][face_num];\n                if (f >= 0) {\n                    let bits = this.swaparray[nbnum][face_num >>> 2];\n                    if ((bits & 1) > 0) {\n                        x = Math.floor(this.nside - x - 1);\n                    }\n                    if ((bits & 2) > 0) {\n                        y = Math.floor(this.nside - y - 1);\n                    }\n                    if ((bits & 4) > 0) {\n                        let tint = x;\n                        x = y;\n                        y = tint;\n                    }\n                    result[i] = this.xyf2nest(x, y, f);\n                }\n                else {\n                    result[i] = -1;\n                }\n            }\n        }\n        return result;\n    }\n    ;\n    nside2order(nside) {\n        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);\n    }\n    ;\n    nest2xyf(ipix) {\n        let pix = Math.floor(ipix & (this.npface - 1));\n        let xyf = new Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1), Math.floor((ipix >> (2 * this.order))));\n        return xyf;\n    }\n    ;\n    xyf2nest(ix, iy, face_num) {\n        return Math.floor(face_num << (2 * this.order))\n            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);\n    }\n    ;\n    loc2pix(hploc) {\n        let z = hploc.z;\n        let phi = hploc.phi;\n        let za = Math.abs(z);\n        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0); // in [0,4)\n        let pixNo;\n        if (za <= this.twothird) { // Equatorial region\n            let temp1 = this.nside * (0.5 + tt);\n            let temp2 = this.nside * (z * 0.75);\n            let jp = Math.floor(temp1 - temp2); // index of ascending edge line\n            let jm = Math.floor(temp1 + temp2); // index of descending edge line\n            let ifp = Math.floor(jp >>> this.order); // in {0,4}\n            let ifm = Math.floor(jm >>> this.order);\n            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));\n            let ix = Math.floor(jm & (this.nside - 1));\n            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);\n            pixNo = this.xyf2nest(ix, iy, face_num);\n        }\n        else { // polar region, za > 2/3\n            let ntt = Math.min(3, Math.floor(tt));\n            let tp = tt - ntt;\n            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?\n                this.nside * Math.sqrt(3 * (1 - za)) :\n                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);\n            let jp = Math.floor(tp * tmp); // increasing edge line index\n            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index\n            if (jp >= this.nside) {\n                jp = this.nside - 1; // for points too close to the boundary\n            }\n            if (jm >= this.nside) {\n                jm = this.nside - 1;\n            }\n            if (z >= 0) {\n                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);\n            }\n            else {\n                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);\n            }\n        }\n        return pixNo;\n    }\n    ;\n    /** Returns the normalized 3-vector corresponding to the center of the\n    supplied pixel.\n    @param pix long the requested pixel number.\n    @return the pixel's center coordinates. */\n    pix2vec(pix) {\n        return this.pix2loc(pix).toVec3();\n    }\n    ;\n    /** Returns the Zphi corresponding to the center of the supplied pixel.\n     @param pix the requested pixel number.\n     @return the pixel's center coordinates. */\n    pix2zphi(pix) {\n        return this.pix2loc(pix).toZphi();\n    }\n    /**\n     * @param pix long\n     * @return Hploc\n     */\n    pix2loc(pix) {\n        let loc = new Hploc(undefined);\n        let xyf = this.nest2xyf(pix);\n        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;\n        let nr;\n        if (jr < this.nside) {\n            nr = jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > this.nl3) {\n            nr = this.nl4 - jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = this.nside;\n            loc.z = (this.nl2 - jr) * this.fact1;\n        }\n        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;\n        //      \tassert(tmp<8*nr); // must not happen\n        if (tmp < 0) {\n            tmp += 8 * nr;\n        }\n        loc.phi = (nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp) / nr;\n        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);\n        return loc;\n    }\n    ;\n    ang2pix(ptg, mirror) {\n        return this.loc2pix(new Hploc(ptg));\n    }\n    ;\n    fmodulo(v1, v2) {\n        if (v1 >= 0) {\n            return (v1 < v2) ? v1 : v1 % v2;\n        }\n        var tmp = v1 % v2 + v2;\n        return (tmp === v2) ? 0.0 : tmp;\n    }\n    ;\n    compress_bits(v) {\n        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));\n        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);\n        return compressed;\n    }\n    ;\n    spread_bits(v) {\n        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))\n            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));\n    }\n    ;\n    /**\n     * Returns a range set of pixels that overlap with the convex polygon\n     * defined by the {@code vertex} array.\n     * <p>\n     * This method is more efficient in the RING scheme.\n     * <p>\n     * This method may return some pixels which don't overlap with the polygon\n     * at all. The higher {@code fact} is chosen, the fewer false positives are\n     * returned, at the cost of increased run time.\n     *\n     * @param vertex\n     *            an array containing the vertices of the requested convex\n     *            polygon.\n     * @param fact\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return the requested set of pixel number ranges\n     */\n    queryPolygonInclusive(vertex, fact) {\n        let inclusive = (fact != 0);\n        let nv = vertex.length;\n        //        let ncirc = inclusive ? nv+1 : nv;\n        if (!(nv >= 3)) {\n            console.log(\"not enough vertices in polygon\");\n            return;\n        }\n        let vv = new Array();\n        for (let i = 0; i < nv; ++i) {\n            vv[i] = Vec3.pointing2Vec3(vertex[i]);\n        }\n        let normal = new Array();\n        let flip = 0;\n        let index = 0;\n        let back = false;\n        while (index < vv.length) {\n            let first = vv[index];\n            let medium = null;\n            let last = null;\n            if (index == vv.length - 1) {\n                last = vv[1];\n                medium = vv[0];\n            }\n            else if (index == vv.length - 2) {\n                last = vv[0];\n                medium = vv[index + 1];\n            }\n            else {\n                medium = vv[index + 1];\n                last = vv[index + 2];\n            }\n            normal[index] = first.cross(medium).norm();\n            let hnd = normal[index].dot(last);\n            if (index == 0) {\n                flip = (hnd < 0.) ? -1 : 1;\n                let tmp = new Pointing(first); // TODO not used\n                back = false;\n            }\n            else {\n                let flipThnd = flip * hnd;\n                if (flipThnd < 0) {\n                    let tmp = new Pointing(medium);\n                    vv.splice(index + 1, 1);\n                    normal.splice(index, 1);\n                    back = true;\n                    index -= 1;\n                    continue;\n                }\n                else {\n                    let tmp = new Pointing(first);\n                    back = false;\n                }\n            }\n            normal[index].scale(flip);\n            index += 1;\n        }\n        nv = vv.length;\n        let ncirc = inclusive ? nv + 1 : nv;\n        let rad = new Array(ncirc);\n        rad = rad.fill(Constants.halfpi);\n        //        rad = rad.fill(1.5707963267948966);\n        //        let p = \"1.5707963267948966\";\n        //        rad = rad.fill(parseFloat(p));\n        if (inclusive) {\n            let cf = new CircleFinder(vv);\n            normal[nv] = cf.getCenter();\n            rad[nv] = Hploc.acos(cf.getCosrad());\n        }\n        return this.queryMultiDisc(normal, rad, fact);\n    }\n    ;\n    /**\n     * For NEST schema only\n     *\n     * @param normal:\n     *            Vec3[]\n     * @param rad:\n     *            Float32Array\n     * @param fact:\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return RangeSet the requested set of pixel number ranges\n     */\n    queryMultiDisc(norm, rad, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let nv = norm.length;\n        // HealpixUtils.check(nv==rad.lengt0,\"inconsistent input arrays\");\n        if (!(nv == rad.length)) {\n            console.error(\"inconsistent input arrays\");\n            return;\n        }\n        let res = new RangeSet(4 << 1);\n        // Removed code for Scheme.RING\n        let oplus = 0;\n        if (inclusive) {\n            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {\n                console.error(\"invalid oversampling factor\");\n            }\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = this.order + oplus; // the order up to which we test\n        // TODO: ignore all disks with radius>=pi\n        //        let crlimit = new Float32Array[omax+1][nv][3];\n        let crlimit = new Array(omax + 1);\n        let o;\n        let i;\n        for (o = 0; o <= omax; ++o) { // prepare data at the required orders\n            crlimit[o] = new Array(nv);\n            let dr = this.bn[o].maxPixrad(); // safety distance\n            for (i = 0; i < nv; ++i) {\n                crlimit[o][i] = new Float64Array(3);\n                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Hploc.cos(rad[i] + dr);\n                crlimit[o][i][1] = (o == 0) ? Hploc.cos(rad[i]) : crlimit[0][i][1];\n                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : Hploc.cos(rad[i] - dr);\n            }\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse\n            // order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let o = stk.otop();\n            stk.pop();\n            let pv = this.bn[o].pix2vec(pix);\n            let zone = 3;\n            for (let i = 0; (i < nv) && (zone > 0); ++i) {\n                let crad = pv.dot(norm[i]);\n                for (let iz = 0; iz < zone; ++iz) {\n                    if (crad < crlimit[o][i][iz]) {\n                        zone = iz;\n                    }\n                }\n            }\n            if (zone > 0) {\n                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);\n            }\n        }\n        return res;\n    }\n    ;\n    /** Integer base 2 logarithm.\n    @param arg\n    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.\n    For negative arguments and zero, 0 is returned. */\n    ilog2(arg) {\n        let max = Math.max(arg, 1);\n        return 31 - Math.clz32(max);\n    }\n    ;\n    /** Computes the cosine of the angular distance between two z, phi positions\n      on the unit sphere. */\n    cosdist_zphi(z1, phi1, z2, phi2) {\n        return z1 * z2 + Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));\n    }\n    /**\n     * @param int o\n     * @param int omax\n     * @param int zone\n     * @param RangeSet pixset\n     * @param long pix\n     * @param pstack stk\n     * @param boolean inclusive\n     */\n    check_pixel(o, omax, zone, pixset, pix, stk, inclusive) {\n        if (zone == 0)\n            return;\n        if (o < this.order) {\n            if (zone >= 3) { // output all subpixels\n                let sdist = 2 * (this.order - o); // the \"bit-shift distance\" between map orders\n                pixset.append1(pix << sdist, ((pix + 1) << sdist));\n            }\n            else { // (zone>=1)\n                for (let i = 0; i < 4; ++i) {\n                    stk.push(4 * pix + 3 - i, o + 1); // add children\n                }\n            }\n        }\n        else if (o > this.order) { // this implies that inclusive==true\n            if (zone >= 2) { // pixel center in shape\n                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                stk.popToMark(); // unwind the stack\n            }\n            else { // (zone>=1): pixel center in safety range\n                if (o < omax) { // check sublevels\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                    stk.popToMark(); // unwind the stack\n                }\n            }\n        }\n        else { // o==order\n            if (zone >= 2) {\n                pixset.append(pix);\n            }\n            else if (inclusive) { // and (zone>=1)\n                if (this.order < omax) { // check sublevels\n                    stk.mark(); // remember current stack position\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix); // output the pixel\n                }\n            }\n        }\n    }\n    /** Returns the maximum angular distance between a pixel center and its\n    corners.\n    @return maximum angular distance between a pixel center and its\n      corners. */\n    maxPixrad() {\n        let zphia = new Zphi(2. / 3., Math.PI / this.nl4);\n        let xyz1 = this.convertZphi2xyz(zphia);\n        let va = new Vec3(xyz1[0], xyz1[1], xyz1[2]);\n        let t1 = 1. - 1. / this.nside;\n        t1 *= t1;\n        let zphib = new Zphi(1 - t1 / 3, 0);\n        let xyz2 = this.convertZphi2xyz(zphib);\n        let vb = new Vec3(xyz2[0], xyz2[1], xyz2[2]);\n        return va.angle(vb);\n    }\n    ;\n    /**\n     * this is a workaround replacing the Vec3(Zphi) constructor.\n     */\n    convertZphi2xyz(zphi) {\n        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));\n        let x = sth * Hploc.cos(zphi.phi);\n        let y = sth * Hploc.sin(zphi.phi);\n        let z = zphi.z;\n        return [x, y, z];\n    }\n    ;\n    /** Returns a range set of pixels which overlap with a given disk. <p>\n      This method is more efficient in the RING scheme. <p>\n      This method may return some pixels which don't overlap with\n      the polygon at all. The higher {@code fact} is chosen, the fewer false\n      positives are returned, at the cost of increased run time.\n      @param ptg the angular coordinates of the disk center\n      @param radius the radius (in radians) of the disk\n      @param fact The overlapping test will be done at the resolution\n        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power\n        of 2, else it can be any positive integer. A typical choice would be 4.\n      @return the requested set of pixel number ranges  */\n    queryDiscInclusive(ptg, radius, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let pixset = new RangeSet();\n        if (radius >= Math.PI) { // disk covers the whole sphere\n            pixset.append1(0, this.npix);\n            return pixset;\n        }\n        let oplus = 0;\n        if (inclusive) {\n            // HealpixUtils.check ((1L<<order_max)>=fact,\"invalid oversampling factor\");\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test\n        let vptg = Vec3.pointing2Vec3(ptg);\n        let crpdr = new Array(omax + 1);\n        let crmdr = new Array(omax + 1);\n        let cosrad = Hploc.cos(radius);\n        let sinrad = Hploc.sin(radius);\n        for (let o = 0; o <= omax; o++) { // prepare data at the required orders\n            let dr = this.mpr[o]; // safety distance\n            let cdr = this.cmpr[o];\n            let sdr = this.smpr[o];\n            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;\n            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let curro = stk.otop();\n            stk.pop();\n            let pos = this.bn[curro].pix2zphi(pix);\n            // cosine of angular distance between pixel center and disk center\n            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);\n            if (cangdist > crpdr[curro]) {\n                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);\n                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);\n            }\n        }\n        return pixset;\n    }\n}\n//# sourceMappingURL=Healpix.js.map","\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { Healpix } from 'healpixjs';\nimport { Pointing } from \"healpixjs\";\nimport { Hploc } from \"healpixjs\";\n\nimport { radToDeg } from '../model/Utils.js'; // TODO change package\nimport { CoordsType } from \"../model/CoordsType.js\";\nimport { HEALPixXYSpace } from \"../model/HEALPixXYSpace.js\";\nimport { Point } from \"../model/Point.js\";\nimport { SphericalCoords } from \"../model/SphericalCoords.js\";\nimport { NumberType } from '../model/NumberType.js';\nimport { AstroCoords } from \"../model/AstroCoords.js\";\nimport { EquatorialCoords } from \"../model/EquatorialCoords.js\";\n\nexport class HiPSHelper {\n\n\n\t// static pxXtile: number = 512; // TODO in some cases it is different\n\tstatic DEFAULT_Naxis1_2: number = 512;\n\t// static RES_ORDER_0: number = 58.6 / HiPSHelper.pxXtile;\n\tstatic RES_ORDER_0: number = 58.6;\n\tstatic H: number = 4;\n\tstatic K: number = 3;\n\tstatic THETAX: number = Hploc.asin((HiPSHelper.K - 1) / HiPSHelper.K);\n\t/**\n\t * Table 1 - ref paper HEALPix — a Framework for High Resolution Discretization,\n\t * and Fast Analysis of Data Distributed on the Sphere\n\t * K. M. G´orski1,2, E. Hivon3,4, A. J. Banday5, B. D. Wandelt6,7, F. K. Hansen8, M.\n\t * Reinecke5, M. Bartelman9\n\t */\n\t/**\n\t * \n\t * @param {decimal degrees} pxsize \n\t * @returns {int} nside\n\t */\n\tstatic computeHiPSOrder(pxsize: number, pxXtile: number): number {\n\t\t/**\n\t\t * with same order k (table 1), HIPS angular resolution is higher of order of 512 (2^9) pixels than \n\t\t * the HEALPix. This is because each tile in a HiPS is represented by default by 512x512 pixels.\\\n\t\t * Angular resolution of different HEALPix orders in respect to the order 0, can be calculated this\n\t\t * way:\n\t\t * \n\t\t * \tL(k) = L(0) / 2^k = 58.6 / 2^k\n\t\t * \n\t\t * Therefore, in the case of HiPS we need to take into account the extra resolution given by the \n\t\t * 512x512 (2^9) tiles. In this case the above becomes:\n\t\t * \t\n\t\t * \tL(k) = L(0) / (2^k * 2^9) \n\t\t * \n\t\t * Though, in order to compute the required order starting from the pxsize desired (in input) we\n\t\t * need to perform these steps:\n\t\t * \n\t\t * \tpxsize = L(k) = L(0) / (2^k * 2^9)\n\t\t * \t2^k = L(0) / (pxsize * 2^9)\n\t\t *  k * Log2 2 = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \tk = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \n\t\t */\n\n\n\t\tlet k = Math.log2( (HiPSHelper.RES_ORDER_0 / pxXtile) / pxsize);\n\t\t// let k = Math.log2(HiPSHelper.RES_ORDER_0 / (pxXtile * pxsize));\n\t\tk = Math.round(k);\n\t\t// let theta0px = HiPSHelper.RES_ORDER_0;\n\t\t// let k = Math.log2(theta0px) - Math.log2(pxsize * 2**9);\n\t\t// k = Match.round(k);\n\t\t// let nside = 2**k;\n\t\t// return {\n\t\t//     \"nside\" : nside,\n\t\t//     \"norder\" : k\n\t\t// };\n\t\treturn k;\n\n\t}\n\tstatic computeHiPSOrder2(pxsize: number, pxXtile: number): number {\n\t\t\n\t\tconst k = Math.log2( Math.sqrt(Math.PI/ 3) / ( pxsize * pxXtile) )\n\t\tconst order = Math.round(k);\n\t\tconsole.warn(k)\n \n\t\treturn order;\n\n\t}\n\n\n\t// based on \"HiPS – Hierarchical Progressive Survey\" IVOA recomandation (formula on table 5)\n\tstatic computeOrder(pxAngSizeDeg: number, pxTileWidth: number): number {\n\t\tconsole.log(`Computing HiPS order having pixel angular size of ${pxAngSizeDeg} in degrees`)\n\t\tconst deg2rad = Math.PI / 180\n\t\tconst pxAngSizeRad = pxAngSizeDeg * deg2rad\n\t\tconsole.log(`pixel angular res in radians ${pxAngSizeRad}`)\n\t\tconst computedOrder = 0.5 * Math.log2 ( Math.PI / (3 * pxAngSizeRad * pxAngSizeRad * pxTileWidth * pxTileWidth) )\n\t\tconsole.log(`Order ${computedOrder}`)\n\t\tif (computedOrder < 0) {\n\t\t\treturn 0\n\t\t}\n\t\treturn Math.floor(computedOrder)\n\t}\n\n\t// based on \"HiPS – Hierarchical Progressive Survey\" IVOA recomandation (formula on table 5)\n\tstatic computePxAngularSize(pxTileWidth: number, order: number) {\n\t\tconst computedPxAngSizeRadiant = Math.sqrt( 4 * Math.PI / (12 * (pxTileWidth * (2**order) )**2 ) )\n\t\tconsole.log(`Computing Pixel size with tile of ${pxTileWidth} pixels and order ${order}`)\n\t\tconst rad2deg = 180 / Math.PI\n\t\tconst deg = computedPxAngSizeRadiant * rad2deg\n\t\tconst arcmin = computedPxAngSizeRadiant * rad2deg * 60\n\t\tconst arcsec = computedPxAngSizeRadiant * rad2deg * 3600\n\t\tconsole.log (\"Pixel size in radiant:\" + computedPxAngSizeRadiant)\n\t\tconsole.log (\"Pixel size in degrees:\" + deg)\n\t\tconsole.log (\"Pixel size in arcmin:\" + arcmin)\n\t\tconsole.log (\"Pixel size in arcsec:\" + arcsec)\n\t\treturn {\n\t\t\t\"rad\": computedPxAngSizeRadiant,\n\t\t\t\"deg\": deg,\n\t\t\t\"arcmin\": arcmin,\n\t\t\t\"arcsec\": arcsec\n\t\t}\n\t}\n\n\n\t/**\n\t * Reference: HiPS – Hierarchical Progressive Survey page 11\n\t * pxsize =~ sqrt[4 * PI / (12 * (512 * 2^order)^2)]\n\t * @param {*} order \n\t */\n\tstatic computePxSize(order: number, pxXtile: number): number {\n\t\t// TODO CHECK IT\n\t\t// let pxsize = 1 / (512 * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\tlet pxsize = 1 / (pxXtile * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\treturn pxsize;\n\t}\n\n\t// /**\n\t//  * \n\t//  * @param {Object {ra, dec}} point  decimal degrees\n\t//  * @returns {Object {phi_rad, theta_rad}} in radians\n\t//  */\n\t// static convert2PhiTheta (point: Point) {\n\t// \tlet phitheta_rad = {};\n\t// \tlet phiTheta_deg = HiPSHelper.astroDegToSpherical(point.ra, point.dec);\n\t// \tphitheta_rad.phi_rad = HiPSHelper.degToRad(phiTheta_deg.phi);\n\t//     phitheta_rad.theta_rad = HiPSHelper.degToRad(phiTheta_deg.theta);\n\t// \treturn phitheta_rad;\n\t// }\n\n\t// static astroDegToSphericalRad(raDeg: number, decDeg: number) {\n\t// \tlet phiThetaDeg = HiPSHelper.astroDegToSpherical(raDeg, decDeg);\n\t// \tlet phiThetaRad = {\n\t// \t\tphi_rad: HiPSHelper.degToRad(phiThetaDeg.phi),\n\t// \t\ttheta_rad: HiPSHelper.degToRad(phiThetaDeg.theta)\n\t// \t}\n\t// \treturn phiThetaRad;\n\t// }\n\n\t// static degToRad(degrees: number): number {\n\t// \treturn (degrees / 180 ) * Math.PI ;\n\t// }\n\n\t// static radToDeg(rad: number): number {\n\t// \treturn (rad / Math.PI ) * 180 ;\n\t// }\n\n\t// static astroDegToSpherical(raDeg: number, decDeg: number): Point{\n\n\t// \tlet phiDeg: number;\n\t// \tlet thetaDeg: number;\n\t// \tphiDeg = raDeg;\n\t// \tif (phiDeg < 0){\n\t// \t\tphiDeg += 360;\n\t// \t}\n\n\t// \tthetaDeg = 90 - decDeg;\n\n\t// \treturn {\n\t// \t\tphi: phiDeg,\n\t// \t\ttheta: thetaDeg\n\t// \t};\n\t// }\n\n\t/**\n\t * \n\t * @param {Object {phi_rad, theta_rad}} phiTheta_rad Center of the circle in radians\n\t * @param {decimal} r Radius of the circle in radians\n\t * @returns \n\t */\n\tstatic computeBbox(point: Point, r: number): number[] {\n\n\t\tlet bbox = [];\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad + r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\n\t\treturn bbox;\n\t}\n\n\tstatic setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n\n\t\tlet xyGridProj: HEALPixXYSpace = {\n\t\t\t\"min_y\": NaN,\n\t\t\t\"max_y\": NaN,\n\t\t\t\"min_x\": NaN,\n\t\t\t\"max_x\": NaN,\n\t\t\t\"gridPointsDeg\": []\n\t\t}\n\n\n\t\tlet cornersVec3 = hp.getBoundariesWithStep(tileno, 1);\n\t\tlet pointings = [];\n\n\t\tfor (let i = 0; i < cornersVec3.length; i++) {\n\t\t\tpointings[i] = new Pointing(cornersVec3[i]);\n\t\t\tif (i >= 1) {\n\t\t\t\tlet a = pointings[i - 1].phi;\n\t\t\t\tlet b = pointings[i].phi;\n\t\t\t\t// case when RA is just crossing the origin (e.g. 357deg - 3deg)\n\t\t\t\tif (Math.abs(a - b) > Math.PI) {\n\t\t\t\t\tif (pointings[i - 1].phi < pointings[i].phi) {\n\t\t\t\t\t\tpointings[i - 1].phi += 2 * Math.PI;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpointings[i].phi += 2 * Math.PI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let j = 0; j < pointings.length; j++) {\n\t\t\tlet coThetaRad = pointings[j].theta;\n\t\t\t// HEALPix works with colatitude (0 North Pole, 180 South Pole)\n\t\t\t// converting the colatitude in latitude (dec)\n\t\t\tlet decRad = Math.PI / 2 - coThetaRad;\n\n\t\t\tlet raRad = pointings[j].phi;\n\n\t\t\t// projection on healpix grid\n\t\t\tlet p = new Point(CoordsType.ASTRO, NumberType.RADIANS, raRad, decRad);\n\t\t\tlet xyDeg = HiPSHelper.world2intermediate(p.astro);\n\t\t\txyGridProj.gridPointsDeg[j * 2] = xyDeg[0];\n\t\t\txyGridProj.gridPointsDeg[j * 2 + 1] = xyDeg[1];\n\n\t\t\tif (isNaN(xyGridProj.max_y) || xyDeg[1] > xyGridProj.max_y) {\n\t\t\t\txyGridProj.max_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_y) || xyDeg[1] < xyGridProj.min_y) {\n\t\t\t\txyGridProj.min_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.max_x) || xyDeg[0] > xyGridProj.max_x) {\n\t\t\t\txyGridProj.max_x = xyDeg[0];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_x) || xyDeg[0] < xyGridProj.min_x) {\n\t\t\t\txyGridProj.min_x = xyDeg[0];\n\t\t\t}\n\n\t\t}\n\t\treturn xyGridProj;\n\t}\n\n\tstatic world2intermediate(ac: AstroCoords): [number, number] {\n\n\t\tlet x_grid: number;\n\t\tlet y_grid: number;\n\n\t\tif (Math.abs(ac.decRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t\t\tx_grid = ac.raDeg;\n\n\t\t\ty_grid = Hploc.sin(ac.decRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t\t} else if (Math.abs(ac.decRad) > HiPSHelper.THETAX) { // polar zones\n\n\t\t\tlet raDeg = ac.raDeg;\n\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\n\t\t\tlet sigma = Math.sqrt(HiPSHelper.K * (1 - Math.abs(Hploc.sin(ac.decRad))));\n\t\t\tlet phi_c = - 180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSHelper.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSHelper.H);\n\n\t\t\tx_grid = phi_c + (raDeg - phi_c) * sigma;\n\t\t\ty_grid = (180 / HiPSHelper.H) * (((HiPSHelper.K + 1) / 2) - sigma);\n\n\t\t\tif (ac.decRad < 0) {\n\t\t\t\ty_grid *= -1;\n\t\t\t}\n\t\t}\n\n\t\treturn [x_grid, y_grid];\n\n\t}\n\n\t// static world2intermediate(sc: SphericalCoords): [number, number] {\n\t//     let x_grid: number;\n\t// \tlet y_grid: number;\n\n\t// \tif ( Math.abs(sc.thetaRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t// \t\tx_grid = sc.phiDeg;\n\n\t// \t\ty_grid = Hploc.sin(sc.thetaRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t// \t} else if ( Math.abs(sc.thetaRad) > HiPSHelper.THETAX) { // polar zones\n\n\t// \t\tlet phiDeg = sc.phiDeg;\n\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || sc.thetaRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\n\t// \t\tlet sigma = Math.sqrt( HiPSHelper.K * (1 - Math.abs(Hploc.sin(sc.thetaRad)) ) );\n\t// \t\tlet phi_c = - 180 + ( 2 * Math.floor( ((sc.phiRad + 180) * HiPSHelper.H/360) + ((1 - w)/2) ) + w ) * ( 180 / HiPSHelper.H );\n\n\t// \t\tx_grid = phi_c + (phiDeg - phi_c) * sigma;\n\t// \t\ty_grid = (180  / HiPSHelper.H) * ( ((HiPSHelper.K + 1)/2) - sigma);\n\n\t// \t\tif (sc.thetaRad < 0) {\n\t// \t\t\ty_grid *= -1;\n\t// \t\t}\n\t// \t}\n\n\t// \treturn [x_grid, y_grid];\n\n\t// }\n\n\tstatic intermediate2pix(x: number, y: number, xyGridProj: HEALPixXYSpace, pxXtile: number): [number, number] {\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);\n\n\t\tlet i_norm: number;\n\t\tlet j_norm: number;\n\t\tif ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {\n\t\t\ti_norm = (x + 360 - xyGridProj.min_x) / xInterval;\n\t\t} else {\n\t\t\ti_norm = (x - xyGridProj.min_x) / xInterval;\n\t\t}\n\t\tj_norm = (y - xyGridProj.min_y) / yInterval;\n\n\n\t\tlet i = 0.5 - (i_norm - j_norm);\n\t\tlet j = (i_norm + j_norm) - 0.5;\n\n\t\t// TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);\n\t\tpxXtile\n\t\t// i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];\n\t\t\n\t\ti = Math.floor(i * pxXtile);\n\t\tj = Math.floor(j * pxXtile);\n\t\treturn [i, pxXtile - j - 1];\n\n\n\n\t}\n\n\n\tstatic pix2intermediate(i: number, j: number, xyGridProj: HEALPixXYSpace, naxis1: number, naxis2: number): [number, number] {\n\t\t/**\n\t\t   * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image\n\t\t * (i_norm,w_pixel) = (1,1) is the upper right corner\n\t\t * dimamond in figure 1 from \"Mapping on the HEalpix grid\" paper\n\t\t * (0,0) leftmost corner\n\t\t * (1,0) upper corner\n\t\t * (0,1) lowest corner\n\t\t * (1,1) rightmost corner\n\t\t * Thanks YAGO! :p\n\t\t */\n\t\t// let cnaxis1 = HiPSHelper.pxXtile;\n\t\t// let cnaxis2 = HiPSHelper.pxXtile;\n\n\t\tlet cnaxis1 = naxis1;\n\t\tlet cnaxis2 = naxis2;\n\t\tif (naxis1) {\n\t\t\tcnaxis1 = naxis1;\n\t\t}\n\t\tif (naxis2) {\n\t\t\tcnaxis2 = naxis2;\n\t\t}\n\t\tlet i_norm = (i + 0.5) / cnaxis1;\n\t\tlet j_norm = (j + 0.5) / cnaxis2;\n\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;\n\t\tlet yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;\n\n\t\t// bi-linear interpolation\n\t\tlet x = xyGridProj.max_x - xInterval * (i_norm + j_norm);\n\t\tlet y = yMean - yInterval * (j_norm - i_norm);\n\n\t\treturn [x, y];\n\t}\n\n\n\tstatic intermediate2world(x: number, y: number): Point {\n\n\t\tlet phiDeg: number;\n\t\tlet thetaDeg: number;\n\t\tlet Yx = 90 * (HiPSHelper.K - 1) / HiPSHelper.H;\n\n\n\n\t\tif (Math.abs(y) <= Yx) { // equatorial belts\n\n\t\t\tphiDeg = x;\n\t\t\tthetaDeg = radToDeg(Math.asin((y * HiPSHelper.H) / (90 * HiPSHelper.K)));\n\n\t\t} else if (Math.abs(y) > Yx) { // polar regions\n\n\t\t\tlet sigma = (HiPSHelper.K + 1) / 2 - Math.abs(y * HiPSHelper.H) / 180;\n\t\t\tlet thetaRad = Hploc.asin(1 - (sigma * sigma) / HiPSHelper.K);\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\t\t\tlet x_c = -180 + (2 * Math.floor((x + 180) * HiPSHelper.H / 360 + (1 - w) / 2) + w) * (180 / HiPSHelper.H);\n\t\t\tphiDeg = x_c + (x - x_c) / sigma;\n\t\t\tthetaDeg = radToDeg(thetaRad);\n\t\t\tif (y <= 0) {\n\t\t\t\tthetaDeg *= -1;\n\t\t\t}\n\t\t}\n\t\t// return [phiDeg, thetaDeg];\n\t\t// TODO CHECK THIS!\n\t\t// let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);\n\t\tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, phiDeg, thetaDeg);\n\n\t\treturn p;\n\n\t}\n\n}\n","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\n\nimport { Healpix } from \"healpixjs\";\nimport { Pointing } from \"healpixjs\";\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { HEALPixXYSpace } from '../model/HEALPixXYSpace.js';\n\nimport { HiPSHelper } from './HiPSHelper.js';\n\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { astroToSpherical, degToRad, fillAstro, radToDeg } from '../model/Utils.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\nimport { INSPECT_MAX_BYTES } from 'buffer';\nimport { FITS } from '../model/FITS.js';\n\n\n\nexport class HiPSProjection extends AbstractProjection {\n\t\n\t// _naxis1!: number;\n\t// _naxis2!: number;\n\t_isGalactic: boolean = false;\n\t_pixno!: number;\n\t_tileslist!: number[];\n\t_hp!: Healpix;\n\t_fh_common!: FITSHeader;\n\t// _ctype1: string; // TODO should be RA ENUM\n\t// _ctype2: string; // TODO should be Dec ENUM\n\t_wcsname: string;\n\t_hipsBaseURI!: string;\n\t// _pxsize!: number;\n\t_fitsheaderlist: FITSHeader[];\n\t_pxvalues: Map<number, Array<Uint8Array>>;\n\t_xyGridProj!: HEALPixXYSpace;\n\t_norder!: number;\n\t_nside!: number;\n\t_radeclist: Array<[number, number]>;\n\t_HIPS_TILE_WIDTH: number;\n\t_fitsUsed: String[] = [];\n\t_HIPS_MAX_ORDER: number;\n\n\t/**\n\t * \n\t * * ex with single local file:\n\t * let hp = new HiPSProjection('/mylocaldir/myfile.fits', null, null, null);\n\t * hp.initFromFile()\n\t * \n\t * * ex with single remote file:\n\t * let hp = new HiPSProjection('http://<hips-server>/Norder7/DirN/NpixXYZ.fits', null, null, null);\n\t * hp.initFromFile()\n\t *\n\t * * ex with HiPS server base local dir:\n\t * let hp = new HiPSProjection(null, <hips-local-root-dir>, pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t * * ex with HiPS server base URL:\n\t * let hp = new HiPSProjection(null, 'http://<hips-server>/<hips-root-dir>', pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t */\n\n\n\t//  constructor(fitsfilepath?: string, hipsBaseURI?: string, pxsize?: number, order?: number) {\n\tconstructor() {\n\t\tsuper(\"'RA---HPX'\", \"'DEC--HPX'\")\n\t\tthis._wcsname = \"HPX\"; // TODO check WCS standard\n\t\t// this._ctype1 = \"RA---HPX\";\n\t\t// this._ctype2 = \"DEC--HPX\";\n\n\t\tthis._pxvalues = new Map<number, Array<Uint8Array>>();\n\t\tthis._fitsheaderlist = new Array<FITSHeader>();\n\t\tthis._radeclist = new Array<[number, number]>();\n\n\t}\n\n\tasync parsePropertiesFile(baseUrl: string): Promise<any> {\n\t\tconst fp = new FITSParser(null);\n\n\t\tconst promise = fp.getFile(baseUrl + \"/properties\").then((propFile: ArrayBuffer | Buffer) => {\n\t\t\tlet prop: string;\n\t\t\tif (propFile instanceof ArrayBuffer) {\n\t\t\t\tconst textDecoder = new TextDecoder(\"iso-8859-1\");\n\t\t\t\tprop = textDecoder.decode(new Uint8Array(propFile));\n\t\t\t} else {\n\t\t\t\tprop = propFile.toString('utf8');\n\t\t\t}\n\t\t\t/**\n\t\t\t \tHiPS – Hierarchical Progressive Survey\n\t\t\t\tVersion 1.0\n\t\t\t\tIVOA Proposed Recommendation\n\t\t\t\t3rd April 2017\n\t\t\t\thttps://www.ivoa.net/documents/HiPS/20170403/PR-HIPS-1.0-20170403.pdf\n\t\t\t */\n\t\t\tconst txtArr = prop.split('\\n');\n\t\t\tthis._HIPS_TILE_WIDTH = 512;\n\t\t\tfor (let line of txtArr) {\n\t\t\t\tif (!line.includes(\"=\")){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst tokens = line.split(\"=\");\n\t\t\t\tif (tokens[1] === undefined){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst key = tokens[0].trim()\n\t\t\t\tconst val = tokens[1].trim()\n\n\t\t\t\tif (key == \"hips_order\") {\n\t\t\t\t\tthis._HIPS_MAX_ORDER = parseInt(val);\n\t\t\t\t\tconsole.log(\"hips_order \"+this._HIPS_MAX_ORDER)\n\t\t\t\t} else if (key == \"hips_tile_width\") {\n\t\t\t\t\tthis._HIPS_TILE_WIDTH = parseInt(val);\n\t\t\t\t\tsuper.naxis1 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tsuper.naxis2 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tconsole.log(\"hips_tile_width \"+this._HIPS_TILE_WIDTH)\n\t\t\t\t} else if (key == \"hips_frame\" && val == \"galactic\") {\n\t\t\t\t\tthis._isGalactic = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn propFile;\n\t\t});\n\n\t\tawait promise;\n\t\treturn promise;\n\t}\n\n\tasync initFromFile(fitsfilepath: string): Promise<FITSParsed> {\n\t\tlet fp = new FITSParser(fitsfilepath);\n\n\t\tlet promise = fp.loadFITS().then(fits => {\n\t\t\tthis._pxvalues.set(0, fits.data);\n\t\t\tthis._fitsheaderlist[0] = fits.header;\n\n\t\t\tlet order = fits.header.get(\"ORDER\");\n\t\t\tthis.init(order);\n\n\t\t\tsuper.naxis1 = fits.header.get(\"NAXIS1\");\n\t\t\tsuper.naxis2 = fits.header.get(\"NAXIS2\");\n\t\t\tthis._HIPS_TILE_WIDTH = super.naxis1;\n\n\t\t\tthis._pixno = fits.header.get(\"NPIX\");\n\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(this._pixno, this._hp);\n\t\t\treturn fits;\n\t\t});\n\t\tawait promise;\n\t\treturn promise;\n\t}\n\n\n\n\tasync initFromHiPSLocationAndPxSize(baseUrl: string, pxsize: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tsuper.pxsize = pxsize;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\t// let order = HiPSHelper.computeHiPSOrder(pxsize, this._HIPS_TILE_WIDTH);\n\t\t// let order2 = HiPSHelper.computeHiPSOrder2(pxsize, this._HIPS_TILE_WIDTH);\n\t\tlet order = HiPSHelper.computeOrder(pxsize, this._HIPS_TILE_WIDTH);\n\t\tif (order > this._HIPS_MAX_ORDER) {\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tthis.init(order);\n\t}\n\n\tasync initFromHiPSLocationAndOrder(baseUrl: string, order: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\tif (order > this._HIPS_MAX_ORDER){\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tsuper.pxsize = HiPSHelper.computePxSize(order, this._HIPS_TILE_WIDTH);\n\t\tthis.init(order);\n\t}\n\n\tinit(order: number) {\n\t\tthis._norder = order;\n\t\tthis._nside = 2 ** order;\n\t\tthis._hp = new Healpix(this._nside);\n\t}\n\n\tprepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\t\tfor (let header of this._fitsheaderlist) {\n\n\t\t\theader.addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n\t\t\theader.addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n\t\t\tif (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n\t\t\t}\n\t\t\tlet bscale = 1.0;\n\t\t\tif (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n\t\t\t\tbscale = fitsHeaderParams.get(\"BSCALE\");\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\t\t\t}\n\n\n\t\t\tlet bzero = 0.0;\n\t\t\tif (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n\t\t\t\tbzero = fitsHeaderParams.get(\"BZERO\");\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\t\t\t}\n\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS\", 2));\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS1\", HiPSHelper.DEFAULT_Naxis1_2));\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS2\", HiPSHelper.DEFAULT_Naxis1_2));\n\n\t\t\theader.addItem(new FITSHeaderItem(\"ORDER\", this._norder));\n\n\t\t\theader.addItem(new FITSHeaderItem(\"CTYPE1\", super.ctype1));\n\t\t\theader.addItem(new FITSHeaderItem(\"CTYPE2\", super.ctype2));\n\n\t\t\t// header.addItem(new FITSHeaderItem(\"CRPIX1\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel i along naxis1\n\t\t\t// header.addItem(new FITSHeaderItem(\"CRPIX2\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel j along naxis2\n\n\t\t\theader.addItem(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n\t\t\theader.addItem(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n\n\t\t}\n\t\treturn this._fitsheaderlist;\n\t}\n\n\n\tgetFITSHeader(): FITSHeader[] {\n\t\treturn this._fitsheaderlist;\n\t}\n\n\tgetCommonFitsHeaderParams(): FITSHeader {\n\t\treturn this._fh_common;\n\t}\n\n\textractPhysicalValues(fits: FITSParsed): number[][] {\n\n\t\tlet bzero = fits.header.get(\"BZERO\");\n\t\tlet bscale = fits.header.get(\"BSCALE\");\n\t\tlet naxis1 = fits.header.get(\"NAXIS1\");\n\t\tlet naxis2 = fits.header.get(\"NAXIS2\");\n\t\tlet bitpix = fits.header.get(\"BITPIX\");\n\t\tlet bytesXelem = Math.abs(bitpix / 8);\n\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n\t\t// let physicalvalues = new Array[naxis2][naxis1];\n\t\tlet physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n\t\tfor (let n2 = 0; n2 < naxis2; n2++) {\n\t\t\tphysicalvalues[n2] = new Array<number>(naxis1);\n\t\t\tfor (let n1 = 0; n1 < naxis1; n1++) {\n\t\t\t\tlet pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n\t\t\t\tlet physicalVal = bzero + bscale * pixval;\n\t\t\t\tphysicalvalues[n2][n1] = physicalVal;\n\t\t\t}\n\t\t}\n\t\treturn physicalvalues;\n\n\t}\n\n\tasync getFITSFiles(inputPixelsList: ImagePixel[], destPath: string): Promise<Map<string, FITSParsed>> {\n\n\t\tconst fitsFilesGenerated = new Map<string, FITSParsed>();\n\t\tlet promises = [];\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\t\tfor (let hipstileno of tilesset) {\n\t\t\tlet tileno = hipstileno;\n\t\t\tlet dir = Math.floor(tileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + tileno + \".fits\";\n\t\t\tlet fp = new FITSParser(fitsurl);\n\n\n\t\t\tpromises.push(fp.loadFITS().then((fits) => {\n\t\t\t\tif (fits !== null) {\n\t\t\t\t\tlet pixno = (fits.header.get(\"NPIX\") !== undefined) ? fits.header.get(\"NPIX\") : tileno;\n\t\t\t\t\t// FITSParser.writeFITS(fits.header, fits.data, destPath+\"/Npix\"+pixno+\".fits\");\n\t\t\t\t\t// fitsFilesGenerated.set(destPath+\"/Npix\"+pixno+\".fits\",FITSParser.generateFITS(fits.header, fits.data) );\n\t\t\t\t\tfitsFilesGenerated.set(destPath + \"/Npix\" + pixno + \".fits\", fits);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\treturn fitsFilesGenerated;\n\t}\n\n\n\tget fitsUsed(): String[] {\n\t\treturn this._fitsUsed;\n\t}\n\n\tasync getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array | undefined> {\n\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\n\t\tlet pixcount = inputPixelsList.length;\n\t\tlet values: Uint8Array | undefined = undefined;\n\t\tlet fitsheaderlist: (FITSHeader | undefined)[] = [];\n\t\tlet promises = [];\n\n\t\tlet self = this;\n\t\tfor (let hipstileno of tilesset) {\n\n\t\t\tlet dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + hipstileno + \".fits\";\n\t\t\tconsole.log(`Identified source file ${fitsurl}`)\n\t\t\tlet fp = new FITSParser(fitsurl);\n\t\t\tpromises.push(fp.loadFITS().then((fits) => {\n\n\t\t\t\tif (fits === null) {\n\t\t\t\t\tfitsheaderlist.push(undefined);\n\t\t\t\t} else {\n\t\t\t\t\tself._fitsUsed.push(fitsurl);\n\n\t\t\t\t\tlet bytesXelem = Math.abs(fits.header.get(\"BITPIX\") / 8);\n\t\t\t\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // => ???????\n\t\t\t\t\tif (values === undefined) {\n\t\t\t\t\t\tvalues = new Uint8Array(pixcount * bytesXelem);\n\t\t\t\t\t}\n\n\t\t\t\t\t// console.log(fitsurl + \" loaded\");\n\t\t\t\t\tfitsheaderlist.push(fits.header);\n\n\t\t\t\t\tfor (let p = 0; p < pixcount; p++) {\n\t\t\t\t\t\tlet imgpx = inputPixelsList[p];\n\n\t\t\t\t\t\tif (imgpx.tileno === hipstileno) {\n\n\n\t\t\t\t\t\t\t// if (imgpx._j < HiPSHelper.DEFAULT_Naxis1_2 && imgpx._i < HiPSHelper.DEFAULT_Naxis1_2) {\n\t\t\t\t\t\t\tif (imgpx._j < fits.header.get(\"NAXIS1\") && imgpx._i < fits.header.get(\"NAXIS2\")) {\n\t\t\t\t\t\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\t\t\t\t\t\tvalues[p * bytesXelem + b] = fits.data[imgpx._j][imgpx._i * bytesXelem + b];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\tif (fitsheaderlist !== undefined) {\n\t\t\tthis.prepareCommonHeader(fitsheaderlist);\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tprepareCommonHeader(fitsheaderlist: (FITSHeader | undefined)[]): void {\n\t\tif (fitsheaderlist === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fh_common) {\n\t\t\tthis._fh_common = new FITSHeader();\n\t\t}\n\n\t\tfor (let i = 0; i < fitsheaderlist.length; i++) {\n\t\t\tlet header = fitsheaderlist[i];\n\t\t\tif (header !== undefined) {\n\n\t\t\t\tfor (let item of header.getItemList()) {\n\t\t\t\t\tif ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\"].includes(item.key)) {\n\t\t\t\t\t\tif (!this._fh_common.getItemListOf(item.key)[0]) {\n\t\t\t\t\t\t\tthis._fh_common.addItem(new FITSHeaderItem(item.key, item.value));\n\t\t\t\t\t\t} else if (this._fh_common.getItemListOf(item.key)[0].value !== item.value) { // this should not happen \n\t\t\t\t\t\t\tthrow new Error(\"Error parsing headers. \" + item.key + \" was \" + this._fh_common.getItemListOf(item.key)[0] + \" and now is \" + item.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\n\t// // TODO MOVE THIS IN AN UTILITY FILE\n\t// pixel2Physical(value, bzero, bscale) {\n\t// \tlet pval = bzero + bscale * value;\n\t// \treturn pval;\n\t// }\n\n\tsetPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n\n\t\t// let vidx = 0; // <------ ERROR!!!!! pixel are not organized by tile!!!\n\n\t\t// let pxXTile = HiPSHelper.DEFAULT_Naxis1_2 * HiPSHelper.DEFAULT_Naxis1_2;\n\t\tlet bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n\t\tlet bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n\t\tlet bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n\t\tif (bytesXelem === undefined || bscale === undefined || bzero === undefined) {\n\t\t\tthrow new Error(\"BITPIX, BSCALE or BZERO are undefined\");\n\t\t}\n\n\n\t\t// let minmaxmap = new Array();\n\t\tlet minmaxmap = new Map();\n\t\tlet nodata = new Map();\n\n\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\t// this._pxvalues.set(tileno, new Array(HiPSHelper.DEFAULT_Naxis1_2));  // <- bidimensional\n\t\t\t// for (let row = 0; row < HiPSHelper.DEFAULT_Naxis1_2; row++) {\n\n\t\t\tthis._pxvalues.set(tileno, new Array(this._HIPS_TILE_WIDTH));  // <- bidimensional\n\t\t\tfor (let row = 0; row < this._HIPS_TILE_WIDTH; row++) {\n\t\t\t\tif (this._pxvalues.has(tileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(tileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\t// p[row] = new Uint8Array(HiPSHelper.DEFAULT_Naxis1_2 * bytesXelem);\n\t\t\t\t\t\tp[row] = new Uint8Array(this._HIPS_TILE_WIDTH * bytesXelem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tminmaxmap.set(\"\" + tileno + \"\", new Array(2));\n\t\t\tnodata.set(\"\" + tileno + \"\", true);\n\t\t});\n\t\tlet ra: number;\n\t\tlet dec: number;\n\t\tlet col: number;\n\t\tlet row: number;\n\n\t\tfor (let rdidx = 0; rdidx < this._radeclist.length; rdidx++) {\n\t\t\t[ra, dec] = this._radeclist[rdidx];\n\t\t\tlet ac = fillAstro(ra, dec, NumberType.DEGREES);\n\t\t\tlet sc = astroToSpherical(ac);\n\t\t\tlet ptg = new Pointing(null, false, sc.thetaRad, sc.phiRad);\n\t\t\tlet pixtileno: number = this._hp.ang2pix(ptg);\n\n\t\t\tlet xyGridProj = HiPSHelper.setupByTile(pixtileno, this._hp);\n\t\t\t// let rarad = degToRad(ra);\n\t\t\t// let decrad = degToRad(dec);\n\t\t\t// TODO CHECK THIS POINT before it was with ra and dec in radians\n\t\t\tlet xy = HiPSHelper.world2intermediate(ac);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tlet ij = HiPSHelper.intermediate2pix(xy[0], xy[1], xyGridProj, this._HIPS_TILE_WIDTH);\n\t\t\tcol = ij[0];\n\t\t\trow = ij[1];\n\n\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\tlet byte = values[rdidx * bytesXelem + b];\n\t\t\t\t// this._pxvalues.get(pixtileno)[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\tp[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nodata.get(\"\" + pixtileno + \"\")) {\n\t\t\t\t\tif (byte != 0) {\n\t\t\t\t\t\tnodata.set(\"\" + pixtileno + \"\", false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet min = minmaxmap.get(\"\" + pixtileno + \"\")[0];\n\t\t\tlet max = minmaxmap.get(\"\" + pixtileno + \"\")[1];\n\n\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\tif (p !== undefined) {\n\t\t\t\t\tlet valpixb = ParseUtils.extractPixelValue(0, p[row].slice(col * bytesXelem, col * bytesXelem + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n\t\t\t\t\tlet valphysical = bzero + bscale * valpixb;\n\t\t\t\t\tif (valphysical < min || isNaN(min)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[0] = valphysical;\n\t\t\t\t\t} else if (valphysical > max || isNaN(max)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[1] = valphysical;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Object.keys(this._pxvalues.keys()).forEach((tileno) => {\n\t\tconst fhKeys = Array.from(this._pxvalues.keys());\n\n\t\tfhKeys.forEach((tileno) => {\n\t\t\tif (nodata.get(\"\" + tileno + \"\") == false) { // there are data\n\t\t\t\t// tileno = parseInt(tileno);\n\t\t\t\tlet header = new FITSHeader();\n\t\t\t\theader.set(\"NPIX\", tileno);\n\t\t\t\t// TODO CONVERT minval and maxval to physical values!\n\t\t\t\t// header.addItem(new FITSHeaderItem(\"DATAMIN\", minmaxmap[\"\" + tileno + \"\"][0]));\n\t\t\t\t// header.addItem(new FITSHeaderItem(\"DATAMAX\", minmaxmap[\"\" + tileno + \"\"][1]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"DATAMIN\", minmaxmap.get(\"\" + tileno + \"\")[0]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"DATAMAX\", minmaxmap.get(\"\" + tileno + \"\")[1]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"NPIX\", tileno));\n\n\t\t\t\tlet vec3 = this._hp.pix2vec(tileno);\n\t\t\t\tlet ptg = new Pointing(vec3);\n\t\t\t\tlet crval1 = radToDeg(ptg.phi);\n\t\t\t\tlet crval2 = 90 - radToDeg(ptg.theta);\n\n\t\t\t\theader.addItem(new FITSHeaderItem(\"CRVAL1\", crval1));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"CRVAL2\", crval2));\n\n\t\t\t\tthis._fitsheaderlist.push(header);\n\t\t\t} else { // no data\n\t\t\t\t// this._pxvalues.delete(parseInt(tileno));\n\t\t\t\tthis._pxvalues.delete(tileno);\n\t\t\t\t// delete this._pxvalues[\"\" + tileno + \"\"];\n\t\t\t}\n\n\t\t});\n\t\tthis.prepareFITSHeader(fitsHeaderParams);\n\t\treturn this._pxvalues;\n\n\t}\n\n\tgetImageRADecList(center: Point, radiusDeg: number): Array<[number, number]> {\n\n\t\tlet ptg = new Pointing(null, false, center.spherical.thetaRad, center.spherical.phiRad);\n\t\tlet radius_rad = degToRad(radiusDeg);\n\n\t\t// with fact 8 the original Java code starts returning the the ptg pixel. with my JS porting only from fact 16\n\t\tlet rangeset = this._hp.queryDiscInclusive(ptg, radius_rad, 4); // <= check it \n\n\t\tthis._tileslist = [];\n\t\tfor (let p = 0; p < rangeset.r.length; p++) {\n\n\t\t\tif (!this._tileslist.includes(rangeset.r[p]) && rangeset.r[p] != 0) {\n\t\t\t\tthis._tileslist.push(rangeset.r[p]);\n\t\t\t}\n\n\t\t}\n\n\t\tlet cpix = this._hp.ang2pix(ptg);\n\t\tif (!this._tileslist.includes(cpix)) {\n\t\t\tthis._tileslist.push(cpix);\n\t\t}\n\n\n\t\tlet minra = center.astro.raDeg - radiusDeg;\n\t\tlet maxra = center.astro.raDeg + radiusDeg;\n\t\tlet mindec = center.astro.decDeg - radiusDeg;\n\t\tlet maxdec = center.astro.decDeg + radiusDeg;\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t// for (let j = 0; j < HiPSHelper.DEFAULT_Naxis1_2; j++) {\n\t\t\t// \tfor (let i = 0; i < HiPSHelper.DEFAULT_Naxis1_2; i++) {\n\t\t\tfor (let j = 0; j < this._HIPS_TILE_WIDTH; j++) {\n\t\t\t\tfor (let i = 0; i < this._HIPS_TILE_WIDTH; i++) {\n\t\t\t\t\tlet p = this.pix2world(i, j);\n\t\t\t\t\tif (p.astro.raDeg < minra || p.astro.raDeg > maxra ||\n\t\t\t\t\t\tp.astro.decDeg < mindec || p.astro.decDeg > maxdec) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis._radeclist.push([p.astro.raDeg, p.astro.decDeg]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this._radeclist;\n\n\n\t}\n\n\n\tpix2world(i: number, j: number): Point {\n\n\t\tlet xy = HiPSHelper.pix2intermediate(i, j, this._xyGridProj, super.naxis1, super.naxis2);\n\t\t// TODO CHECK BELOW before it was only which is supposed to be wrong since intermediate2world returns SphericalCoords, not AstroCoords\n\t\t/**  \n\t\tlet raDecDeg = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\tif (raDecDeg[0] > 360){\n\t\t\traDecDeg[0] -= 360;\n\t\t}\n\t\treturn raDecDeg;\n\t\t*/\n\t\tlet p = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\t// if (p.spherical.phiDeg > 360){\n\t\t// \tsc.phiDeg -= 360;\n\t\t// }\n\t\treturn p;\n\t}\n\n\n\t// conversion taken from https://astrophysicsandpython.com/2022/03/15/html-js-equatorial-to-galactic-coordinates/\n\tconvertToGalactic(radeclist: number[][]): number[][] {\n\t\tlet finalradeclist: number[][] = [];\n\t\tconst deg2rad = Math.PI / 180\n\t\tconst rad2deg = 180 / Math.PI\n\t\tconst l_NCP = deg2rad * 122.930\n\t\tconst d_NGP = deg2rad * 27.1284\n\t\tconst a_NGP = deg2rad * 192.8595\n\t\tradeclist.forEach(([ra, dec]) => {\n\t\t\tconst ra_rad = deg2rad * ra\n\t\t\tconst dec_rad = deg2rad * dec\n\t\t\t// sin(b)\n\t\t\tconst sin_b = Math.sin(d_NGP) * Math.sin(dec_rad) + \n\t\t\t\t\t\t\tMath.cos(d_NGP) * Math.cos(dec_rad) * Math.cos(ra_rad - a_NGP);\n\t\t\tconst b = Math.asin(sin_b)\n\t\t\tconst b_deg = b * rad2deg\n\n\t\t\t// l_NCP - l\n\t\t\tconst lNCP_minus_l = Math.atan ( ( Math.cos(dec_rad) * Math.sin(ra_rad - a_NGP)) /\n\t\t\t\t\t\t\t(Math.sin(dec_rad) * Math.cos(d_NGP) - Math.cos(dec_rad) * Math.sin(d_NGP) * Math.cos(ra_rad - a_NGP)) );\n\t\t\tconst l = l_NCP - lNCP_minus_l\n\t\t\tconst l_deg = l * rad2deg\n\t\t\t\n\t\t\tfinalradeclist.push([l_deg, b_deg])\n\t\t});\n\t\treturn finalradeclist;\n\t}\n\n\tworld2pix(radeclist: number[][]): ImagePixel[] {\n\n\t\t// let imgpxlist = new ImagePixel[radeclist.length];\n\t\tlet imgpxlist: ImagePixel[] = [];\n\t\tlet tileno: number;\n\t\tlet prevTileno: number | undefined = undefined;\n\t\t// let k = 0;\n\n\t\t/*\n\t\t\tif HiPS in galactic => convert the full list of (RA, Dec) to Galactic  (l, b)\n\t\t*/\n\n\t\tif (this._isGalactic){\n\t\t\tradeclist = this.convertToGalactic(radeclist);\n\t\t}\n\n\t\tradeclist.forEach(([ra, dec]) => {\n\n\t\t\tconst p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n\t\t\t// let phiTheta_rad = HiPSHelper.astroDegToSphericalRad(ra, dec);\n\t\t\tconst ptg = new Pointing(null, false, p.spherical.thetaRad, p.spherical.phiRad);\n\n\t\t\ttileno = this._hp.ang2pix(ptg);\n\t\t\tif (prevTileno !== tileno || prevTileno === undefined) {\n\t\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t\tprevTileno = tileno;\n\t\t\t}\n\t\t\t// let rarad =  HiPSHelper.degToRad(ra);\n\t\t\t// let decrad = HiPSHelper.degToRad(dec);\n\t\t\tconst xy = HiPSHelper.world2intermediate(p.astro);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tconst ij = HiPSHelper.intermediate2pix(xy[0], xy[1], this._xyGridProj, this._HIPS_TILE_WIDTH);\n\n\t\t\timgpxlist.push(new ImagePixel(ij[0], ij[1], tileno));\n\t\t});\n\n\t\treturn imgpxlist;\n\t}\n\n\n}\n","\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport {Point} from \"../model/Point.js\";\nimport {AbstractProjection} from \"./AbstractProjection.js\";\n\n\nexport class HEALPixProjection extends AbstractProjection {\n    \n    constructor() {\n        super(\"'RA---HPX'\", \"'DEC--HPX'\")\n    }\n    \n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeader {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    \n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n    \n\n}","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\nimport {Point} from '../model/Point.js';\n\n\nexport class GnomonicProjection extends AbstractProjection {\n\n\n\n\n    _minra: number;\n    _mindec: number;\n    _pxmatrix;\n    _fitsheader: FITSHeader[];\n    _inflie: string;\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n\n    constructor(infile?: string) {\n        super(\"'RA---TAN'\", \"'DEC--TAN'\");\n        if (infile) {\n            this._inflie = infile;\n        }\n    }\n\n\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n\n        let fp = new FITSParser(infile);\n\n        let promise = fp.loadFITS().then(fits => {\n\n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            super.naxis1 = fits.header.get(\"NAXIS1\");\n            super.naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value;\n            this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value;\n\n            this._minra = this._craDeg - this._pxsize1 * super.naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            this._mindec = this._cdecDeg - this._pxsize2 * super.naxis2 / 2;\n\n            return fits;\n\n        });\n        await promise;\n        return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\n        this._fitsheader[0] = new FITSHeader();\n\n\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS1\", super.naxis1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS2\", super.naxis2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE1\", super.ctype1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE2\", super.ctype2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT1\", super.pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT2\", super.pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX1\", super.naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX2\", super.naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n\n    getFITSHeader(): FITSHeader[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeader {\n        let header = new FITSHeader();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                // header.set(key, value);\n                header.addItem(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= super.naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= super.naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = (this._pxvalues.get(0))[imgpx._j][(imgpx._i) * bytesXelem + b];\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n        // let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        // let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        // let maxpixb = minpixb;\n\n        // let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        // let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        // this._minphysicalval = bzero + bscale * minpixb;\n        // this._maxphysicalval = bzero + bscale * maxpixb;\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n\n        // TODO ...\n        return null;\n    }\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]>{\n\n        // let promise = new Promise((resolve, reject) => {\n        //     this.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n\n        //     this._pxsize = pxsize;\n        //     this._minra = center.ra - radius;\n        //     if (this._minra < 0) {\n        //         this._minra += 360;\n        //     }\n        //     this._mindec = center.dec - radius;\n\n        //     let radeclist = [];\n        //     let pra, pdec;\n\n        // TODO ...\n        /*\n        basing on naxis1 and naxis2 call pix2world!!!\n        */\n\n\n\n        /*\n        \n\n        mindec = center.dec - radius;\n        maxdec = center.dec + radius;\n        below pixel size should  depend on the distance from the center\n        let l =  0;\n        let factor = 1;\n        \n        for (let d = mindec; d < maxdec; d+=pxsize) { <--ERROR the external loop must be over RA\n            factor = 1 + 2**l;\n            rapxsize = pxsize/factor;\n            for (let r = 0; r < 360; r+=rapxsize) {\n                radeclist.push(r, d); \n            }\n            l++;\n        }\n        */\n\n\n\n\n\n        // let cidx = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        // this._cra = radeclist[cidx][0];\n        // this._cdec = radeclist[cidx][1];\n\n        // resolve(radeclist);\n        // });\n        // return promise;\n        return null;\n\n    }\n\n    pix2world(i: number, j: number): Point {\n\n        // TODO ...\n        let x, y;\n        let CDELT1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0];\n        let CDELT2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0];\n        let PC1_1 = this._fitsheader[0].getItemListOf(\"PC1_1\")[0];\n        let PC1_2 = this._fitsheader[0].getItemListOf(\"PC1_2\")[0];\n        let PC2_1 = this._fitsheader[0].getItemListOf(\"PC2_1\")[0];\n        let PC2_2 = this._fitsheader[0].getItemListOf(\"PC2_2\")[0];\n\n        let CD1_1 = this._fitsheader[0].getItemListOf(\"CD1_1\")[0];\n        let CD1_2 = this._fitsheader[0].getItemListOf(\"CD1_2\")[0];\n        let CD2_1 = this._fitsheader[0].getItemListOf(\"CD2_1\")[0];\n        let CD2_2 = this._fitsheader[0].getItemListOf(\"CD2_2\")[0];\n\n        let CRPIX1 = this._fitsheader[0].getItemListOf(\"CRPIX1\")[0];\n        let CRPIX2 = this._fitsheader[0].getItemListOf(\"CRPIX2\")[0];\n\n\n        if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            PC1_1 !== undefined && PC1_2 !== undefined &&\n            PC2_1 !== undefined && PC2_2 !== undefined\n        ) { // if CDELTia and PCi_ja notation\n            x = CDELT1 * (PC1_1 * (i - CRPIX1) + PC1_2 * (j - CRPIX2));\n            y = CDELT2 * (PC2_1 * (i - CRPIX1) + PC2_2 * (j - CRPIX2));\n        } else { // else CDi_ja notation\n            x = CD1_1 * (i - CRPIX1) + CD1_2 * (j - CRPIX2);\n            y = CD2_1 * (i - CRPIX1) + CD2_2 * (j - CRPIX2);\n        }\n\n\n\n\n        // let phi = math.arg(-y / x);\n        // let R_theta = Math.sqrt(x * x + y * y);\n        // let theta = Math.atan2(180 / (Math.PI * R_theta));\n\n        // let ra, dec;\n        // ra = phi;\n        // dec = theta;\n        // // TODO check if phi, theta match with ra, dec or they need to be (linearly) converted \n\n        // return [ra, dec];\n\n        return null;\n    }\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        let CDELT1 = (this._fitsheader[0].getItemListOf(\"CDELT1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT1\")[0] : undefined;\n        let CDELT2 = (this._fitsheader[0].getItemListOf(\"CDELT2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT2\")[0] : undefined;\n        let PC1_1 = (this._fitsheader[0].getItemListOf(\"PC1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_1\")[0] : undefined;\n        let PC1_2 = (this._fitsheader[0].getItemListOf(\"PC1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_2\")[0] : undefined;\n        let PC2_1 = (this._fitsheader[0].getItemListOf(\"PC2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_1\")[0] : undefined;\n        let PC2_2 = (this._fitsheader[0].getItemListOf(\"PC2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_2\")[0] : undefined;\n\n        let CD1_1 = (this._fitsheader[0].getItemListOf(\"CD1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_1\")[0] : undefined;\n        let CD1_2 = (this._fitsheader[0].getItemListOf(\"CD1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_2\")[0] : undefined;\n        let CD2_1 = (this._fitsheader[0].getItemListOf(\"CD2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_1\")[0] : undefined;\n        let CD2_2 = (this._fitsheader[0].getItemListOf(\"CD2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_2\")[0] : undefined;\n\n        let CRPIX1 = (this._fitsheader[0].getItemListOf(\"CRPIX1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX1\")[0] : undefined;\n        let CRPIX2 = (this._fitsheader[0].getItemListOf(\"CRPIX2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX2\")[0] : undefined;\n\n        radeclist.forEach(([ra, dec]) => {\n\n            // TODO ...\n            // let i, j;\n            // // (linearly) convert ra, dec into phi, theta\n            // let theta = dec;\n            // let phi = ra;\n            // let R_theta = (180 / Math.PI) * math.cot(theta);\n            // let x = R_theta * Math.sin(phi);\n            // let y = - R_theta * Math.cos(phi);\n            // if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            //     PC1_1 !== undefined && PC1_2 !== undefined &&\n            //     PC2_1 !== undefined && PC2_2 !== undefined\n            // ) { // if CDELTia and PCi_ja notation\n            //     j = y * CDELT1 * PC1_1 / (CDELT1 * CDELT2 * (PC1_1 * PC2_2 - PC2_1 * PC1_2)) + PC1_1 * CRPIX2 * (PC2_2 - PC2_1) / (PC1_1 * PC2_2 - PC2_1 * PC1_2);\n            //     i = x / (CDELT1 * PC1_1) + CRPIX1 - j * PC1_2 / PC1_1 + CRPIX2 * PC1_2 / PC1_1;\n            // } else { // else CDi_ja notation\n            //     j = y * CD1_1 / (CD1_1 * CD2_2 - CD1_2 * CD2_1) + CRPIX2 * CD1_1 * (CD2_2 - CD2_1) / (CD1_1 * CD2_2 - CD1_2 * CD2_1);\n            //     i = (x + CD1_1 * CRPIX1 - CD1_2 * j + CD1_2 * CRPIX2) / CD1_1;\n            // }\n            // imgpxlist.push(new ImagePixel(i, j));\n\n        });\n        return imgpxlist;\n\n    }\n\n    // getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n    //     let canvas2d = new Canvas2D(this._pxvalues, this._fitsheader, this, tfunction, colormap, inverse);\n    //     return canvas2d;\n    // }\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nimport { FITSParser } from 'jsfitsio';\nimport { MercatorProjection } from './projections/MercatorProjection.js';\nimport { HiPSProjection } from './projections/HiPSProjection.js';\nimport { Point } from './model/Point.js';\nimport { AbstractProjection } from './projections/AbstractProjection.js';\nimport { CutoutResult } from './model/CutoutResult.js';\n\nimport { HEALPixProjection } from './projections/HEALPixProjection.js';\nimport { GnomonicProjection } from './projections/GnomonicProjection.js';\nimport { FITS } from './model/FITS.js';\n\nexport class WCSLight {\n\n    static async cutout(center: Point, radius: number,\n        pxsize: number, inproj: AbstractProjection, outproj: AbstractProjection): Promise<CutoutResult> {\n\n        const outRADecList: Array<Array<number>> = outproj.getImageRADecList(center, radius, pxsize);\n        if (outRADecList.length == 0) {\n            const res: CutoutResult = {\n                fitsheader: null,\n                fitsdata: null,\n                inproj: inproj,\n                outproj: outproj,\n                fitsused: inproj.fitsUsed\n            };\n            return res;\n        }\n        const inputPixelsList = inproj.world2pix(outRADecList);\n        try {\n\n            const invalues = await inproj.getPixValues(inputPixelsList);\n            const fitsHeaderParams = inproj.getCommonFitsHeaderParams();\n            if (invalues !== undefined) {\n                const fitsdata = outproj.setPxsValue(invalues, fitsHeaderParams);\n                const fitsheader = outproj.getFITSHeader();\n                const fits = new FITS(fitsheader, fitsdata)\n                \n                const res: CutoutResult = {\n                    fitsheader: fits.header,\n                    fitsdata: fits.data,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            } else {\n                const nanFits = outproj.generateFITSWithNaN()\n                const res: CutoutResult = {\n                    fitsheader: nanFits.header,\n                    fitsdata: nanFits.data,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            }\n\n        } catch (err) {\n            console.error(\"[WCSLight] ERROR: \" + err);\n            return null;\n        }\n\n    }\n\n    /**\n     * \n     * @param {*} fitsheader \n     * @param {*} fitsdata \n     * @returns {URL}\n     */\n    static generateFITS(fitsheader: any, fitsdata: any): string {\n        const blobUrl = FITSParser.generateFITS(fitsheader, fitsdata);\n        return blobUrl;\n    }\n\n\n\n\n    static changeProjection(filepath, outprojname) {\n        // TODO\n    }\n\n\n    static getProjection(projectionName: string) {\n        if (projectionName === \"Mercator\") {\n            return new MercatorProjection();\n        } else if (projectionName === \"HiPS\") {\n            return new HiPSProjection();\n        } else if (projectionName === \"HEALPix\") {\n            return new HEALPixProjection();\n        } else if (projectionName === \"Gnomonic\") {\n            return new GnomonicProjection();\n        } else {\n            return null;\n            // throw new ProjectionNotFound(projectionName);\n        }\n    }\n\n    static getAvaillableProjections() {\n        return [\"Mercator\", \"HiPS\", \"HEALPix\"];\n    }\n\n}\n\n","\n\n\n// import { FITSParser } from 'fitsparser/FITSParser-node';\n// import { FITSHeader } from 'fitsparser/model/FITSHeader';\n// import { FITSHeaderItem } from 'fitsparser/model/FITSHeaderItem';\n// import { FITSParsed } from 'fitsparser/model/FITSParsed';\n\n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { AbstractProjection } from './AbstractProjection.js';\nimport {Point} from '../model/Point.js';\n\nexport class TestProj extends AbstractProjection{\n    \n    _minra: number;\n    _mindec: number;\n    _fitsheader: FITSHeader[];\n    _infile: string;\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n    constructor() {\n        super(\"RA---MER\", \"DEC--MER\")\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this._pxvalues = new Map<number, Array<Uint8Array>>();\n        const fh = new FITSHeader();\n        const fp = new FITSParser(\"./notexistent/\");\n        const fhi = new FITSHeaderItem(\"mykey\", \"myvalue\", \"mycomment\");\n\n\n    }\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    \n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeader {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    public computeSquaredNaxes(d: number, ps: number): void {\n        throw new Error('Method not implemented.');\n    }\n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number):  Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n}"],"names":["root","factory","exports","module","define","amd","self","inProgress","dataWebpackPrefix","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call","m","d","definition","key","o","Object","defineProperty","enumerable","get","f","e","chunkId","Promise","all","keys","reduce","promises","u","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","l","url","done","push","script","needAttach","scripts","document","getElementsByTagName","i","length","s","getAttribute","createElement","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","event","onerror","onload","clearTimeout","doneFns","parentNode","removeChild","forEach","fn","setTimeout","bind","type","target","head","appendChild","r","Symbol","toStringTag","value","scriptUrl","importScripts","location","currentScript","test","Error","replace","p","installedChunks","j","installedChunkData","promise","resolve","reject","error","errorType","realSrc","message","name","request","webpackJsonpCallback","parentChunkLoadingFunction","data","chunkIds","moreModules","runtime","some","id","chunkLoadingGlobal","FITSHeaderItem","constructor","comment","_key","_value","_comment","FITSHeader","Map","super","_offset","_items","offset","getItemList","getItemListOf","res","item","addItemAtTheBeginning","includes","set","newitemlist","concat","addItem","getNumRows","ParseUtils","getStringAt","chars","String","fromCharCode","charCodeAt","join","byteString","n","toString","substr","parse32bitSinglePrecisionFloatingPoint","byte1","byte2","byte3","byte4","long","Math","pow","convertBlankToBytes","blank","nbytes","str","abs","buffer","ArrayBuffer","uint8","Uint8Array","parseInt","parseFloatingPointFormat","bytes","ebits","fbits","bits","byte","reverse","bias","substring","Infinity","generate16bit2sComplement","val","TypeError","parse16bit2sComplement","unsigned","parse32bit2sComplement","getByteAt","extractPixelValue","bitpix","px_val","slice","FITSWriter","_headerArray","_payloadArray","Array","_fitsData","run","header","rawdata","prepareHeader","prepareFITS","headerDetails","formatHeaderLine","strBytelen","TextEncoder","encode","ceil","ab","keyword","len","typedArrayToURL","b","Blob","URL","createObjectURL","ParsePayload","fitsheader","_u8data","_BZERO","_BSCALE","_BLANK","_BITPIX","_NAXIS1","_NAXIS2","_DATAMIN","_DATAMAX","_physicalblank","init","min","max","computePhysicalMinAndMax","maxitem","minitem","bytesXelem","pxLength","byteLength","ph_val","pixel2physicalValue","parse","c","k","pixelvalues","floor","pxval","ParseHeader","textDecoder","TextDecoder","u8line","u8key","u8val","u8ind","fitsLine","nline","decode","trim","firstchar","Number","parseLogicalValue","parseFloatValue","parseIntValue","now","Date","parseStringValue","u8buffer","decoded","idx","lastIndexOf","tokens","split","parseFloat","NumberType","CoordsType","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","result","then","apply","FITSParser","_url","loadFITS","getFile","processFits","catch","_a","_b","response","generateFITS","writer","uri","toLowerCase","err","getLocalFile","FITS","_header","_data","AbstractProjection","ctype1","ctype2","naxis1","naxis2","pxsize","_ctype1","_ctype2","_naxis1","_naxis2","_pxsize","generateFITSWithNaN","fitsheaders","NaN","pv","fill","computeSquaredNaxes","ps","ImagePixel","tileno","_i","_j","_tileno","geti","getj","cartesianToSpherical","xyz","dotXYZ","a","x","y","z","sqrt","thetaRad","acos","thetaDeg","radToDeg","phiRad","atan2","phiDeg","sphericalToAstro","phiTheta","raDeg","decDeg","degToRad","astroToSpherical","raDec","sphericalToCartesian","sin","cos","fillAstro","ra","dec","unit","DEGREES","RADIANS","console","fillSpherical","phi","theta","degrees","PI","radians","Point","in_type","coords","CARTESIAN","toFixed","MAX_DECIMALS","ASTRO","SPHERICAL","spherical","astro","cartesian","MercatorProjection","_wcsname","_pxvalues","_fitsheader","initFromFile","infile","fp","_infile","_fitsUsed","fits","_craDeg","_cdecDeg","pxsize1","pxsize2","_minra","_mindec","extractPhysicalValues","bzero","bscale","physicalvalues","n2","n1","physicalVal","prepareFITSHeader","fitsHeaderParams","_minphysicalval","_maxphysicalval","getFITSHeader","getCommonFitsHeaderParams","fitsUsed","getPixValues","inputPixelsList","blankBytes","pixcount","values","imgpx","setPxsValue","minpixb","maxpixb","valphysical","isNaN","log","getImageRADecList","center","radius","radeclist","cidx","pix2world","world2pix","imgpxlist","radecItem","Constants","halfpi","inv_halfpi","twopi","inv_twopi","Zphi","z_","phi_","Hploc","ptg","PI4_A","PI4_B","PI4_C","M_1_PI","sth","have_sth","_phi","setZ","setSth","toVec3","st","Vec3","toZphi","q","sincoshelper","asin","mulsign","atan2k","copySign","magnitude","sign","atanhelper","t","isinf","isnan","Pointing","vec3","mirror","in_theta","in_phi","in_x","in_y","in_z","getX","getY","getZ","scale","cross","v","add","normalize","norm","lengthSquared","dot","v1","sub","angle","flip","pointing2Vec3","pointing","CircleFinder","point","np","cosrad","getCircle","getCircle2","q1","q2","getCenter","getCosrad","Fxyf","fx","fy","face","jrll","jpll","toHploc","nr","loc","jr","tmp","pstack","sz","Int32Array","p_","o_","pop","popToMark","size","mark","otop","ptop","RangeSet","cap","append","append1","newsize","rnew","ensureCapacity","resize","sliced","Xyf","ix","iy","Healpix","nside_in","order_max","twothird","ns_max","ctab","Uint16Array","utab","Int16Array","xoffset","yoffset","facearray","swaparray","nside","npface","npix","order","nside2order","nl2","nl3","nl4","fact2","fact1","ncap","bn","mpr","cmpr","smpr","computeBn","maxPixrad","getNPix","getBoundaries","pix","points","xyf","nest2xyf","dc","xc","yc","getBoundariesWithStep","getPointsForXyfNoStep","getPointsForXyf","neighbours","ipix","face_num","nsm1","fpix","px0","spread_bits","py0","pxp","pyp","pxm","pym","nbnum","tint","xyf2nest","log2","compress_bits","loc2pix","hploc","pixNo","za","tt","fmodulo","temp1","temp2","jp","jm","ifp","ifm","ntt","tp","pix2vec","pix2loc","pix2zphi","ang2pix","v2","raw","queryPolygonInclusive","vertex","fact","inclusive","nv","vv","normal","index","back","first","medium","last","hnd","splice","rad","cf","queryMultiDisc","oplus","ilog2","omax","crlimit","dr","Float64Array","stk","zone","crad","iz","check_pixel","arg","clz32","cosdist_zphi","z1","phi1","z2","phi2","pixset","sdist","zphia","xyz1","convertZphi2xyz","va","t1","zphib","xyz2","vb","zphi","queryDiscInclusive","vptg","crpdr","crmdr","sinrad","cdr","sdr","curro","pos","cangdist","HiPSHelper","computeHiPSOrder","pxXtile","RES_ORDER_0","round","computeHiPSOrder2","warn","computeOrder","pxAngSizeDeg","pxTileWidth","pxAngSizeRad","computedOrder","computePxAngularSize","computedPxAngSizeRadiant","rad2deg","deg","arcmin","arcsec","computePxSize","computeBbox","bbox","setupByTile","hp","xyGridProj","cornersVec3","pointings","coThetaRad","decRad","raRad","xyDeg","world2intermediate","gridPointsDeg","max_y","min_y","max_x","min_x","ac","x_grid","y_grid","THETAX","K","H","w","sigma","phi_c","intermediate2pix","i_norm","j_norm","xInterval","yInterval","pix2intermediate","cnaxis1","cnaxis2","yMean","intermediate2world","Yx","x_c","DEFAULT_Naxis1_2","HiPSProjection","_isGalactic","_fitsheaderlist","_radeclist","parsePropertiesFile","baseUrl","propFile","txtArr","_HIPS_TILE_WIDTH","line","_HIPS_MAX_ORDER","fitsfilepath","_pixno","_xyGridProj","_hp","initFromHiPSLocationAndPxSize","_hipsBaseURI","initFromHiPSLocationAndOrder","_norder","_nside","_fh_common","getFITSFiles","destPath","fitsFilesGenerated","tilesset","Set","hipstileno","dir","fitsurl","pixno","fitsheaderlist","prepareCommonHeader","col","row","minmaxmap","nodata","_tileslist","has","rdidx","sc","pixtileno","xy","ij","from","crval1","crval2","delete","radiusDeg","radius_rad","rangeset","cpix","minra","maxra","mindec","maxdec","convertToGalactic","finalradeclist","deg2rad","l_NCP","d_NGP","a_NGP","ra_rad","dec_rad","sin_b","b_deg","lNCP_minus_l","atan","l_deg","prevTileno","HEALPixProjection","hipsURI","GnomonicProjection","_inflie","_pxsize1","_pxsize2","CDELT1","CDELT2","PC1_1","PC1_2","PC2_1","PC2_2","CD1_1","CD1_2","CD2_1","CD2_2","CRPIX1","CRPIX2","WCSLight","cutout","inproj","outproj","outRADecList","fitsdata","fitsused","invalues","nanFits","changeProjection","filepath","outprojname","getProjection","projectionName","getAvaillableProjections","TestProj"],"sourceRoot":""}