{"version":3,"file":"wcslight.min.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,IAA0C;AAChD;AACA,GAAG,iCAAO,CAAC,OAAS,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AAC/B,IAAI,KAAK,EAMN;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,WAAW;;;AAGf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC,eAAe;AACf,kDAAkD;AAClD,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB,gDAAgD;AAChD,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC,2BAA2B;AAC3B;AACA,MAAM,uCAAuC;AAC7C;AACA,MAAM,uCAAuC;AAC7C;AACA;AACA,MAAM,uCAAuC;AAC7C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yCAAyC,SAAS;AAClD;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,WAAW;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM,WAAW;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2DAA2D;AAC3D,wCAAwC;AACxC,0BAA0B;AAC1B,gCAAgC,EAAE;AAClC,gDAAgD;AAChD,6FAA6F;AAC7F,mDAAmD;AACnD,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA,SAAS,qBAAM,oBAAoB,qBAAM;AACzC;AACA;;;;;;;;;;;;;;;;;;;;;ACjsBA;;;;;;;GAOG;;;;;;;;;;AAEmC;AACmC;AACR;AAKM;AACE;AAElE,MAAM,QAAQ;IAEjB,2BAA2B;IAC3B,gBAAgB,CAAC;IAEjB,MAAM,CAAO,MAAM,CAAC,MAAa,EAAE,MAAc,EAC7C,MAAc,EAAE,MAA0B,EAAE,OAA2B;;YAEvE,MAAM,YAAY,GAAyB,OAAO,CAAC,iBAAiB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;YAC7F,IAAI,YAAY,CAAC,MAAM,IAAI,CAAC,EAAE;gBAC1B,MAAM,GAAG,GAAiB;oBACtB,UAAU,EAAE,IAAI;oBAChB,QAAQ,EAAE,IAAI;oBACd,MAAM,EAAE,MAAM;oBACd,OAAO,EAAE,OAAO;oBAChB,QAAQ,EAAE,MAAM,CAAC,QAAQ;iBAC5B,CAAC;gBACF,OAAO,GAAG,CAAC;aACd;YACD,MAAM,eAAe,GAAG,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;YACvD,IAAI;gBAEA,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;gBAC5D,MAAM,gBAAgB,GAAG,MAAM,CAAC,yBAAyB,EAAE,CAAC;gBAC5D,IAAI,QAAQ,KAAK,SAAS,EAAE;oBACxB,MAAM,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC,QAAQ,EAAE,gBAAgB,CAAC,CAAC;oBACjE,MAAM,UAAU,GAAG,OAAO,CAAC,aAAa,EAAE,CAAC;oBAC3C,wCAAwC;oBACxC,MAAM,GAAG,GAAiB;wBACtB,UAAU,EAAE,UAAU;wBACtB,QAAQ,EAAE,QAAQ;wBAClB,MAAM,EAAE,MAAM;wBACd,OAAO,EAAE,OAAO;wBAChB,QAAQ,EAAE,MAAM,CAAC,QAAQ;qBAC5B,CAAC;oBACF,OAAO,GAAG,CAAC;iBACd;qBAAM;oBACH,MAAM,GAAG,GAAiB;wBACtB,UAAU,EAAE,IAAI;wBAChB,QAAQ,EAAE,IAAI;wBACd,MAAM,EAAE,MAAM;wBACd,OAAO,EAAE,OAAO;wBAChB,QAAQ,EAAE,MAAM,CAAC,QAAQ;qBAC5B,CAAC;oBACF,OAAO,GAAG,CAAC;iBACd;aAEJ;YAAC,OAAO,GAAG,EAAE;gBACV,OAAO,CAAC,KAAK,CAAC,oBAAoB,GAAG,GAAG,CAAC,CAAC;gBAC1C,OAAO,IAAI,CAAC;aACf;QAEL,CAAC;KAAA;IAED;;;;;OAKG;IACH,MAAM,CAAC,YAAY,CAAC,UAAe,EAAE,QAAa;QAC9C,MAAM,OAAO,GAAG,6DAAuB,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QAC9D,OAAO,OAAO,CAAC;IACnB,CAAC;IAKD,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE,WAAW;QACzC,OAAO;IACX,CAAC;IAGD,MAAM,CAAC,aAAa,CAAC,cAAsB;QACvC,IAAI,cAAc,KAAK,UAAU,EAAE;YAC/B,OAAO,IAAI,kFAAkB,EAAE,CAAC;SACnC;aAAM,IAAI,cAAc,KAAK,MAAM,EAAE;YAClC,OAAO,IAAI,0EAAc,EAAE,CAAC;SAC/B;aAAM,IAAI,cAAc,KAAK,SAAS,EAAE;YACrC,OAAO,IAAI,gFAAiB,EAAE,CAAC;SAClC;aAAM,IAAI,cAAc,KAAK,UAAU,EAAE;YACtC,OAAO,IAAI,kFAAkB,EAAE,CAAC;SACnC;aAAM;YACH,OAAO,IAAI,CAAC;YACZ,gDAAgD;SACnD;IACL,CAAC;IAED,MAAM,CAAC,wBAAwB;QAC3B,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;IAC3C,CAAC;CAEJ;;;;;;;;;;;;;;;;AC/GD;;;;;GAKG;AAEH,IAAY,UAIX;AAJD,WAAY,UAAU;IACpB,qCAAuB;IACvB,qCAAuB;IACvB,6BAAe;AACjB,CAAC,EAJW,UAAU,KAAV,UAAU,QAIrB;;;;;;;;;;;;;;;;ACXD;;;;;;;GAOG;AAII,MAAM,UAAU;IAKnB,YAAa,IAAY,IAAI,EAAE,IAAY,IAAI,EAAE,SAAiB,IAAI;QAClE,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAED,IAAI;QACA,OAAO,IAAI,CAAC,EAAE,CAAC;IACnB,CAAC;IAED,IAAI;QACA,OAAO,IAAI,CAAC,EAAE,CAAC;IACnB,CAAC;IAED,IAAI,MAAM;QACN,OAAO,IAAI,CAAC,OAAO;IACvB,CAAC;CACJ;;;;;;;;;;;;;;;;ACjCD,IAAY,UAMX;AAND,WAAY,UAAU;IAClB,iDAAO;IACP,iDAAO;IACP,iDAAO;IACP,yCAAG;IACH,yCAAG;AACP,CAAC,EANW,UAAU,KAAV,UAAU,QAMrB;;;;;;;;;;;;;;;;;;ACND;;GAEG;;;;;;;;;;;;;AAEiI;AAGvF;AAMtC,MAAM,KAAK;IASjB,YAAY,OAAmB,EAAE,IAAgB,EAAE,GAAG,MAAqB;QAP3E,+BAAoB;QACpB,iCAAiC;QACjC,6BAA6B;QAE7B,mCAA4B;QAC5B,mCAA4B;QAI3B,IAAI,OAAO,IAAI,gEAAoB,EAAC;YACnC,2BAAI,wBAAW,CAAC,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,qBAAM,CAAC,YAAY,CAAC,CAAC,CAAC;YACvE,2BAAI,wBAAW,CAAC,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,qBAAM,CAAC,YAAY,CAAC,CAAC,CAAC;YACvE,2BAAI,wBAAW,CAAC,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,qBAAM,CAAC,YAAY,CAAC,CAAC,CAAC;YACvE,2BAAI,oBAAc,+DAAoB,CAAC,2BAAI,wBAAW,CAAC,OAAC;YAExD,2BAAI,gBAAU,2DAAgB,CAAC,2BAAI,wBAAW,CAAC,OAAC;SAEhD;aAAM,IAAI,OAAO,IAAI,4DAAgB,EAAC;YACtC,2BAAI,gBAAU,oDAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAG,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,OAAC;YACrD,2BAAI,oBAAc,2DAAgB,CAAC,2BAAI,oBAAO,CAAC,OAAC;YAChD,2BAAI,oBAAc,+DAAoB,CAAC,2BAAI,wBAAW,EAAE,GAAG,CAAC,OAAC,CAAC,4EAA4E;SAE1I;aAAM,IAAI,OAAO,IAAI,gEAAoB,EAAC;YAC1C,2BAAI,oBAAc,wDAAa,CAAC,MAAM,CAAC,CAAC,CAAC,EAAG,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,OAAC;YAC7D,2BAAI,oBAAc,+DAAoB,CAAC,2BAAI,wBAAW,EAAE,GAAG,CAAC,OAAC,CAAC,4EAA4E;YAC1I,2BAAI,gBAAU,2DAAgB,CAAC,2BAAI,wBAAW,CAAC,OAAC;SAEhD;aAAK;YACL,OAAO,CAAC,KAAK,CAAC,aAAa,GAAC,OAAO,GAAC,kBAAkB,CAAC,CAAC;SACxD;QACD,IAAI,2BAAI,wBAAW,CAAC,MAAM,GAAG,GAAG,EAAE;YACjC,2BAAI,wBAAW,CAAC,MAAM,IAAI,GAAG,CAAC;SAC9B;QACD,IAAI,2BAAI,oBAAO,CAAC,KAAK,GAAG,GAAG,EAAE;YAC5B,2BAAI,oBAAO,CAAC,KAAK,IAAI,GAAG,CAAC;SACzB;IACF,CAAC;IAGD,+DAA+D;IAE/D,yCAAyC;IAEzC,oGAAoG;IACpG,oGAAoG;IACpG,oGAAoG;IAEpG,6DAA6D;IAC7D,qDAAqD;IAErD,2CAA2C;IAE3C,mFAAmF;IACnF,gHAAgH;IAChH,0FAA0F;IAC1F,gHAAgH;IAChH,aAAa;IACb,4DAA4D;IAC5D,kBAAkB;IAClB,MAAM;IACN,qDAAqD;IACrD,+IAA+I;IAE/I,+CAA+C;IAE/C,8FAA8F;IAC9F,sIAAsI;IACtI,qGAAqG;IACrG,sIAAsI;IACtI,aAAa;IACb,gEAAgE;IAChE,kBAAkB;IAClB,MAAM;IAEN,+IAA+I;IAC/I,qDAAqD;IAErD,UAAU;IACV,6DAA6D;IAC7D,KAAK;IACL,IAAI;IAEJ,IAAI,SAAS;QACZ,OAAO,2BAAI,wBAAW,CAAC;IACxB,CAAC;IAED,IAAI,KAAK;QACR,OAAO,2BAAI,oBAAO,CAAC;IACpB,CAAC;IAED,IAAI,SAAS;QACZ,OAAO,2BAAI,wBAAW,CAAC;IACxB,CAAC;CAyED;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpLD;;GAEG;AACH,gCAAgC;AAKa;AAI7C,SAAS,KAAK;AAEd,CAAC;AAEM,SAAS,oBAAoB,CAAC,GAAoB;IACxD,IAAI,MAAM,GAAG,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAC3B,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC1B,IAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC;IACnC,IAAI,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAClC,+DAA+D;IAC/D,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACvC,IAAI,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;IAE9B,IAAI,MAAM,GAAG,CAAC,EAAC;QACd,MAAM,IAAI,GAAG,CAAC;KACd;IACD,OAAO;QACN,MAAM,EAAE,MAAM;QACd,QAAQ,EAAE,QAAQ;QAClB,MAAM,EAAC,MAAM;QACb,QAAQ,EAAE,QAAQ;KAClB,CAAC;AACH,CAAC;AAAA,CAAC;AAEK,SAAS,gBAAgB,CAAC,QAAyB;IACzD,IAAI,KAAa,CAAC;IAClB,IAAI,MAAc,CAAC;IAEnB,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC;IACxB,IAAI,KAAK,GAAG,CAAC,EAAC;QACb,KAAK,IAAI,GAAG,CAAC;KACb;IACD,MAAM,GAAG,EAAE,GAAG,QAAQ,CAAC,QAAQ,CAAC;IAEhC,OAAO;QACN,OAAO,EAAE,KAAK;QACd,QAAQ,EAAE,MAAM;QAChB,OAAO,EAAE,QAAQ,CAAC,KAAK,CAAC;QACxB,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC;KAE1B,CAAC;AACH,CAAC;AAEM,SAAS,gBAAgB,CAAC,KAAkB;IAElD,IAAI,MAAc,CAAC;IACnB,IAAI,QAAgB,CAAC;IAErB,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC;IACrB,IAAI,MAAM,GAAG,CAAC,EAAC;QACd,MAAM,IAAI,GAAG,CAAC;KACd;IAED,QAAQ,GAAG,EAAE,GAAG,KAAK,CAAC,MAAM,CAAC;IAE7B,OAAO;QACN,QAAQ,EAAE,MAAM;QAChB,UAAU,EAAE,QAAQ;QACpB,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC;QAC1B,UAAU,EAAE,QAAQ,CAAC,QAAQ,CAAC;KAC9B,CAAC;AACH,CAAC;AAEM,SAAS,oBAAoB,CAAC,QAAyB,EAAE,CAAS;IACxE,CAAC,GAAG,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7B,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IACpE,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IACpE,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAExC,OAAO;QACN,GAAG,EAAE,CAAC;QACN,GAAG,EAAE,CAAC;QACN,GAAG,EAAE,CAAC;KACN,CAAC;AACH,CAAC;AAAA,CAAC;AAEK,SAAS,SAAS,CAAC,EAAU,EAAE,GAAW,EAAE,IAAgB;IAClE,IAAI,IAAI,IAAI,8DAAkB,EAAE;QAC/B,OAAO;YACN,OAAO,EAAE,EAAE;YACX,QAAQ,EAAE,GAAG;YACb,OAAO,EAAE,QAAQ,CAAC,EAAE,CAAC;YACrB,QAAQ,EAAE,QAAQ,CAAC,GAAG,CAAC;SACvB;KACD;SAAM,IAAI,IAAI,IAAI,8DAAkB,EAAE;QACtC,OAAO;YACN,OAAO,EAAE,EAAE;YACX,QAAQ,EAAE,GAAG;YACb,OAAO,EAAE,QAAQ,CAAC,EAAE,CAAC;YACrB,QAAQ,EAAE,QAAQ,CAAC,GAAG,CAAC;SACvB;KACD;SAAM;QACN,OAAO,CAAC,KAAK,CAAC,8BAA8B,GAAG,IAAI,GAAG,gBAAgB,CAAC,CAAC;KACxE;AAEF,CAAC;AAGM,SAAS,aAAa,CAAC,GAAW,EAAE,KAAa,EAAE,IAAgB;IACzE,IAAI,IAAI,IAAI,8DAAkB,EAAE;QAC/B,OAAO;YACN,QAAQ,EAAE,GAAG;YACb,UAAU,EAAE,KAAK;YACjB,QAAQ,EAAE,QAAQ,CAAC,GAAG,CAAC;YACvB,UAAU,EAAE,QAAQ,CAAC,KAAK,CAAC;SAC3B;KACD;SAAM,IAAI,IAAI,IAAI,8DAAkB,EAAE;QACtC,OAAO;YACN,QAAQ,EAAE,QAAQ,CAAC,GAAG,CAAC;YACvB,UAAU,EAAE,QAAQ,CAAC,KAAK,CAAC;YAC3B,QAAQ,EAAE,GAAG;YACb,UAAU,EAAE,KAAK;SACjB;KACD;SAAM;QACN,OAAO,CAAC,KAAK,CAAC,8BAA8B,GAAG,IAAI,GAAG,gBAAgB,CAAC,CAAC;KACxE;AACF,CAAC;AAED,SAAS,GAAG,CAAC,CAAkB,EAAE,CAAkB;IAClD,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC;AAEI,SAAS,YAAY,CAAC,QAAgB;IAE7C,yBAAyB;IACxB,IAAI,IAAI,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;IACnC,IAAI,IAAI,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;IACnC,IAAI,IAAI,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;IAEnC,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;IAC9B,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;IAC9B,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;IAE9B,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IACnC,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IACnC,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAEnC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;AAE/D,CAAC;AAEM,SAAS,QAAQ,CAAC,OAAe;IACvC,OAAO,CAAC,OAAO,GAAG,GAAG,CAAE,GAAG,IAAI,CAAC,EAAE,CAAE;AACpC,CAAC;AAEM,SAAS,QAAQ,CAAC,OAAe;IACvC,OAAO,OAAO,GAAG,GAAG,GAAG,IAAI,CAAC,EAAE,CAAC;AAChC,CAAC;AAEM,SAAS,UAAU,CAAC,KAAa;IAEvC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAC,EAAE,CAAC,CAAC;IAC7B,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,GAAC,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;IACxC,IAAI,CAAC,GAAG,CAAC,KAAK,GAAC,EAAE,GAAG,CAAC,GAAG,CAAC,GAAC,EAAE,CAAC,GAAG,IAAI,CAAC;IAErC,OAAO;QACN,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;KACJ,CAAC;AACH,CAAC;AAEM,SAAS,WAAW,CAAC,MAAc;IACzC,IAAI,IAAI,GAAG,CAAC,CAAC;IACb,IAAI,MAAM,GAAG,CAAC,EAAC;QACd,IAAI,GAAG,CAAC,CAAC,CAAC;KACV;IAED,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAClC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IAE/B,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAE,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;IAE3C,IAAI,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,GAAG,CAAC,GAAC,EAAE,CAAC,GAAG,IAAI,CAAC;IACvC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;IAEb,OAAO;QACN,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;QACJ,CAAC,EAAE,CAAC;KACJ,CAAC;AACH,CAAC;AAED,SAAS,UAAU,CAAC,MAAyB;IAC5C,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC/B,IAAI,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC,GAAC,IAAI,CAAC,CAAC;IACvE,OAAO,GAAG,CAAC;AACZ,CAAC;AAED,SAAS,SAAS,CAAC,KAAgB;IAClC,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9B,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC,GAAC,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC;IACzE,OAAO,GAAG,CAAC;AACZ,CAAC;AAED,SAAS,YAAY,CAAC,EAAoB,EAAE,MAAc;IACzD,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IACd,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IACd,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAC,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC,GAAC,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC7D,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAClB,CAAC;;;;;;;;;;;;;;;;AC9MD;;;;;;;GAOG;AAEI,MAAe,kBAAkB;CA+BvC;;;;;;;;;;;;;;;;;;AC9CY;;;;;;;;;;AACb;;;;;;;GAOG;AAG0D;AAEvB;AACA;AACI;AAEJ;AAI/B,MAAM,kBAAmB,SAAQ,sEAAkB;IAwBtD,YAAY,MAAe;QACvB,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;QAE1B,IAAI,MAAM,EAAE;YACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;SACzB;IACL,CAAC;IA/BD,IAAW,QAAQ;QACf,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IA+BK,YAAY,CAAC,MAAc;;YAE7B,IAAI,EAAE,GAAG,IAAI,gDAAU,CAAC,MAAM,CAAC,CAAC;YAEhC,IAAI,OAAO,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBAEpC,4BAA4B;gBAC5B,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;gBACjC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;gBAClC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACzC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACzC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBAC5D,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBAE7D,yDAAyD;gBACzD,yDAAyD;gBACzD,wEAAwE;gBACxE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBACrE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;gBAErE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;gBAC9D,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;oBACjB,IAAI,CAAC,MAAM,IAAI,GAAG,CAAC;iBACtB;gBACD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;gBAEhE,OAAO,IAAI,CAAC;YAEhB,CAAC,CAAC,CAAC;YACH,MAAM,OAAO,CAAC;YACd,OAAO,OAAO,CAAC;QACnB,CAAC;KAAA;IAED,qBAAqB,CAAC,IAAgB;QAElC,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACrC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACtC,IAAI,UAAU,GAAG,oEAA8B,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,sDAAsD;QAC7I,kDAAkD;QAClD,IAAI,cAAc,GAAe,IAAI,KAAK,CAAW,MAAM,CAAC,CAAC;QAE7D,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,EAAE,EAAE,EAAE,EAAE;YAChC,cAAc,CAAC,EAAE,CAAC,GAAG,IAAI,KAAK,CAAS,MAAM,CAAC,CAAC;YAC/C,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,EAAE,EAAE,EAAE,EAAE;gBAChC,IAAI,MAAM,GAAG,kEAA4B,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE,GAAG,UAAU,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,EAAE,MAAM,CAAC,CAAC;gBAClH,IAAI,WAAW,GAAG,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC;gBAC1C,cAAc,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC;aACxC;SACJ;QACD,OAAO,cAAc,CAAC;IAG1B,CAAC;IAED,iBAAiB,CAAC,gBAA4B;QAE1C,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,gDAAU,EAAE,CAAC;QAGvC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QACxG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QAExG,IAAI,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,EAAE;YAC7C,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SAC3F;QAED,IAAI,MAAM,GAAG,GAAG,CAAC;QACjB,IAAI,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;YAC9C,MAAM,GAAG,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;SAC3C;QACD,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;QAElE,IAAI,KAAK,GAAG,GAAG,CAAC;QAChB,IAAI,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,EAAE;YAC7C,KAAK,GAAG,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;SACzC;QACD,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QAGhE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;QAC5D,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QACxE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QAExE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QACxE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QAExE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,qCAAqC;QAC9G,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,qCAAqC;QAC9G,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,yCAAyC;QACtH,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,yCAAyC;QACtH,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,6BAA6B;QACtG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,8BAA8B;QAExG,IAAI,GAAG,GAAG,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC;QAChD,IAAI,GAAG,GAAG,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC;QAChD,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,iBAAiB;QAClF,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,iBAAiB;QAGlF,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,gBAAgB,CAAC,CAAC,CAAC;QAC5E,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,SAAS,EAAE,uDAAuD,CAAC,CAAC,CAAC;QACpH,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,KAAK,CAAC,CAAC,CAAC;QAEvD,OAAO,IAAI,CAAC,WAAW,CAAC;IAE5B,CAAC;IAED,aAAa;QACT,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED,yBAAyB;QACrB,IAAI,MAAM,GAAG,IAAI,gDAAU,EAAE,CAAC;QAC9B,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE;YAC5C,oFAAoF;YACpF,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAE1E,0BAA0B;gBAC1B,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;aAElD;SACJ;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAEK,YAAY,CAAC,eAA6B;;YAE5C,IAAI,OAAO,GAAG,IAAI,OAAO,CAAa,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACtD,IAAI;oBACA,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;oBACjE,IAAI,UAAU,GAAG,oEAA8B,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,UAAU,CAAC,CAAC;oBAC9F,IAAI,QAAQ,GAAG,eAAe,CAAC,MAAM,CAAC;oBAEtC,IAAI,MAAM,GAAG,IAAI,UAAU,CAAC,QAAQ,GAAG,UAAU,CAAC,CAAC;oBAEnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;wBAE/B,IAAI,KAAK,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;wBAC/B,2EAA2E;wBAC3E,6DAA6D;wBAC7D,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO;4BAC5C,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE;4BAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;gCACjC,MAAM,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;6BAC9C;yBACJ;6BAAM;4BACH,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;gCACjC,MAAM,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC;6BAC/F;yBAEJ;qBACJ;oBACD,OAAO,CAAC,MAAM,CAAC,CAAC;iBACnB;gBAAC,OAAO,GAAG,EAAE;oBACV,MAAM,CAAC,8BAA8B,GAAG,GAAG,CAAC,CAAC;iBAChD;YAEL,CAAC,CAAC,CAAC;YACH,OAAO,OAAO,CAAC;QAEnB,CAAC;KAAA;IAED,mBAAmB,CAAC,CAAS,EAAE,EAAU;QACrC,oCAAoC;QACpC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;QACjC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;IACtB,CAAC;IAED,WAAW,CAAC,MAAkB,EAAE,gBAA4B;QACxD,iEAAiE;QACjE,8GAA8G;QAC9G,yBAAyB;QAEzB,sGAAsG;QACtG,mGAAmG;QAEnG,mDAAmD;QACnD,mDAAmD;QACnD,4CAA4C;QAC5C,2CAA2C;QAC3C,qEAAqE;QACrE,IAAI;QAEJ,WAAW;QACX,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,iBAAiB,CAAC,MAAa,EAAE,MAAc,EAAE,MAAc;QAE3D,mDAAmD;QACnD,2EAA2E;QAE3E,6BAA6B;QAC7B,wCAAwC;QACxC,6BAA6B;QAC7B,8BAA8B;QAC9B,QAAQ;QACR,0CAA0C;QAE1C,0BAA0B;QAC1B,qBAAqB;QAErB,WAAW;QACX;;UAEE;QAIF;;;;;;;;;;;;;;;;;UAiBE;QAMF,uEAAuE;QACvE,kCAAkC;QAClC,mCAAmC;QAEnC,sBAAsB;QACtB,MAAM;QACN,kBAAkB;QAClB,OAAO,IAAI,CAAC;IAEhB,CAAC;IAED,SAAS,CAAC,CAAS,EAAE,CAAS;QAE1B,WAAW;QACX,IAAI,CAAC,EAAE,CAAC,CAAC;QACT,IAAI,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5D,IAAI,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5D,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1D,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1D,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1D,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAE1D,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1D,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1D,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1D,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAE1D,IAAI,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5D,IAAI,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QAG5D,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,KAAK,SAAS;YAC5C,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS;YAC1C,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS,EAC5C,EAAE,iCAAiC;YACjC,CAAC,GAAG,MAAM,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC;YAC3D,CAAC,GAAG,MAAM,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC;SAC9D;aAAM,EAAE,uBAAuB;YAC5B,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC;YAChD,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC;SACnD;QAKD,8BAA8B;QAC9B,0CAA0C;QAC1C,qDAAqD;QAErD,eAAe;QACf,YAAY;QACZ,eAAe;QACf,0FAA0F;QAE1F,oBAAoB;QAEpB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,SAAS,CAAC,SAAqB;QAE3B,IAAI,SAAS,GAAiB,EAAE,CAAC;QAEjC,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACnI,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACnI,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAChI,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAChI,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAChI,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAEhI,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAChI,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAChI,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAChI,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAEhI,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACnI,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAEnI,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE;YAE5B,WAAW;YACX,YAAY;YACZ,gDAAgD;YAChD,mBAAmB;YACnB,gBAAgB;YAChB,mDAAmD;YACnD,mCAAmC;YACnC,qCAAqC;YACrC,sDAAsD;YACtD,oDAAoD;YACpD,iDAAiD;YACjD,wCAAwC;YACxC,yJAAyJ;YACzJ,sFAAsF;YACtF,mCAAmC;YACnC,4HAA4H;YAC5H,qEAAqE;YACrE,IAAI;YACJ,wCAAwC;QAE5C,CAAC,CAAC,CAAC;QACH,OAAO,SAAS,CAAC;IAErB,CAAC;CAOJ;;;;;;;;;;;;;;;;;AC7Y0D;AAGpD,MAAM,iBAAkB,SAAQ,sEAAkB;IACrD,IAAW,QAAQ;QACf,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,YAAY,CAAC,YAAqB,EAAE,OAAgB,EAAE,MAAe,EAAE,KAAc;QACxF,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,iBAAiB,CAAC,gBAA4B;QACjD,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,aAAa;QAChB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,yBAAyB;QAC5B,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,qBAAqB,CAAC,IAAgB;QACzC,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,YAAY,CAAC,eAA6B;QAC7C,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,mBAAmB,CAAC,CAAS,EAAE,EAAU;QAC5C,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,WAAW,CAAC,MAAkB,EAAE,gBAA4B;QAC/D,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,iBAAiB,CAAC,MAAa,EAAE,MAAc,EAAE,MAAc;QAClE,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,SAAS,CAAC,CAAS,EAAE,CAAS;QACjC,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,SAAS,CAAC,SAAqB;QAClC,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;CAGJ;;;;;;;;;;;;;;;;;;;;;AC9CD;;;;;;;GAOG;AAIkC;AACH;AAEW,CAAC,sBAAsB;AAChB;AAEV;AAEU;AAI7C,MAAM,UAAU;IAUtB;;;;;OAKG;IACH;;;;OAIG;IACH,MAAM,CAAC,gBAAgB,CAAC,MAAc,EAAE,OAAe;QACtD;;;;;;;;;;;;;;;;;;;;;WAqBG;QAGH,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAE,CAAC,UAAU,CAAC,WAAW,GAAG,OAAO,CAAC,GAAG,MAAM,CAAC,CAAC;QAChE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAClB,yCAAyC;QACzC,0DAA0D;QAC1D,sBAAsB;QACtB,oBAAoB;QACpB,WAAW;QACX,uBAAuB;QACvB,mBAAmB;QACnB,KAAK;QACL,OAAO,CAAC,CAAC;IAEV,CAAC;IAED;;;;OAIG;IACH,MAAM,CAAC,aAAa,CAAC,KAAa,EAAE,OAAe;QAClD,gBAAgB;QAChB,gEAAgE;QAChE,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC,OAAO,GAAG,UAAC,EAAI,KAAK,EAAC,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;QACjE,OAAO,MAAM,CAAC;IACf,CAAC;IAED,MAAM;IACN,MAAM;IACN,sDAAsD;IACtD,uDAAuD;IACvD,MAAM;IACN,2CAA2C;IAC3C,0BAA0B;IAC1B,2EAA2E;IAC3E,iEAAiE;IACjE,wEAAwE;IACxE,wBAAwB;IACxB,IAAI;IAEJ,iEAAiE;IACjE,oEAAoE;IACpE,uBAAuB;IACvB,mDAAmD;IACnD,sDAAsD;IACtD,KAAK;IACL,uBAAuB;IACvB,IAAI;IAEJ,6CAA6C;IAC7C,uCAAuC;IACvC,IAAI;IAEJ,yCAAyC;IACzC,mCAAmC;IACnC,IAAI;IAEJ,oEAAoE;IAEpE,uBAAuB;IACvB,yBAAyB;IACzB,mBAAmB;IACnB,oBAAoB;IACpB,mBAAmB;IACnB,KAAK;IAEL,2BAA2B;IAE3B,YAAY;IACZ,iBAAiB;IACjB,oBAAoB;IACpB,MAAM;IACN,IAAI;IAEJ;;;;;OAKG;IACH,MAAM,CAAC,WAAW,CAAC,KAAY,EAAE,CAAS;QAEzC,IAAI,IAAI,GAAG,EAAE,CAAC;QACd,IAAI,CAAC,IAAI,CAAC,IAAI,+CAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,SAAS,CAAC,QAAQ,GAAG,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/F,IAAI,CAAC,IAAI,CAAC,IAAI,+CAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,SAAS,CAAC,QAAQ,GAAG,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/F,IAAI,CAAC,IAAI,CAAC,IAAI,+CAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,SAAS,CAAC,QAAQ,GAAG,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/F,IAAI,CAAC,IAAI,CAAC,IAAI,+CAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,SAAS,CAAC,QAAQ,GAAG,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAE/F,OAAO,IAAI,CAAC;IACb,CAAC;IAED,MAAM,CAAC,WAAW,CAAC,MAAc,EAAE,EAAW;QAE7C,IAAI,UAAU,GAAmB;YAChC,OAAO,EAAE,GAAG;YACZ,OAAO,EAAE,GAAG;YACZ,OAAO,EAAE,GAAG;YACZ,OAAO,EAAE,GAAG;YACZ,eAAe,EAAE,EAAE;SACnB;QAGD,IAAI,WAAW,GAAG,EAAE,CAAC,qBAAqB,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QACtD,IAAI,SAAS,GAAG,EAAE,CAAC;QAEnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC5C,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,+CAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5C,IAAI,CAAC,IAAI,CAAC,EAAE;gBACX,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;gBAC7B,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;gBACzB,gEAAgE;gBAChE,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,EAAE,EAAE;oBAC9B,IAAI,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;wBAC5C,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;qBACpC;yBAAM;wBACN,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;qBAChC;iBACD;aACD;SACD;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC1C,IAAI,UAAU,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;YACpC,+DAA+D;YAC/D,8CAA8C;YAC9C,IAAI,MAAM,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,UAAU,CAAC;YAEtC,IAAI,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;YAE7B,6BAA6B;YAC7B,IAAI,CAAC,GAAG,IAAI,kDAAK,CAAC,kEAAgB,EAAE,oEAAkB,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;YACvE,IAAI,KAAK,GAAG,UAAU,CAAC,kBAAkB,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YACnD,UAAU,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAC3C,UAAU,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAE/C,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,KAAK,EAAE;gBAC3D,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;aAC5B;YACD,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,KAAK,EAAE;gBAC3D,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;aAC5B;YACD,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,KAAK,EAAE;gBAC3D,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;aAC5B;YACD,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,KAAK,EAAE;gBAC3D,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;aAC5B;SAED;QACD,OAAO,UAAU,CAAC;IACnB,CAAC;IAED,MAAM,CAAC,kBAAkB,CAAC,EAAe;QAExC,IAAI,MAAc,CAAC;QACnB,IAAI,MAAc,CAAC;QAEnB,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,UAAU,CAAC,MAAM,EAAE,EAAE,mBAAmB;YAClE,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC;YAElB,MAAM,GAAG,gDAAS,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,UAAU,CAAC,CAAC,GAAG,EAAE,GAAG,UAAU,CAAC,CAAC,CAAC;SAGjE;aAAM,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,EAAE,cAAc;YAEnE,IAAI,KAAK,GAAG,EAAE,CAAC,KAAK,CAAC;YAErB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ;YACnB,IAAI,UAAU,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,sBAAsB;gBACpE,CAAC,GAAG,CAAC,CAAC;aACN;YAED,IAAI,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,gDAAS,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YAC3E,IAAI,KAAK,GAAG,CAAE,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG,UAAU,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAEzH,MAAM,GAAG,KAAK,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC;YACzC,MAAM,GAAG,CAAC,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;YAEnE,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE;gBAClB,MAAM,IAAI,CAAC,CAAC,CAAC;aACb;SACD;QAED,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAEzB,CAAC;IAED,qEAAqE;IACrE,0BAA0B;IAC1B,uBAAuB;IAEvB,0EAA0E;IAC1E,wBAAwB;IAExB,wEAAwE;IAGxE,2EAA2E;IAE3E,4BAA4B;IAE5B,wBAAwB;IACxB,4EAA4E;IAC5E,YAAY;IACZ,MAAM;IAEN,qFAAqF;IACrF,iIAAiI;IAEjI,+CAA+C;IAC/C,wEAAwE;IAExE,2BAA2B;IAC3B,mBAAmB;IACnB,MAAM;IACN,KAAK;IAEL,4BAA4B;IAE5B,IAAI;IAEJ,MAAM,CAAC,gBAAgB,CAAC,CAAS,EAAE,CAAS,EAAE,UAA0B,EAAE,OAAe;QACxF,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;QAC9D,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;QAE9D,IAAI,MAAc,CAAC;QACnB,IAAI,MAAc,CAAC;QACnB,IAAI,CAAC,UAAU,CAAC,KAAK,GAAG,GAAG,IAAI,UAAU,CAAC,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,KAAK,EAAE;YAC/E,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC;SAClD;aAAM;YACN,MAAM,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC;SAC5C;QACD,MAAM,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC;QAG5C,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;QAChC,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,GAAG,GAAG,CAAC;QAEhC,kFAAkF;QAClF,OAAO;QACP,mDAAmD;QACnD,mDAAmD;QACnD,mDAAmD;QAEnD,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC;QAC5B,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC;QAC5B,OAAO,CAAC,CAAC,EAAE,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAI7B,CAAC;IAGD,MAAM,CAAC,gBAAgB,CAAC,CAAS,EAAE,CAAS,EAAE,UAA0B,EAAE,MAAc,EAAE,MAAc;QACvG;;;;;;;;;WASG;QACH,oCAAoC;QACpC,oCAAoC;QAEpC,IAAI,OAAO,GAAG,MAAM,CAAC;QACrB,IAAI,OAAO,GAAG,MAAM,CAAC;QACrB,IAAI,MAAM,EAAE;YACX,OAAO,GAAG,MAAM,CAAC;SACjB;QACD,IAAI,MAAM,EAAE;YACX,OAAO,GAAG,MAAM,CAAC;SACjB;QACD,IAAI,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,OAAO,CAAC;QACjC,IAAI,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,OAAO,CAAC;QAEjC,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;QACpE,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;QACpE,IAAI,KAAK,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;QAExD,0BAA0B;QAC1B,IAAI,CAAC,GAAG,UAAU,CAAC,KAAK,GAAG,SAAS,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;QACzD,IAAI,CAAC,GAAG,KAAK,GAAG,SAAS,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;QAE9C,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACf,CAAC;IAGD,MAAM,CAAC,kBAAkB,CAAC,CAAS,EAAE,CAAS;QAE7C,IAAI,MAAc,CAAC;QACnB,IAAI,QAAgB,CAAC;QACrB,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC;QAIhD,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,mBAAmB;YAE3C,MAAM,GAAG,CAAC,CAAC;YACX,QAAQ,GAAG,yDAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SAEzE;aAAM,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,EAAE,EAAE,gBAAgB;YAE9C,IAAI,KAAK,GAAG,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;YACtE,IAAI,QAAQ,GAAG,iDAAU,CAAC,CAAC,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9D,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ;YACnB,IAAI,UAAU,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,QAAQ,GAAG,CAAC,EAAE,EAAE,sBAAsB;gBACnE,CAAC,GAAG,CAAC,CAAC;aACN;YACD,IAAI,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,UAAU,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAC3G,MAAM,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,KAAK,CAAC;YACjC,QAAQ,GAAG,yDAAQ,CAAC,QAAQ,CAAC,CAAC;YAC9B,IAAI,CAAC,IAAI,CAAC,EAAE;gBACX,QAAQ,IAAI,CAAC,CAAC,CAAC;aACf;SACD;QACD,6BAA6B;QAC7B,mBAAmB;QACnB,iFAAiF;QACjF,IAAI,CAAC,GAAG,IAAI,kDAAK,CAAC,kEAAgB,EAAE,oEAAkB,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;QAE1E,OAAO,CAAC,CAAC;IAEV,CAAC;;AA/WD,sEAAsE;AAC/D,2BAAgB,GAAW,GAAG,CAAC;AACtC,0DAA0D;AACnD,sBAAW,GAAW,IAAI,CAAC;AAC3B,YAAC,GAAW,CAAC,CAAC;AACd,YAAC,GAAW,CAAC,CAAC;AACd,iBAAM,GAAW,iDAAU,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;ACjC1D;;;;;;;;;;AACb;;;;;;;GAOG;AAGmC;AACA;AACI;AAEJ;AAEF;AACC;AAKQ;AAGO;AACgC;AAC1C;AACU;AACA;AAM7C,MAAM,cAAc;IAwB1B;;;;;;;;;;;;;;;;;;OAkBG;IAGH,+FAA+F;IAC/F;QA1CA,gBAAW,GAAY,KAAK,CAAC;QAiB7B,cAAS,GAAa,EAAE,CAAC;QA2BxB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC,0BAA0B;QACjD,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;QAE1B,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAA6B,CAAC;QACtD,IAAI,CAAC,eAAe,GAAG,IAAI,KAAK,EAAc,CAAC;QAC/C,IAAI,CAAC,UAAU,GAAG,IAAI,KAAK,EAAoB,CAAC;IAEjD,CAAC;IAEK,mBAAmB,CAAC,OAAe;;YACxC,MAAM,EAAE,GAAG,IAAI,gDAAU,CAAC,IAAI,CAAC,CAAC;YAEhC,MAAM,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,GAAG,aAAa,CAAC,CAAC,IAAI,CAAC,CAAC,QAA8B,EAAE,EAAE;gBAC3F,IAAI,IAAY,CAAC;gBACjB,IAAI,QAAQ,YAAY,WAAW,EAAE;oBACpC,MAAM,WAAW,GAAG,IAAI,WAAW,CAAC,YAAY,CAAC,CAAC;oBAClD,IAAI,GAAG,WAAW,CAAC,MAAM,CAAC,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;iBACpD;qBAAM;oBACN,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;iBACjC;gBACD;;;;;;mBAMG;gBACH,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBAChC,IAAI,CAAC,gBAAgB,GAAG,GAAG,CAAC;gBAC5B,KAAK,IAAI,IAAI,IAAI,MAAM,EAAE;oBACxB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAC;wBACvB,SAAS;qBACT;oBAED,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBAC/B,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,SAAS,EAAC;wBAC3B,SAAS;qBACT;oBACD,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;oBAC5B,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;oBAE5B,IAAI,GAAG,IAAI,YAAY,EAAE;wBACxB,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;wBACrC,OAAO,CAAC,GAAG,CAAC,aAAa,GAAC,IAAI,CAAC,eAAe,CAAC;qBAC/C;yBAAM,IAAI,GAAG,IAAI,iBAAiB,EAAE;wBACpC,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;wBACtC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC;wBACrC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC;wBACrC,OAAO,CAAC,GAAG,CAAC,kBAAkB,GAAC,IAAI,CAAC,gBAAgB,CAAC;qBACrD;yBAAM,IAAI,GAAG,IAAI,YAAY,IAAI,GAAG,IAAI,UAAU,EAAE;wBACpD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;qBAExB;iBACD;gBACD,OAAO,QAAQ,CAAC;YACjB,CAAC,CAAC,CAAC;YAEH,MAAM,OAAO,CAAC;YACd,OAAO,OAAO,CAAC;QAChB,CAAC;KAAA;IAEK,YAAY,CAAC,YAAoB;;YACtC,IAAI,EAAE,GAAG,IAAI,gDAAU,CAAC,YAAY,CAAC,CAAC;YAEtC,IAAI,OAAO,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACvC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;gBACjC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;gBAEtC,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBACrC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAEjB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACzC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACzC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,OAAO,CAAC;gBAErC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBAEtC,IAAI,CAAC,WAAW,GAAG,kEAAsB,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC;YACb,CAAC,CAAC,CAAC;YACH,MAAM,OAAO,CAAC;YACd,OAAO,OAAO,CAAC;QAChB,CAAC;KAAA;IAIK,6BAA6B,CAAC,OAAe,EAAE,MAAc;;YAClE,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC;YAC5B,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;YACtB,IAAI,IAAI,CAAC,gBAAgB,KAAK,SAAS,EAAE;gBACxC,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;aACxC;YACD,IAAI,KAAK,GAAG,uEAA2B,CAAC,MAAM,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;YACvE,IAAI,KAAK,GAAG,IAAI,CAAC,eAAe,EAAE;gBACjC,KAAK,GAAG,IAAI,CAAC,eAAe;aAC5B;YACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAClB,CAAC;KAAA;IAEK,4BAA4B,CAAC,OAAe,EAAE,KAAa;;YAChE,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC;YAC5B,IAAI,IAAI,CAAC,gBAAgB,KAAK,SAAS,EAAE;gBACxC,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;aACxC;YACD,IAAI,KAAK,GAAG,IAAI,CAAC,eAAe,EAAC;gBAChC,KAAK,GAAG,IAAI,CAAC,eAAe;aAC5B;YACD,IAAI,CAAC,OAAO,GAAG,oEAAwB,CAAC,KAAK,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;YACtE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAClB,CAAC;KAAA;IAED,IAAI,CAAC,KAAa;QACjB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,UAAC,EAAI,KAAK,EAAC;QACzB,IAAI,CAAC,GAAG,GAAG,IAAI,8CAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACrC,CAAC;IAED,iBAAiB,CAAC,gBAA4B;QAC7C,KAAK,IAAI,MAAM,IAAI,IAAI,CAAC,eAAe,EAAE;YAExC,MAAM,CAAC,qBAAqB,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC3F,MAAM,CAAC,qBAAqB,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAE3F,IAAI,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,EAAE;gBAChD,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;aAC3E;YACD,IAAI,MAAM,GAAG,GAAG,CAAC;YACjB,IAAI,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;gBACjD,MAAM,GAAG,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACxC,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;aACrD;YAGD,IAAI,KAAK,GAAG,GAAG,CAAC;YAChB,IAAI,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,EAAE;gBAChD,KAAK,GAAG,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBACtC,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;aACnD;YAED,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;YAC/C,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,uEAA2B,CAAC,CAAC,CAAC;YAC1E,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,uEAA2B,CAAC,CAAC,CAAC;YAE1E,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;YAE1D,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;YAC3D,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;YAE3D,yHAAyH;YACzH,yHAAyH;YAEzH,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,gBAAgB,CAAC,CAAC,CAAC;YAC/D,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,SAAS,EAAE,uDAAuD,CAAC,CAAC,CAAC;SAEvG;QACD,OAAO,IAAI,CAAC,eAAe,CAAC;IAC7B,CAAC;IAGD,aAAa;QACZ,OAAO,IAAI,CAAC,eAAe,CAAC;IAC7B,CAAC;IAED,yBAAyB;QACxB,OAAO,IAAI,CAAC,UAAU,CAAC;IACxB,CAAC;IAED,qBAAqB,CAAC,IAAgB;QAErC,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACrC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACtC,IAAI,UAAU,GAAG,oEAA8B,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,sDAAsD;QAC7I,kDAAkD;QAClD,IAAI,cAAc,GAAe,IAAI,KAAK,CAAW,MAAM,CAAC,CAAC;QAE7D,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,EAAE,EAAE,EAAE,EAAE;YACnC,cAAc,CAAC,EAAE,CAAC,GAAG,IAAI,KAAK,CAAS,MAAM,CAAC,CAAC;YAC/C,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,EAAE,EAAE,EAAE,EAAE;gBACnC,IAAI,MAAM,GAAG,kEAA4B,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE,GAAG,UAAU,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,EAAE,MAAM,CAAC,CAAC;gBAClH,IAAI,WAAW,GAAG,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC;gBAC1C,cAAc,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC;aACrC;SACD;QACD,OAAO,cAAc,CAAC;IAEvB,CAAC;IAEK,YAAY,CAAC,eAA6B,EAAE,QAAgB;;YAEjE,MAAM,kBAAkB,GAAG,IAAI,GAAG,EAAsB,CAAC;YACzD,IAAI,QAAQ,GAAG,EAAE,CAAC;YAClB,IAAI,QAAQ,GAAG,IAAI,GAAG,EAAU,CAAC;YACjC,eAAe,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBACjC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YAC5B,CAAC,CAAC,CAAC;YACH,KAAK,IAAI,UAAU,IAAI,QAAQ,EAAE;gBAChC,IAAI,MAAM,GAAG,UAAU,CAAC;gBACxB,IAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,mDAAmD;gBACjG,IAAI,OAAO,GAAG,IAAI,CAAC,YAAY,GAAG,SAAS,GAAG,IAAI,CAAC,OAAO,GAAG,MAAM,GAAG,GAAG,GAAG,OAAO,GAAG,MAAM,GAAG,OAAO,CAAC;gBACvG,IAAI,EAAE,GAAG,IAAI,gDAAU,CAAC,OAAO,CAAC,CAAC;gBAGjC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;oBACzC,IAAI,IAAI,KAAK,IAAI,EAAE;wBAClB,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;wBACvF,gFAAgF;wBAChF,2GAA2G;wBAC3G,kBAAkB,CAAC,GAAG,CAAC,QAAQ,GAAG,OAAO,GAAG,KAAK,GAAG,OAAO,EAAE,IAAI,CAAC,CAAC;qBACnE;gBACF,CAAC,CAAC,CAAC,CAAC;aACJ;YACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC5B,OAAO,kBAAkB,CAAC;QAC3B,CAAC;KAAA;IAGD,IAAI,QAAQ;QACX,OAAO,IAAI,CAAC,SAAS,CAAC;IACvB,CAAC;IAEK,YAAY,CAAC,eAA6B;;YAE/C,IAAI,QAAQ,GAAG,IAAI,GAAG,EAAU,CAAC;YACjC,eAAe,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBACjC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YAC5B,CAAC,CAAC,CAAC;YAEH,IAAI,QAAQ,GAAG,eAAe,CAAC,MAAM,CAAC;YACtC,IAAI,MAAM,GAA2B,SAAS,CAAC;YAC/C,IAAI,cAAc,GAA+B,EAAE,CAAC;YACpD,IAAI,QAAQ,GAAG,EAAE,CAAC;YAElB,IAAI,IAAI,GAAG,IAAI,CAAC;YAChB,KAAK,IAAI,UAAU,IAAI,QAAQ,EAAE;gBAEhC,IAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,mDAAmD;gBACrG,IAAI,OAAO,GAAG,IAAI,CAAC,YAAY,GAAG,SAAS,GAAG,IAAI,CAAC,OAAO,GAAG,MAAM,GAAG,GAAG,GAAG,OAAO,GAAG,UAAU,GAAG,OAAO,CAAC;gBAC3G,OAAO,CAAC,GAAG,CAAC,0BAA0B,OAAO,EAAE,CAAC;gBAChD,IAAI,EAAE,GAAG,IAAI,gDAAU,CAAC,OAAO,CAAC,CAAC;gBACjC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;oBAEzC,IAAI,IAAI,KAAK,IAAI,EAAE;wBAClB,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;qBAC/B;yBAAM;wBACN,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;wBAE7B,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;wBACzD,IAAI,UAAU,GAAG,oEAA8B,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,aAAa;wBACpG,IAAI,MAAM,KAAK,SAAS,EAAE;4BACzB,MAAM,GAAG,IAAI,UAAU,CAAC,QAAQ,GAAG,UAAU,CAAC,CAAC;yBAC/C;wBAED,oCAAoC;wBACpC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBAEjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;4BAClC,IAAI,KAAK,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;4BAE/B,IAAI,KAAK,CAAC,MAAM,KAAK,UAAU,EAAE;gCAGhC,0FAA0F;gCAC1F,IAAI,KAAK,CAAC,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,KAAK,CAAC,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;oCACjF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;wCACpC,MAAM,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC;qCAC5E;iCACD;6BACD;yBACD;qBACD;gBAKF,CAAC,CAAC,CAAC,CAAC;aACJ;YACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC5B,IAAI,cAAc,KAAK,SAAS,EAAE;gBACjC,IAAI,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC;aACzC;YAED,OAAO,MAAM,CAAC;QACf,CAAC;KAAA;IAED,mBAAmB,CAAC,CAAS,EAAE,EAAU;QACxC,oCAAoC;QACpC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;QACjC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;IACnB,CAAC;IAED,mBAAmB,CAAC,cAA0C;QAC7D,IAAI,cAAc,KAAK,SAAS,EAAE;YACjC,OAAO;SACP;QACD,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACrB,IAAI,CAAC,UAAU,GAAG,IAAI,gDAAU,EAAE,CAAC;SACnC;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/C,IAAI,MAAM,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;YAC/B,IAAI,MAAM,KAAK,SAAS,EAAE;gBAEzB,KAAK,IAAI,IAAI,IAAI,MAAM,CAAC,WAAW,EAAE,EAAE;oBACtC,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;wBACjF,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;4BAChD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;yBAClE;6BAAM,IAAI,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,EAAE,EAAE,0BAA0B;4BACvG,MAAM,IAAI,KAAK,CAAC,yBAAyB,GAAG,IAAI,CAAC,GAAG,GAAG,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;yBAC3I;qBACD;iBACD;aAED;SAED;IAEF,CAAC;IAKD,uCAAuC;IACvC,yCAAyC;IACzC,sCAAsC;IACtC,gBAAgB;IAChB,IAAI;IAEJ,WAAW,CAAC,MAAkB,EAAE,gBAA4B;QAE3D,yEAAyE;QAEzE,2EAA2E;QAC3E,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;QAC9D,IAAI,MAAM,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QACnG,IAAI,KAAK,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QAEhG,IAAI,UAAU,KAAK,SAAS,IAAI,MAAM,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS,EAAE;YAC5E,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;SACzD;QAGD,+BAA+B;QAC/B,IAAI,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;QAC1B,IAAI,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;QAIvB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,MAAc,EAAE,EAAE;YAC1C,2FAA2F;YAC3F,gEAAgE;YAEhE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAE,mBAAmB;YAClF,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,gBAAgB,EAAE,GAAG,EAAE,EAAE;gBACrD,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;oBAC/B,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;oBACnC,IAAI,CAAC,KAAK,SAAS,EAAE;wBACpB,qEAAqE;wBACrE,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,gBAAgB,GAAG,UAAU,CAAC,CAAC;qBAC5D;iBACD;aACD;YAED,SAAS,CAAC,GAAG,CAAC,EAAE,GAAG,MAAM,GAAG,EAAE,EAAE,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAC9C,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,MAAM,GAAG,EAAE,EAAE,IAAI,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;QACH,IAAI,EAAU,CAAC;QACf,IAAI,GAAW,CAAC;QAChB,IAAI,GAAW,CAAC;QAChB,IAAI,GAAW,CAAC;QAEhB,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YAC5D,CAAC,EAAE,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACnC,IAAI,EAAE,GAAG,0DAAS,CAAC,EAAE,EAAE,GAAG,EAAE,oEAAkB,CAAC,CAAC;YAChD,IAAI,EAAE,GAAG,iEAAgB,CAAC,EAAE,CAAC,CAAC;YAC9B,IAAI,GAAG,GAAG,IAAI,+CAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC,QAAQ,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC;YAC5D,IAAI,SAAS,GAAW,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAE9C,IAAI,UAAU,GAAG,kEAAsB,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;YAC7D,4BAA4B;YAC5B,8BAA8B;YAC9B,iEAAiE;YACjE,IAAI,EAAE,GAAG,yEAA6B,CAAC,EAAE,CAAC,CAAC;YAC3C,IAAI,IAAI,CAAC,gBAAgB,KAAK,SAAS,EAAE;gBACxC,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;aACnD;YACD,IAAI,EAAE,GAAG,uEAA2B,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;YACtF,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;YACZ,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;YAEZ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;gBACpC,IAAI,IAAI,GAAG,MAAM,CAAC,KAAK,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC;gBAC1C,sFAAsF;gBACtF,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;oBAClC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBACtC,IAAI,CAAC,KAAK,SAAS,EAAE;wBACpB,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,UAAU,GAAG,CAAC,CAAC,GAAG,IAAI,EAAC,mBAAmB;qBACvD;iBACD;gBACD,IAAI,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,SAAS,GAAG,EAAE,CAAC,EAAE;oBACpC,IAAI,IAAI,IAAI,CAAC,EAAE;wBACd,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,SAAS,GAAG,EAAE,EAAE,KAAK,CAAC,CAAC;qBACvC;iBACD;aAED;YAED,IAAI,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC,EAAE,GAAG,SAAS,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAChD,IAAI,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC,EAAE,GAAG,SAAS,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAEhD,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBAClC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBACtC,IAAI,CAAC,KAAK,SAAS,EAAE;oBACpB,IAAI,OAAO,GAAG,kEAA4B,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,GAAG,UAAU,EAAE,GAAG,GAAG,UAAU,GAAG,UAAU,CAAC,EAAE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAC7I,IAAI,WAAW,GAAG,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;oBAC3C,IAAI,WAAW,GAAG,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE;wBACpC,SAAS,CAAC,GAAG,CAAC,EAAE,GAAG,SAAS,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC;qBACpD;yBAAM,IAAI,WAAW,GAAG,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE;wBAC3C,SAAS,CAAC,GAAG,CAAC,EAAE,GAAG,SAAS,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC;qBACpD;iBACD;aACD;SAED;QAGD,2DAA2D;QAC3D,MAAM,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;QAEjD,MAAM,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YACzB,IAAI,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,MAAM,GAAG,EAAE,CAAC,IAAI,KAAK,EAAE,EAAE,iBAAiB;gBAC7D,6BAA6B;gBAC7B,IAAI,MAAM,GAAG,IAAI,gDAAU,EAAE,CAAC;gBAC9B,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;gBAC3B,qDAAqD;gBACrD,iFAAiF;gBACjF,iFAAiF;gBACjF,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,SAAS,EAAE,SAAS,CAAC,GAAG,CAAC,EAAE,GAAG,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAClF,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,SAAS,EAAE,SAAS,CAAC,GAAG,CAAC,EAAE,GAAG,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAClF,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;gBAEnD,IAAI,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;gBACpC,IAAI,GAAG,GAAG,IAAI,+CAAQ,CAAC,IAAI,CAAC,CAAC;gBAC7B,IAAI,MAAM,GAAG,yDAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBAC/B,IAAI,MAAM,GAAG,EAAE,GAAG,yDAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAEtC,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;gBACrD,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;gBAErD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aAClC;iBAAM,EAAE,UAAU;gBAClB,2CAA2C;gBAC3C,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC9B,2CAA2C;aAC3C;QAEF,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,CAAC;QACzC,OAAO,IAAI,CAAC,SAAS,CAAC;IAEvB,CAAC;IAED,iBAAiB,CAAC,MAAa,EAAE,SAAiB;QAEjD,IAAI,GAAG,GAAG,IAAI,+CAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,SAAS,CAAC,QAAQ,EAAE,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QACxF,IAAI,UAAU,GAAG,yDAAQ,CAAC,SAAS,CAAC,CAAC;QAErC,8GAA8G;QAC9G,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,kBAAkB,CAAC,GAAG,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,eAAe;QAE/E,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;QACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAE3C,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;gBACnE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACpC;SAED;QAED,IAAI,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACjC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YACpC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC3B;QAGD,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC;QAC3C,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC;QAC3C,IAAI,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;QAC7C,IAAI,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC;QAE7C,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,MAAc,EAAE,EAAE;YAC1C,IAAI,CAAC,WAAW,GAAG,kEAAsB,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;YAC5D,0DAA0D;YAC1D,2DAA2D;YAC3D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC,EAAE,EAAE;gBAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC,EAAE,EAAE;oBAC/C,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC7B,IAAI,CAAC,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,IAAI,CAAC,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK;wBACjD,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM,EAAE;wBACpD,SAAS;qBACT;oBACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;iBACtD;aACD;QACF,CAAC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC,UAAU,CAAC;IAGxB,CAAC;IAGD,SAAS,CAAC,CAAS,EAAE,CAAS;QAE7B,IAAI,EAAE,GAAG,uEAA2B,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QACzF,sIAAsI;QACtI;;;;;;UAME;QACF,IAAI,CAAC,GAAG,yEAA6B,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACpD,iCAAiC;QACjC,qBAAqB;QACrB,IAAI;QACJ,OAAO,CAAC,CAAC;IACV,CAAC;IAGD,iHAAiH;IACjH,iBAAiB,CAAC,SAAqB;QACtC,IAAI,cAAc,GAAe,EAAE,CAAC;QACpC,MAAM,OAAO,GAAG,IAAI,CAAC,EAAE,GAAG,GAAG;QAC7B,MAAM,OAAO,GAAG,GAAG,GAAG,IAAI,CAAC,EAAE;QAC7B,MAAM,KAAK,GAAG,OAAO,GAAG,OAAO;QAC/B,MAAM,KAAK,GAAG,OAAO,GAAG,OAAO;QAC/B,MAAM,KAAK,GAAG,OAAO,GAAG,QAAQ;QAChC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE;YAC/B,MAAM,MAAM,GAAG,OAAO,GAAG,EAAE;YAC3B,MAAM,OAAO,GAAG,OAAO,GAAG,GAAG;YAC7B,SAAS;YACT,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC;gBAC7C,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;YACnE,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;YAC1B,MAAM,KAAK,GAAG,CAAC,GAAG,OAAO;YAEzB,YAAY;YACZ,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAG,CAAE,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;gBAC5E,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC,CAAE,CAAC;YAC7G,MAAM,CAAC,GAAG,KAAK,GAAG,YAAY;YAC9B,MAAM,KAAK,GAAG,CAAC,GAAG,OAAO;YAEzB,cAAc,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;QACH,OAAO,cAAc,CAAC;IACvB,CAAC;IAED,SAAS,CAAC,SAAqB;QAE9B,oDAAoD;QACpD,IAAI,SAAS,GAAiB,EAAE,CAAC;QACjC,IAAI,MAAc,CAAC;QACnB,IAAI,UAAU,GAAuB,SAAS,CAAC;QAC/C,aAAa;QAEb;;UAEE;QAEF,IAAI,IAAI,CAAC,WAAW,EAAC;YACpB,IAAI,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;YACvD,SAAS,GAAG,cAAc,CAAC;SAC3B;QAED,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE;YAE/B,IAAI,CAAC,GAAG,IAAI,kDAAK,CAAC,kEAAgB,EAAE,oEAAkB,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC;YACjE,iEAAiE;YACjE,IAAI,GAAG,GAAG,IAAI,+CAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAE9E,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAC/B,IAAI,UAAU,KAAK,MAAM,IAAI,UAAU,KAAK,SAAS,EAAE;gBACtD,IAAI,CAAC,WAAW,GAAG,kEAAsB,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC5D,UAAU,GAAG,MAAM,CAAC;aACpB;YACD,wCAAwC;YACxC,yCAAyC;YACzC,IAAI,EAAE,GAAG,yEAA6B,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YAChD,IAAI,IAAI,CAAC,gBAAgB,KAAK,SAAS,EAAE;gBACxC,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;aACnD;YACD,IAAI,EAAE,GAAG,uEAA2B,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;YAE5F,SAAS,CAAC,IAAI,CAAC,IAAI,4DAAU,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;QACtD,CAAC,CAAC,CAAC;QAEH,OAAO,SAAS,CAAC;IAClB,CAAC;CAoBD;;;;;;;;;;;;;;;;;;;;;;;ACnsBD;;;;;;;GAOG;;;;;;;;;;AAImC;AACA;AACI;AAEJ;AAIc;AACV;AACU;AACA;AACrB;AAGxB,MAAM,kBAAkB;IAuB3B;QAEI,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC,0CAA0C;QACjE,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;QAC1B,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAA6B,CAAC;QACtD,IAAI,CAAC,WAAW,GAAG,IAAI,KAAK,EAAc,CAAC;IAC/C,CAAC;IAGK,YAAY,CAAC,MAAc;;YAE7B,IAAI,EAAE,GAAG,IAAI,gDAAU,CAAC,MAAM,CAAC,CAAC;YAChC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;YACtB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC;YAE3B,IAAI,OAAO,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBAEpC,4BAA4B;gBAC5B,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;gBACjC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;gBAClC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACzC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACzC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAe,CAAC;gBACtE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAe,CAAC;gBAEvE,yDAAyD;gBACzD,yDAAyD;gBACzD,wEAAwE;gBACxE,kFAAkF;gBAClF,kFAAkF;gBAElF,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAe,CAAC;gBAC/E,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAe,CAAC;gBAC/E,IAAI,OAAO,KAAK,OAAO,IAAI,OAAO,KAAK,SAAS,IAAI,OAAO,KAAK,SAAS,EAAE;oBACvE,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC;oBAClD,yCAAI,CAAC;iBACR;gBACD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;gBAEvB,iEAAiE;gBACjE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;gBAC7D,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;oBACjB,IAAI,CAAC,MAAM,IAAI,GAAG,CAAC;iBACtB;gBACD,mEAAmE;gBACnE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;gBAE/D,OAAO,IAAI,CAAC;YAChB,CAAC,CAAC,CAAC;YACH,MAAM,OAAO,CAAC;YACd,OAAO,OAAO,CAAC;QACnB,CAAC;KAAA;IAED,qBAAqB,CAAC,IAAgB;QAElC,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACrC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACtC,IAAI,UAAU,GAAG,oEAA8B,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,sDAAsD;QAC7I,kDAAkD;QAClD,IAAI,cAAc,GAAe,IAAI,KAAK,CAAW,MAAM,CAAC,CAAC;QAE7D,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,EAAE,EAAE,EAAE,EAAE;YAChC,cAAc,CAAC,EAAE,CAAC,GAAG,IAAI,KAAK,CAAS,MAAM,CAAC,CAAC;YAC/C,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,EAAE,EAAE,EAAE,EAAE;gBAChC,IAAI,MAAM,GAAG,kEAA4B,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE,GAAG,UAAU,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,EAAE,MAAM,CAAC,CAAC;gBAClH,IAAI,WAAW,GAAG,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC;gBAC1C,cAAc,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC;aACxC;SACJ;QACD,OAAO,cAAc,CAAC;IAG1B,CAAC;IAED,iBAAiB,CAAC,gBAA4B;QAE1C,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,gDAAU,EAAE,CAAC;QAGvC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QACxG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QAExG,IAAI,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,EAAE;YAC7C,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SAC3F;QAED,IAAI,MAAM,GAAG,GAAG,CAAC;QACjB,IAAI,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;YAC9C,MAAM,GAAG,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;SAC3C;QACD,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;QAElE,IAAI,KAAK,GAAG,GAAG,CAAC;QAChB,IAAI,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,EAAE;YAC7C,KAAK,GAAG,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;SACzC;QACD,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QAGhE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;QAC5D,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QACxE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QAExE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,GAAG,GAAC,IAAI,CAAC,OAAO,GAAC,GAAG,CAAC,CAAC,CAAC;QAChF,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,GAAG,GAAC,IAAI,CAAC,OAAO,GAAC,GAAG,CAAC,CAAC,CAAC;QAEhF,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,qCAAqC;QAC9G,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,qCAAqC;QAC9G,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,yCAAyC;QACtH,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,yCAAyC;QACtH,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,6BAA6B;QACtG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,8BAA8B;QAExG,IAAI,GAAG,GAAG,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC;QAChD,IAAI,GAAG,GAAG,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC;QAChD,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,iBAAiB;QAClF,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,iBAAiB;QAGlF,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC,CAAC;QAC9E,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,SAAS,EAAE,yDAAyD,CAAC,CAAC,CAAC;QACtH,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,KAAK,CAAC,CAAC,CAAC;QAEvD,OAAO,IAAI,CAAC,WAAW,CAAC;IAE5B,CAAC;IACD,aAAa;QACT,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED,yBAAyB;QACrB,IAAI,MAAM,GAAG,IAAI,gDAAU,EAAE,CAAC;QAC9B,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE;YAC5C,oFAAoF;YACpF,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAE1E,MAAM,CAAC,OAAO,CAAC,IAAI,oDAAc,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;aAElD;SACJ;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAED,IAAI,QAAQ;QACd,OAAO,IAAI,CAAC,SAAS,CAAC;IACvB,CAAC;IAEQ,YAAY,CAAC,eAA6B;;YAE5C,IAAI,OAAO,GAAG,IAAI,OAAO,CAAa,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACtD,IAAI;oBACA,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;oBACjE,IAAI,UAAU,GAAG,oEAA8B,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,UAAU,CAAC,CAAC;oBAC9F,IAAI,QAAQ,GAAG,eAAe,CAAC,MAAM,CAAC;oBAEtC,IAAI,MAAM,GAAG,IAAI,UAAU,CAAC,QAAQ,GAAG,UAAU,CAAC,CAAC;oBAEnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;wBAE/B,IAAI,KAAK,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC;wBAC/B,2EAA2E;wBAC3E,6DAA6D;wBAC7D,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO;4BAC5C,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,EAAE;4BAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;gCACjC,MAAM,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;6BAC9C;yBACJ;6BAAM;4BACH,IAAI,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;4BAC/B,IAAI,EAAE,KAAK,SAAS,EAAE;gCAElB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;oCAEjC,MAAM,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC;iCAC1E;6BACJ;yBAEJ;qBACJ;oBACD,OAAO,CAAC,MAAM,CAAC,CAAC;iBACnB;gBAAC,OAAO,GAAG,EAAE;oBACV,MAAM,CAAC,8BAA8B,GAAG,GAAG,CAAC,CAAC;iBAChD;YAEL,CAAC,CAAC,CAAC;YACH,OAAO,OAAO,CAAC;QAEnB,CAAC;KAAA;IAGD,mBAAmB,CAAC,CAAS,EAAE,EAAU;QACrC,oCAAoC;QACpC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;QACjC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;IACtB,CAAC;IAID,WAAW,CAAC,MAAkB,EAAE,gBAA4B;QAExD,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;QAC9D,IAAI,OAAO,GAAG,kEAA4B,CAAC,CAAC,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC3G,IAAI,OAAO,GAAG,OAAO,CAAC;QAEtB,IAAI,MAAM,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QACnG,IAAI,KAAK,GAAG,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QAEhG,IAAI,CAAC,eAAe,GAAG,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;QAChD,IAAI,CAAC,eAAe,GAAG,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;QAEhD,4CAA4C;QAC5C,2CAA2C;QAC3C,qEAAqE;QACrE,IAAI;QACJ,kFAAkF;QAElF,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,KAAK,CAAa,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QAC3D,IAAI,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAC/B,IAAI,EAAE,KAAK,SAAS,EAAE;YAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,EAAE;gBACnC,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,CAAC;aACrD;YAED,IAAI,CAAU,CAAC;YACf,IAAI,CAAU,CAAC;YACf,IAAI,CAAU,CAAC;YACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACnD,uEAAuE;gBAEvE,IAAI;oBACA,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;oBACjC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,UAAU,CAAC;oBAExC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;wBAC7B,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC;qBAC7C;oBAGD,IAAI,OAAO,GAAG,kEAA4B,CAAC,CAAC,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,UAAU,EAAE,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,UAAU,CAAC,EAAE,gBAAgB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAC3I,IAAI,WAAW,GAAG,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;oBAE3C,IAAI,WAAW,GAAG,IAAI,CAAC,eAAe,IAAI,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;wBACnE,IAAI,CAAC,eAAe,GAAG,WAAW,CAAC;qBACtC;yBAAM,IAAI,WAAW,GAAG,IAAI,CAAC,eAAe,IAAI,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;wBAC1E,IAAI,CAAC,eAAe,GAAG,WAAW,CAAC;qBACtC;iBACJ;gBAAC,OAAO,GAAG,EAAE;oBACV,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC;oBAChB,OAAO,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC;oBACrB,OAAO,CAAC,GAAG,CAAC,eAAe,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;oBACtC,OAAO,CAAC,GAAG,CAAC,2BAA2B,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBACvD,OAAO,CAAC,GAAG,CAAC,6BAA6B,GAAG,MAAM,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC;iBAC1E;aAEJ;SACJ;QAED,IAAI,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,CAAC;QACzC,OAAO,IAAI,CAAC,SAAS,CAAC;IAE1B,CAAC;IAID,iBAAiB,CAAC,MAAa,EAAE,MAAc,EAAE,MAAc;QAG3D,IAAI,CAAC,mBAAmB,CAAC,CAAC,GAAG,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC,sBAAsB;QACpE,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC;QAC1C,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;YACjB,IAAI,CAAC,MAAM,IAAI,GAAG,CAAC;SACtB;QACD,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC;QAE5C,IAAI,SAAS,GAA4B,IAAI,KAAK,EAAoB,CAAC;QAEvE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,EAAE;YACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC,EAAE,EAAE;gBACnC,SAAS,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;aACzF;SACJ;QAED,wEAAwE;QACxE,qEAAqE;QACrE,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC3C,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QAClC,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QAEnC,OAAO,SAAS,CAAC;IAGrB,CAAC;IAGD,gGAAgG;IAEhG,6DAA6D;IAC7D,gFAAgF;IAChF,iCAAiC;IACjC,+CAA+C;IAC/C,iCAAiC;IACjC,kCAAkC;IAClC,YAAY;IACZ,iDAAiD;IAEjD,iEAAiE;IAEjE,mDAAmD;IACnD,uDAAuD;IACvD,0GAA0G;IAC1G,oBAAoB;IACpB,YAAY;IAEZ,4EAA4E;IAC5E,+CAA+C;IAC/C,gDAAgD;IAEhD,8BAA8B;IAC9B,UAAU;IACV,sBAAsB;IAEtB,IAAI;IAEJ,yDAAyD;IACzD,SAAS,CAAC,CAAS,EAAE,CAAS;QAE1B,IAAI,EAAU,CAAC;QACf,IAAI,GAAW,CAAC;QAChB,uCAAuC;QACvC,0CAA0C;QAC1C,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC;QACpC,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QACtC,IAAI,CAAC,GAAG,IAAI,kDAAK,CAAC,kEAAgB,EAAE,oEAAkB,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC;QACjE,OAAO,CAAC,CAAC;QACT,oBAAoB;IAExB,CAAC;IAED,6DAA6D;IAE7D,uEAAuE;IAEvE,4DAA4D;IAC5D,kCAAkC;IAElC,iDAAiD;IACjD,yCAAyC;IACzC,0CAA0C;IAC1C,0EAA0E;IAC1E,4EAA4E;IAC5E,wDAAwD;IACxD,gBAAgB;IAEhB,kCAAkC;IAClC,cAAc;IAEd,UAAU;IACV,sBAAsB;IACtB,IAAI;IAEJ,SAAS,CAAC,SAAqB;QAE3B,IAAI,SAAS,GAAiB,EAAE,CAAC;QAEjC,KAAK,IAAI,SAAS,IAAI,SAAS,EAAE;YAC7B,IAAI,EAAE,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,GAAG,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YACvB,0DAA0D;YAC1D,4DAA4D;YAC5D,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;YACtD,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;YACxD,SAAS,CAAC,IAAI,CAAC,IAAI,4DAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;SACxC;QAED,OAAO,SAAS,CAAC;IAErB,CAAC;CASJ;;;;;;;;;;;;;;;;;ACtbD,2DAA2D;AAC3D,4DAA4D;AAC5D,oEAAoE;AACpE,4DAA4D;AAGtB;AACA;AACI;AAOnC,MAAM,QAAQ;IAmBjB;QACI,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC,0CAA0C;QACjE,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC;QAC1B,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAA6B,CAAC;QACtD,MAAM,EAAE,GAAG,IAAI,gDAAU,EAAE,CAAC;QAC5B,MAAM,EAAE,GAAG,IAAI,gDAAU,CAAC,gBAAgB,CAAC,CAAC;QAC5C,MAAM,GAAG,GAAG,IAAI,oDAAc,CAAC,OAAO,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;IAGpE,CAAC;IACD,IAAW,QAAQ;QACf,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IAEM,YAAY,CAAC,YAAqB,EAAE,OAAgB,EAAE,MAAe,EAAE,KAAc;QACxF,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,iBAAiB,CAAC,gBAA4B;QACjD,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,aAAa;QAChB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,yBAAyB;QAC5B,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,qBAAqB,CAAC,IAAgB;QACzC,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,YAAY,CAAC,eAA6B;QAC7C,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,mBAAmB,CAAC,CAAS,EAAE,EAAU;QAC5C,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,WAAW,CAAC,MAAkB,EAAE,gBAA4B;QAC/D,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,iBAAiB,CAAC,MAAa,EAAE,MAAc,EAAE,MAAc;QAClE,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,SAAS,CAAC,CAAS,EAAE,CAAS;QACjC,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;IACM,SAAS,CAAC,SAAqB;QAClC,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC/C,CAAC;CACJ;;;;;;;;;;;ACrFD;;;;;;;;;;;;;;;;ACAiC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACmC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACxDa;AACoC;AACN;AACV;AACE;AACM;AACJ;AACI;AACR;AACF;AACE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,2BAA2B,gDAAS;AACpC,2BAA2B,gDAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAAI;AAC5B,wBAAwB,0CAAI;AAC5B,wBAAwB,0CAAI;AAC5B,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,4BAA4B,0CAAI;AAChC,mCAAmC,0CAAI;AACvC,uCAAuC,0CAAI;AAC3C,uCAAuC,0CAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wCAAG;AACzB;AACA;AACA;AACA,wBAAwB,0CAAI;AAC5B,wBAAwB,0CAAI;AAC5B,wBAAwB,0CAAI;AAC5B,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,sBAAsB,wCAAG;AACzB;AACA;AACA;AACA,wBAAwB,0CAAI;AAC5B,wBAAwB,0CAAI;AAC5B,wBAAwB,0CAAI;AAC5B,wBAAwB,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wCAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,mCAAmC;AACnC;AACA;AACA,gDAAgD;AAChD,gDAAgD;AAChD,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,mDAAmD;AACnD;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,8CAA8C,2DAAgB,6BAA6B,2DAAgB;AAC3G;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB,wBAAwB,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,oBAAoB,wDAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAQ,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAgB;AACvC;AACA;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC;AACA,sBAAsB,iDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB,wBAAwB,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW,OAAO;AACtC;AACA,6CAA6C;AAC7C,wBAAwB,QAAQ;AAChC;AACA,kEAAkE,gDAAS;AAC3E,8CAA8C,gDAAS;AACvD,6DAA6D,gDAAS;AACtE;AACA;AACA,sBAAsB,8CAAM;AAC5B,wBAAwB,QAAQ,OAAO;AACvC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,eAAe,eAAe;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,kDAAkD;AAClD;AACA;AACA,mBAAmB;AACnB,gCAAgC,OAAO;AACvC,sDAAsD;AACtD;AACA;AACA;AACA,mCAAmC;AACnC,6BAA6B;AAC7B,+DAA+D;AAC/D,iCAAiC;AACjC;AACA,mBAAmB;AACnB,gCAAgC;AAChC,oCAAoC,OAAO,OAAO;AAClD,0DAA0D;AAC1D;AACA;AACA,uBAAuB;AACvB,mEAAmE;AACnE,qCAAqC;AACrC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,kCAAkC;AAClC,yCAAyC;AACzC,gCAAgC;AAChC,oCAAoC,OAAO,OAAO;AAClD,0DAA0D;AAC1D;AACA;AACA,uBAAuB;AACvB,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAAI;AAC5B;AACA,qBAAqB,0CAAI;AACzB;AACA;AACA,wBAAwB,0CAAI;AAC5B;AACA,qBAAqB,0CAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS;AAC/B,sBAAsB,gDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA,SAAS,iBAAiB,wBAAwB,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAQ;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,mBAAmB,wDAAkB;AACrC;AACA;AACA,qBAAqB,gDAAS;AAC9B,qBAAqB,gDAAS;AAC9B,wBAAwB,WAAW,OAAO;AAC1C,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,wBAAwB,QAAQ,OAAO;AACvC;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7vBiC;AACA;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAI;AAC7B;AACA;AACA;AACA;AACA,mBAAmB,0CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/LmC;AAC5B;AACP;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA,yBAAyB,kDAAW;AACpC;AACA,4BAA4B,kDAAW;AACvC;AACA;AACA,2BAA2B,kDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACmC;AACM;AAClC;AACP;AACA,4BAA4B,kDAAQ;AACpC;AACA,sBAAsB,gDAAS;AAC/B,2BAA2B,gDAAS;AACpC,2BAA2B,gDAAS;AACpC,qBAAqB,gDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,eAAe,kDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gDAAS;AAC3B,sBAAsB,gDAAS;AAC/B,sBAAsB,gDAAS;AAC/B,gBAAgB,gDAAS;AACzB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpHA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACR2C;AACN;AACY;AAChB;AACM;AACE;AACA;AACR;AACF;AACE;AACE;AACnC;;;;;;;;;;;;;;;ACXO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5CA;;AAEA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6C;AACI;AACF;AAC/C;AACA,YAAY,WAAW;AAChB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,uBAAuB,8DAAiB;AACxC,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sNAA2B;AACzD;AACA;AACA;AACA;AACA,8BAA8B,+MAAsB;AACpD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACsB;AACd;AAC7C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oEAAc;AACvC;AACA;AACA,wBAAwB,wCAAwC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC,mCAAmC,gEAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB,+CAAI,qBAAqB,0BAA0B;AACzE,gDAAgD,uBAAuB;AACvE;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5JmD;AACQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oEAAc;AACzC;AACA;AACA;AACA,+BAA+B,oEAAc;AAC7C;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAc;AACjD;AACA;AACA;AACA,mCAAmC,oEAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAc;AACjC;AACA;AACA,mBAAmB,oEAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5KA;AAC2D;AACd;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAc;AAC9C,gCAAgC,oEAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,qBAAqB,6EAAiC;AACtD;AACA;AACA;AACA,qBAAqB,6EAAiC;AACtD;AACA;AACA;AACA;AACA,qBAAqB,+EAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+EAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA,4BAA4B,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1I2D;AACR;AACN;AACA;AACE;AACE;AACJ;AAC7C;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UCxBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA;WACA,uBAAuB,4BAA4B;WACnD;WACA;WACA;WACA,iBAAiB,oBAAoB;WACrC;WACA,mGAAmG,YAAY;WAC/G;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,mEAAmE,iCAAiC;WACpG;WACA;WACA;WACA;;;;;WCzCA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA,iCAAiC;;WAEjC;WACA;WACA;WACA,KAAK;WACL,eAAe;WACf;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;WACA;WACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpFsC;AAIU;AAOA;AACA;AACV;AAWA;AACgC;AACA;AACF;AACd;AACQ;AACQ;AACpB","sources":["webpack://wcslight/webpack/universalModuleDefinition","webpack://wcslight/./node_modules/blob-polyfill/Blob.js","webpack://wcslight/./src/WCSLight.ts","webpack://wcslight/./src/model/CoordsType.ts","webpack://wcslight/./src/model/ImagePixel.ts","webpack://wcslight/./src/model/NumberType.ts","webpack://wcslight/./src/model/Point.ts","webpack://wcslight/./src/model/Utils.ts","webpack://wcslight/./src/projections/AbstractProjection.ts","webpack://wcslight/./src/projections/GnomonicProjection.ts","webpack://wcslight/./src/projections/HEALPixProjection.ts","webpack://wcslight/./src/projections/HiPSHelper.ts","webpack://wcslight/./src/projections/HiPSProjection.ts","webpack://wcslight/./src/projections/MercatorProjection.ts","webpack://wcslight/./src/projections/TestProj.ts","webpack://wcslight/ignored|/Users/fgiordano/Desktop/dottorato/code/github/wcslight/src/projections|process","webpack://wcslight/./node_modules/healpixjs/lib-esm/CircleFinder.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Constants.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Fxyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Healpix.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Hploc.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Pointing.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/RangeSet.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Vec3.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Xyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Zphi.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/index.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/pstack.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSParser.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSWriter.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParsePayload.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseUtils.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/index.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js","webpack://wcslight/webpack/bootstrap","webpack://wcslight/webpack/runtime/compat get default export","webpack://wcslight/webpack/runtime/define property getters","webpack://wcslight/webpack/runtime/ensure chunk","webpack://wcslight/webpack/runtime/get javascript chunk filename","webpack://wcslight/webpack/runtime/global","webpack://wcslight/webpack/runtime/hasOwnProperty shorthand","webpack://wcslight/webpack/runtime/load script","webpack://wcslight/webpack/runtime/make namespace object","webpack://wcslight/webpack/runtime/publicPath","webpack://wcslight/webpack/runtime/jsonp chunk loading","webpack://wcslight/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"wcslight\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wcslight\"] = factory();\n\telse\n\t\troot[\"wcslight\"] = factory();\n})(self, () => {\nreturn ","/* Blob.js\n * A Blob, File, FileReader & URL implementation.\n * 2020-02-01\n *\n * By Eli Grey, https://eligrey.com\n * By Jimmy Wrting, https://github.com/jimmywarting\n * License: MIT\n *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md\n */\n\n(function(global) {\n\t(function (factory) {\n\t\tif (typeof define === \"function\" && define.amd) {\n\t\t\t// AMD. Register as an anonymous module.\n\t\t\tdefine([\"exports\"], factory);\n\t\t} else if (typeof exports === \"object\" && typeof exports.nodeName !== \"string\") {\n\t\t\t// CommonJS\n\t\t\tfactory(exports);\n\t\t} else {\n\t\t\t// Browser globals\n\t\t\tfactory(global);\n\t\t}\n\t})(function (exports) {\n\t\t\"use strict\";\n\n\t\tvar BlobBuilder = global.BlobBuilder\n\t\t\t|| global.WebKitBlobBuilder\n\t\t\t|| global.MSBlobBuilder\n\t\t\t|| global.MozBlobBuilder;\n\n\t\tvar URL = global.URL || global.webkitURL || function (href, a) {\n\t\t\ta = document.createElement(\"a\");\n\t\t\ta.href = href;\n\t\t\treturn a;\n\t\t};\n\n\t\tvar origBlob = global.Blob;\n\t\tvar createObjectURL = URL.createObjectURL;\n\t\tvar revokeObjectURL = URL.revokeObjectURL;\n\t\tvar strTag = global.Symbol && global.Symbol.toStringTag;\n\t\tvar blobSupported = false;\n\t\tvar blobSupportsArrayBufferView = false;\n\t\tvar blobBuilderSupported = BlobBuilder\n\t\t\t&& BlobBuilder.prototype.append\n\t\t\t&& BlobBuilder.prototype.getBlob;\n\n\t\ttry {\n\t\t\t// Check if Blob constructor is supported\n\t\t\tblobSupported = new Blob([\"\"]).size === 2;\n\n\t\t\t// Check if Blob constructor supports ArrayBufferViews\n\t\t\t// Fails in Safari 6, so we need to map to ArrayBuffers there.\n\t\t\tblobSupportsArrayBufferView = new Blob([new Uint8Array([1, 2])]).size === 2;\n\t\t} catch (e) {/**/}\n\n\n\t\t// Helper function that maps ArrayBufferViews to ArrayBuffers\n\t\t// Used by BlobBuilder constructor and old browsers that didn't\n\t\t// support it in the Blob constructor.\n\t\tfunction mapArrayBufferViews (ary) {\n\t\t\treturn ary.map(function (chunk) {\n\t\t\t\tif (chunk.buffer instanceof ArrayBuffer) {\n\t\t\t\t\tvar buf = chunk.buffer;\n\n\t\t\t\t\t// if this is a subarray, make a copy so we only\n\t\t\t\t\t// include the subarray region from the underlying buffer\n\t\t\t\t\tif (chunk.byteLength !== buf.byteLength) {\n\t\t\t\t\t\tvar copy = new Uint8Array(chunk.byteLength);\n\t\t\t\t\t\tcopy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n\t\t\t\t\t\tbuf = copy.buffer;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn buf;\n\t\t\t\t}\n\n\t\t\t\treturn chunk;\n\t\t\t});\n\t\t}\n\n\t\tfunction BlobBuilderConstructor (ary, options) {\n\t\t\toptions = options || {};\n\n\t\t\tvar bb = new BlobBuilder();\n\t\t\tmapArrayBufferViews(ary).forEach(function (part) {\n\t\t\t\tbb.append(part);\n\t\t\t});\n\n\t\t\treturn options.type ? bb.getBlob(options.type) : bb.getBlob();\n\t\t}\n\n\t\tfunction BlobConstructor (ary, options) {\n\t\t\treturn new origBlob(mapArrayBufferViews(ary), options || {});\n\t\t}\n\n\t\tif (global.Blob) {\n\t\t\tBlobBuilderConstructor.prototype = Blob.prototype;\n\t\t\tBlobConstructor.prototype = Blob.prototype;\n\t\t}\n\n\t\t/********************************************************/\n\t\t/*               String Encoder fallback                */\n\t\t/********************************************************/\n\t\tfunction stringEncode (string) {\n\t\t\tvar pos = 0;\n\t\t\tvar len = string.length;\n\t\t\tvar Arr = global.Uint8Array || Array; // Use byte array when possible\n\n\t\t\tvar at = 0; // output position\n\t\t\tvar tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n\t\t\tvar target = new Arr((tlen >> 3) << 3); // ... but at 8 byte offset\n\n\t\t\twhile (pos < len) {\n\t\t\t\tvar value = string.charCodeAt(pos++);\n\t\t\t\tif (value >= 0xd800 && value <= 0xdbff) {\n\t\t\t\t\t// high surrogate\n\t\t\t\t\tif (pos < len) {\n\t\t\t\t\t\tvar extra = string.charCodeAt(pos);\n\t\t\t\t\t\tif ((extra & 0xfc00) === 0xdc00) {\n\t\t\t\t\t\t\t++pos;\n\t\t\t\t\t\t\tvalue = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (value >= 0xd800 && value <= 0xdbff) {\n\t\t\t\t\t\tcontinue; // drop lone surrogate\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// expand the buffer if we couldn't write 4 bytes\n\t\t\t\tif (at + 4 > target.length) {\n\t\t\t\t\ttlen += 8; // minimum extra\n\t\t\t\t\ttlen *= (1.0 + (pos / string.length) * 2); // take 2x the remaining\n\t\t\t\t\ttlen = (tlen >> 3) << 3; // 8 byte offset\n\n\t\t\t\t\tvar update = new Uint8Array(tlen);\n\t\t\t\t\tupdate.set(target);\n\t\t\t\t\ttarget = update;\n\t\t\t\t}\n\n\t\t\t\tif ((value & 0xffffff80) === 0) { // 1-byte\n\t\t\t\t\ttarget[at++] = value; // ASCII\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if ((value & 0xfffff800) === 0) { // 2-byte\n\t\t\t\t\ttarget[at++] = ((value >> 6) & 0x1f) | 0xc0;\n\t\t\t\t} else if ((value & 0xffff0000) === 0) { // 3-byte\n\t\t\t\t\ttarget[at++] = ((value >> 12) & 0x0f) | 0xe0;\n\t\t\t\t\ttarget[at++] = ((value >> 6) & 0x3f) | 0x80;\n\t\t\t\t} else if ((value & 0xffe00000) === 0) { // 4-byte\n\t\t\t\t\ttarget[at++] = ((value >> 18) & 0x07) | 0xf0;\n\t\t\t\t\ttarget[at++] = ((value >> 12) & 0x3f) | 0x80;\n\t\t\t\t\ttarget[at++] = ((value >> 6) & 0x3f) | 0x80;\n\t\t\t\t} else {\n\t\t\t\t\t// FIXME: do we care\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttarget[at++] = (value & 0x3f) | 0x80;\n\t\t\t}\n\n\t\t\treturn target.slice(0, at);\n\t\t}\n\n\t\t/********************************************************/\n\t\t/*               String Decoder fallback                */\n\t\t/********************************************************/\n\t\tfunction stringDecode (buf) {\n\t\t\tvar end = buf.length;\n\t\t\tvar res = [];\n\n\t\t\tvar i = 0;\n\t\t\twhile (i < end) {\n\t\t\t\tvar firstByte = buf[i];\n\t\t\t\tvar codePoint = null;\n\t\t\t\tvar bytesPerSequence = (firstByte > 0xEF) ? 4\n\t\t\t\t\t: (firstByte > 0xDF) ? 3\n\t\t\t\t\t\t: (firstByte > 0xBF) ? 2\n\t\t\t\t\t\t\t: 1;\n\n\t\t\t\tif (i + bytesPerSequence <= end) {\n\t\t\t\t\tvar secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t\t\t\t\tswitch (bytesPerSequence) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (firstByte < 0x80) {\n\t\t\t\t\t\t\tcodePoint = firstByte;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tsecondByte = buf[i + 1];\n\t\t\t\t\t\tif ((secondByte & 0xC0) === 0x80) {\n\t\t\t\t\t\t\ttempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t\t\t\t\t\t\tif (tempCodePoint > 0x7F) {\n\t\t\t\t\t\t\t\tcodePoint = tempCodePoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tsecondByte = buf[i + 1];\n\t\t\t\t\t\tthirdByte = buf[i + 2];\n\t\t\t\t\t\tif ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t\t\t\t\t\t\ttempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t\t\t\t\t\t\tif (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t\t\t\t\t\t\t\tcodePoint = tempCodePoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tsecondByte = buf[i + 1];\n\t\t\t\t\t\tthirdByte = buf[i + 2];\n\t\t\t\t\t\tfourthByte = buf[i + 3];\n\t\t\t\t\t\tif ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t\t\t\t\t\t\ttempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t\t\t\t\t\t\tif (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t\t\t\t\t\t\t\tcodePoint = tempCodePoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (codePoint === null) {\n\t\t\t\t\t// we did not generate a valid codePoint so insert a\n\t\t\t\t\t// replacement char (U+FFFD) and advance only 1 byte\n\t\t\t\t\tcodePoint = 0xFFFD;\n\t\t\t\t\tbytesPerSequence = 1;\n\t\t\t\t} else if (codePoint > 0xFFFF) {\n\t\t\t\t\t// encode to utf16 (surrogate pair dance)\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\tres.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t\t\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\n\t\t\t\t}\n\n\t\t\t\tres.push(codePoint);\n\t\t\t\ti += bytesPerSequence;\n\t\t\t}\n\n\t\t\tvar len = res.length;\n\t\t\tvar str = \"\";\n\t\t\tvar j = 0;\n\n\t\t\twhile (j < len) {\n\t\t\t\tstr += String.fromCharCode.apply(String, res.slice(j, j += 0x1000));\n\t\t\t}\n\n\t\t\treturn str;\n\t\t}\n\n\t\t// string -> buffer\n\t\tvar textEncode = typeof TextEncoder === \"function\"\n\t\t\t? TextEncoder.prototype.encode.bind(new TextEncoder())\n\t\t\t: stringEncode;\n\n\t\t// buffer -> string\n\t\tvar textDecode = typeof TextDecoder === \"function\"\n\t\t\t? TextDecoder.prototype.decode.bind(new TextDecoder())\n\t\t\t: stringDecode;\n\n\t\tfunction FakeBlobBuilder () {\n\t\t\tfunction bufferClone (buf) {\n\t\t\t\tvar view = new Array(buf.byteLength);\n\t\t\t\tvar array = new Uint8Array(buf);\n\t\t\t\tvar i = view.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tview[i] = array[i];\n\t\t\t\t}\n\t\t\t\treturn view;\n\t\t\t}\n\t\t\tfunction array2base64 (input) {\n\t\t\t\tvar byteToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n\t\t\t\tvar output = [];\n\n\t\t\t\tfor (var i = 0; i < input.length; i += 3) {\n\t\t\t\t\tvar byte1 = input[i];\n\t\t\t\t\tvar haveByte2 = i + 1 < input.length;\n\t\t\t\t\tvar byte2 = haveByte2 ? input[i + 1] : 0;\n\t\t\t\t\tvar haveByte3 = i + 2 < input.length;\n\t\t\t\t\tvar byte3 = haveByte3 ? input[i + 2] : 0;\n\n\t\t\t\t\tvar outByte1 = byte1 >> 2;\n\t\t\t\t\tvar outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n\t\t\t\t\tvar outByte3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);\n\t\t\t\t\tvar outByte4 = byte3 & 0x3F;\n\n\t\t\t\t\tif (!haveByte3) {\n\t\t\t\t\t\toutByte4 = 64;\n\n\t\t\t\t\t\tif (!haveByte2) {\n\t\t\t\t\t\t\toutByte3 = 64;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tbyteToCharMap[outByte1], byteToCharMap[outByte2],\n\t\t\t\t\t\tbyteToCharMap[outByte3], byteToCharMap[outByte4]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn output.join(\"\");\n\t\t\t}\n\n\t\t\tvar create = Object.create || function (a) {\n\t\t\t\tfunction c () {}\n\t\t\t\tc.prototype = a;\n\t\t\t\treturn new c();\n\t\t\t};\n\n\t\t\tfunction getObjectTypeName (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t}\n\n\t\t\tfunction isPrototypeOf(c, o) {\n\t\t\t\treturn typeof c === \"object\" && Object.prototype.isPrototypeOf.call(c.prototype, o);\n\t\t\t}\n\n\t\t\tfunction isDataView (o) {\n\t\t\t\treturn getObjectTypeName(o) === \"DataView\" || isPrototypeOf(global.DataView, o);\n\t\t\t}\n\n\t\t\tvar arrayBufferClassNames = [\n\t\t\t\t\"Int8Array\",\n\t\t\t\t\"Uint8Array\",\n\t\t\t\t\"Uint8ClampedArray\",\n\t\t\t\t\"Int16Array\",\n\t\t\t\t\"Uint16Array\",\n\t\t\t\t\"Int32Array\",\n\t\t\t\t\"Uint32Array\",\n\t\t\t\t\"Float32Array\",\n\t\t\t\t\"Float64Array\",\n\t\t\t\t\"ArrayBuffer\"\n\t\t\t];\n\n\t\t\tfunction includes(a, v) {\n\t\t\t\treturn a.indexOf(v) !== -1;\n\t\t\t}\n\n\t\t\tfunction isArrayBuffer(o) {\n\t\t\t\treturn includes(arrayBufferClassNames, getObjectTypeName(o)) || isPrototypeOf(global.ArrayBuffer, o);\n\t\t\t}\n\n\t\t\tfunction concatTypedarrays (chunks) {\n\t\t\t\tvar size = 0;\n\t\t\t\tvar j = chunks.length;\n\t\t\t\twhile (j--) { size += chunks[j].length; }\n\t\t\t\tvar b = new Uint8Array(size);\n\t\t\t\tvar offset = 0;\n\t\t\t\tfor (var i = 0; i < chunks.length; i++) {\n\t\t\t\t\tvar chunk = chunks[i];\n\t\t\t\t\tb.set(chunk, offset);\n\t\t\t\t\toffset += chunk.byteLength || chunk.length;\n\t\t\t\t}\n\n\t\t\t\treturn b;\n\t\t\t}\n\n\t\t\t/********************************************************/\n\t\t\t/*                   Blob constructor                   */\n\t\t\t/********************************************************/\n\t\t\tfunction Blob (chunks, opts) {\n\t\t\t\tchunks = chunks ? chunks.slice() : [];\n\t\t\t\topts = opts == null ? {} : opts;\n\t\t\t\tfor (var i = 0, len = chunks.length; i < len; i++) {\n\t\t\t\t\tvar chunk = chunks[i];\n\t\t\t\t\tif (chunk instanceof Blob) {\n\t\t\t\t\t\tchunks[i] = chunk._buffer;\n\t\t\t\t\t} else if (typeof chunk === \"string\") {\n\t\t\t\t\t\tchunks[i] = textEncode(chunk);\n\t\t\t\t\t} else if (isDataView(chunk)) {\n\t\t\t\t\t\tchunks[i] = bufferClone(chunk.buffer);\n\t\t\t\t\t} else if (isArrayBuffer(chunk)) {\n\t\t\t\t\t\tchunks[i] = bufferClone(chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunks[i] = textEncode(String(chunk));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._buffer = global.Uint8Array\n\t\t\t\t\t? concatTypedarrays(chunks)\n\t\t\t\t\t: [].concat.apply([], chunks);\n\t\t\t\tthis.size = this._buffer.length;\n\n\t\t\t\tthis.type = opts.type || \"\";\n\t\t\t\tif (/[^\\u0020-\\u007E]/.test(this.type)) {\n\t\t\t\t\tthis.type = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tthis.type = this.type.toLowerCase();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBlob.prototype.arrayBuffer = function () {\n\t\t\t\treturn Promise.resolve(this._buffer.buffer || this._buffer);\n\t\t\t};\n\n\t\t\tBlob.prototype.text = function () {\n\t\t\t\treturn Promise.resolve(textDecode(this._buffer));\n\t\t\t};\n\n\t\t\tBlob.prototype.slice = function (start, end, type) {\n\t\t\t\tvar slice = this._buffer.slice(start || 0, end || this._buffer.length);\n\t\t\t\treturn new Blob([slice], {type: type});\n\t\t\t};\n\n\t\t\tBlob.prototype.toString = function () {\n\t\t\t\treturn \"[object Blob]\";\n\t\t\t};\n\n\t\t\t/********************************************************/\n\t\t\t/*                   File constructor                   */\n\t\t\t/********************************************************/\n\t\t\tfunction File (chunks, name, opts) {\n\t\t\t\topts = opts || {};\n\t\t\t\tvar a = Blob.call(this, chunks, opts) || this;\n\t\t\t\ta.name = name.replace(/\\//g, \":\");\n\t\t\t\ta.lastModifiedDate = opts.lastModified ? new Date(opts.lastModified) : new Date();\n\t\t\t\ta.lastModified = +a.lastModifiedDate;\n\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tFile.prototype = create(Blob.prototype);\n\t\t\tFile.prototype.constructor = File;\n\n\t\t\tif (Object.setPrototypeOf) {\n\t\t\t\tObject.setPrototypeOf(File, Blob);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFile.__proto__ = Blob;\n\t\t\t\t} catch (e) {/**/}\n\t\t\t}\n\n\t\t\tFile.prototype.toString = function () {\n\t\t\t\treturn \"[object File]\";\n\t\t\t};\n\n\t\t\t/********************************************************/\n\t\t\t/*                FileReader constructor                */\n\t\t\t/********************************************************/\n\t\t\tfunction FileReader () {\n\t\t\t\tif (!(this instanceof FileReader)) {\n\t\t\t\t\tthrow new TypeError(\"Failed to construct 'FileReader': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n\t\t\t\t}\n\n\t\t\t\tvar delegate = document.createDocumentFragment();\n\t\t\t\tthis.addEventListener = delegate.addEventListener;\n\t\t\t\tthis.dispatchEvent = function (evt) {\n\t\t\t\t\tvar local = this[\"on\" + evt.type];\n\t\t\t\t\tif (typeof local === \"function\") local(evt);\n\t\t\t\t\tdelegate.dispatchEvent(evt);\n\t\t\t\t};\n\t\t\t\tthis.removeEventListener = delegate.removeEventListener;\n\t\t\t}\n\n\t\t\tfunction _read (fr, blob, kind) {\n\t\t\t\tif (!(blob instanceof Blob)) {\n\t\t\t\t\tthrow new TypeError(\"Failed to execute '\" + kind + \"' on 'FileReader': parameter 1 is not of type 'Blob'.\");\n\t\t\t\t}\n\n\t\t\t\tfr.result = \"\";\n\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tthis.readyState = FileReader.LOADING;\n\t\t\t\t\tfr.dispatchEvent(new Event(\"load\"));\n\t\t\t\t\tfr.dispatchEvent(new Event(\"loadend\"));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tFileReader.EMPTY = 0;\n\t\t\tFileReader.LOADING = 1;\n\t\t\tFileReader.DONE = 2;\n\t\t\tFileReader.prototype.error = null;\n\t\t\tFileReader.prototype.onabort = null;\n\t\t\tFileReader.prototype.onerror = null;\n\t\t\tFileReader.prototype.onload = null;\n\t\t\tFileReader.prototype.onloadend = null;\n\t\t\tFileReader.prototype.onloadstart = null;\n\t\t\tFileReader.prototype.onprogress = null;\n\n\t\t\tFileReader.prototype.readAsDataURL = function (blob) {\n\t\t\t\t_read(this, blob, \"readAsDataURL\");\n\t\t\t\tthis.result = \"data:\" + blob.type + \";base64,\" + array2base64(blob._buffer);\n\t\t\t};\n\n\t\t\tFileReader.prototype.readAsText = function (blob) {\n\t\t\t\t_read(this, blob, \"readAsText\");\n\t\t\t\tthis.result = textDecode(blob._buffer);\n\t\t\t};\n\n\t\t\tFileReader.prototype.readAsArrayBuffer = function (blob) {\n\t\t\t\t_read(this, blob, \"readAsText\");\n\t\t\t\t// return ArrayBuffer when possible\n\t\t\t\tthis.result = (blob._buffer.buffer || blob._buffer).slice();\n\t\t\t};\n\n\t\t\tFileReader.prototype.abort = function () {};\n\n\t\t\t/********************************************************/\n\t\t\t/*                         URL                          */\n\t\t\t/********************************************************/\n\t\t\tURL.createObjectURL = function (blob) {\n\t\t\t\treturn blob instanceof Blob\n\t\t\t\t\t? \"data:\" + blob.type + \";base64,\" + array2base64(blob._buffer)\n\t\t\t\t\t: createObjectURL.call(URL, blob);\n\t\t\t};\n\n\t\t\tURL.revokeObjectURL = function (url) {\n\t\t\t\trevokeObjectURL && revokeObjectURL.call(URL, url);\n\t\t\t};\n\n\t\t\t/********************************************************/\n\t\t\t/*                         XHR                          */\n\t\t\t/********************************************************/\n\t\t\tvar _send = global.XMLHttpRequest && global.XMLHttpRequest.prototype.send;\n\t\t\tif (_send) {\n\t\t\t\tXMLHttpRequest.prototype.send = function (data) {\n\t\t\t\t\tif (data instanceof Blob) {\n\t\t\t\t\t\tthis.setRequestHeader(\"Content-Type\", data.type);\n\t\t\t\t\t\t_send.call(this, textDecode(data._buffer));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_send.call(this, data);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\texports.Blob = Blob;\n\t\t\texports.File = File;\n\t\t\texports.FileReader = FileReader;\n\t\t\texports.URL = URL;\n\t\t}\n\n\t\tfunction fixFileAndXHR () {\n\t\t\tvar isIE = !!global.ActiveXObject || (\n\t\t\t\t\"-ms-scroll-limit\" in document.documentElement.style &&\n\t\t\t\t\"-ms-ime-align\" in document.documentElement.style\n\t\t\t);\n\n\t\t\t// Monkey patched\n\t\t\t// IE doesn't set Content-Type header on XHR whose body is a typed Blob\n\t\t\t// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/6047383\n\t\t\tvar _send = global.XMLHttpRequest && global.XMLHttpRequest.prototype.send;\n\t\t\tif (isIE && _send) {\n\t\t\t\tXMLHttpRequest.prototype.send = function (data) {\n\t\t\t\t\tif (data instanceof Blob) {\n\t\t\t\t\t\tthis.setRequestHeader(\"Content-Type\", data.type);\n\t\t\t\t\t\t_send.call(this, data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_send.call(this, data);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tnew File([], \"\");\n\t\t\t\texports.File = global.File;\n\t\t\t\texports.FileReader = global.FileReader;\n\t\t\t} catch (e) {\n\t\t\t\ttry {\n\t\t\t\t\texports.File = new Function(\"class File extends Blob {\" +\n\t\t\t\t\t\t\"constructor(chunks, name, opts) {\" +\n\t\t\t\t\t\t\t\"opts = opts || {};\" +\n\t\t\t\t\t\t\t\"super(chunks, opts || {});\" +\n\t\t\t\t\t\t\t\"this.name = name.replace(/\\\\//g, \\\":\\\");\" +\n\t\t\t\t\t\t\t\"this.lastModifiedDate = opts.lastModified ? new Date(opts.lastModified) : new Date();\" +\n\t\t\t\t\t\t\t\"this.lastModified = +this.lastModifiedDate;\" +\n\t\t\t\t\t\t\"}};\" +\n\t\t\t\t\t\t\"return new File([], \\\"\\\"), File\"\n\t\t\t\t\t)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\texports.File = function (b, d, c) {\n\t\t\t\t\t\tvar blob = new Blob(b, c);\n\t\t\t\t\t\tvar t = c && void 0 !== c.lastModified ? new Date(c.lastModified) : new Date();\n\n\t\t\t\t\t\tblob.name = d.replace(/\\//g, \":\");\n\t\t\t\t\t\tblob.lastModifiedDate = t;\n\t\t\t\t\t\tblob.lastModified = +t;\n\t\t\t\t\t\tblob.toString = function () {\n\t\t\t\t\t\t\treturn \"[object File]\";\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (strTag) {\n\t\t\t\t\t\t\tblob[strTag] = \"File\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn blob;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (blobSupported) {\n\t\t\tfixFileAndXHR();\n\t\t\texports.Blob = blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n\t\t} else if (blobBuilderSupported) {\n\t\t\tfixFileAndXHR();\n\t\t\texports.Blob = BlobBuilderConstructor;\n\t\t} else {\n\t\t\tFakeBlobBuilder();\n\t\t}\n\n\t\tif (strTag) {\n\t\t\tif (!exports.File.prototype[strTag]) exports.File.prototype[strTag] = \"File\";\n\t\t\tif (!exports.Blob.prototype[strTag]) exports.Blob.prototype[strTag] = \"Blob\";\n\t\t\tif (!exports.FileReader.prototype[strTag]) exports.FileReader.prototype[strTag] = \"FileReader\";\n\t\t}\n\n\t\tvar blob = exports.Blob.prototype;\n\t\tvar stream;\n\n\t\ttry {\n\t\t\tnew ReadableStream({ type: \"bytes\" });\n\t\t\tstream = function stream() {\n\t\t\t\tvar position = 0;\n\t\t\t\tvar blob = this;\n\n\t\t\t\treturn new ReadableStream({\n\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\tautoAllocateChunkSize: 524288,\n\n\t\t\t\t\tpull: function (controller) {\n\t\t\t\t\t\tvar v = controller.byobRequest.view;\n\t\t\t\t\t\tvar chunk = blob.slice(position, position + v.byteLength);\n\t\t\t\t\t\treturn chunk.arrayBuffer()\n\t\t\t\t\t\t\t.then(function (buffer) {\n\t\t\t\t\t\t\t\tvar uint8array = new Uint8Array(buffer);\n\t\t\t\t\t\t\t\tvar bytesRead = uint8array.byteLength;\n\n\t\t\t\t\t\t\t\tposition += bytesRead;\n\t\t\t\t\t\t\t\tv.set(uint8array);\n\t\t\t\t\t\t\t\tcontroller.byobRequest.respond(bytesRead);\n\n\t\t\t\t\t\t\t\tif(position >= blob.size)\n\t\t\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t} catch (e) {\n\t\t\ttry {\n\t\t\t\tnew ReadableStream({});\n\t\t\t\tstream = function stream(blob){\n\t\t\t\t\tvar position = 0;\n\n\t\t\t\t\treturn new ReadableStream({\n\t\t\t\t\t\tpull: function (controller) {\n\t\t\t\t\t\t\tvar chunk = blob.slice(position, position + 524288);\n\n\t\t\t\t\t\t\treturn chunk.arrayBuffer().then(function (buffer) {\n\t\t\t\t\t\t\t\tposition += buffer.byteLength;\n\t\t\t\t\t\t\t\tvar uint8array = new Uint8Array(buffer);\n\t\t\t\t\t\t\t\tcontroller.enqueue(uint8array);\n\n\t\t\t\t\t\t\t\tif (position == blob.size)\n\t\t\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} catch (e) {\n\t\t\t\ttry {\n\t\t\t\t\tnew Response(\"\").body.getReader().read();\n\t\t\t\t\tstream = function stream() {\n\t\t\t\t\t\treturn (new Response(this)).body;\n\t\t\t\t\t};\n\t\t\t\t} catch (e) {\n\t\t\t\t\tstream = function stream() {\n\t\t\t\t\t\tthrow new Error(\"Include https://github.com/MattiasBuelens/web-streams-polyfill\");\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction promisify(obj) {\n\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\tobj.onload = obj.onerror = function(evt) {\n\t\t\t\t\tobj.onload = obj.onerror = null;\n\n\t\t\t\t\tevt.type === \"load\" ?\n\t\t\t\t\t\tresolve(obj.result || obj) :\n\t\t\t\t\t\treject(new Error(\"Failed to read the blob/file\"));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\tif (!blob.arrayBuffer) {\n\t\t\tblob.arrayBuffer = function arrayBuffer() {\n\t\t\t\tvar fr = new FileReader();\n\t\t\t\tfr.readAsArrayBuffer(this);\n\t\t\t\treturn promisify(fr);\n\t\t\t};\n\t\t}\n\n\t\tif (!blob.text) {\n\t\t\tblob.text = function text() {\n\t\t\t\tvar fr = new FileReader();\n\t\t\t\tfr.readAsText(this);\n\t\t\t\treturn promisify(fr);\n\t\t\t};\n\t\t}\n\n\t\tif (!blob.stream) {\n\t\t\tblob.stream = stream;\n\t\t}\n\t});\n})(\n\ttypeof self !== \"undefined\" && self ||\n\t\ttypeof window !== \"undefined\" && window ||\n\t\ttypeof global !== \"undefined\" && global ||\n\t\tthis\n);\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nimport { FITSParser } from 'jsfitsio';\nimport { MercatorProjection } from './projections/MercatorProjection.js';\nimport { HiPSProjection } from './projections/HiPSProjection.js';\nimport { Point } from './model/Point.js';\nimport { AbstractProjection } from './projections/AbstractProjection.js';\nimport { CutoutResult } from './model/CutoutResult.js';\n\nimport { HEALPixProjection } from './projections/HEALPixProjection.js';\nimport { GnomonicProjection } from './projections/GnomonicProjection.js';\n\nexport class WCSLight {\n\n    /** @constructs WCSLight */\n    constructor() { }\n\n    static async cutout(center: Point, radius: number,\n        pxsize: number, inproj: AbstractProjection, outproj: AbstractProjection): Promise<CutoutResult> {\n\n        const outRADecList: Array<Array<number>> = outproj.getImageRADecList(center, radius, pxsize);\n        if (outRADecList.length == 0) {\n            const res: CutoutResult = {\n                fitsheader: null,\n                fitsdata: null,\n                inproj: inproj,\n                outproj: outproj,\n                fitsused: inproj.fitsUsed\n            };\n            return res;\n        }\n        const inputPixelsList = inproj.world2pix(outRADecList);\n        try {\n\n            const invalues = await inproj.getPixValues(inputPixelsList);\n            const fitsHeaderParams = inproj.getCommonFitsHeaderParams();\n            if (invalues !== undefined) {\n                const fitsdata = outproj.setPxsValue(invalues, fitsHeaderParams);\n                const fitsheader = outproj.getFITSHeader();\n                // let canvas2d = outproj.getCanvas2d();\n                const res: CutoutResult = {\n                    fitsheader: fitsheader,\n                    fitsdata: fitsdata,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            } else {\n                const res: CutoutResult = {\n                    fitsheader: null,\n                    fitsdata: null,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            }\n\n        } catch (err) {\n            console.error(\"[WCSLight] ERROR: \" + err);\n            return null;\n        }\n\n    }\n\n    /**\n     * \n     * @param {*} fitsheader \n     * @param {*} fitsdata \n     * @returns {URL}\n     */\n    static generateFITS(fitsheader: any, fitsdata: any): string {\n        const blobUrl = FITSParser.generateFITS(fitsheader, fitsdata);\n        return blobUrl;\n    }\n\n\n\n\n    static changeProjection(filepath, outprojname) {\n        // TODO\n    }\n\n\n    static getProjection(projectionName: string) {\n        if (projectionName === \"Mercator\") {\n            return new MercatorProjection();\n        } else if (projectionName === \"HiPS\") {\n            return new HiPSProjection();\n        } else if (projectionName === \"HEALPix\") {\n            return new HEALPixProjection();\n        } else if (projectionName === \"Gnomonic\") {\n            return new GnomonicProjection();\n        } else {\n            return null;\n            // throw new ProjectionNotFound(projectionName);\n        }\n    }\n\n    static getAvaillableProjections() {\n        return [\"Mercator\", \"HiPS\", \"HEALPix\"];\n    }\n\n}\n\n","/**\n * @author Fabrizio Giordano (Fab77)\n * Enum for coordinate types.\n * @readonly\n * @enum {{name: string, hex: string}}\n */\n\nexport enum CoordsType {\n  CARTESIAN = \"cartesian\",\n  SPHERICAL = \"spherical\",\n  ASTRO = \"astro\"\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\n\nexport class ImagePixel {\n    _i: number;     // int i of input projection\n    _j: number;     // int j of input projection\n    _tileno: number;// int\n    \n    constructor (i: number = null, j: number = null, tileno: number = null) {\n        this._i = i;\n        this._j = j;\n        this._tileno = tileno;\n    }\n\n    geti() {\n        return this._i;\n    }\n\n    getj() {\n        return this._j;\n    }\n\n    get tileno() {\n        return this._tileno\n    }\n}\n","export enum NumberType {\n    DEGREES,\n    RADIANS,\n    DECIMAL,\n    HMS,\n    DMS\n}","/**\n * @author Fabrizio Giordano (Fab77)\n */\n\nimport {sphericalToCartesian, cartesianToSpherical, sphericalToAstro, astroToSpherical, fillSpherical, fillAstro} from './Utils.js';\nimport { CartesianCoords } from './CartesianCoords.js';\nimport { AstroCoords} from './AstroCoords.js';\nimport { CoordsType } from './CoordsType.js';\nimport { SphericalCoords } from './SphericalCoords.js';\nimport { NumberType } from './NumberType.js';\nimport { EquatorialCoords } from './EquatorialCoords.js';\nimport { GalacticCoords } from './GalacticCoords.js';\n\nexport class Point{\n\n\t#astro: AstroCoords;\n\t// #equatorial: EquatorialCoords;\n\t// #galactic: GalacticCoords;\n\n\t#spherical: SphericalCoords;\n\t#cartesian: CartesianCoords;\n\n\tconstructor(in_type: CoordsType, unit: NumberType, ...coords: Array<number>) {\n\n\t\tif (in_type == CoordsType.CARTESIAN){\n\t\t\tthis.#cartesian.x = parseFloat(coords[0].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.y = parseFloat(coords[1].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.z = parseFloat(coords[2].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t\t} else if (in_type == CoordsType.ASTRO){\n\t\t\tthis.#astro = fillAstro(coords[0],  coords[1], unit);\n\t\t\tthis.#spherical = astroToSpherical(this.#astro);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\n\t\t} else if (in_type == CoordsType.SPHERICAL){\n\t\t\tthis.#spherical = fillSpherical(coords[0],  coords[1], unit);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\n\t\t} else{\n\t\t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t\t}\n\t\tif (this.#spherical.phiDeg > 360) {\n\t\t\tthis.#spherical.phiDeg -= 360;\n\t\t}\n\t\tif (this.#astro.raDeg > 360) {\n\t\t\tthis.#astro.raDeg -= 360;\n\t\t}\n\t}\n\n\n\t// constructor(in_options: ICoordsFormat, in_type: CoordsType){\n\t\t\n\t// \tif (in_type == CoordsType.CARTESIAN){\n\n\t// \t\tthis.#cartesian.x = parseFloat((in_options as CartesianCoords).x.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.y = parseFloat((in_options as CartesianCoords).y.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.z = parseFloat((in_options as CartesianCoords).z.toFixed(global.MAX_DECIMALS));\n\n\t// \t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else if (in_type == CoordsType.ASTRO){\n\t\t\t\n\t// \t\tif ((in_options as AstroCoords).raDeg && (in_options as AstroCoords).decDeg) {\n\t// \t\t\tthis.#astro = radegDecdegToAstro((in_options as AstroCoords).raDeg,  (in_options as AstroCoords).decDeg );\n\t// \t\t} else if ((in_options as AstroCoords).raRad && (in_options as AstroCoords).decRad) {\n\t// \t\t\tthis.#astro = raradDecradToAstro((in_options as AstroCoords).raRad,  (in_options as AstroCoords).decRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"AstroCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\t// \t\tthis.#spherical = astroToSpherical(this.#astro);\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\t\n\t// \t}else if (in_type == CoordsType.SPHERICAL){\n\n\t// \t\tif ((in_options as SphericalCoords).phiDeg && (in_options as SphericalCoords).thetaDeg) {\n\t// \t\t\tthis.#spherical = phidegThetadegToSpherical((in_options as SphericalCoords).phiDeg,  (in_options as SphericalCoords).thetaDeg );\n\t// \t\t} else if ((in_options as SphericalCoords).phiRad && (in_options as SphericalCoords).thetaRad) {\n\t// \t\t\tthis.#spherical = phiradThetaradToSpherical((in_options as SphericalCoords).phiRad,  (in_options as SphericalCoords).thetaRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"SphericalCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else{\n\t// \t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t// \t}\n\t// }\n\n\tget spherical() {\n\t\treturn this.#spherical;\n\t}\n\n\tget astro() {\n\t\treturn this.#astro;\n\t}\n\n\tget cartesian() {\n\t\treturn this.#cartesian;\n\t}\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// /** Scale the vector by a given factor\n    // @param n the scale factor */\n\t// scale(n: number): Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*n, this.y*n, this.z*n);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// dot(v: Point): number{ \n\t// \treturn this.x*v.x + this.y*v.y + this.z*v.z; \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// cross(v: Point): Point{ \n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.y*v.z - v.y*this.z, this.z*v.x - v.z*this.x, this.x*v.y - v.x*this.y);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// norm() : Point{\n\t// \tlet d = 1./this.length();\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*d, this.y*d, this.z*d);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// length(): number{ \n\t// \treturn Math.sqrt(this.lengthSquared()); \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// lengthSquared(): number{ \n\t// \treturn this.x*this.x + this.y*this.y + this.z*this.z; \n  \t// };\n\n\t// subtract(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x - v.x, this.y - v.y, this.z - v.z);\n\t// }\n\n\t// add(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x + v.x, this.y + v.y, this.z + v.z);\n\t// }\n\t\n\n\t// get x(){\n\t// \treturn this._x;\n\t// }\n\t\n\t// get y(){\n\t// \treturn this._y;\n\t// }\n\t\n\t// get z(){\n\t// \treturn this._z;\n\t// }\n\t\n\t// get xyz(){\n    //     return this._xyz;\n    // }\n\t\n    // get raDeg(){\n    //     return this._raDeg;\n    // }\n    \n    // get decDeg(){\n    //     return this._decDeg;\n    // }\n    \n    // get raDecDeg(){\n    //     return this._raDecDeg;\n    // }\n    \n    // toADQL(){\n    // \treturn this._raDecDeg[0]+\",\"+this._raDecDeg[1];\n    // }\n    \n    // toString(){\n    // \treturn \"(raDeg, decDeg) => (\"+this._raDecDeg[0]+\",\"+this._raDecDeg[1]+\") (x, y,z) => (\"+this._xyz[0]+\",\"+this._xyz[1]+\",\"+this._xyz[2]+\")\";\n    // }\n}\n\n","/**\n * @author Fabrizio Giordano (Fab)\n */\n// import vec3 from 'gl-matrix';\n\nimport { AstroCoords } from \"./AstroCoords.js\";\nimport { CartesianCoords } from \"./CartesianCoords.js\";\nimport { HMSCoords } from \"./HMSCoords.js\";\nimport { NumberType } from \"./NumberType.js\";\nimport { SexagesimalCoords } from \"./SexagesimalCoords.js\";\nimport { SphericalCoords } from \"./SphericalCoords.js\";\n\nfunction Utils(){\n\t\n}\n\nexport function cartesianToSpherical(xyz: CartesianCoords): SphericalCoords{\n\tlet dotXYZ = dot(xyz, xyz);\n\tlet r = Math.sqrt(dotXYZ);\t\n\tlet thetaRad = Math.acos(xyz[2]/r);\n\tlet thetaDeg = radToDeg(thetaRad);\n\t// NB: in atan(y/x) is written with params switched atan2(x, y)\n\tlet phiRad = Math.atan2(xyz[1],xyz[0]);\n\tlet phiDeg = radToDeg(phiRad);\n\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\treturn {\n\t\tphiDeg: phiDeg, \n\t\tthetaDeg: thetaDeg,\n\t\tphiRad:phiRad,\n\t\tthetaRad: thetaRad\n\t};\n};\n\nexport function sphericalToAstro(phiTheta: SphericalCoords): AstroCoords{\n\tlet raDeg: number;\n\tlet decDeg: number;\n\n\traDeg = phiTheta.phiDeg;\n\tif (raDeg < 0){\n\t\traDeg += 360;\n\t}\n\tdecDeg = 90 - phiTheta.thetaDeg;\n\t\n\treturn {\n\t\t\"raDeg\": raDeg,\n\t\t\"decDeg\": decDeg,\n\t\t\"raRad\": degToRad(raDeg),\n\t\t\"decRad\": degToRad(decDeg)\n\n\t};\n}\n\nexport function astroToSpherical(raDec: AstroCoords): SphericalCoords{\n\t\n\tlet phiDeg: number;\n\tlet thetaDeg: number;\n\n\tphiDeg = raDec.raDeg;\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\t\n\tthetaDeg = 90 - raDec.decDeg;\n\t\n\treturn {\n\t\t\"phiDeg\": phiDeg,\n\t\t\"thetaDeg\": thetaDeg,\n\t\t\"phiRad\": degToRad(phiDeg),\n\t\t\"thetaRad\": degToRad(thetaDeg),\n\t};\n}\n\nexport function sphericalToCartesian(phiTheta: SphericalCoords, r: number): CartesianCoords{\n\tr = (r == undefined) ? 1 : r;\n\tvar x = r * Math.sin(phiTheta.thetaRad) * Math.cos(phiTheta.phiRad);\n\tvar y = r * Math.sin(phiTheta.thetaRad) * Math.sin(phiTheta.phiRad);\n\tvar z = r * Math.cos(phiTheta.thetaRad);\n\n\treturn {\n\t\t\"x\": x, \n\t\t\"y\": y, \n\t\t\"z\": z\n\t};\n};\n\nexport function fillAstro(ra: number, dec: number, unit: NumberType): AstroCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"raDeg\": ra,\n\t\t\t\"decDeg\": dec,\n\t\t\t\"raRad\": degToRad(ra),\n\t\t\t\"decRad\": degToRad(dec)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"raRad\": ra,\n\t\t\t\"decRad\": dec,\n\t\t\t\"raDeg\": radToDeg(ra),\n\t\t\t\"decDeg\": radToDeg(dec)\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n\t\n}\n\n\nexport function fillSpherical(phi: number, theta: number, unit: NumberType):  SphericalCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"phiDeg\": phi,\n\t\t\t\"thetaDeg\": theta,\n\t\t\t\"phiRad\": degToRad(phi),\n\t\t\t\"thetaRad\": degToRad(theta)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"phiDeg\": radToDeg(phi),\n\t\t\t\"thetaDeg\": radToDeg(theta),\n\t\t\t\"phiRad\": phi,\n\t\t\t\"thetaRad\": theta\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n}\n\nfunction dot(a: CartesianCoords, b: CartesianCoords) : number{\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n\nexport function colorHex2RGB(hexColor: string): [number, number, number] {\n\n//\tconsole.log(hexColor);\n\tvar hex1 = hexColor.substring(1,3);\n\tvar hex2 = hexColor.substring(3,5);\n\tvar hex3 = hexColor.substring(5,7);\n\t\n\tvar dec1 = parseInt(hex1, 16);\n\tvar dec2 = parseInt(hex2, 16);\n\tvar dec3 = parseInt(hex3, 16);\n\t\n\tvar rgb1 = (dec1 / 255).toFixed(2);\n\tvar rgb2 = (dec2 / 255).toFixed(2);\n\tvar rgb3 = (dec3 / 255).toFixed(2);\n\t\n\treturn [parseFloat(rgb1), parseFloat(rgb2), parseFloat(rgb3)];\n\n}\n\nexport function degToRad(degrees: number) : number{\n\treturn (degrees / 180 ) * Math.PI ;\n}\n\nexport function radToDeg(radians: number) : number{\n\treturn radians * 180 / Math.PI;\n}\n\nexport function raDegToHMS(raDeg: number): HMSCoords{\n\t\n\tvar h = Math.floor(raDeg/15);\n\tvar m = Math.floor((raDeg/15 - h) * 60);\n\tvar s = (raDeg/15 - h - m/60) * 3600;\n\t\n\treturn {\n\t\th: h, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nexport function decDegToDMS(decDeg: number): SexagesimalCoords{\n\tvar sign = 1;\n\tif (decDeg < 0){\n\t\tsign = -1;\n\t}\n\t\n\tvar decDeg_abs = Math.abs(decDeg);\n\tvar d = Math.trunc(decDeg_abs);\n\t\n\tvar m = Math.trunc( (decDeg_abs - d) * 60);\n\t\n\tvar s = (decDeg_abs - d - m/60) * 3600;\n\td = d * sign;\n\t\n\treturn {\n\t\td: d, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nfunction dms2DecDeg(decDMS: SexagesimalCoords){\n\tvar sign = Math.sign(decDMS.d);\n\tvar deg = (decDMS.d) + sign * (decDMS.m / 60) + sign * (decDMS.s/3600);\n\treturn deg;\n}\n\nfunction hms2RaDeg(raHMS: HMSCoords){\n\tvar sign = Math.sign(raHMS.h);\n\tvar deg = (raHMS.h + sign * (raHMS.m / 60) + sign * (raHMS.s/3600)) * 15;\n\treturn deg;\n}\n\nfunction worldToModel(xy: [number, number], radius: number): [number, number, number]{\n\tvar x = xy[0];\n\tvar y = xy[1];\n\tvar z = Math.sqrt(radius*radius - xy[0]*xy[0] - xy[1]*xy[1]);\n\treturn [x, y, z];\n}\n\n","import { FITSHeader } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\n// import { AstroCoords } from \"src/model/AstroCoords\";\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport {Point} from \"../model/Point.js\";\n\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nexport abstract class AbstractProjection {\n\n    // constructor() { }\n\n    public abstract initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed | undefined>;\n\n    public abstract prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[];\n\n    public abstract getFITSHeader(): FITSHeader[];\n\n    public abstract getCommonFitsHeaderParams(): FITSHeader;\n\n    public abstract extractPhysicalValues(fits: FITSParsed): number[][];\n\n    public abstract getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array | undefined>;\n\n    public abstract computeSquaredNaxes(d: number, ps: number): void;\n\n    // protected abstract prepareCommonHeader(fitsheaderlist: FITSHeader[]): void;\n\n    public abstract setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>>;\n\n    public abstract getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]>;\n\n    public abstract pix2world(i: number, j: number): Point;\n\n    public abstract get fitsUsed(): String[];\n    \n    // public abstract world2pix(radeclist: number[][]): Promise<ImagePixel[]>\n    public abstract world2pix(radeclist: number[][]): ImagePixel[]\n\n}\n","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\nimport {Point} from '../model/Point.js';\n\n\nexport class GnomonicProjection extends AbstractProjection {\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n\n    _minra: number;\n    _mindec: number;\n    _naxis1: number;\n    _naxis2: number;\n    _pxsize: number;\n    _pxmatrix;\n    _fitsheader: FITSHeader[];\n    _inflie: string;\n    _ctype1: string; // TODO should be RA ENUM\n    _ctype2: string; // TODO should be Dec ENUM\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n\n    constructor(infile?: string) {\n        super();\n        this._ctype1 = \"RA---TAN\";\n        this._ctype2 = \"DEC--TAN\";\n\n        if (infile) {\n            this._inflie = infile;\n        }\n    }\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n\n        let fp = new FITSParser(infile);\n\n        let promise = fp.loadFITS().then(fits => {\n\n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            this._naxis1 = fits.header.get(\"NAXIS1\");\n            this._naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value;\n            this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value;\n\n            this._minra = this._craDeg - this._pxsize1 * this._naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n\n            return fits;\n\n        });\n        await promise;\n        return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\n        this._fitsheader[0] = new FITSHeader();\n\n\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS1\", this._naxis1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS2\", this._naxis2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE1\", this._ctype1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE2\", this._ctype2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT1\", this._pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT2\", this._pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX1\", this._naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX2\", this._naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n\n    getFITSHeader(): FITSHeader[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeader {\n        let header = new FITSHeader();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                // header.set(key, value);\n                header.addItem(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= this._naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= this._naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = (this._pxvalues.get(0))[imgpx._j][(imgpx._i) * bytesXelem + b];\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n    computeSquaredNaxes(d: number, ps: number): void {\n        // first aprroximation to be checked\n        this._naxis1 = Math.ceil(d / ps);\n        this._naxis2 = this._naxis1;\n        this._pxsize = ps;\n    }\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n        // let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        // let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        // let maxpixb = minpixb;\n\n        // let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        // let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        // this._minphysicalval = bzero + bscale * minpixb;\n        // this._maxphysicalval = bzero + bscale * maxpixb;\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n\n        // TODO ...\n        return null;\n    }\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]>{\n\n        // let promise = new Promise((resolve, reject) => {\n        //     this.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n\n        //     this._pxsize = pxsize;\n        //     this._minra = center.ra - radius;\n        //     if (this._minra < 0) {\n        //         this._minra += 360;\n        //     }\n        //     this._mindec = center.dec - radius;\n\n        //     let radeclist = [];\n        //     let pra, pdec;\n\n        // TODO ...\n        /*\n        basing on naxis1 and naxis2 call pix2world!!!\n        */\n\n\n\n        /*\n        \n\n        mindec = center.dec - radius;\n        maxdec = center.dec + radius;\n        below pixel size should  depend on the distance from the center\n        let l =  0;\n        let factor = 1;\n        \n        for (let d = mindec; d < maxdec; d+=pxsize) { <--ERROR the external loop must be over RA\n            factor = 1 + 2**l;\n            rapxsize = pxsize/factor;\n            for (let r = 0; r < 360; r+=rapxsize) {\n                radeclist.push(r, d); \n            }\n            l++;\n        }\n        */\n\n\n\n\n\n        // let cidx = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        // this._cra = radeclist[cidx][0];\n        // this._cdec = radeclist[cidx][1];\n\n        // resolve(radeclist);\n        // });\n        // return promise;\n        return null;\n\n    }\n\n    pix2world(i: number, j: number): Point {\n\n        // TODO ...\n        let x, y;\n        let CDELT1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0];\n        let CDELT2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0];\n        let PC1_1 = this._fitsheader[0].getItemListOf(\"PC1_1\")[0];\n        let PC1_2 = this._fitsheader[0].getItemListOf(\"PC1_2\")[0];\n        let PC2_1 = this._fitsheader[0].getItemListOf(\"PC2_1\")[0];\n        let PC2_2 = this._fitsheader[0].getItemListOf(\"PC2_2\")[0];\n\n        let CD1_1 = this._fitsheader[0].getItemListOf(\"CD1_1\")[0];\n        let CD1_2 = this._fitsheader[0].getItemListOf(\"CD1_2\")[0];\n        let CD2_1 = this._fitsheader[0].getItemListOf(\"CD2_1\")[0];\n        let CD2_2 = this._fitsheader[0].getItemListOf(\"CD2_2\")[0];\n\n        let CRPIX1 = this._fitsheader[0].getItemListOf(\"CRPIX1\")[0];\n        let CRPIX2 = this._fitsheader[0].getItemListOf(\"CRPIX2\")[0];\n\n\n        if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            PC1_1 !== undefined && PC1_2 !== undefined &&\n            PC2_1 !== undefined && PC2_2 !== undefined\n        ) { // if CDELTia and PCi_ja notation\n            x = CDELT1 * (PC1_1 * (i - CRPIX1) + PC1_2 * (j - CRPIX2));\n            y = CDELT2 * (PC2_1 * (i - CRPIX1) + PC2_2 * (j - CRPIX2));\n        } else { // else CDi_ja notation\n            x = CD1_1 * (i - CRPIX1) + CD1_2 * (j - CRPIX2);\n            y = CD2_1 * (i - CRPIX1) + CD2_2 * (j - CRPIX2);\n        }\n\n\n\n\n        // let phi = math.arg(-y / x);\n        // let R_theta = Math.sqrt(x * x + y * y);\n        // let theta = Math.atan2(180 / (Math.PI * R_theta));\n\n        // let ra, dec;\n        // ra = phi;\n        // dec = theta;\n        // // TODO check if phi, theta match with ra, dec or they need to be (linearly) converted \n\n        // return [ra, dec];\n\n        return null;\n    }\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        let CDELT1 = (this._fitsheader[0].getItemListOf(\"CDELT1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT1\")[0] : undefined;\n        let CDELT2 = (this._fitsheader[0].getItemListOf(\"CDELT2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT2\")[0] : undefined;\n        let PC1_1 = (this._fitsheader[0].getItemListOf(\"PC1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_1\")[0] : undefined;\n        let PC1_2 = (this._fitsheader[0].getItemListOf(\"PC1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_2\")[0] : undefined;\n        let PC2_1 = (this._fitsheader[0].getItemListOf(\"PC2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_1\")[0] : undefined;\n        let PC2_2 = (this._fitsheader[0].getItemListOf(\"PC2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_2\")[0] : undefined;\n\n        let CD1_1 = (this._fitsheader[0].getItemListOf(\"CD1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_1\")[0] : undefined;\n        let CD1_2 = (this._fitsheader[0].getItemListOf(\"CD1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_2\")[0] : undefined;\n        let CD2_1 = (this._fitsheader[0].getItemListOf(\"CD2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_1\")[0] : undefined;\n        let CD2_2 = (this._fitsheader[0].getItemListOf(\"CD2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_2\")[0] : undefined;\n\n        let CRPIX1 = (this._fitsheader[0].getItemListOf(\"CRPIX1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX1\")[0] : undefined;\n        let CRPIX2 = (this._fitsheader[0].getItemListOf(\"CRPIX2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX2\")[0] : undefined;\n\n        radeclist.forEach(([ra, dec]) => {\n\n            // TODO ...\n            // let i, j;\n            // // (linearly) convert ra, dec into phi, theta\n            // let theta = dec;\n            // let phi = ra;\n            // let R_theta = (180 / Math.PI) * math.cot(theta);\n            // let x = R_theta * Math.sin(phi);\n            // let y = - R_theta * Math.cos(phi);\n            // if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            //     PC1_1 !== undefined && PC1_2 !== undefined &&\n            //     PC2_1 !== undefined && PC2_2 !== undefined\n            // ) { // if CDELTia and PCi_ja notation\n            //     j = y * CDELT1 * PC1_1 / (CDELT1 * CDELT2 * (PC1_1 * PC2_2 - PC2_1 * PC1_2)) + PC1_1 * CRPIX2 * (PC2_2 - PC2_1) / (PC1_1 * PC2_2 - PC2_1 * PC1_2);\n            //     i = x / (CDELT1 * PC1_1) + CRPIX1 - j * PC1_2 / PC1_1 + CRPIX2 * PC1_2 / PC1_1;\n            // } else { // else CDi_ja notation\n            //     j = y * CD1_1 / (CD1_1 * CD2_2 - CD1_2 * CD2_1) + CRPIX2 * CD1_1 * (CD2_2 - CD2_1) / (CD1_1 * CD2_2 - CD1_2 * CD2_1);\n            //     i = (x + CD1_1 * CRPIX1 - CD1_2 * j + CD1_2 * CRPIX2) / CD1_1;\n            // }\n            // imgpxlist.push(new ImagePixel(i, j));\n\n        });\n        return imgpxlist;\n\n    }\n\n    // getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n    //     let canvas2d = new Canvas2D(this._pxvalues, this._fitsheader, this, tfunction, colormap, inverse);\n    //     return canvas2d;\n    // }\n}\n","\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport {Point} from \"../model/Point.js\";\nimport {AbstractProjection} from \"./AbstractProjection.js\";\n\n\nexport class HEALPixProjection extends AbstractProjection {\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeader {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    public computeSquaredNaxes(d: number, ps: number): void {\n        throw new Error('Method not implemented.');\n    }\n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n    \n\n}","\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { Healpix } from 'healpixjs';\nimport { Pointing } from \"healpixjs\";\nimport { Hploc } from \"healpixjs\";\n\nimport { radToDeg } from '../model/Utils.js'; // TODO change package\nimport { CoordsType } from \"../model/CoordsType.js\";\nimport { HEALPixXYSpace } from \"../model/HEALPixXYSpace.js\";\nimport { Point } from \"../model/Point.js\";\nimport { SphericalCoords } from \"../model/SphericalCoords.js\";\nimport { NumberType } from '../model/NumberType.js';\nimport { AstroCoords } from \"../model/AstroCoords.js\";\nimport { EquatorialCoords } from \"../model/EquatorialCoords.js\";\n\nexport class HiPSHelper {\n\n\n\t// static pxXtile: number = 512; // TODO in some cases it is different\n\tstatic DEFAULT_Naxis1_2: number = 512;\n\t// static RES_ORDER_0: number = 58.6 / HiPSHelper.pxXtile;\n\tstatic RES_ORDER_0: number = 58.6;\n\tstatic H: number = 4;\n\tstatic K: number = 3;\n\tstatic THETAX: number = Hploc.asin((HiPSHelper.K - 1) / HiPSHelper.K);\n\t/**\n\t * Table 1 - ref paper HEALPix  a Framework for High Resolution Discretization,\n\t * and Fast Analysis of Data Distributed on the Sphere\n\t * K. M. Gorski1,2, E. Hivon3,4, A. J. Banday5, B. D. Wandelt6,7, F. K. Hansen8, M.\n\t * Reinecke5, M. Bartelman9\n\t */\n\t/**\n\t * \n\t * @param {decimal degrees} pxsize \n\t * @returns {int} nside\n\t */\n\tstatic computeHiPSOrder(pxsize: number, pxXtile: number): number {\n\t\t/**\n\t\t * with same order k (table 1), HIPS angular resolution is higher of order of 512 (2^9) pixels than \n\t\t * the HEALPix. This is because each tile in a HiPS is represented by default by 512x512 pixels.\\\n\t\t * Angular resolution of different HEALPix orders in respect to the order 0, can be calculated this\n\t\t * way:\n\t\t * \n\t\t * \tL(k) = L(0) / 2^k = 58.6 / 2^k\n\t\t * \n\t\t * Therefore, in the case of HiPS we need to take into account the extra resolution given by the \n\t\t * 512x512 (2^9) tiles. In this case the above becomes:\n\t\t * \t\n\t\t * \tL(k) = L(0) / (2^k * 2^9) \n\t\t * \n\t\t * Though, in order to compute the required order starting from the pxsize desired (in input) we\n\t\t * need to perform these steps:\n\t\t * \n\t\t * \tpxsize = L(k) = L(0) / (2^k * 2^9)\n\t\t * \t2^k = L(0) / (pxsize * 2^9)\n\t\t *  k * Log2 2 = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \tk = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \n\t\t */\n\n\n\t\tlet k = Math.log2( (HiPSHelper.RES_ORDER_0 / pxXtile) / pxsize);\n\t\tk = Math.round(k);\n\t\t// let theta0px = HiPSHelper.RES_ORDER_0;\n\t\t// let k = Math.log2(theta0px) - Math.log2(pxsize * 2**9);\n\t\t// k = Match.round(k);\n\t\t// let nside = 2**k;\n\t\t// return {\n\t\t//     \"nside\" : nside,\n\t\t//     \"norder\" : k\n\t\t// };\n\t\treturn k;\n\n\t}\n\n\t/**\n\t * Reference: HiPS  Hierarchical Progressive Survey page 11\n\t * pxsize =~ sqrt[4 * PI / (12 * (512 * 2^order)^2)]\n\t * @param {*} order \n\t */\n\tstatic computePxSize(order: number, pxXtile: number): number {\n\t\t// TODO CHECK IT\n\t\t// let pxsize = 1 / (512 * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\tlet pxsize = 1 / (pxXtile * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\treturn pxsize;\n\t}\n\n\t// /**\n\t//  * \n\t//  * @param {Object {ra, dec}} point  decimal degrees\n\t//  * @returns {Object {phi_rad, theta_rad}} in radians\n\t//  */\n\t// static convert2PhiTheta (point: Point) {\n\t// \tlet phitheta_rad = {};\n\t// \tlet phiTheta_deg = HiPSHelper.astroDegToSpherical(point.ra, point.dec);\n\t// \tphitheta_rad.phi_rad = HiPSHelper.degToRad(phiTheta_deg.phi);\n\t//     phitheta_rad.theta_rad = HiPSHelper.degToRad(phiTheta_deg.theta);\n\t// \treturn phitheta_rad;\n\t// }\n\n\t// static astroDegToSphericalRad(raDeg: number, decDeg: number) {\n\t// \tlet phiThetaDeg = HiPSHelper.astroDegToSpherical(raDeg, decDeg);\n\t// \tlet phiThetaRad = {\n\t// \t\tphi_rad: HiPSHelper.degToRad(phiThetaDeg.phi),\n\t// \t\ttheta_rad: HiPSHelper.degToRad(phiThetaDeg.theta)\n\t// \t}\n\t// \treturn phiThetaRad;\n\t// }\n\n\t// static degToRad(degrees: number): number {\n\t// \treturn (degrees / 180 ) * Math.PI ;\n\t// }\n\n\t// static radToDeg(rad: number): number {\n\t// \treturn (rad / Math.PI ) * 180 ;\n\t// }\n\n\t// static astroDegToSpherical(raDeg: number, decDeg: number): Point{\n\n\t// \tlet phiDeg: number;\n\t// \tlet thetaDeg: number;\n\t// \tphiDeg = raDeg;\n\t// \tif (phiDeg < 0){\n\t// \t\tphiDeg += 360;\n\t// \t}\n\n\t// \tthetaDeg = 90 - decDeg;\n\n\t// \treturn {\n\t// \t\tphi: phiDeg,\n\t// \t\ttheta: thetaDeg\n\t// \t};\n\t// }\n\n\t/**\n\t * \n\t * @param {Object {phi_rad, theta_rad}} phiTheta_rad Center of the circle in radians\n\t * @param {decimal} r Radius of the circle in radians\n\t * @returns \n\t */\n\tstatic computeBbox(point: Point, r: number): number[] {\n\n\t\tlet bbox = [];\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad + r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\n\t\treturn bbox;\n\t}\n\n\tstatic setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n\n\t\tlet xyGridProj: HEALPixXYSpace = {\n\t\t\t\"min_y\": NaN,\n\t\t\t\"max_y\": NaN,\n\t\t\t\"min_x\": NaN,\n\t\t\t\"max_x\": NaN,\n\t\t\t\"gridPointsDeg\": []\n\t\t}\n\n\n\t\tlet cornersVec3 = hp.getBoundariesWithStep(tileno, 1);\n\t\tlet pointings = [];\n\n\t\tfor (let i = 0; i < cornersVec3.length; i++) {\n\t\t\tpointings[i] = new Pointing(cornersVec3[i]);\n\t\t\tif (i >= 1) {\n\t\t\t\tlet a = pointings[i - 1].phi;\n\t\t\t\tlet b = pointings[i].phi;\n\t\t\t\t// case when RA is just crossing the origin (e.g. 357deg - 3deg)\n\t\t\t\tif (Math.abs(a - b) > Math.PI) {\n\t\t\t\t\tif (pointings[i - 1].phi < pointings[i].phi) {\n\t\t\t\t\t\tpointings[i - 1].phi += 2 * Math.PI;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpointings[i].phi += 2 * Math.PI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let j = 0; j < pointings.length; j++) {\n\t\t\tlet coThetaRad = pointings[j].theta;\n\t\t\t// HEALPix works with colatitude (0 North Pole, 180 South Pole)\n\t\t\t// converting the colatitude in latitude (dec)\n\t\t\tlet decRad = Math.PI / 2 - coThetaRad;\n\n\t\t\tlet raRad = pointings[j].phi;\n\n\t\t\t// projection on healpix grid\n\t\t\tlet p = new Point(CoordsType.ASTRO, NumberType.RADIANS, raRad, decRad);\n\t\t\tlet xyDeg = HiPSHelper.world2intermediate(p.astro);\n\t\t\txyGridProj.gridPointsDeg[j * 2] = xyDeg[0];\n\t\t\txyGridProj.gridPointsDeg[j * 2 + 1] = xyDeg[1];\n\n\t\t\tif (isNaN(xyGridProj.max_y) || xyDeg[1] > xyGridProj.max_y) {\n\t\t\t\txyGridProj.max_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_y) || xyDeg[1] < xyGridProj.min_y) {\n\t\t\t\txyGridProj.min_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.max_x) || xyDeg[0] > xyGridProj.max_x) {\n\t\t\t\txyGridProj.max_x = xyDeg[0];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_x) || xyDeg[0] < xyGridProj.min_x) {\n\t\t\t\txyGridProj.min_x = xyDeg[0];\n\t\t\t}\n\n\t\t}\n\t\treturn xyGridProj;\n\t}\n\n\tstatic world2intermediate(ac: AstroCoords): [number, number] {\n\n\t\tlet x_grid: number;\n\t\tlet y_grid: number;\n\n\t\tif (Math.abs(ac.decRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t\t\tx_grid = ac.raDeg;\n\n\t\t\ty_grid = Hploc.sin(ac.decRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t\t} else if (Math.abs(ac.decRad) > HiPSHelper.THETAX) { // polar zones\n\n\t\t\tlet raDeg = ac.raDeg;\n\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\n\t\t\tlet sigma = Math.sqrt(HiPSHelper.K * (1 - Math.abs(Hploc.sin(ac.decRad))));\n\t\t\tlet phi_c = - 180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSHelper.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSHelper.H);\n\n\t\t\tx_grid = phi_c + (raDeg - phi_c) * sigma;\n\t\t\ty_grid = (180 / HiPSHelper.H) * (((HiPSHelper.K + 1) / 2) - sigma);\n\n\t\t\tif (ac.decRad < 0) {\n\t\t\t\ty_grid *= -1;\n\t\t\t}\n\t\t}\n\n\t\treturn [x_grid, y_grid];\n\n\t}\n\n\t// static world2intermediate(sc: SphericalCoords): [number, number] {\n\t//     let x_grid: number;\n\t// \tlet y_grid: number;\n\n\t// \tif ( Math.abs(sc.thetaRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t// \t\tx_grid = sc.phiDeg;\n\n\t// \t\ty_grid = Hploc.sin(sc.thetaRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t// \t} else if ( Math.abs(sc.thetaRad) > HiPSHelper.THETAX) { // polar zones\n\n\t// \t\tlet phiDeg = sc.phiDeg;\n\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || sc.thetaRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\n\t// \t\tlet sigma = Math.sqrt( HiPSHelper.K * (1 - Math.abs(Hploc.sin(sc.thetaRad)) ) );\n\t// \t\tlet phi_c = - 180 + ( 2 * Math.floor( ((sc.phiRad + 180) * HiPSHelper.H/360) + ((1 - w)/2) ) + w ) * ( 180 / HiPSHelper.H );\n\n\t// \t\tx_grid = phi_c + (phiDeg - phi_c) * sigma;\n\t// \t\ty_grid = (180  / HiPSHelper.H) * ( ((HiPSHelper.K + 1)/2) - sigma);\n\n\t// \t\tif (sc.thetaRad < 0) {\n\t// \t\t\ty_grid *= -1;\n\t// \t\t}\n\t// \t}\n\n\t// \treturn [x_grid, y_grid];\n\n\t// }\n\n\tstatic intermediate2pix(x: number, y: number, xyGridProj: HEALPixXYSpace, pxXtile: number): [number, number] {\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);\n\n\t\tlet i_norm: number;\n\t\tlet j_norm: number;\n\t\tif ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {\n\t\t\ti_norm = (x + 360 - xyGridProj.min_x) / xInterval;\n\t\t} else {\n\t\t\ti_norm = (x - xyGridProj.min_x) / xInterval;\n\t\t}\n\t\tj_norm = (y - xyGridProj.min_y) / yInterval;\n\n\n\t\tlet i = 0.5 - (i_norm - j_norm);\n\t\tlet j = (i_norm + j_norm) - 0.5;\n\n\t\t// TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);\n\t\tpxXtile\n\t\t// i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];\n\t\t\n\t\ti = Math.floor(i * pxXtile);\n\t\tj = Math.floor(j * pxXtile);\n\t\treturn [i, pxXtile - j - 1];\n\n\n\n\t}\n\n\n\tstatic pix2intermediate(i: number, j: number, xyGridProj: HEALPixXYSpace, naxis1: number, naxis2: number): [number, number] {\n\t\t/**\n\t\t   * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image\n\t\t * (i_norm,w_pixel) = (1,1) is the upper right corner\n\t\t * dimamond in figure 1 from \"Mapping on the HEalpix grid\" paper\n\t\t * (0,0) leftmost corner\n\t\t * (1,0) upper corner\n\t\t * (0,1) lowest corner\n\t\t * (1,1) rightmost corner\n\t\t * Thanks YAGO! :p\n\t\t */\n\t\t// let cnaxis1 = HiPSHelper.pxXtile;\n\t\t// let cnaxis2 = HiPSHelper.pxXtile;\n\n\t\tlet cnaxis1 = naxis1;\n\t\tlet cnaxis2 = naxis2;\n\t\tif (naxis1) {\n\t\t\tcnaxis1 = naxis1;\n\t\t}\n\t\tif (naxis2) {\n\t\t\tcnaxis2 = naxis2;\n\t\t}\n\t\tlet i_norm = (i + 0.5) / cnaxis1;\n\t\tlet j_norm = (j + 0.5) / cnaxis2;\n\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;\n\t\tlet yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;\n\n\t\t// bi-linear interpolation\n\t\tlet x = xyGridProj.max_x - xInterval * (i_norm + j_norm);\n\t\tlet y = yMean - yInterval * (j_norm - i_norm);\n\n\t\treturn [x, y];\n\t}\n\n\n\tstatic intermediate2world(x: number, y: number): Point {\n\n\t\tlet phiDeg: number;\n\t\tlet thetaDeg: number;\n\t\tlet Yx = 90 * (HiPSHelper.K - 1) / HiPSHelper.H;\n\n\n\n\t\tif (Math.abs(y) <= Yx) { // equatorial belts\n\n\t\t\tphiDeg = x;\n\t\t\tthetaDeg = radToDeg(Math.asin((y * HiPSHelper.H) / (90 * HiPSHelper.K)));\n\n\t\t} else if (Math.abs(y) > Yx) { // polar regions\n\n\t\t\tlet sigma = (HiPSHelper.K + 1) / 2 - Math.abs(y * HiPSHelper.H) / 180;\n\t\t\tlet thetaRad = Hploc.asin(1 - (sigma * sigma) / HiPSHelper.K);\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\t\t\tlet x_c = -180 + (2 * Math.floor((x + 180) * HiPSHelper.H / 360 + (1 - w) / 2) + w) * (180 / HiPSHelper.H);\n\t\t\tphiDeg = x_c + (x - x_c) / sigma;\n\t\t\tthetaDeg = radToDeg(thetaRad);\n\t\t\tif (y <= 0) {\n\t\t\t\tthetaDeg *= -1;\n\t\t\t}\n\t\t}\n\t\t// return [phiDeg, thetaDeg];\n\t\t// TODO CHECK THIS!\n\t\t// let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);\n\t\tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, phiDeg, thetaDeg);\n\n\t\treturn p;\n\n\t}\n\n}\n","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\n\nimport { Healpix } from \"healpixjs\";\nimport { Pointing } from \"healpixjs\";\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { HEALPixXYSpace } from '../model/HEALPixXYSpace.js';\n\nimport { HiPSHelper } from './HiPSHelper.js';\n\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { astroToSpherical, degToRad, fillAstro, radToDeg } from '../model/Utils.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\nimport { INSPECT_MAX_BYTES } from 'buffer';\n\n\n\nexport class HiPSProjection implements AbstractProjection {\n\n\t_naxis1!: number;\n\t_naxis2!: number;\n\t_isGalactic: boolean = false;\n\t_pixno!: number;\n\t_tileslist!: number[];\n\t_hp!: Healpix;\n\t_fh_common!: FITSHeader;\n\t_ctype1: string; // TODO should be RA ENUM\n\t_ctype2: string; // TODO should be Dec ENUM\n\t_wcsname: string;\n\t_hipsBaseURI!: string;\n\t_pxsize!: number;\n\t_fitsheaderlist: FITSHeader[];\n\t_pxvalues: Map<number, Array<Uint8Array>>;\n\t_xyGridProj!: HEALPixXYSpace;\n\t_norder!: number;\n\t_nside!: number;\n\t_radeclist: Array<[number, number]>;\n\t_HIPS_TILE_WIDTH: number;\n\t_fitsUsed: String[] = [];\n\t_HIPS_MAX_ORDER: number;\n\n\t/**\n\t * \n\t * * ex with single local file:\n\t * let hp = new HiPSProjection('/mylocaldir/myfile.fits', null, null, null);\n\t * hp.initFromFile()\n\t * \n\t * * ex with single remote file:\n\t * let hp = new HiPSProjection('http://<hips-server>/Norder7/DirN/NpixXYZ.fits', null, null, null);\n\t * hp.initFromFile()\n\t *\n\t * * ex with HiPS server base local dir:\n\t * let hp = new HiPSProjection(null, <hips-local-root-dir>, pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t * * ex with HiPS server base URL:\n\t * let hp = new HiPSProjection(null, 'http://<hips-server>/<hips-root-dir>', pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t */\n\n\n\t//  constructor(fitsfilepath?: string, hipsBaseURI?: string, pxsize?: number, order?: number) {\n\tconstructor() {\n\n\t\tthis._wcsname = \"HPX\"; // TODO check WCS standard\n\t\tthis._ctype1 = \"RA---HPX\";\n\t\tthis._ctype2 = \"DEC--HPX\";\n\n\t\tthis._pxvalues = new Map<number, Array<Uint8Array>>();\n\t\tthis._fitsheaderlist = new Array<FITSHeader>();\n\t\tthis._radeclist = new Array<[number, number]>();\n\n\t}\n\n\tasync parsePropertiesFile(baseUrl: string): Promise<any> {\n\t\tconst fp = new FITSParser(null);\n\n\t\tconst promise = fp.getFile(baseUrl + \"/properties\").then((propFile: ArrayBuffer | Buffer) => {\n\t\t\tlet prop: string;\n\t\t\tif (propFile instanceof ArrayBuffer) {\n\t\t\t\tconst textDecoder = new TextDecoder(\"iso-8859-1\");\n\t\t\t\tprop = textDecoder.decode(new Uint8Array(propFile));\n\t\t\t} else {\n\t\t\t\tprop = propFile.toString('utf8');\n\t\t\t}\n\t\t\t/**\n\t\t\t \tHiPS  Hierarchical Progressive Survey\n\t\t\t\tVersion 1.0\n\t\t\t\tIVOA Proposed Recommendation\n\t\t\t\t3rd April 2017\n\t\t\t\thttps://www.ivoa.net/documents/HiPS/20170403/PR-HIPS-1.0-20170403.pdf\n\t\t\t */\n\t\t\tconst txtArr = prop.split('\\n');\n\t\t\tthis._HIPS_TILE_WIDTH = 512;\n\t\t\tfor (let line of txtArr) {\n\t\t\t\tif (!line.includes(\"=\")){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst tokens = line.split(\"=\");\n\t\t\t\tif (tokens[1] === undefined){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst key = tokens[0].trim()\n\t\t\t\tconst val = tokens[1].trim()\n\n\t\t\t\tif (key == \"hips_order\") {\n\t\t\t\t\tthis._HIPS_MAX_ORDER = parseInt(val);\n\t\t\t\t\tconsole.log(\"hips_order \"+this._HIPS_MAX_ORDER)\n\t\t\t\t} else if (key == \"hips_tile_width\") {\n\t\t\t\t\tthis._HIPS_TILE_WIDTH = parseInt(val);\n\t\t\t\t\tthis._naxis1 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tthis._naxis2 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tconsole.log(\"hips_tile_width \"+this._HIPS_TILE_WIDTH)\n\t\t\t\t} else if (key == \"hips_frame\" && val == \"galactic\") {\n\t\t\t\t\tthis._isGalactic = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn propFile;\n\t\t});\n\n\t\tawait promise;\n\t\treturn promise;\n\t}\n\n\tasync initFromFile(fitsfilepath: string): Promise<FITSParsed> {\n\t\tlet fp = new FITSParser(fitsfilepath);\n\n\t\tlet promise = fp.loadFITS().then(fits => {\n\t\t\tthis._pxvalues.set(0, fits.data);\n\t\t\tthis._fitsheaderlist[0] = fits.header;\n\n\t\t\tlet order = fits.header.get(\"ORDER\");\n\t\t\tthis.init(order);\n\n\t\t\tthis._naxis1 = fits.header.get(\"NAXIS1\");\n\t\t\tthis._naxis2 = fits.header.get(\"NAXIS2\");\n\t\t\tthis._HIPS_TILE_WIDTH = this._naxis1;\n\n\t\t\tthis._pixno = fits.header.get(\"NPIX\");\n\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(this._pixno, this._hp);\n\t\t\treturn fits;\n\t\t});\n\t\tawait promise;\n\t\treturn promise;\n\t}\n\n\n\n\tasync initFromHiPSLocationAndPxSize(baseUrl: string, pxsize: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tthis._pxsize = pxsize;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\tlet order = HiPSHelper.computeHiPSOrder(pxsize, this._HIPS_TILE_WIDTH);\n\t\tif (order > this._HIPS_MAX_ORDER) {\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tthis.init(order);\n\t}\n\n\tasync initFromHiPSLocationAndOrder(baseUrl: string, order: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\tif (order > this._HIPS_MAX_ORDER){\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tthis._pxsize = HiPSHelper.computePxSize(order, this._HIPS_TILE_WIDTH);\n\t\tthis.init(order);\n\t}\n\n\tinit(order: number) {\n\t\tthis._norder = order;\n\t\tthis._nside = 2 ** order;\n\t\tthis._hp = new Healpix(this._nside);\n\t}\n\n\tprepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\t\tfor (let header of this._fitsheaderlist) {\n\n\t\t\theader.addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n\t\t\theader.addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n\t\t\tif (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n\t\t\t}\n\t\t\tlet bscale = 1.0;\n\t\t\tif (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n\t\t\t\tbscale = fitsHeaderParams.get(\"BSCALE\");\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\t\t\t}\n\n\n\t\t\tlet bzero = 0.0;\n\t\t\tif (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n\t\t\t\tbzero = fitsHeaderParams.get(\"BZERO\");\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\t\t\t}\n\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS\", 2));\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS1\", HiPSHelper.DEFAULT_Naxis1_2));\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS2\", HiPSHelper.DEFAULT_Naxis1_2));\n\n\t\t\theader.addItem(new FITSHeaderItem(\"ORDER\", this._norder));\n\n\t\t\theader.addItem(new FITSHeaderItem(\"CTYPE1\", this._ctype1));\n\t\t\theader.addItem(new FITSHeaderItem(\"CTYPE2\", this._ctype2));\n\n\t\t\t// header.addItem(new FITSHeaderItem(\"CRPIX1\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel i along naxis1\n\t\t\t// header.addItem(new FITSHeaderItem(\"CRPIX2\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel j along naxis2\n\n\t\t\theader.addItem(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n\t\t\theader.addItem(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n\n\t\t}\n\t\treturn this._fitsheaderlist;\n\t}\n\n\n\tgetFITSHeader(): FITSHeader[] {\n\t\treturn this._fitsheaderlist;\n\t}\n\n\tgetCommonFitsHeaderParams(): FITSHeader {\n\t\treturn this._fh_common;\n\t}\n\n\textractPhysicalValues(fits: FITSParsed): number[][] {\n\n\t\tlet bzero = fits.header.get(\"BZERO\");\n\t\tlet bscale = fits.header.get(\"BSCALE\");\n\t\tlet naxis1 = fits.header.get(\"NAXIS1\");\n\t\tlet naxis2 = fits.header.get(\"NAXIS2\");\n\t\tlet bitpix = fits.header.get(\"BITPIX\");\n\t\tlet bytesXelem = Math.abs(bitpix / 8);\n\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n\t\t// let physicalvalues = new Array[naxis2][naxis1];\n\t\tlet physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n\t\tfor (let n2 = 0; n2 < naxis2; n2++) {\n\t\t\tphysicalvalues[n2] = new Array<number>(naxis1);\n\t\t\tfor (let n1 = 0; n1 < naxis1; n1++) {\n\t\t\t\tlet pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n\t\t\t\tlet physicalVal = bzero + bscale * pixval;\n\t\t\t\tphysicalvalues[n2][n1] = physicalVal;\n\t\t\t}\n\t\t}\n\t\treturn physicalvalues;\n\n\t}\n\n\tasync getFITSFiles(inputPixelsList: ImagePixel[], destPath: string): Promise<Map<string, FITSParsed>> {\n\n\t\tconst fitsFilesGenerated = new Map<string, FITSParsed>();\n\t\tlet promises = [];\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\t\tfor (let hipstileno of tilesset) {\n\t\t\tlet tileno = hipstileno;\n\t\t\tlet dir = Math.floor(tileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + tileno + \".fits\";\n\t\t\tlet fp = new FITSParser(fitsurl);\n\n\n\t\t\tpromises.push(fp.loadFITS().then((fits) => {\n\t\t\t\tif (fits !== null) {\n\t\t\t\t\tlet pixno = (fits.header.get(\"NPIX\") !== undefined) ? fits.header.get(\"NPIX\") : tileno;\n\t\t\t\t\t// FITSParser.writeFITS(fits.header, fits.data, destPath+\"/Npix\"+pixno+\".fits\");\n\t\t\t\t\t// fitsFilesGenerated.set(destPath+\"/Npix\"+pixno+\".fits\",FITSParser.generateFITS(fits.header, fits.data) );\n\t\t\t\t\tfitsFilesGenerated.set(destPath + \"/Npix\" + pixno + \".fits\", fits);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\treturn fitsFilesGenerated;\n\t}\n\n\n\tget fitsUsed(): String[] {\n\t\treturn this._fitsUsed;\n\t}\n\n\tasync getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array | undefined> {\n\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\n\t\tlet pixcount = inputPixelsList.length;\n\t\tlet values: Uint8Array | undefined = undefined;\n\t\tlet fitsheaderlist: (FITSHeader | undefined)[] = [];\n\t\tlet promises = [];\n\n\t\tlet self = this;\n\t\tfor (let hipstileno of tilesset) {\n\n\t\t\tlet dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + hipstileno + \".fits\";\n\t\t\tconsole.log(`Identified source file ${fitsurl}`)\n\t\t\tlet fp = new FITSParser(fitsurl);\n\t\t\tpromises.push(fp.loadFITS().then((fits) => {\n\n\t\t\t\tif (fits === null) {\n\t\t\t\t\tfitsheaderlist.push(undefined);\n\t\t\t\t} else {\n\t\t\t\t\tself._fitsUsed.push(fitsurl);\n\n\t\t\t\t\tlet bytesXelem = Math.abs(fits.header.get(\"BITPIX\") / 8);\n\t\t\t\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // => ???????\n\t\t\t\t\tif (values === undefined) {\n\t\t\t\t\t\tvalues = new Uint8Array(pixcount * bytesXelem);\n\t\t\t\t\t}\n\n\t\t\t\t\t// console.log(fitsurl + \" loaded\");\n\t\t\t\t\tfitsheaderlist.push(fits.header);\n\n\t\t\t\t\tfor (let p = 0; p < pixcount; p++) {\n\t\t\t\t\t\tlet imgpx = inputPixelsList[p];\n\n\t\t\t\t\t\tif (imgpx.tileno === hipstileno) {\n\n\n\t\t\t\t\t\t\t// if (imgpx._j < HiPSHelper.DEFAULT_Naxis1_2 && imgpx._i < HiPSHelper.DEFAULT_Naxis1_2) {\n\t\t\t\t\t\t\tif (imgpx._j < fits.header.get(\"NAXIS1\") && imgpx._i < fits.header.get(\"NAXIS2\")) {\n\t\t\t\t\t\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\t\t\t\t\t\tvalues[p * bytesXelem + b] = fits.data[imgpx._j][imgpx._i * bytesXelem + b];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\tif (fitsheaderlist !== undefined) {\n\t\t\tthis.prepareCommonHeader(fitsheaderlist);\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tcomputeSquaredNaxes(d: number, ps: number): void {\n\t\t// first aprroximation to be checked\n\t\tthis._naxis1 = Math.ceil(d / ps);\n\t\tthis._naxis2 = this._naxis1;\n\t\tthis._pxsize = ps;\n\t}\n\n\tprepareCommonHeader(fitsheaderlist: (FITSHeader | undefined)[]): void {\n\t\tif (fitsheaderlist === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fh_common) {\n\t\t\tthis._fh_common = new FITSHeader();\n\t\t}\n\n\t\tfor (let i = 0; i < fitsheaderlist.length; i++) {\n\t\t\tlet header = fitsheaderlist[i];\n\t\t\tif (header !== undefined) {\n\n\t\t\t\tfor (let item of header.getItemList()) {\n\t\t\t\t\tif ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\"].includes(item.key)) {\n\t\t\t\t\t\tif (!this._fh_common.getItemListOf(item.key)[0]) {\n\t\t\t\t\t\t\tthis._fh_common.addItem(new FITSHeaderItem(item.key, item.value));\n\t\t\t\t\t\t} else if (this._fh_common.getItemListOf(item.key)[0].value !== item.value) { // this should not happen \n\t\t\t\t\t\t\tthrow new Error(\"Error parsing headers. \" + item.key + \" was \" + this._fh_common.getItemListOf(item.key)[0] + \" and now is \" + item.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\n\t// // TODO MOVE THIS IN AN UTILITY FILE\n\t// pixel2Physical(value, bzero, bscale) {\n\t// \tlet pval = bzero + bscale * value;\n\t// \treturn pval;\n\t// }\n\n\tsetPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n\n\t\t// let vidx = 0; // <------ ERROR!!!!! pixel are not organized by tile!!!\n\n\t\t// let pxXTile = HiPSHelper.DEFAULT_Naxis1_2 * HiPSHelper.DEFAULT_Naxis1_2;\n\t\tlet bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n\t\tlet bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n\t\tlet bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n\t\tif (bytesXelem === undefined || bscale === undefined || bzero === undefined) {\n\t\t\tthrow new Error(\"BITPIX, BSCALE or BZERO are undefined\");\n\t\t}\n\n\n\t\t// let minmaxmap = new Array();\n\t\tlet minmaxmap = new Map();\n\t\tlet nodata = new Map();\n\n\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\t// this._pxvalues.set(tileno, new Array(HiPSHelper.DEFAULT_Naxis1_2));  // <- bidimensional\n\t\t\t// for (let row = 0; row < HiPSHelper.DEFAULT_Naxis1_2; row++) {\n\n\t\t\tthis._pxvalues.set(tileno, new Array(this._HIPS_TILE_WIDTH));  // <- bidimensional\n\t\t\tfor (let row = 0; row < this._HIPS_TILE_WIDTH; row++) {\n\t\t\t\tif (this._pxvalues.has(tileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(tileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\t// p[row] = new Uint8Array(HiPSHelper.DEFAULT_Naxis1_2 * bytesXelem);\n\t\t\t\t\t\tp[row] = new Uint8Array(this._HIPS_TILE_WIDTH * bytesXelem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tminmaxmap.set(\"\" + tileno + \"\", new Array(2));\n\t\t\tnodata.set(\"\" + tileno + \"\", true);\n\t\t});\n\t\tlet ra: number;\n\t\tlet dec: number;\n\t\tlet col: number;\n\t\tlet row: number;\n\n\t\tfor (let rdidx = 0; rdidx < this._radeclist.length; rdidx++) {\n\t\t\t[ra, dec] = this._radeclist[rdidx];\n\t\t\tlet ac = fillAstro(ra, dec, NumberType.DEGREES);\n\t\t\tlet sc = astroToSpherical(ac);\n\t\t\tlet ptg = new Pointing(null, false, sc.thetaRad, sc.phiRad);\n\t\t\tlet pixtileno: number = this._hp.ang2pix(ptg);\n\n\t\t\tlet xyGridProj = HiPSHelper.setupByTile(pixtileno, this._hp);\n\t\t\t// let rarad = degToRad(ra);\n\t\t\t// let decrad = degToRad(dec);\n\t\t\t// TODO CHECK THIS POINT before it was with ra and dec in radians\n\t\t\tlet xy = HiPSHelper.world2intermediate(ac);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tlet ij = HiPSHelper.intermediate2pix(xy[0], xy[1], xyGridProj, this._HIPS_TILE_WIDTH);\n\t\t\tcol = ij[0];\n\t\t\trow = ij[1];\n\n\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\tlet byte = values[rdidx * bytesXelem + b];\n\t\t\t\t// this._pxvalues.get(pixtileno)[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\tp[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nodata.get(\"\" + pixtileno + \"\")) {\n\t\t\t\t\tif (byte != 0) {\n\t\t\t\t\t\tnodata.set(\"\" + pixtileno + \"\", false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet min = minmaxmap.get(\"\" + pixtileno + \"\")[0];\n\t\t\tlet max = minmaxmap.get(\"\" + pixtileno + \"\")[1];\n\n\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\tif (p !== undefined) {\n\t\t\t\t\tlet valpixb = ParseUtils.extractPixelValue(0, p[row].slice(col * bytesXelem, col * bytesXelem + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n\t\t\t\t\tlet valphysical = bzero + bscale * valpixb;\n\t\t\t\t\tif (valphysical < min || isNaN(min)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[0] = valphysical;\n\t\t\t\t\t} else if (valphysical > max || isNaN(max)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[1] = valphysical;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Object.keys(this._pxvalues.keys()).forEach((tileno) => {\n\t\tconst fhKeys = Array.from(this._pxvalues.keys());\n\n\t\tfhKeys.forEach((tileno) => {\n\t\t\tif (nodata.get(\"\" + tileno + \"\") == false) { // there are data\n\t\t\t\t// tileno = parseInt(tileno);\n\t\t\t\tlet header = new FITSHeader();\n\t\t\t\theader.set(\"NPIX\", tileno);\n\t\t\t\t// TODO CONVERT minval and maxval to physical values!\n\t\t\t\t// header.addItem(new FITSHeaderItem(\"DATAMIN\", minmaxmap[\"\" + tileno + \"\"][0]));\n\t\t\t\t// header.addItem(new FITSHeaderItem(\"DATAMAX\", minmaxmap[\"\" + tileno + \"\"][1]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"DATAMIN\", minmaxmap.get(\"\" + tileno + \"\")[0]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"DATAMAX\", minmaxmap.get(\"\" + tileno + \"\")[1]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"NPIX\", tileno));\n\n\t\t\t\tlet vec3 = this._hp.pix2vec(tileno);\n\t\t\t\tlet ptg = new Pointing(vec3);\n\t\t\t\tlet crval1 = radToDeg(ptg.phi);\n\t\t\t\tlet crval2 = 90 - radToDeg(ptg.theta);\n\n\t\t\t\theader.addItem(new FITSHeaderItem(\"CRVAL1\", crval1));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"CRVAL2\", crval2));\n\n\t\t\t\tthis._fitsheaderlist.push(header);\n\t\t\t} else { // no data\n\t\t\t\t// this._pxvalues.delete(parseInt(tileno));\n\t\t\t\tthis._pxvalues.delete(tileno);\n\t\t\t\t// delete this._pxvalues[\"\" + tileno + \"\"];\n\t\t\t}\n\n\t\t});\n\t\tthis.prepareFITSHeader(fitsHeaderParams);\n\t\treturn this._pxvalues;\n\n\t}\n\n\tgetImageRADecList(center: Point, radiusDeg: number): Array<[number, number]> {\n\n\t\tlet ptg = new Pointing(null, false, center.spherical.thetaRad, center.spherical.phiRad);\n\t\tlet radius_rad = degToRad(radiusDeg);\n\n\t\t// with fact 8 the original Java code starts returning the the ptg pixel. with my JS porting only from fact 16\n\t\tlet rangeset = this._hp.queryDiscInclusive(ptg, radius_rad, 4); // <= check it \n\n\t\tthis._tileslist = [];\n\t\tfor (let p = 0; p < rangeset.r.length; p++) {\n\n\t\t\tif (!this._tileslist.includes(rangeset.r[p]) && rangeset.r[p] != 0) {\n\t\t\t\tthis._tileslist.push(rangeset.r[p]);\n\t\t\t}\n\n\t\t}\n\n\t\tlet cpix = this._hp.ang2pix(ptg);\n\t\tif (!this._tileslist.includes(cpix)) {\n\t\t\tthis._tileslist.push(cpix);\n\t\t}\n\n\n\t\tlet minra = center.astro.raDeg - radiusDeg;\n\t\tlet maxra = center.astro.raDeg + radiusDeg;\n\t\tlet mindec = center.astro.decDeg - radiusDeg;\n\t\tlet maxdec = center.astro.decDeg + radiusDeg;\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t// for (let j = 0; j < HiPSHelper.DEFAULT_Naxis1_2; j++) {\n\t\t\t// \tfor (let i = 0; i < HiPSHelper.DEFAULT_Naxis1_2; i++) {\n\t\t\tfor (let j = 0; j < this._HIPS_TILE_WIDTH; j++) {\n\t\t\t\tfor (let i = 0; i < this._HIPS_TILE_WIDTH; i++) {\n\t\t\t\t\tlet p = this.pix2world(i, j);\n\t\t\t\t\tif (p.astro.raDeg < minra || p.astro.raDeg > maxra ||\n\t\t\t\t\t\tp.astro.decDeg < mindec || p.astro.decDeg > maxdec) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis._radeclist.push([p.astro.raDeg, p.astro.decDeg]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this._radeclist;\n\n\n\t}\n\n\n\tpix2world(i: number, j: number): Point {\n\n\t\tlet xy = HiPSHelper.pix2intermediate(i, j, this._xyGridProj, this._naxis1, this._naxis2);\n\t\t// TODO CHECK BELOW before it was only which is supposed to be wrong since intermediate2world returns SphericalCoords, not AstroCoords\n\t\t/**  \n\t\tlet raDecDeg = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\tif (raDecDeg[0] > 360){\n\t\t\traDecDeg[0] -= 360;\n\t\t}\n\t\treturn raDecDeg;\n\t\t*/\n\t\tlet p = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\t// if (p.spherical.phiDeg > 360){\n\t\t// \tsc.phiDeg -= 360;\n\t\t// }\n\t\treturn p;\n\t}\n\n\n\t// conversion taken from https://astrophysicsandpython.com/2022/03/15/html-js-equatorial-to-galactic-coordinates/\n\tconvertToGalactic(radeclist: number[][]): number[][] {\n\t\tlet finalradeclist: number[][] = [];\n\t\tconst deg2rad = Math.PI / 180\n\t\tconst rad2deg = 180 / Math.PI\n\t\tconst l_NCP = deg2rad * 122.930\n\t\tconst d_NGP = deg2rad * 27.1284\n\t\tconst a_NGP = deg2rad * 192.8595\n\t\tradeclist.forEach(([ra, dec]) => {\n\t\t\tconst ra_rad = deg2rad * ra\n\t\t\tconst dec_rad = deg2rad * dec\n\t\t\t// sin(b)\n\t\t\tconst sin_b = Math.sin(d_NGP) * Math.sin(dec_rad) + \n\t\t\t\t\t\t\tMath.cos(d_NGP) * Math.cos(dec_rad) * Math.cos(ra_rad - a_NGP);\n\t\t\tconst b = Math.asin(sin_b)\n\t\t\tconst b_deg = b * rad2deg\n\n\t\t\t// l_NCP - l\n\t\t\tconst lNCP_minus_l = Math.atan ( ( Math.cos(dec_rad) * Math.sin(ra_rad - a_NGP)) /\n\t\t\t\t\t\t\t(Math.sin(dec_rad) * Math.cos(d_NGP) - Math.cos(dec_rad) * Math.sin(d_NGP) * Math.cos(ra_rad - a_NGP)) );\n\t\t\tconst l = l_NCP - lNCP_minus_l\n\t\t\tconst l_deg = l * rad2deg\n\t\t\t\n\t\t\tfinalradeclist.push([l_deg, b_deg])\n\t\t});\n\t\treturn finalradeclist;\n\t}\n\n\tworld2pix(radeclist: number[][]): ImagePixel[] {\n\n\t\t// let imgpxlist = new ImagePixel[radeclist.length];\n\t\tlet imgpxlist: ImagePixel[] = [];\n\t\tlet tileno: number;\n\t\tlet prevTileno: number | undefined = undefined;\n\t\t// let k = 0;\n\n\t\t/*\n\t\t\tif HiPS in galactic => convert the full list of (RA, Dec) to Galactic  (l, b)\n\t\t*/\n\n\t\tif (this._isGalactic){\n\t\t\tlet finalradeclist = this.convertToGalactic(radeclist);\n\t\t\tradeclist = finalradeclist;\n\t\t}\n\n\t\tradeclist.forEach(([ra, dec]) => {\n\n\t\t\tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n\t\t\t// let phiTheta_rad = HiPSHelper.astroDegToSphericalRad(ra, dec);\n\t\t\tlet ptg = new Pointing(null, false, p.spherical.thetaRad, p.spherical.phiRad);\n\n\t\t\ttileno = this._hp.ang2pix(ptg);\n\t\t\tif (prevTileno !== tileno || prevTileno === undefined) {\n\t\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t\tprevTileno = tileno;\n\t\t\t}\n\t\t\t// let rarad =  HiPSHelper.degToRad(ra);\n\t\t\t// let decrad = HiPSHelper.degToRad(dec);\n\t\t\tlet xy = HiPSHelper.world2intermediate(p.astro);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tlet ij = HiPSHelper.intermediate2pix(xy[0], xy[1], this._xyGridProj, this._HIPS_TILE_WIDTH);\n\n\t\t\timgpxlist.push(new ImagePixel(ij[0], ij[1], tileno));\n\t\t});\n\n\t\treturn imgpxlist;\n\t}\n\n\n\t// getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n\t// \tlet canvaslist = [];\n\t// \tlet i = 0;\n\t// \tObject.keys(this._pxvalues).forEach((tileno) => {\n\t// \t\tlet values = this._pxvalues[\"\" + tileno + \"\"];\n\n\t// \t\t// TODO change this._fitsheaderlist as per this._pxvalues in order to access to the header by \"tileno\"\n\t// \t\tlet header = this._fitsheaderlist[i];\n\n\t// \t\tlet canvas2d = new Canvas2D(values, header, this, tfunction, colormap, inverse);\n\t// \t\tcanvaslist.push(canvas2d);\n\t// \t\ti++;\n\t// \t});\n\n\t// \treturn canvaslist;\n\t// }\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n \n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\n\n\nexport class MercatorProjection implements AbstractProjection {\n\n    _minra!: number;\n    _mindec!: number;\n    _naxis1!: number;\n    _naxis2!: number;\n    \n    _fitsheader: FITSHeader[];\n    _infile!: string;\n    _ctype1: string; // TODO should be RA ENUM\n    _ctype2: string; // TODO should be Dec ENUM\n    _craDeg!: number;\n    _cdecDeg!: number;\n\n    _pxsize!: number;\n    _pxsize1!: number;\n    _pxsize2!: number;\n\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval!: number;\n    _maxphysicalval!: number;\n    _wcsname: string;\n    _fitsUsed: String[];\n    constructor() {\n\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this._ctype1 = \"RA---MER\";\n        this._ctype2 = \"DEC--MER\";\n        this._pxvalues = new Map<number, Array<Uint8Array>>();\n        this._fitsheader = new Array<FITSHeader>();\n    }\n\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n        \n        let fp = new FITSParser(infile);\n        this._infile = infile;\n        this._fitsUsed.push(infile)\n\n        let promise = fp.loadFITS().then(fits => {\n            \n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            this._naxis1 = fits.header.get(\"NAXIS1\");\n            this._naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value as number;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value as number;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            // this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            // this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n\n            const pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            const pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n            if (pxsize1 !== pxsize2 || pxsize1 === undefined || pxsize2 === undefined) {\n                throw new Error(\"pxsize1 is not equal to pxsize2\")\n                exit;\n            }\n            this._pxsize = pxsize1;\n\n            // this._minra = this._craDeg - this._pxsize1 * this._naxis1 / 2;\n            this._minra = this._craDeg - this._pxsize * this._naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            // this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n            this._mindec = this._cdecDeg - this._pxsize * this._naxis2 / 2;\n\n            return fits;\n        });\n        await promise;\n        return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\n        this._fitsheader[0] = new FITSHeader();\n\n\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS1\", this._naxis1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS2\", this._naxis2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE1\", \"'\"+this._ctype1+\"'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE2\", \"'\"+this._ctype2+\"'\"));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT1\", this._pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT2\", this._pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX1\", this._naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX2\", this._naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"ORIGIN\", \"'WCSLight v.0.x'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"COMMENT\", \"'WCSLight v0.x developed by F.Giordano and Y.Ascasibar'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n    getFITSHeader(): FITSHeader[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeader {\n        let header = new FITSHeader();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                header.addItem(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    get fitsUsed(): String[]{\n\t\treturn this._fitsUsed;\n\t}\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= this._naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= this._naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        let pv = this._pxvalues.get(0);\n                        if (pv !== undefined) {\n\n                            for (let b = 0; b < bytesXelem; b++) {\n\n                                values[p * bytesXelem + b] = pv[imgpx._j][(imgpx._i) * bytesXelem + b];\n                            }\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n\n    computeSquaredNaxes(d: number, ps: number): void {\n        // first approximation to be checked\n        this._naxis1 = Math.ceil(d / ps);\n        this._naxis2 = this._naxis1;\n        this._pxsize = ps;\n    }\n\n\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n\n        let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        let maxpixb = minpixb;\n\n        let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        this._minphysicalval = bzero + bscale * minpixb;\n        this._maxphysicalval = bzero + bscale * maxpixb;\n\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n        // this._pxvalues.set(0, new Uint8Array[this._naxis2][this._naxis1 * bytesXelem]);\n\n        this._pxvalues.set(0, new Array<Uint8Array>(this._naxis2));\n        let pv = this._pxvalues.get(0);\n        if (pv !== undefined) {\n            for (let r = 0; r < this._naxis2; r++) {\n                pv[r] = new Uint8Array(this._naxis1 * bytesXelem);\n            }\n\n            let r!: number;\n            let c!: number;\n            let b!: number;\n            for (let p = 0; (p * bytesXelem) < values.length; p++) {\n                // console.log(\"processing \"+p + \" of \"+ (values.length / bytesXelem));\n\n                try {\n                    r = Math.floor(p / this._naxis1);\n                    c = (p - r * this._naxis1) * bytesXelem;\n\n                    for (b = 0; b < bytesXelem; b++) {\n                        pv[r][c + b] = values[p * bytesXelem + b];\n                    }\n\n\n                    let valpixb = ParseUtils.extractPixelValue(0, values.slice(p * bytesXelem, (p * bytesXelem) + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n                    let valphysical = bzero + bscale * valpixb;\n\n                    if (valphysical < this._minphysicalval || isNaN(this._minphysicalval)) {\n                        this._minphysicalval = valphysical;\n                    } else if (valphysical > this._maxphysicalval || isNaN(this._maxphysicalval)) {\n                        this._maxphysicalval = valphysical;\n                    }\n                } catch (err) {\n                    console.log(err)\n                    console.log(\"p \" + p)\n                    console.log(\"r %, c %, b %\" + r, c, b)\n                    console.log(\"this._pxvalues[r][c + b] \" + pv[r][c + b])\n                    console.log(\"values[p * bytesXelem + b] \" + values[p * bytesXelem + b])\n                }\n\n            }\n        }\n\n        this.prepareFITSHeader(fitsHeaderParams);\n        return this._pxvalues;\n\n    }\n\n\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n\n\n        this.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n        this._pxsize = pxsize;\n        this._minra = center.astro.raDeg - radius;\n        if (this._minra < 0) {\n            this._minra += 360;\n        }\n        this._mindec = center.astro.decDeg - radius;\n\n        let radeclist: Array<[number, number]> = new Array<[number, number]>();\n\n        for (let d = 0; d < this._naxis2; d++) {\n            for (let r = 0; r < this._naxis1; r++) {\n                radeclist.push([this._minra + (r * this._pxsize), this._mindec + (d * this._pxsize)]);\n            }\n        }\n\n        // let cidx2 = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        // let cidx3 = (this._naxis2 / 2 ) * this._naxis1 + this._naxis1 / 2;\n        let cidx = Math.ceil(radeclist.length / 2);\n        this._craDeg = radeclist[cidx][0];\n        this._cdecDeg = radeclist[cidx][1];\n\n        return radeclist;\n\n\n    }\n\n\n    // getImageRADecList(center: AstroCoords, radius: number, pxsize: number): Promise<number[][]> {\n\n    //     let promise = new Promise<[]> ( (resolve, reject) => {\n    //         this.computeSquaredNaxes (2 * radius, pxsize); // compute naxis[1, 2]\n    //         this._pxsize = pxsize;\n    //         this._minra = center.raDeg - radius;\n    //         if (this._minra < 0) {\n    //             this._minra += 360;\n    //         }\n    //         this._mindec = center.decDeg - radius;\n\n    //         let radeclist:number[][] = new Array<Array<number>>();\n\n    //         for (let d = 0; d < this._naxis2; d++) {\n    //             for (let r = 0; r < this._naxis1; r++) {\n    //                 radeclist.push([ this._minra + (r * this._pxsize), this._mindec + (d * this._pxsize)]);\n    //             }    \n    //         }\n\n    //         let cidx = (this._naxis2/2 - 1) * this._naxis1 +  this._naxis1/2;\n    //         this._craDeg = radeclist[ cidx ][0];\n    //         this._cdecDeg = radeclist[ cidx ][1];\n\n    //         resolve(radeclist);\n    //     });\n    //     return promise;\n\n    // }\n\n    /** TODO !!! check and handle RA passing through 360-0 */\n    pix2world(i: number, j: number): Point {\n\n        let ra: number;\n        let dec: number;\n        // ra = i * this._stepra + this._minra;\n        // dec = j * this._stepdec + this._mindec;\n        ra = i * this._pxsize + this._minra;\n        dec = j * this._pxsize + this._mindec;\n        let p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n        return p;\n        // return [ra, dec];\n\n    }\n\n    // world2pix (radeclist: number[][]): Promise<ImagePixel[]> {\n\n    //     let promise = new Promise<ImagePixel[]> ( (resolve, reject) => {\n\n    //         this.initFromFile(this._infile).then( (data) => {\n    //             let imgpxlist = [];\n\n    //             for (let radecItem of radeclist) {\n    //                 let ra = radecItem[0];\n    //                 let dec = radecItem[1];\n    //                 let i = Math.floor((ra - this._minra) / this._pxsize1);\n    //                 let j = Math.floor((dec - this._mindec) / this._pxsize2);\n    //                 imgpxlist.push(new ImagePixel(i, j));\n    //             }\n\n    //             resolve(imgpxlist);\n    //         });\n\n    //     });\n    //     return promise;\n    // }\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        for (let radecItem of radeclist) {\n            let ra = radecItem[0];\n            let dec = radecItem[1];\n            // let i = Math.floor((ra - this._minra) / this._pxsize1);\n            // let j = Math.floor((dec - this._mindec) / this._pxsize2);\n            let i = Math.floor((ra - this._minra) / this._pxsize);\n            let j = Math.floor((dec - this._mindec) / this._pxsize);\n            imgpxlist.push(new ImagePixel(i, j));\n        }\n\n        return imgpxlist;\n\n    }\n\n    // getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n    // \tlet canvas2d =  new Canvas2D(this._pxvalues, this._fitsheader, this, tfunction, colormap, inverse);\n    // \treturn canvas2d;\n    // }\n\n\n}\n","\n\n\n// import { FITSParser } from 'fitsparser/FITSParser-node';\n// import { FITSHeader } from 'fitsparser/model/FITSHeader';\n// import { FITSHeaderItem } from 'fitsparser/model/FITSHeaderItem';\n// import { FITSParsed } from 'fitsparser/model/FITSParsed';\n\n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { AbstractProjection } from './AbstractProjection.js';\nimport {Point} from '../model/Point.js';\n\nexport class TestProj implements AbstractProjection{\n    \n    _minra: number;\n    _mindec: number;\n    _naxis1: number;\n    _naxis2: number;\n    _pxsize: number;\n    _fitsheader: FITSHeader[];\n    _infile: string;\n    _ctype1: string; // TODO should be RA ENUM\n    _ctype2: string; // TODO should be Dec ENUM\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n    constructor() {\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this._ctype1 = \"RA---MER\";\n        this._ctype2 = \"DEC--MER\";\n        this._pxvalues = new Map<number, Array<Uint8Array>>();\n        const fh = new FITSHeader();\n        const fp = new FITSParser(\"./notexistent/\");\n        const fhi = new FITSHeaderItem(\"mykey\", \"myvalue\", \"mycomment\");\n\n\n    }\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    \n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeader {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    public computeSquaredNaxes(d: number, ps: number): void {\n        throw new Error('Method not implemented.');\n    }\n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number):  Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n}","/* (ignored) */","import { Vec3 } from './Vec3.js';\nexport class CircleFinder {\n    /**\n     * @param point: Vec3\n     */\n    constructor(point) {\n        let np = point.length;\n        //HealpixUtils.check(np>=2,\"too few points\");\n        if (!(np >= 2)) {\n            console.log(\"too few points\");\n            return;\n        }\n        this.center = point[0].add(point[1]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 2; i < np; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle(point, i);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q: int\n     */\n    getCircle(point, q) {\n        this.center = point[0].add(point[q]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 1; i < q; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle2(point, i, q);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q1: int\n     * @param q2: int\n     */\n    getCircle2(point, q1, q2) {\n        this.center = point[q1].add(point[q2]);\n        this.center.normalize();\n        this.cosrad = point[q1].dot(this.center);\n        for (let i = 0; i < q1; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.center = (point[q1].sub(point[i])).cross(point[q2].sub(point[i]));\n                this.center.normalize();\n                this.cosrad = point[i].dot(this.center);\n                if (this.cosrad < 0) {\n                    this.center.flip();\n                    this.cosrad = -this.cosrad;\n                }\n            }\n        }\n    }\n    ;\n    getCenter() {\n        return new Vec3(this.center.x, this.center.y, this.center.z);\n    }\n    getCosrad() {\n        return this.cosrad;\n    }\n    ;\n}\n//# sourceMappingURL=CircleFinder.js.map","export class Constants {\n}\n//\tstatic halfpi = Math.PI/2.;\nConstants.halfpi = 1.5707963267948966;\nConstants.inv_halfpi = 2. / Math.PI;\n/** The Constant twopi. */\nConstants.twopi = 2 * Math.PI;\nConstants.inv_twopi = 1. / (2 * Math.PI);\n//# sourceMappingURL=Constants.js.map","/**\n * Partial porting to Javascript of Fxyf.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nexport class Fxyf {\n    constructor(x, y, f) {\n        this.fx = x;\n        this.fy = y;\n        this.face = f;\n        // coordinate of the lowest corner of each face\n        this.jrll = new Uint8Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Uint8Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.halfpi = Math.PI / 2.;\n    }\n    toHploc() {\n        let loc = new Hploc();\n        let jr = this.jrll[this.face] - this.fx - this.fy;\n        let nr;\n        if (jr < 1) {\n            nr = jr;\n            let tmp = nr * nr / 3.;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > 3) {\n            nr = 4 - jr;\n            let tmp = nr * nr / 3.;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = 1;\n            loc.z = (2 - jr) * 2.0 / 3.;\n        }\n        let tmp = this.jpll[this.face] * nr + this.fx - this.fy;\n        if (tmp < 0) {\n            tmp += 8;\n        }\n        if (tmp >= 8) {\n            tmp -= 8;\n        }\n        loc.phi = (nr < 1e-15) ? 0 : (0.5 * this.halfpi * tmp) / nr;\n        return loc;\n    }\n    ;\n    toVec3() {\n        return this.toHploc().toVec3();\n    }\n    ;\n}\n//# sourceMappingURL=Fxyf.js.map","\"use strict\";\nimport { CircleFinder } from \"./CircleFinder.js\";\nimport { Constants } from \"./Constants.js\";\nimport { Fxyf } from \"./Fxyf.js\";\nimport { Hploc } from \"./Hploc.js\";\nimport { Pointing } from \"./Pointing.js\";\nimport { pstack } from \"./pstack.js\";\nimport { RangeSet } from \"./RangeSet.js\";\nimport { Vec3 } from \"./Vec3.js\";\nimport { Xyf } from \"./Xyf.js\";\nimport { Zphi } from \"./Zphi.js\";\n/**\n * Partial porting to Javascript of HealpixBase.java from Healpix3.30\n */\n// import Fxyf from './Fxyf.js';\n// import Hploc from './Hploc.js';\n// import Xyf from './Xyf.js';\n// import Vec3 from './Vec3.js';\n// import Pointing from './Pointing.js';\n// import CircleFinder from './CircleFinder.js';\n// import Zphi from './Zphi.js';\n// import pstack from './pstack.js';\n// import Constants from './Constants.js';\n// import RangeSet from './RangeSet.js';\nexport class Healpix {\n    constructor(nside_in) {\n        this.order_max = 29;\n        this.inv_halfpi = 2.0 / Math.PI;\n        this.twothird = 2.0 / 3.;\n        // console.log(\"twothird \"+this.twothird);\n        // this.ns_max=1L<<order_max;\n        this.ns_max = Math.pow(2, this.order_max);\n        this.ctab = new Uint16Array([\n            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,\n            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,\n            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,\n            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,\n            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,\n            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,\n            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,\n            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,\n            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,\n            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,\n            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,\n            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,\n            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,\n            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,\n            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,\n            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855\n        ]);\n        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,\n            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,\n            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,\n            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,\n            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,\n            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,\n            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,\n            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,\n            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,\n            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,\n            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,\n            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,\n            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,\n            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,\n            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,\n            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,\n            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,\n            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);\n        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);\n        this.facearray = [\n            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),\n            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),\n            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),\n            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]),\n            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),\n            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),\n            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),\n            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),\n            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]) // N\n        ];\n        // questo forse deve essere un UInt8Array. Viene usato da neighbours\n        this.swaparray = [\n            new Int16Array([0, 0, 3]),\n            new Int16Array([0, 0, 6]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([0, 0, 5]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([5, 0, 0]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([6, 0, 0]),\n            new Int16Array([3, 0, 0]) // N\n        ];\n        if (nside_in <= this.ns_max && nside_in > 0) {\n            this.nside = nside_in;\n            this.npface = this.nside * this.nside;\n            this.npix = 12 * this.npface;\n            this.order = this.nside2order(this.nside);\n            this.nl2 = 2 * this.nside;\n            this.nl3 = 3 * this.nside;\n            this.nl4 = 4 * this.nside;\n            this.fact2 = 4.0 / this.npix;\n            this.fact1 = (this.nside << 1) * this.fact2;\n            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap\n            // console.log(\"order: \"+this.order);\n            // console.log(\"nside: \"+this.nside);\n        }\n        this.bn = [];\n        this.mpr = [];\n        this.cmpr = [];\n        this.smpr = [];\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // Uncaught RangeError: Maximum call stack size exceeded\n        // MOVED TO computeBn()\n        //        for (let i=0; i <= this.order_max; ++i) {\n        //        \tthis.bn[i]=new Healpix(1<<i);\n        //        \tthis.mpr[i]=bn[i].maxPixrad();\n        //        \tthis.cmpr[i]=Math.cos(mpr[i]);\n        //        \tthis.smpr[i]=Math.sin(mpr[i]);\n        //        }\n    }\n    computeBn() {\n        for (let i = 0; i <= this.order_max; ++i) {\n            this.bn[i] = new Healpix(1 << i);\n            this.mpr[i] = this.bn[i].maxPixrad();\n            this.cmpr[i] = Hploc.cos(this.mpr[i]);\n            this.smpr[i] = Hploc.sin(this.mpr[i]);\n        }\n    }\n    getNPix() {\n        return this.npix;\n    }\n    ;\n    getBoundaries(pix) {\n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        // console.log(\"PIXEL: \"+pix);\n        // console.log(\"XYF \"+xyf.ix+\" \"+xyf.iy+\" \"+xyf.face);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        // let d = 1.0/(this.nside);\n        // console.log(\"------------------------\");\n        // console.log(\"xc, yc, dc \"+xc+\",\"+ yc+\",\"+ dc);\n        // console.log(\"xc+dc-d, yc+dc, xyf.face, d \"+(xc+dc) +\",\"+ (yc+dc)+\",\"+\n        // xyf.face+\",\"+ d);\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        // console.log(\"Points for npix: \"+pix);\n        // console.log(points);\n        // if (pix > 750){\n        // console.log(\"pix: \"+pix);\n        // console.log(\"dc: \"+dc);\n        // console.log(\"xyf.ix: \"+xyf.ix);\n        // console.log(\"xyf.iy: \"+xyf.iy);\n        // console.log(\"xc: \"+xc);\n        // console.log(\"yc: \"+yc);\n        // console.log(\"d: \"+d);\n        // }\n        return points;\n    }\n    ;\n    /** Returns a set of points along the boundary of the given pixel.\n     * Step 1 gives 4 points on the corners. The first point corresponds\n     * to the northernmost corner, the subsequent points follow the pixel\n     * boundary through west, south and east corners.\n     *\n     * @param pix pixel index number\n     * @param step the number of returned points is 4*step\n     * @return {@link Vec3} for each point\n     */\n    getBoundariesWithStep(pix, step) {\n        // var points = new Array(); \n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        let d = 1.0 / (this.nside * step);\n        for (let i = 0; i < step; i++) {\n            points[i] = new Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();\n            points[i + step] = new Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();\n            points[i + 2 * step] = new Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();\n            points[i + 3 * step] = new Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();\n        }\n        return points;\n    }\n    ;\n    getPointsForXyfNoStep(x, y, face) {\n        let nside = Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    getPointsForXyf(x, y, step, face) {\n        let nside = step * Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    /** Returns the neighboring pixels of ipix.\n    This method works in both RING and NEST schemes, but is\n    considerably faster in the NEST scheme.\n    @param ipix the requested pixel number.\n    @return array with indices of the neighboring pixels.\n      The returned array contains (in this order)\n      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor\n      of ipix. If a neighbor does not exist (this can only happen\n      for the W, N, E and S neighbors), its entry is set to -1. */\n    neighbours(ipix) {\n        let result = new Int32Array(8);\n        let xyf = this.nest2xyf(ipix);\n        let ix = xyf.ix;\n        let iy = xyf.iy;\n        let face_num = xyf.face;\n        var nsm1 = this.nside - 1;\n        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {\n            let fpix = Math.floor(face_num << (2 * this.order));\n            let px0 = this.spread_bits(ix);\n            let py0 = this.spread_bits(iy) << 1;\n            let pxp = this.spread_bits(ix + 1);\n            let pyp = this.spread_bits(iy + 1) << 1;\n            let pxm = this.spread_bits(ix - 1);\n            let pym = this.spread_bits(iy - 1) << 1;\n            result[0] = fpix + pxm + py0;\n            result[1] = fpix + pxm + pyp;\n            result[2] = fpix + px0 + pyp;\n            result[3] = fpix + pxp + pyp;\n            result[4] = fpix + pxp + py0;\n            result[5] = fpix + pxp + pym;\n            result[6] = fpix + px0 + pym;\n            result[7] = fpix + pxm + pym;\n        }\n        else {\n            for (let i = 0; i < 8; ++i) {\n                let x = ix + this.xoffset[i];\n                let y = iy + this.yoffset[i];\n                let nbnum = 4;\n                if (x < 0) {\n                    x += this.nside;\n                    nbnum -= 1;\n                }\n                else if (x >= this.nside) {\n                    x -= this.nside;\n                    nbnum += 1;\n                }\n                if (y < 0) {\n                    y += this.nside;\n                    nbnum -= 3;\n                }\n                else if (y >= this.nside) {\n                    y -= this.nside;\n                    nbnum += 3;\n                }\n                let f = this.facearray[nbnum][face_num];\n                if (f >= 0) {\n                    let bits = this.swaparray[nbnum][face_num >>> 2];\n                    if ((bits & 1) > 0) {\n                        x = Math.floor(this.nside - x - 1);\n                    }\n                    if ((bits & 2) > 0) {\n                        y = Math.floor(this.nside - y - 1);\n                    }\n                    if ((bits & 4) > 0) {\n                        let tint = x;\n                        x = y;\n                        y = tint;\n                    }\n                    result[i] = this.xyf2nest(x, y, f);\n                }\n                else {\n                    result[i] = -1;\n                }\n            }\n        }\n        return result;\n    }\n    ;\n    nside2order(nside) {\n        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);\n    }\n    ;\n    nest2xyf(ipix) {\n        let pix = Math.floor(ipix & (this.npface - 1));\n        let xyf = new Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1), Math.floor((ipix >> (2 * this.order))));\n        return xyf;\n    }\n    ;\n    xyf2nest(ix, iy, face_num) {\n        return Math.floor(face_num << (2 * this.order))\n            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);\n    }\n    ;\n    loc2pix(hploc) {\n        let z = hploc.z;\n        let phi = hploc.phi;\n        let za = Math.abs(z);\n        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0); // in [0,4)\n        let pixNo;\n        if (za <= this.twothird) { // Equatorial region\n            let temp1 = this.nside * (0.5 + tt);\n            let temp2 = this.nside * (z * 0.75);\n            let jp = Math.floor(temp1 - temp2); // index of ascending edge line\n            let jm = Math.floor(temp1 + temp2); // index of descending edge line\n            let ifp = Math.floor(jp >>> this.order); // in {0,4}\n            let ifm = Math.floor(jm >>> this.order);\n            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));\n            let ix = Math.floor(jm & (this.nside - 1));\n            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);\n            pixNo = this.xyf2nest(ix, iy, face_num);\n        }\n        else { // polar region, za > 2/3\n            let ntt = Math.min(3, Math.floor(tt));\n            let tp = tt - ntt;\n            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?\n                this.nside * Math.sqrt(3 * (1 - za)) :\n                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);\n            let jp = Math.floor(tp * tmp); // increasing edge line index\n            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index\n            if (jp >= this.nside) {\n                jp = this.nside - 1; // for points too close to the boundary\n            }\n            if (jm >= this.nside) {\n                jm = this.nside - 1;\n            }\n            if (z >= 0) {\n                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);\n            }\n            else {\n                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);\n            }\n        }\n        return pixNo;\n    }\n    ;\n    /** Returns the normalized 3-vector corresponding to the center of the\n    supplied pixel.\n    @param pix long the requested pixel number.\n    @return the pixel's center coordinates. */\n    pix2vec(pix) {\n        return this.pix2loc(pix).toVec3();\n    }\n    ;\n    /** Returns the Zphi corresponding to the center of the supplied pixel.\n     @param pix the requested pixel number.\n     @return the pixel's center coordinates. */\n    pix2zphi(pix) {\n        return this.pix2loc(pix).toZphi();\n    }\n    /**\n     * @param pix long\n     * @return Hploc\n     */\n    pix2loc(pix) {\n        let loc = new Hploc(undefined);\n        let xyf = this.nest2xyf(pix);\n        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;\n        let nr;\n        if (jr < this.nside) {\n            nr = jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > this.nl3) {\n            nr = this.nl4 - jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = this.nside;\n            loc.z = (this.nl2 - jr) * this.fact1;\n        }\n        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;\n        //      \tassert(tmp<8*nr); // must not happen\n        if (tmp < 0) {\n            tmp += 8 * nr;\n        }\n        loc.phi = (nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp) / nr;\n        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);\n        return loc;\n    }\n    ;\n    ang2pix(ptg, mirror) {\n        return this.loc2pix(new Hploc(ptg));\n    }\n    ;\n    fmodulo(v1, v2) {\n        if (v1 >= 0) {\n            return (v1 < v2) ? v1 : v1 % v2;\n        }\n        var tmp = v1 % v2 + v2;\n        return (tmp === v2) ? 0.0 : tmp;\n    }\n    ;\n    compress_bits(v) {\n        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));\n        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);\n        return compressed;\n    }\n    ;\n    spread_bits(v) {\n        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))\n            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));\n    }\n    ;\n    /**\n     * Returns a range set of pixels that overlap with the convex polygon\n     * defined by the {@code vertex} array.\n     * <p>\n     * This method is more efficient in the RING scheme.\n     * <p>\n     * This method may return some pixels which don't overlap with the polygon\n     * at all. The higher {@code fact} is chosen, the fewer false positives are\n     * returned, at the cost of increased run time.\n     *\n     * @param vertex\n     *            an array containing the vertices of the requested convex\n     *            polygon.\n     * @param fact\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return the requested set of pixel number ranges\n     */\n    queryPolygonInclusive(vertex, fact) {\n        let inclusive = (fact != 0);\n        let nv = vertex.length;\n        //        let ncirc = inclusive ? nv+1 : nv;\n        if (!(nv >= 3)) {\n            console.log(\"not enough vertices in polygon\");\n            return;\n        }\n        let vv = new Array();\n        for (let i = 0; i < nv; ++i) {\n            vv[i] = Vec3.pointing2Vec3(vertex[i]);\n        }\n        let normal = new Array();\n        let flip = 0;\n        let index = 0;\n        let back = false;\n        while (index < vv.length) {\n            let first = vv[index];\n            let medium = null;\n            let last = null;\n            if (index == vv.length - 1) {\n                last = vv[1];\n                medium = vv[0];\n            }\n            else if (index == vv.length - 2) {\n                last = vv[0];\n                medium = vv[index + 1];\n            }\n            else {\n                medium = vv[index + 1];\n                last = vv[index + 2];\n            }\n            normal[index] = first.cross(medium).norm();\n            let hnd = normal[index].dot(last);\n            if (index == 0) {\n                flip = (hnd < 0.) ? -1 : 1;\n                let tmp = new Pointing(first); // TODO not used\n                back = false;\n            }\n            else {\n                let flipThnd = flip * hnd;\n                if (flipThnd < 0) {\n                    let tmp = new Pointing(medium);\n                    vv.splice(index + 1, 1);\n                    normal.splice(index, 1);\n                    back = true;\n                    index -= 1;\n                    continue;\n                }\n                else {\n                    let tmp = new Pointing(first);\n                    back = false;\n                }\n            }\n            normal[index].scale(flip);\n            index += 1;\n        }\n        nv = vv.length;\n        let ncirc = inclusive ? nv + 1 : nv;\n        let rad = new Array(ncirc);\n        rad = rad.fill(Constants.halfpi);\n        //        rad = rad.fill(1.5707963267948966);\n        //        let p = \"1.5707963267948966\";\n        //        rad = rad.fill(parseFloat(p));\n        if (inclusive) {\n            let cf = new CircleFinder(vv);\n            normal[nv] = cf.getCenter();\n            rad[nv] = Hploc.acos(cf.getCosrad());\n        }\n        return this.queryMultiDisc(normal, rad, fact);\n    }\n    ;\n    /**\n     * For NEST schema only\n     *\n     * @param normal:\n     *            Vec3[]\n     * @param rad:\n     *            Float32Array\n     * @param fact:\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return RangeSet the requested set of pixel number ranges\n     */\n    queryMultiDisc(norm, rad, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let nv = norm.length;\n        // HealpixUtils.check(nv==rad.lengt0,\"inconsistent input arrays\");\n        if (!(nv == rad.length)) {\n            console.error(\"inconsistent input arrays\");\n            return;\n        }\n        let res = new RangeSet(4 << 1);\n        // Removed code for Scheme.RING\n        let oplus = 0;\n        if (inclusive) {\n            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {\n                console.error(\"invalid oversampling factor\");\n            }\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = this.order + oplus; // the order up to which we test\n        // TODO: ignore all disks with radius>=pi\n        //        let crlimit = new Float32Array[omax+1][nv][3];\n        let crlimit = new Array(omax + 1);\n        let o;\n        let i;\n        for (o = 0; o <= omax; ++o) { // prepare data at the required orders\n            crlimit[o] = new Array(nv);\n            let dr = this.bn[o].maxPixrad(); // safety distance\n            for (i = 0; i < nv; ++i) {\n                crlimit[o][i] = new Float64Array(3);\n                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Hploc.cos(rad[i] + dr);\n                crlimit[o][i][1] = (o == 0) ? Hploc.cos(rad[i]) : crlimit[0][i][1];\n                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : Hploc.cos(rad[i] - dr);\n            }\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse\n            // order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let o = stk.otop();\n            stk.pop();\n            let pv = this.bn[o].pix2vec(pix);\n            let zone = 3;\n            for (let i = 0; (i < nv) && (zone > 0); ++i) {\n                let crad = pv.dot(norm[i]);\n                for (let iz = 0; iz < zone; ++iz) {\n                    if (crad < crlimit[o][i][iz]) {\n                        zone = iz;\n                    }\n                }\n            }\n            if (zone > 0) {\n                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);\n            }\n        }\n        return res;\n    }\n    ;\n    /** Integer base 2 logarithm.\n    @param arg\n    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.\n    For negative arguments and zero, 0 is returned. */\n    ilog2(arg) {\n        let max = Math.max(arg, 1);\n        return 31 - Math.clz32(max);\n    }\n    ;\n    /** Computes the cosine of the angular distance between two z, phi positions\n      on the unit sphere. */\n    cosdist_zphi(z1, phi1, z2, phi2) {\n        return z1 * z2 + Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));\n    }\n    /**\n     * @param int o\n     * @param int omax\n     * @param int zone\n     * @param RangeSet pixset\n     * @param long pix\n     * @param pstack stk\n     * @param boolean inclusive\n     */\n    check_pixel(o, omax, zone, pixset, pix, stk, inclusive) {\n        if (zone == 0)\n            return;\n        if (o < this.order) {\n            if (zone >= 3) { // output all subpixels\n                let sdist = 2 * (this.order - o); // the \"bit-shift distance\" between map orders\n                pixset.append1(pix << sdist, ((pix + 1) << sdist));\n            }\n            else { // (zone>=1)\n                for (let i = 0; i < 4; ++i) {\n                    stk.push(4 * pix + 3 - i, o + 1); // add children\n                }\n            }\n        }\n        else if (o > this.order) { // this implies that inclusive==true\n            if (zone >= 2) { // pixel center in shape\n                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                stk.popToMark(); // unwind the stack\n            }\n            else { // (zone>=1): pixel center in safety range\n                if (o < omax) { // check sublevels\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                    stk.popToMark(); // unwind the stack\n                }\n            }\n        }\n        else { // o==order\n            if (zone >= 2) {\n                pixset.append(pix);\n            }\n            else if (inclusive) { // and (zone>=1)\n                if (this.order < omax) { // check sublevels\n                    stk.mark(); // remember current stack position\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix); // output the pixel\n                }\n            }\n        }\n    }\n    /** Returns the maximum angular distance between a pixel center and its\n    corners.\n    @return maximum angular distance between a pixel center and its\n      corners. */\n    maxPixrad() {\n        let zphia = new Zphi(2. / 3., Math.PI / this.nl4);\n        let xyz1 = this.convertZphi2xyz(zphia);\n        let va = new Vec3(xyz1[0], xyz1[1], xyz1[2]);\n        let t1 = 1. - 1. / this.nside;\n        t1 *= t1;\n        let zphib = new Zphi(1 - t1 / 3, 0);\n        let xyz2 = this.convertZphi2xyz(zphib);\n        let vb = new Vec3(xyz2[0], xyz2[1], xyz2[2]);\n        return va.angle(vb);\n    }\n    ;\n    /**\n     * this is a workaround replacing the Vec3(Zphi) constructor.\n     */\n    convertZphi2xyz(zphi) {\n        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));\n        let x = sth * Hploc.cos(zphi.phi);\n        let y = sth * Hploc.sin(zphi.phi);\n        let z = zphi.z;\n        return [x, y, z];\n    }\n    ;\n    /** Returns a range set of pixels which overlap with a given disk. <p>\n      This method is more efficient in the RING scheme. <p>\n      This method may return some pixels which don't overlap with\n      the polygon at all. The higher {@code fact} is chosen, the fewer false\n      positives are returned, at the cost of increased run time.\n      @param ptg the angular coordinates of the disk center\n      @param radius the radius (in radians) of the disk\n      @param fact The overlapping test will be done at the resolution\n        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power\n        of 2, else it can be any positive integer. A typical choice would be 4.\n      @return the requested set of pixel number ranges  */\n    queryDiscInclusive(ptg, radius, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let pixset = new RangeSet();\n        if (radius >= Math.PI) { // disk covers the whole sphere\n            pixset.append1(0, this.npix);\n            return pixset;\n        }\n        let oplus = 0;\n        if (inclusive) {\n            // HealpixUtils.check ((1L<<order_max)>=fact,\"invalid oversampling factor\");\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test\n        let vptg = Vec3.pointing2Vec3(ptg);\n        let crpdr = new Array(omax + 1);\n        let crmdr = new Array(omax + 1);\n        let cosrad = Hploc.cos(radius);\n        let sinrad = Hploc.sin(radius);\n        for (let o = 0; o <= omax; o++) { // prepare data at the required orders\n            let dr = this.mpr[o]; // safety distance\n            let cdr = this.cmpr[o];\n            let sdr = this.smpr[o];\n            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;\n            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let curro = stk.otop();\n            stk.pop();\n            let pos = this.bn[curro].pix2zphi(pix);\n            // cosine of angular distance between pixel center and disk center\n            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);\n            if (cangdist > crpdr[curro]) {\n                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);\n                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);\n            }\n        }\n        return pixset;\n    }\n}\n//# sourceMappingURL=Healpix.js.map","import { Vec3 } from './Vec3.js';\nimport { Zphi } from './Zphi.js';\nexport class Hploc {\n    constructor(ptg) {\n        Hploc.PI4_A = 0.7853981554508209228515625;\n        Hploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\n        Hploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n        Hploc.M_1_PI = 0.3183098861837906715377675267450287;\n        if (ptg) {\n            this.sth = 0.0;\n            this.have_sth = false;\n            this.z = Hploc.cos(ptg.theta);\n            this._phi = ptg.phi;\n            if (Math.abs(this.z) > 0.99) {\n                this.sth = Hploc.sin(ptg.theta);\n                this.have_sth = true;\n            }\n        }\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    ;\n    get phi() {\n        return this._phi;\n    }\n    ;\n    set phi(phi) {\n        this._phi = phi;\n    }\n    ;\n    setSth(sth) {\n        this.sth = sth;\n    }\n    ;\n    toVec3() {\n        var st = this.have_sth ? this.sth : Math.sqrt((1.0 - this.z) * (1.0 + this.z));\n        // var vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);\n        var vector = new Vec3(st * Math.cos(this.phi), st * Math.sin(this.phi), this.z);\n        return vector;\n    }\n    ;\n    toZphi() {\n        return new Zphi(this.z, this.phi);\n    }\n    static sin(d) {\n        let u = d * Hploc.M_1_PI;\n        let q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 4.0 * q;\n        d -= x * Hploc.PI4_A;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 1) != 0) {\n            d = -d;\n        }\n        return this.sincoshelper(d);\n    }\n    ;\n    static cos(d) {\n        //\t\tlet u = d * Hploc.M_1_PI - 0.5;\n        let u = d * Hploc.M_1_PI - 0.5;\n        //\t\tu -= 0.5;\n        let q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 2.0 * q;\n        let t = x * Hploc.PI4_A;\n        d = d - t;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 2) == 0) {\n            d = -d;\n        }\n        return Hploc.sincoshelper(d);\n    }\n    ;\n    static sincoshelper(d) {\n        let s = d * d;\n        let u = -7.97255955009037868891952e-18;\n        u = u * s + 2.81009972710863200091251e-15;\n        u = u * s - 7.64712219118158833288484e-13;\n        u = u * s + 1.60590430605664501629054e-10;\n        u = u * s - 2.50521083763502045810755e-08;\n        u = u * s + 2.75573192239198747630416e-06;\n        u = u * s - 0.000198412698412696162806809;\n        u = u * s + 0.00833333333333332974823815;\n        u = u * s - 0.166666666666666657414808;\n        return s * u * d + d;\n    }\n    ;\n    /** This method calculates the arc sine of x in radians. The return\n    value is in the range [-pi/2, pi/2]. The results may have\n    maximum error of 3 ulps. */\n    static asin(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1 + d) * (1 - d))), d);\n    }\n    ;\n    /** This method calculates the arc cosine of x in radians. The\n        return value is in the range [0, pi]. The results may have\n        maximum error of 3 ulps. */\n    static acos(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.sqrt((1 + d) * (1 - d)), Math.abs(d)), d) + (d < 0 ? Math.PI : 0);\n    }\n    ;\n    static mulsign(x, y) {\n        let sign = Hploc.copySign(1, y);\n        return sign * x;\n    }\n    ;\n    static copySign(magnitude, sign) {\n        return sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);\n        // let finalsign = 1;\n        // if (Object.is(finalsign , -0)){\n        // \tsign = -1;\n        // }else if (Object.is(finalsign , 0)){\n        // \tsign = 1;\n        // }else {\n        // \tsign = Math.sign(finalsign);\n        // }\n        // return finalsign * magnitude;\n    }\n    static atanhelper(s) {\n        let t = s * s;\n        let u = -1.88796008463073496563746e-05;\n        u = u * t + (0.000209850076645816976906797);\n        u = u * t + (-0.00110611831486672482563471);\n        u = u * t + (0.00370026744188713119232403);\n        u = u * t + (-0.00889896195887655491740809);\n        u = u * t + (0.016599329773529201970117);\n        u = u * t + (-0.0254517624932312641616861);\n        u = u * t + (0.0337852580001353069993897);\n        u = u * t + (-0.0407629191276836500001934);\n        u = u * t + (0.0466667150077840625632675);\n        u = u * t + (-0.0523674852303482457616113);\n        u = u * t + (0.0587666392926673580854313);\n        u = u * t + (-0.0666573579361080525984562);\n        u = u * t + (0.0769219538311769618355029);\n        u = u * t + (-0.090908995008245008229153);\n        u = u * t + (0.111111105648261418443745);\n        u = u * t + (-0.14285714266771329383765);\n        u = u * t + (0.199999999996591265594148);\n        u = u * t + (-0.333333333333311110369124);\n        return u * t * s + s;\n    }\n    ;\n    static atan2k(y, x) {\n        let q = 0.;\n        if (x < 0) {\n            x = -x;\n            q = -2.;\n        }\n        if (y > x) {\n            let t = x;\n            x = y;\n            y = -t;\n            q += 1.;\n        }\n        return Hploc.atanhelper(y / x) + q * (Math.PI / 2);\n    }\n    ;\n    /** This method calculates the arc tangent of y/x in radians, using\n    the signs of the two arguments to determine the quadrant of the\n    result. The results may have maximum error of 2 ulps. */\n    static atan2(y, x) {\n        let r = Hploc.atan2k(Math.abs(y), x);\n        r = Hploc.mulsign(r, x);\n        if (Hploc.isinf(x) || x == 0) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI / 2)) : 0);\n        }\n        if (Hploc.isinf(y)) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI * 1 / 4)) : 0);\n        }\n        if (y == 0) {\n            r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);\n        }\n        return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);\n    }\n    ;\n    /** Checks if the argument is a NaN or not. */\n    static isnan(d) {\n        return d != d;\n    }\n    ;\n    /** Checks if the argument is either positive or negative infinity. */\n    static isinf(d) {\n        return Math.abs(d) === +Infinity;\n    }\n    ;\n}\nHploc.PI4_A = 0.7853981554508209228515625;\nHploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\nHploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\nHploc.M_1_PI = 0.3183098861837906715377675267450287;\n//# sourceMappingURL=Hploc.js.map","import { Hploc } from './Hploc.js';\nexport class Pointing {\n    /**\n     *\n     * @param {*} vec3 Vec3.js\n     * @param {*} mirror\n     * @param {*} in_theta radians\n     * @param {*} in_phi radians\n     */\n    constructor(vec3, mirror, in_theta, in_phi) {\n        if (vec3 != null) {\n            this.theta = Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);\n            if (mirror) {\n                this.phi = -Hploc.atan2(vec3.y, vec3.x);\n            }\n            else {\n                this.phi = Hploc.atan2(vec3.y, vec3.x);\n            }\n            if (this.phi < 0.0) {\n                this.phi = this.phi + 2 * Math.PI;\n            }\n            if (this.phi >= 2 * Math.PI) {\n                this.phi = this.phi - 2 * Math.PI;\n            }\n        }\n        else {\n            this.theta = in_theta;\n            this.phi = in_phi;\n        }\n    }\n}\n//# sourceMappingURL=Pointing.js.map","export class RangeSet {\n    /**\n     * @param int cap: initial capacity\n     */\n    constructor(cap) {\n        if (cap < 0)\n            console.error(\"capacity must be positive\");\n        this.r = new Int32Array(cap << 1);\n        this.sz = 0;\n    }\n    ;\n    /** Append a single-value range to the object.\n    @param val value to append */\n    append(val) {\n        this.append1(val, val + 1);\n    }\n    ;\n    /** Append a range to the object.\n   @param a first long in range\n   @param b one-after-last long in range */\n    append1(a, b) {\n        if (a >= b)\n            return;\n        if ((this.sz > 0) && (a <= this.r[this.sz - 1])) {\n            if (a < this.r[this.sz - 2])\n                console.error(\"bad append operation\");\n            if (b > this.r[this.sz - 1])\n                this.r[this.sz - 1] = b;\n            return;\n        }\n        // this.ensureCapacity(this.sz+2);\n        let cap = this.sz + 2;\n        if (this.r.length < cap) {\n            let newsize = Math.max(2 * this.r.length, cap);\n            let rnew = new Int32Array(newsize);\n            rnew.set(this.r);\n            this.r = rnew;\n        }\n        this.r[this.sz] = a;\n        this.r[this.sz + 1] = b;\n        this.sz += 2;\n    }\n    ;\n    /** Make sure the object can hold at least the given number of entries.\n     * @param cap int\n     * */\n    ensureCapacity(cap) {\n        if (this.r.length < cap)\n            this.resize(Math.max(2 * this.r.length, cap));\n    }\n    ;\n    /**\n     * @param newsize int\n     */\n    resize(newsize) {\n        if (newsize < this.sz)\n            console.error(\"requested array size too small\");\n        if (newsize == this.r.length)\n            return;\n        let rnew = new Int32Array(newsize);\n        let sliced = this.r.slice(0, this.sz + 1);\n        //\t\tthis.arrayCopy(this.r, 0, rnew, 0, this.sz);\n        this.r = sliced;\n    }\n    ;\n}\n//# sourceMappingURL=RangeSet.js.map","/**\n * Partial porting to Javascript of Vec3.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nimport { Pointing } from './Pointing.js';\nexport class Vec3 {\n    constructor(in_x, in_y, in_z) {\n        if (in_x instanceof Pointing) {\n            let ptg = in_x;\n            let sth = Hploc.sin(ptg.theta);\n            this.x = sth * Hploc.cos(ptg.phi);\n            this.y = sth * Hploc.sin(ptg.phi);\n            this.z = Hploc.cos(ptg.theta);\n        }\n        else {\n            this.x = in_x;\n            this.y = in_y;\n            this.z = in_z;\n        }\n    }\n    getX() {\n        return this.x;\n    }\n    ;\n    getY() {\n        return this.y;\n    }\n    ;\n    getZ() {\n        return this.z;\n    }\n    ;\n    /** Scale the vector by a given factor\n    @param n the scale factor */\n    scale(n) {\n        this.x *= n;\n        this.y *= n;\n        this.z *= n;\n    }\n    ;\n    /** Vector cross product.\n    @param v another vector\n    @return the vector cross product between this vector and {@code v} */\n    cross(v) {\n        return new Vec3(this.y * v.z - v.y * this.z, this.z * v.x - v.z * this.x, this.x * v.y - v.x * this.y);\n    }\n    ;\n    /** Vector addition\n        * @param v the vector to be added\n        * @return addition result */\n    add(v) {\n        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    ;\n    /** Normalize the vector */\n    normalize() {\n        let d = 1. / this.length();\n        this.x *= d;\n        this.y *= d;\n        this.z *= d;\n    }\n    ;\n    /** Return normalized vector */\n    norm() {\n        let d = 1. / this.length();\n        return new Vec3(this.x * d, this.y * d, this.z * d);\n    }\n    ;\n    /** Vector length\n    @return the length of the vector. */\n    length() {\n        return Math.sqrt(this.lengthSquared());\n    }\n    ;\n    /** Squared vector length\n        @return the squared length of the vector. */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    ;\n    /** Computes the dot product of the this vector and {@code v1}.\n     * @param v1 another vector\n     * @return dot product */\n    dot(v1) {\n        return this.x * v1.x + this.y * v1.y + this.z * v1.z;\n    }\n    ;\n    /** Vector subtraction\n     * @param v the vector to be subtracted\n     * @return subtraction result */\n    sub(v) {\n        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    ;\n    /** Angle between two vectors.\n    @param v1 another vector\n    @return the angle in radians between this vector and {@code v1};\n      constrained to the range [0,PI]. */\n    angle(v1) {\n        return Hploc.atan2(this.cross(v1).length(), this.dot(v1));\n    }\n    /** Invert the signs of all components */\n    flip() {\n        this.x *= -1.0;\n        this.y *= -1.0;\n        this.z *= -1.0;\n    }\n    static pointing2Vec3(pointing) {\n        let sth = Hploc.sin(pointing.theta);\n        let x = sth * Hploc.cos(pointing.phi);\n        let y = sth * Hploc.sin(pointing.phi);\n        let z = Hploc.cos(pointing.theta);\n        return new Vec3(x, y, z);\n    }\n    ;\n}\n//# sourceMappingURL=Vec3.js.map","/**\n * Partial porting to Javascript of Xyf.java from Healpix3.30\n */\nexport class Xyf {\n    constructor(x, y, f) {\n        this.ix = x;\n        this.iy = y;\n        this.face = f;\n    }\n}\n//# sourceMappingURL=Xyf.js.map","export class Zphi {\n    /** Creation from individual components */\n    constructor(z_, phi_) {\n        this.z = z_;\n        this.phi = phi_;\n    }\n    ;\n}\n//# sourceMappingURL=Zphi.js.map","export { Constants } from \"./Constants.js\";\nexport { pstack } from \"./pstack.js\";\nexport { CircleFinder } from './CircleFinder.js';\nexport { Fxyf } from './Fxyf.js';\nexport { Healpix } from './Healpix.js';\nexport { Pointing } from './Pointing.js';\nexport { RangeSet } from './RangeSet.js';\nexport { Vec3 } from './Vec3.js';\nexport { Xyf } from './Xyf.js';\nexport { Zphi } from './Zphi.js';\nexport { Hploc } from './Hploc.js';\n//# sourceMappingURL=index.js.map","export class pstack {\n    /** Creation from individual components */\n    constructor(sz) {\n        this.p = new Array(sz);\n        this.o = new Int32Array(sz);\n        this.s = 0;\n        this.m = 0;\n    }\n    ;\n    /**\n     * @param p long\n     * @param o int\n     */\n    push(p_, o_) {\n        this.p[this.s] = p_;\n        this.o[this.s] = o_;\n        ++this.s;\n    }\n    ;\n    pop() {\n        --this.s;\n    }\n    ;\n    popToMark() {\n        this.s = this.m;\n    }\n    ;\n    size() {\n        return this.s;\n    }\n    ;\n    mark() {\n        this.m = this.s;\n    }\n    ;\n    otop() {\n        return this.o[this.s - 1];\n    }\n    ;\n    ptop() {\n        return this.p[this.s - 1];\n    }\n    ;\n}\n//# sourceMappingURL=pstack.js.map","/**\n\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FITSWriter } from \"./FITSWriter.js\";\nimport { ParsePayload } from \"./ParsePayload.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\n// import fetch from 'cross-fetch';\n// import { readFile } from \"node:fs/promises\";\nexport class FITSParser {\n    constructor(url) {\n        this._url = url;\n    }\n    loadFITS() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getFile(this._url)\n                .then((rawdata) => {\n                if (rawdata !== null && rawdata.byteLength > 0) {\n                    const uint8 = new Uint8Array(rawdata);\n                    const fits = this.processFits(uint8);\n                    return fits;\n                }\n                return null;\n            })\n                .catch((error) => {\n                var _a, _b;\n                if ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) {\n                    throw new Error(\"[FITSParser->loadFITS] \" + error.response.data.message);\n                }\n                throw error;\n            });\n        });\n    }\n    processFits(rawdata) {\n        const header = ParseHeader.parse(rawdata);\n        const payloadParser = new ParsePayload(header, rawdata);\n        const pixelvalues = payloadParser.parse();\n        // if (rawdata.length > (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length))) {\n        // let leftover = rawdata.length - (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length));\n        // \tthrow new Error(\"[FITSParser->processFits] It seems that there's at least one more HDU since there are \" + leftover + \" bytes not processed.\");\n        // \tconsole.warn(\"It seems that there's at least one more HDU since there are \" + leftover + \" bytes not processed.\")\n        // }\n        return {\n            header: header,\n            data: pixelvalues,\n        };\n    }\n    static generateFITS(header, rawdata) {\n        const writer = new FITSWriter();\n        writer.run(header, rawdata);\n        return writer.typedArrayToURL();\n    }\n    getFile(uri) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let data;\n            if (!uri.substring(0, 5).toLowerCase().includes(\"http\")) {\n                let p = yield import('./getLocalFile.js');\n                // data = await p.getLocalFile(uri);\n                return yield p.getLocalFile(uri);\n            }\n            else {\n                let p = yield import('./getFile.js');\n                return p.getFile(uri).then((data) => {\n                    return data;\n                }).catch((err) => {\n                    // console.error(\"Error in FITSParser getFile \", uri, err);\n                    return null;\n                });\n                // data = await p.getFile(uri);\n                // return await p.getFile(uri).catch((err) => {\n                //   console.error(err);\n                // });\n            }\n            // return data;\n        });\n    }\n}\n//# sourceMappingURL=FITSParser.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/fitsontheweb\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n * import GnomonicProjection from './GnomonicProjection';\n * BITPIX definition from https://archive.stsci.edu/fits/fits_standard/node39.html\n * and \"Definition of the Flexible Image Transport System (FITS)\" standard document\n * defined by FITS Working Group from the International Astronomical Union\n * http://fits.gsfc.nasa.gov/iaufwg/\n * 8\t8-bit Character or unsigned binary integer\n * 16\t16-bit twos-complement binary integer\n * 32\t32-bit twos-complement binary integer\n * -32\t32-bit IEEE single precision floating point\n * -64\t64-bit IEEE double precision floating point\n *\n */\nimport { Blob } from 'blob-polyfill';\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\n// import fs from 'node:fs/promises';\nexport class FITSWriter {\n    constructor() {\n        this._headerArray = new Uint8Array();\n        this._payloadArray = new Array();\n        this._fitsData = new Uint8Array();\n    }\n    run(header, rawdata) {\n        this.prepareHeader(header);\n        this._payloadArray = rawdata;\n        this.prepareFITS();\n    }\n    prepareHeader(headerDetails) {\n        const item = new FITSHeaderItem(\"END\");\n        headerDetails.addItem(item);\n        let str = \"\";\n        for (let i = 0; i < headerDetails.getItemList().length; i++) {\n            const item = headerDetails.getItemList()[i];\n            let s = this.formatHeaderLine(item);\n            if (s !== undefined) {\n                str += s;\n            }\n        }\n        const strBytelen = new TextEncoder().encode(str).length;\n        const nhdu = Math.ceil(strBytelen / 2880);\n        const offset = nhdu * 2880;\n        for (let j = 0; j < offset - strBytelen; j++) {\n            str += \" \";\n        }\n        const ab = new ArrayBuffer(str.length);\n        // Javascript character occupies 2 16-bit -> reducing it to 1 byte\n        this._headerArray = new Uint8Array(ab);\n        for (let i = 0; i < str.length; i++) {\n            this._headerArray[i] = ParseUtils.getByteAt(str, i);\n        }\n    }\n    // formatHeaderLine(item: string | undefined, value: string | number, comment: string) {\n    formatHeaderLine(item) {\n        let str;\n        let keyword = item.key;\n        let value = item.value;\n        let comment = item.comment;\n        if (keyword !== null && keyword !== undefined) {\n            str = keyword;\n            if (keyword == \"END\") {\n                for (let j = 80; j > keyword.length; j--) {\n                    str += \" \";\n                }\n                return str;\n            }\n            if (keyword == \"COMMENT\" || keyword == \"HISTORY\") {\n                for (let i = 0; i < 10 - keyword.length; i++) {\n                    str += \" \";\n                }\n                str += value;\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n                return str;\n            }\n            for (let i = 0; i < 8 - keyword.length; i++) {\n                str += \" \";\n            }\n            str += \"= \";\n            if (value !== null && value !== undefined) {\n                // value\n                str += value;\n                if (comment !== null && comment !== undefined) {\n                    str += comment;\n                }\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n            else {\n                if (comment !== null && comment !== undefined) {\n                    str += comment;\n                }\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n        }\n        else {\n            // keyword null\n            str = \"\";\n            for (let j = 0; j < 18; j++) {\n                str += \" \";\n            }\n            if (comment !== null && comment !== undefined) {\n                str += comment;\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n            else {\n                str = \"\";\n                for (let j = 80; j > 0; j--) {\n                    str += \" \";\n                }\n            }\n        }\n        return str;\n    }\n    prepareFITS() {\n        const bytes = new Uint8Array(this._headerArray.length +\n            this._payloadArray[0].length * this._payloadArray.length);\n        bytes.set(this._headerArray, 0);\n        for (let i = 0; i < this._payloadArray.length; i++) {\n            const uint8 = this._payloadArray[i];\n            bytes.set(uint8, this._headerArray.length + i * uint8.length);\n        }\n        this._fitsData = bytes;\n    }\n    // writeFITS(fileuri: string) {\n    //   // const dirname = path.dirname(fileuri);\n    //   // fs.mkdir(dirname, { recursive: true });\n    //   fs.writeFile(fileuri, this._fitsData);\n    //   // if (fs.existsSync(dirname)) {\n    //   //   fs.writeFileSync(fileuri, this._fitsData);\n    //   // } else {\n    //   //   console.error(dirname + \" doesn't exist\");\n    //   // }\n    // }\n    typedArrayToURL() {\n        const b = new Blob([this._fitsData], { type: \"application/fits\" });\n        // console.log(`<html><body><img src='${URL.createObjectURL(b)}'</body></html>`);\n        return URL.createObjectURL(b);\n    }\n}\n//# sourceMappingURL=FITSWriter.js.map","import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseHeader {\n    static parse(rawdata) {\n        // only one header block (2880) allowed atm.\n        // TODO handle multiple header blocks\n        // let headerByteData = new Uint8Array(rawdata, 0, 2880);\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const header = new FITSHeader();\n        let nline = 0;\n        let key = \"\";\n        let val;\n        let u8line;\n        let u8key;\n        let u8val;\n        let u8ind;\n        // let ind: string;\n        let item;\n        let fitsLine;\n        item = null;\n        while (key !== \"END\" && rawdata.length > 0) {\n            // line 80 characters\n            u8line = new Uint8Array(rawdata.slice(nline * 80, nline * 80 + 80));\n            nline++;\n            // key\n            u8key = new Uint8Array(u8line.slice(0, 8));\n            key = textDecoder.decode(u8key).trim();\n            // value indicator\n            u8ind = new Uint8Array(u8line.slice(8, 10));\n            // ind = textDecoder.decode(u8ind);\n            // reading value\n            u8val = new Uint8Array(u8line.slice(10, 80));\n            val = textDecoder.decode(u8val).trim();\n            // ascii 61 -> =\n            // ascii 32 -> [space]\n            if (u8ind[0] == 61 && u8ind[1] == 32) {\n                let firstchar = 32;\n                for (let i = 0; i < u8val.length; i++) {\n                    if (u8val[i] != 32) {\n                        firstchar = u8val[i];\n                        break;\n                    }\n                }\n                // ascii 39 -> '\n                if (firstchar == 39 || !Number(val)) {\n                    // [ival, icomment]\n                    // fitsLine = ParseHeader.parseStringValue(u8val);\n                    fitsLine = ParseHeader.parseLogicalValue(u8val);\n                }\n                else {\n                    // ascii 84 -> T\n                    // ascii 70 -> F\n                    if (firstchar == 84 || firstchar == 70) {\n                        // T or F\n                        fitsLine = ParseHeader.parseLogicalValue(u8val);\n                    }\n                    else {\n                        val = textDecoder.decode(u8val).trim();\n                        if (val.includes(\".\")) {\n                            fitsLine = ParseHeader.parseFloatValue(u8val);\n                        }\n                        else {\n                            fitsLine = ParseHeader.parseIntValue(u8val);\n                        }\n                    }\n                }\n                item = new FITSHeaderItem(key, fitsLine.val, fitsLine.comment);\n            }\n            else {\n                if (key == \"COMMENT\" || key == \"HISTORY\") {\n                    item = new FITSHeaderItem(key, undefined, val);\n                }\n                else {\n                    let firstchar = 32;\n                    for (let i = 0; i < u8val.length; i++) {\n                        if (u8val[i] != 32) {\n                            firstchar = u8val[i];\n                            break;\n                        }\n                    }\n                    if (firstchar == 47) {\n                        // single / this is the case when no key nor value indicator is defined\n                        item = new FITSHeaderItem(undefined, undefined, val);\n                    }\n                    else if (firstchar == 32) {\n                        // case when there's a line with only spaces\n                        item = new FITSHeaderItem(undefined, undefined, undefined);\n                    }\n                }\n            }\n            if (item != null) {\n                header.addItem(item);\n            }\n        }\n        item = new FITSHeaderItem(\"COMMENT\", \"FITS generated with FITSParser on \", undefined);\n        header.addItem(item);\n        const now = new Date();\n        item = new FITSHeaderItem(\"COMMENT\", now.toString());\n        header.addItem(item);\n        const nblock = Math.ceil(nline / 36);\n        const offset = nblock * 2880;\n        header.offset = offset;\n        return header;\n    }\n    static parseStringValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const decoded = textDecoder.decode(u8buffer).trim();\n        const idx = decoded.lastIndexOf(\"/\");\n        const val = decoded.substring(0, idx);\n        let comment = decoded.substring(idx);\n        // if (comment === undefined) {\n        //   comment = null;\n        // }\n        return {\n            val: val,\n            comment: comment,\n        };\n    }\n    static parseLogicalValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: tokens[0].trim(),\n                comment: undefined,\n            };\n        }\n        return {\n            val: tokens[0].trim(),\n            comment: \" /\" + tokens[1],\n        };\n    }\n    static parseIntValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: parseInt(tokens[0].trim()),\n                comment: undefined,\n            };\n        }\n        return {\n            val: parseInt(tokens[0].trim()),\n            comment: \" /\" + tokens[1],\n        };\n    }\n    static parseFloatValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: parseFloat(tokens[0].trim()),\n                comment: undefined,\n            };\n        }\n        return {\n            val: parseFloat(tokens[0].trim()),\n            comment: \" /\" + tokens[1],\n        };\n    }\n}\n//# sourceMappingURL=ParseHeader.js.map","// \"use strict\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\n// let colorsMap = new Map();\n// colorsMap.set(\"grayscale\",\"grayscale\");\n// colorsMap.set(\"planck\",\"planck\");\n// colorsMap.set(\"eosb\",\"eosb\");\n// colorsMap.set(\"rainbow\",\"rainbow\");\n// colorsMap.set(\"cmb\",\"cmb\");\n// colorsMap.set(\"cubehelix\",\"cubehelix\");\nexport class ParsePayload {\n    constructor(fitsheader, rawdata) {\n        this._u8data = new Uint8Array();\n        this._BZERO = undefined;\n        this._BSCALE = undefined;\n        this._BLANK = undefined;\n        this._BITPIX = undefined;\n        this._NAXIS1 = undefined;\n        this._NAXIS2 = undefined;\n        this._DATAMIN = undefined;\n        this._DATAMAX = undefined;\n        this._physicalblank = undefined;\n        const buffer = rawdata.slice(fitsheader.offset);\n        this._u8data = new Uint8Array(buffer);\n        this.init(fitsheader);\n    }\n    init(fitsheader) {\n        this._BZERO = fitsheader.get(\"BZERO\");\n        if (this._BZERO === undefined) {\n            this._BZERO = 0;\n        }\n        this._BSCALE = fitsheader.get(\"BSCALE\");\n        if (this._BSCALE === undefined) {\n            this._BSCALE = 1;\n        }\n        this._BLANK = fitsheader.get(\"BLANK\"); // undefined in case it's not present in the header\n        // this._BLANK_pv = this._BZERO + this._BSCALE * this._BLANK || undefined;\n        this._BITPIX = fitsheader.get(\"BITPIX\");\n        this._NAXIS1 = fitsheader.get(\"NAXIS1\");\n        this._NAXIS2 = fitsheader.get(\"NAXIS2\");\n        this._DATAMIN = fitsheader.get(\"DATAMIN\");\n        this._DATAMAX = fitsheader.get(\"DATAMAX\");\n        this._physicalblank = undefined;\n        if (this._DATAMAX === undefined || this._DATAMIN === undefined) {\n            const [min, max] = this.computePhysicalMinAndMax();\n            this._DATAMAX = max;\n            this._DATAMIN = min;\n            const maxitem = new FITSHeaderItem(\"DATAMAX\", max, \" / computed with FITSParser\");\n            const minitem = new FITSHeaderItem(\"DATAMIN\", min, \" / computed with FITSParser\");\n            fitsheader.addItem(maxitem);\n            fitsheader.addItem(minitem);\n            // fitsheader.set(\"DATAMAX\", max);\n            // fitsheader.set(\"DATAMIN\", min);\n        }\n        // let item = new FITSHeaderItem(\"END\", null, null);\n        // fitsheader.addItem(item);\n    }\n    computePhysicalMinAndMax() {\n        let i = 0;\n        if (this._BITPIX === undefined) {\n            throw new Error(\"BITPIX is not defined\");\n        }\n        const bytesXelem = Math.abs(this._BITPIX / 8);\n        const pxLength = this._u8data.byteLength / bytesXelem;\n        let px_val, ph_val;\n        let min = undefined;\n        let max = undefined;\n        if (this._BLANK !== undefined) {\n            this._physicalblank = this.pixel2physicalValue(this._BLANK);\n        }\n        while (i < pxLength) {\n            // px_val = this.extractPixelValue(bytesXelem*i);\n            px_val = this.extractPixelValue(bytesXelem * i);\n            if (px_val === undefined) {\n                i++;\n                continue;\n            }\n            ph_val = this.pixel2physicalValue(px_val);\n            if (min === undefined) {\n                min = ph_val;\n            }\n            if (max === undefined) {\n                max = ph_val;\n            }\n            //TODO check below if\n            if (this._physicalblank === undefined || this._physicalblank !== ph_val) {\n                if (ph_val !== undefined && (ph_val < min || min === undefined)) {\n                    min = ph_val;\n                }\n                if (ph_val !== undefined && (ph_val > max || max === undefined)) {\n                    max = ph_val;\n                }\n            }\n            i++;\n        }\n        return [min, max];\n    }\n    parse() {\n        // let px_val; // pixel array value\n        // let ph_val = undefined; // pixel physical value\n        if (this._BITPIX === undefined) {\n            throw new Error(\"BITPIX is undefined\");\n        }\n        if (this._NAXIS1 === undefined) {\n            throw new Error(\"NAXIS1 is undefined\");\n        }\n        if (this._NAXIS2 === undefined) {\n            throw new Error(\"NAXIS2 is undefined\");\n        }\n        const bytesXelem = Math.abs(this._BITPIX / 8);\n        let pxLength = this._u8data.byteLength / bytesXelem;\n        pxLength = this._NAXIS1 * this._NAXIS2;\n        let k = 0;\n        let c, r;\n        const pixelvalues = [];\n        //  let pixv, pv;\n        while (k < pxLength) {\n            r = Math.floor(k / this._NAXIS1); // row\n            c = (k - r * this._NAXIS1) * bytesXelem; // col\n            if (c === 0) {\n                pixelvalues[r] = new Uint8Array(this._NAXIS1 * bytesXelem);\n            }\n            // px_val = this.extractPixelValue(bytesXelem * k);\n            // ph_val = this.pixel2physicalValue(px_val);\n            // TODO check if ph_val == blank\n            // if not then use ph_val to compute datamin and datamax\n            for (let i = 0; i < bytesXelem; i++) {\n                pixelvalues[r][c + i] = this._u8data[k * bytesXelem + i];\n            }\n            // if (k == 232) {\n            // \tpixv = this.extractPixelValue(k * bytesXelem);\n            // \tpv = this._BZERO + this._BSCALE * pixv;\n            // }\n            k++;\n        }\n        return pixelvalues;\n    }\n    /** this can be deleted */\n    extractPixelValue(offset) {\n        let px_val = undefined; // pixel value\n        if (this._BITPIX == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(this._u8data[offset], this._u8data[offset + 1]);\n        }\n        else if (this._BITPIX == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(this._u8data[offset], this._u8data[offset + 1], this._u8data[offset + 2], this._u8data[offset + 3]);\n        }\n        else if (this._BITPIX == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 4), 8, 23);\n        }\n        else if (this._BITPIX == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (this._BITPIX == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n    pixel2physicalValue(pxval) {\n        if (this._BZERO === undefined || this._BSCALE === undefined) {\n            throw new Error(\"Either BZERO or BSCALE is undefined\");\n        }\n        return this._BZERO + this._BSCALE * pxval;\n    }\n}\n//# sourceMappingURL=ParsePayload.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseUtils {\n    static getStringAt(data, offset, length) {\n        const chars = [];\n        for (let i = offset, j = 0; i < offset + length; i++, j++) {\n            chars[j] = String.fromCharCode(data.charCodeAt(i) & 0xff);\n        }\n        return chars.join(\"\");\n    }\n    static byteString(n) {\n        if (n < 0 || n > 255 || n % 1 !== 0) {\n            throw new Error(n + \" does not fit in a byte\");\n        }\n        return (\"000000000\" + n.toString(2)).substr(-8);\n    }\n    static parse32bitSinglePrecisionFloatingPoint(byte1, byte2, byte3, byte4) {\n        let long = (((((byte1 << 8) + byte2) << 8) + byte3) << 8) + byte4;\n        if (long < 0)\n            long += 4294967296;\n        const float = (1.0 + (long & 0x007fffff) / 0x0800000) *\n            Math.pow(2, ((long & 0x7f800000) >> 23) - 127);\n        return float;\n    }\n    static convertBlankToBytes(blank, nbytes) {\n        let str = Math.abs(blank).toString(2);\n        while (str.length / 8 < nbytes) {\n            str += \"0\";\n        }\n        const buffer = new ArrayBuffer(nbytes);\n        const uint8 = new Uint8Array(buffer);\n        for (let i = 0; i < nbytes; i++) {\n            uint8[i] = parseInt(str.substr(8 * i, 8 * (i + 1)), 2);\n        }\n        return uint8;\n    }\n    /** https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac */\n    static parseFloatingPointFormat(bytes, ebits, fbits) {\n        // Bytes to bits\n        const bits = [];\n        for (let i = bytes.length; i; i -= 1) {\n            let byte = bytes[i - 1];\n            for (let j = 8; j; j -= 1) {\n                bits.push(byte % 2 ? 1 : 0);\n                byte = byte >> 1;\n            }\n        }\n        bits.reverse();\n        const str = bits.join(\"\");\n        // Unpack sign, exponent, fraction\n        const bias = (1 << (ebits - 1)) - 1;\n        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n        const e = parseInt(str.substring(1, 1 + ebits), 2);\n        const f = parseInt(str.substring(1 + ebits), 2);\n        // Produce number\n        if (e === (1 << ebits) - 1) {\n            return f !== 0 ? undefined : s * Infinity;\n        }\n        else if (e > 0) {\n            return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));\n        }\n        else if (f !== 0) {\n            return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));\n        }\n        else {\n            return s * 0;\n        }\n    }\n    static generate16bit2sComplement(val) {\n        throw new TypeError(\"not implemented yet\" + val);\n    }\n    static parse16bit2sComplement(byte1, byte2) {\n        const unsigned = (byte1 << 8) | byte2;\n        if (unsigned & 0x8000) {\n            return unsigned | 0xffff0000;\n        }\n        else {\n            return unsigned;\n        }\n    }\n    static parse32bit2sComplement(byte1, byte2, byte3, byte4) {\n        const unsigned = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;\n        const s = (unsigned & 0x80000000) >> 31;\n        let res = unsigned & 0xffffffff;\n        if (s) {\n            res = (~unsigned & 0xffffffff) + 1;\n            return -1 * res;\n        }\n        return res;\n    }\n    /**\n     *\n     * @param {*} data string?\n     * @param {*} offset offset in the data\n     * @returns returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index.\n     */\n    static getByteAt(data, offset) {\n        const dataOffset = 0;\n        return data.charCodeAt(offset + dataOffset) & 0xff;\n    }\n    static extractPixelValue(offset, bytes, bitpix) {\n        let px_val = undefined; // pixel value\n        // let px_val1, px_val2, px_val3, px_val4;\n        if (bitpix == 8) {\n            px_val = bytes[0];\n        }\n        else if (bitpix == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(bytes[offset], bytes[offset + 1]);\n        }\n        else if (bitpix == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]);\n        }\n        else if (bitpix == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 8, 23);\n        }\n        else if (bitpix == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (bitpix == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n// export default ParseUtils;\n//# sourceMappingURL=ParseUtils.js.map","export { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nexport { FITSHeader } from \"./model/FITSHeader.js\";\nexport { FITSParser } from \"./FITSParser.js\";\nexport { FITSWriter } from \"./FITSWriter.js\";\nexport { ParseHeader } from \"./ParseHeader.js\";\nexport { ParsePayload } from \"./ParsePayload.js\";\nexport { ParseUtils } from \"./ParseUtils.js\";\n//# sourceMappingURL=index.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n// reference FTIS standard doc https://heasarc.gsfc.nasa.gov/docs/fcg/standard_dict.html\nexport class FITSHeader extends Map {\n    constructor() {\n        super();\n        this._offset = undefined;\n        this._items = [];\n    }\n    set offset(offset) {\n        this._offset = offset;\n    }\n    get offset() {\n        return this._offset;\n    }\n    getItemList() {\n        return this._items;\n    }\n    getItemListOf(key) {\n        const res = [];\n        for (let i = 0; i < this._items.length; i++) {\n            const item = this._items[i];\n            if (item.key == key) {\n                res.push(item);\n            }\n        }\n        return res;\n    }\n    addItemAtTheBeginning(item) {\n        if (item.key !== undefined) {\n            if ([\n                \"SIMPLE\",\n                \"BITPIX\",\n                \"NAXIS\",\n                \"NAXIS1\",\n                \"NAXIS2\",\n                \"BLANK\",\n                \"BZERO\",\n                \"BSCALE\",\n                \"DATAMIN\",\n                \"DATAMAX\",\n                \"NPIX\",\n                \"ORDER\",\n                \"CRPIX1\",\n                \"CRPIX2\",\n                \"CDELT1\",\n                \"CDELT2\",\n                \"CRVAL1\",\n                \"CRVAL2\",\n            ].includes(item.key)) {\n                this.set(item.key, item.value);\n            }\n        }\n        const newitemlist = [item].concat(this._items);\n        this._items = newitemlist;\n    }\n    addItem(item) {\n        if (item.key !== undefined) {\n            if ([\n                \"SIMPLE\",\n                \"BITPIX\",\n                \"NAXIS\",\n                \"NAXIS1\",\n                \"NAXIS2\",\n                \"BLANK\",\n                \"BZERO\",\n                \"BSCALE\",\n                \"DATAMIN\",\n                \"DATAMAX\",\n                \"NPIX\",\n                \"ORDER\",\n                \"CRPIX1\",\n                \"CRPIX2\",\n                \"CDELT1\",\n                \"CDELT2\",\n                \"CRVAL1\",\n                \"CRVAL2\",\n            ].includes(item.key)) {\n                this.set(item.key, item.value);\n            }\n        }\n        this._items.push(item);\n    }\n    getNumRows() {\n        return this._items.length;\n    }\n}\n//# sourceMappingURL=FITSHeader.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class FITSHeaderItem {\n    constructor(key, value, comment) {\n        this._key = key !== undefined ? key : undefined;\n        this._value = value !== undefined ? value : undefined;\n        this._comment = comment !== undefined ? comment : undefined;\n    }\n    get key() {\n        return this._key;\n    }\n    get comment() {\n        return this._comment;\n    }\n    get value() {\n        return this._value;\n    }\n}\n//# sourceMappingURL=FITSHeaderItem.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"wcslight:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"wcslight.min\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkwcslight\"] = self[\"webpackChunkwcslight\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","\nexport {WCSLight} from './WCSLight.js'\n\nexport {AstroCoords} from './model/AstroCoords.js'\nexport {CartesianCoords} from './model/CartesianCoords.js'\nexport {CoordsType} from './model/CoordsType.js'\nexport {CutoutResult} from './model/CutoutResult.js'\nexport {EquatorialCoords} from './model/EquatorialCoords.js'\nexport {GalacticCoords} from './model/GalacticCoords.js'\nexport {HEALPixXYSpace} from './model/HEALPixXYSpace.js'\nexport {HMSCoords} from './model/HMSCoords.js'\nexport {ICoordsFormat} from './model/ICoordsFormat.js'\nexport {ImagePixel} from './model/ImagePixel.js'\nexport {NumberType} from './model/NumberType.js'\nexport {Point} from './model/Point.js'\nexport {SexagesimalCoords} from './model/SexagesimalCoords.js'\nexport {SphericalCoords} from './model/SphericalCoords.js'\nexport { \n    sphericalToCartesian, \n    cartesianToSpherical, \n    sphericalToAstro, \n    fillSpherical,\n    astroToSpherical, \n    degToRad, \n    fillAstro, \n    radToDeg } from './model/Utils.js'\nexport {AbstractProjection} from './projections/AbstractProjection.js'\nexport {GnomonicProjection} from './projections/GnomonicProjection.js'\nexport {HEALPixProjection} from './projections/HEALPixProjection.js'\nexport {HiPSHelper} from './projections/HiPSHelper.js'\nexport {HiPSProjection} from './projections/HiPSProjection.js'\nexport {MercatorProjection} from './projections/MercatorProjection.js'\nexport {TestProj} from './projections/TestProj.js'"],"names":[],"sourceRoot":""}