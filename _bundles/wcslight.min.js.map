{"version":3,"file":"wcslight.min.js","mappings":"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","sources":["webpack://wcslight/webpack/universalModuleDefinition","webpack://wcslight/webpack/runtime/load script","webpack://wcslight/webpack/bootstrap","webpack://wcslight/webpack/runtime/define property getters","webpack://wcslight/webpack/runtime/ensure chunk","webpack://wcslight/webpack/runtime/get javascript chunk filename","webpack://wcslight/webpack/runtime/global","webpack://wcslight/webpack/runtime/hasOwnProperty shorthand","webpack://wcslight/webpack/runtime/make namespace object","webpack://wcslight/webpack/runtime/publicPath","webpack://wcslight/webpack/runtime/jsonp chunk loading","webpack://wcslight/../FITSParser/lib-esm/model/FITSHeaderItem.js","webpack://wcslight/../FITSParser/lib-esm/model/FITSHeaderManager.js","webpack://wcslight/../FITSParser/lib-esm/FITSWriter.js","webpack://wcslight/../FITSParser/lib-esm/ParseHeader.js","webpack://wcslight/../FITSParser/lib-esm/ParseUtils.js","webpack://wcslight/../FITSParser/lib-esm/ParsePayload.js","webpack://wcslight/../FITSParser/lib-esm/FITSParser.js","webpack://wcslight/./src/model/NumberType.ts","webpack://wcslight/./src/model/CoordsType.ts","webpack://wcslight/./src/model/FITS.ts","webpack://wcslight/./src/projections/AbstractProjection.ts","webpack://wcslight/./src/model/ImagePixel.ts","webpack://wcslight/./src/model/Utils.ts","webpack://wcslight/./src/model/Point.ts","webpack://wcslight/./src/projections/MercatorProjection.ts","webpack://wcslight/./node_modules/healpixjs/lib-esm/Constants.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Zphi.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Hploc.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Pointing.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Vec3.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/CircleFinder.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Fxyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/pstack.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/RangeSet.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Xyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Healpix.js","webpack://wcslight/./src/projections/HiPSHelper.ts","webpack://wcslight/./src/projections/HiPSProjection.ts","webpack://wcslight/./src/projections/HEALPixProjection.ts","webpack://wcslight/./src/projections/GnomonicProjection.ts","webpack://wcslight/./src/WCSLight.ts","webpack://wcslight/./src/projections/TestProj.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"wcslight\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wcslight\"] = factory();\n\telse\n\t\troot[\"wcslight\"] = factory();\n})(self, () => {\nreturn ","var inProgress = {};\nvar dataWebpackPrefix = \"wcslight:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t434: 0,\n\t992: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkwcslight\"] = self[\"webpackChunkwcslight\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class FITSHeaderItem {\n    constructor(key, value, comment) {\n        this._key = \"\";\n        this._value = \"\";\n        this._comment = \"\";\n        this._key = key;\n        this._value = value;\n        this._comment = comment;\n    }\n    get key() {\n        return this._key;\n    }\n    get comment() {\n        return this._comment;\n    }\n    get value() {\n        return this._value;\n    }\n}\n","export class FITSHeaderManager {\n    constructor() {\n        this.items = [];\n    }\n    insert(item, position) {\n        if (item.key === \"SIMPLE\") {\n            this.items.splice(0, 0, item);\n        }\n        else if (item.key === \"BITPIX\") {\n            this.items.splice(1, 0, item);\n        }\n        else if (item.key === \"NAXIS\") {\n            this.items.splice(2, 0, item);\n        }\n        else if (item.key === \"NAXIS1\") {\n            this.items.splice(3, 0, item);\n        }\n        else if (item.key === \"NAXIS2\") {\n            this.items.splice(4, 0, item);\n        }\n        if (position !== undefined && position >= 0 && position <= this.items.length) {\n            this.items.splice(position, 0, item);\n        }\n        else {\n            this.items.push(item);\n        }\n    }\n    getItems() {\n        return this.items;\n    }\n    remove(key) {\n        this.items = this.items.filter(item => item.key !== key);\n    }\n    findById(key) {\n        const item = this.items.find(item => item.key === key);\n        if (!item) {\n            return null;\n        }\n        return item;\n    }\n}\n","// import { FITSHeader } from \"./model/FITSHeader.js\"\nimport * as fs from 'fs';\nexport class FITSWriter {\n    static createFITS(fitsParsed) {\n        const headerBytes = this.createHeader(fitsParsed.header);\n        const dataBytes = this.createData(fitsParsed.data);\n        // Concatenate header and data to form a complete FITS file\n        const fitsFile = new Uint8Array(headerBytes.length + dataBytes.length);\n        fitsFile.set(headerBytes, 0);\n        fitsFile.set(dataBytes, headerBytes.length);\n        return fitsFile;\n    }\n    static createHeader(header) {\n        let headerString = \"\";\n        // Convert header items to FITS 80-character records\n        for (const item of header.getItems()) {\n            const key = item.key ? item.key.padEnd(8, \" \") : \"        \";\n            const value = item.value !== undefined ? `= ${item.value}` : \"\";\n            const comment = item.comment ? ` / ${item.comment}` : \"\";\n            let record = `${key}${value}${comment}`.padEnd(80, \" \");\n            headerString += record;\n        }\n        // End header with \"END\" record and pad to 2880-byte multiple\n        headerString += \"END\".padEnd(80, \" \");\n        while (headerString.length % 2880 !== 0) {\n            headerString += \" \";\n        }\n        return new TextEncoder().encode(headerString);\n    }\n    static createData(data) {\n        // Concatenate all data rows into a single Uint8Array\n        let totalLength = data.reduce((sum, row) => sum + row.length, 0);\n        let dataBytes = new Uint8Array(totalLength);\n        let offset = 0;\n        for (let row of data) {\n            dataBytes.set(row, offset);\n            offset += row.length;\n        }\n        // Ensure data section is a multiple of 2880 bytes\n        let paddingSize = (2880 - (dataBytes.length % 2880)) % 2880;\n        if (paddingSize > 0) {\n            let paddedData = new Uint8Array(dataBytes.length + paddingSize);\n            paddedData.set(dataBytes);\n            return paddedData;\n        }\n        return dataBytes;\n    }\n    static typedArrayToURL(fitsParsed) {\n        const fitsFile = this.createFITS(fitsParsed);\n        const blob = new Blob([fitsFile], { type: \"application/fits\" });\n        // console.log(`<html><body><img src='${URL.createObjectURL(b)}'</body></html>`);\n        const url = URL.createObjectURL(blob);\n        console.log(`Generated FITS file URL: ${url}`);\n        const revokeTimeout_sec = 10;\n        setTimeout(() => url, revokeTimeout_sec * 1000);\n        console.log(`Generated FITS will be available for ${revokeTimeout_sec} seconds: ${url}`);\n        return url;\n    }\n    static writeFITSFile(fitsParsed, filePath) {\n        const fitsFile = this.createFITS(fitsParsed);\n        try {\n            fs.writeFileSync(filePath, fitsFile);\n            console.log(`FITS file written successfully to: ${filePath}`);\n        }\n        catch (error) {\n            console.error(`Error writing FITS file: ${error}`);\n        }\n    }\n}\n// const fitsParsed: FITSParsed = {\n//   header: new FITSHeader(),\n//   data: [new Uint8Array([1, 2, 3]), new Uint8Array([4, 5, 6])]\n// };\n// // Specify the file path\n// const filePath = \"/Users/fabriziogiordano/Desktop/PhD/code/new/FITSParser/output.fits\";\n// // Write the FITS file to the filesystem\n// FITSWriter.writeFITSFile(fitsParsed, filePath);\n","// import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { FITSHeaderManager } from \"./model/FITSHeaderManager.js\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseHeader {\n    static checkFITSItem(header, key) {\n        const item = header.findById(key);\n        let VALUE = null;\n        if (item) {\n            VALUE = Number(item.value);\n        }\n        return VALUE;\n    }\n    static parse(rawdata) {\n        // only one header block (2880) allowed atm.\n        // TODO handle multiple header blocks\n        // let headerByteData = new Uint8Array(rawdata, 0, 2880);\n        const textDecoder = new TextDecoder('ascii');\n        const headerSize = 2880; // FITS headers are in 2880-byte blocks\n        const headerText = textDecoder.decode(rawdata.slice(0, headerSize));\n        const header = new FITSHeaderManager();\n        const lines = headerText.match(/.{1,80}/g) || [];\n        for (const line of lines) {\n            const key = line.slice(0, 8).trim();\n            let value;\n            let comment = \"\";\n            if (key && key !== 'END') {\n                const rawValue = line.slice(10).trim().split('/')[0].trim();\n                if (isNaN(Number(rawValue))) {\n                    value = rawValue;\n                }\n                else {\n                    value = Number(rawValue);\n                }\n                if (line.includes('/')) {\n                    comment = line.slice(10).trim().split('/')[1].trim();\n                }\n                const item = new FITSHeaderItem(key, value, comment);\n                header.insert(item);\n            }\n        }\n        return header;\n    }\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseUtils {\n    static getStringAt(data, offset, length) {\n        const chars = [];\n        for (let i = offset, j = 0; i < offset + length; i++, j++) {\n            chars[j] = String.fromCharCode(data.charCodeAt(i) & 0xff);\n        }\n        return chars.join(\"\");\n    }\n    static byteString(n) {\n        if (n < 0 || n > 255 || n % 1 !== 0) {\n            throw new Error(n + \" does not fit in a byte\");\n        }\n        return (\"000000000\" + n.toString(2)).substr(-8);\n    }\n    static parse32bitSinglePrecisionFloatingPoint(byte1, byte2, byte3, byte4) {\n        let long = (((((byte1 << 8) + byte2) << 8) + byte3) << 8) + byte4;\n        if (long < 0)\n            long += 4294967296;\n        const float = (1.0 + (long & 0x007fffff) / 0x0800000) *\n            Math.pow(2, ((long & 0x7f800000) >> 23) - 127);\n        return float;\n    }\n    static convertBlankToBytes(blank, nbytes) {\n        let str = Math.abs(blank).toString(2);\n        while (str.length / 8 < nbytes) {\n            str += \"0\";\n        }\n        const buffer = new ArrayBuffer(nbytes);\n        const uint8 = new Uint8Array(buffer);\n        for (let i = 0; i < nbytes; i++) {\n            uint8[i] = parseInt(str.substr(8 * i, 8 * (i + 1)), 2);\n        }\n        return uint8;\n    }\n    /** https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac */\n    static parseFloatingPointFormat(bytes, ebits, fbits) {\n        // Bytes to bits\n        const bits = [];\n        for (let i = bytes.length; i; i -= 1) {\n            let byte = bytes[i - 1];\n            for (let j = 8; j; j -= 1) {\n                bits.push(byte % 2 ? 1 : 0);\n                byte = byte >> 1;\n            }\n        }\n        bits.reverse();\n        const str = bits.join(\"\");\n        // Unpack sign, exponent, fraction\n        const bias = (1 << (ebits - 1)) - 1;\n        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n        const e = parseInt(str.substring(1, 1 + ebits), 2);\n        const f = parseInt(str.substring(1 + ebits), 2);\n        // Produce number\n        if (e === (1 << ebits) - 1) {\n            return f !== 0 ? null : s * Infinity;\n        }\n        else if (e > 0) {\n            return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));\n        }\n        else if (f !== 0) {\n            return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));\n        }\n        else {\n            return s * 0;\n        }\n    }\n    static generate16bit2sComplement(val) {\n        throw new TypeError(\"not implemented yet\" + val);\n    }\n    static parse16bit2sComplement(byte1, byte2) {\n        const unsigned = (byte1 << 8) | byte2;\n        if (unsigned & 0x8000) {\n            return unsigned | 0xffff0000;\n        }\n        else {\n            return unsigned;\n        }\n    }\n    static parse32bit2sComplement(byte1, byte2, byte3, byte4) {\n        const unsigned = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;\n        const s = (unsigned & 0x80000000) >> 31;\n        let res = unsigned & 0xffffffff;\n        if (s) {\n            res = (~unsigned & 0xffffffff) + 1;\n            return -1 * res;\n        }\n        return res;\n    }\n    /**\n     *\n     * @param {*} data string?\n     * @param {*} offset offset in the data\n     * @returns returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index.\n     */\n    static getByteAt(data, offset) {\n        const dataOffset = 0;\n        return data.charCodeAt(offset + dataOffset) & 0xff;\n    }\n    static extractPixelValue(offset, bytes, bitpix) {\n        let px_val = null; // pixel value\n        // let px_val1, px_val2, px_val3, px_val4;\n        if (bitpix == 8) {\n            px_val = bytes[0];\n        }\n        else if (bitpix == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(bytes[offset], bytes[offset + 1]);\n        }\n        else if (bitpix == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]);\n        }\n        else if (bitpix == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 8, 23);\n        }\n        else if (bitpix == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (bitpix == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n// export default ParseUtils;\n","// \"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n// import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\nexport class ParsePayload {\n    static computePhysicalMinAndMax(header, rawData) {\n        const BITPIX = ParseHeader.checkFITSItem(header, \"BITPIX\");\n        if (BITPIX === null) {\n            return null;\n        }\n        const NAXIS1 = ParseHeader.checkFITSItem(header, \"NAXIS1\");\n        if (NAXIS1 === null) {\n            return null;\n        }\n        const NAXIS2 = ParseHeader.checkFITSItem(header, \"NAXIS2\");\n        if (NAXIS2 === null) {\n            return null;\n        }\n        const DATAMIN = ParseHeader.checkFITSItem(header, \"DATAMIN\");\n        const DATAMAX = ParseHeader.checkFITSItem(header, \"DATAMAX\");\n        if (!BITPIX || !NAXIS1 || !NAXIS2) {\n            return null; // return early if invalid data.\n        }\n        if (!DATAMAX || !DATAMIN) {\n            const [min, max] = ParsePayload.computePhysicalValues(rawData, header);\n            if (min && max) {\n                const maxitem = new FITSHeaderItem(\"DATAMAX\", min, \"computed by jsfitsio\");\n                const minitem = new FITSHeaderItem(\"DATAMIN\", max, \"computed by jsfitsio\");\n                header.insert(maxitem);\n                header.insert(minitem);\n            }\n        }\n        const endItem = new FITSHeaderItem('END', \"\", \"\");\n        header.insert(endItem);\n        return header;\n        // TODO: END tag shall be added here\n    }\n    static computePhysicalValues(rawData, header) {\n        const BITPIX = ParseHeader.checkFITSItem(header, \"BITPIX\");\n        if (BITPIX === null || isNaN(BITPIX)) {\n            return [null, null];\n        }\n        const BLANK = ParseHeader.checkFITSItem(header, \"BLANK\");\n        if (BLANK === null || isNaN(BITPIX)) {\n            return [null, null];\n        }\n        let BZERO = ParseHeader.checkFITSItem(header, \"BZERO\");\n        if (BZERO === null) {\n            BZERO = 0;\n        }\n        let BSCALE = ParseHeader.checkFITSItem(header, \"BSCALE\");\n        if (BSCALE === null) {\n            BSCALE = 1;\n        }\n        let i = 0;\n        const bytesXelem = Math.abs(BITPIX / 8);\n        const pxLength = rawData.byteLength / bytesXelem;\n        let min = null;\n        let max = null;\n        let physicalblank = null;\n        if (BLANK) {\n            physicalblank = ParsePayload.pixel2physicalValue(BLANK, BSCALE, BZERO);\n        }\n        while (i < pxLength) {\n            let px_val = ParsePayload.extractPixelValue(rawData, bytesXelem * i, BITPIX);\n            if (px_val === null) {\n                i++;\n                continue;\n            }\n            let ph_val = ParsePayload.pixel2physicalValue(px_val, BSCALE, BZERO);\n            if (!min) {\n                min = ph_val;\n            }\n            if (!max) {\n                max = ph_val;\n            }\n            // check this block if it is still applicable\n            if (physicalblank === null || physicalblank !== ph_val) {\n                if (ph_val !== null && (ph_val < min || min === null)) {\n                    min = ph_val;\n                }\n                if (ph_val !== null && (ph_val > max || max === null)) {\n                    max = ph_val;\n                }\n            }\n            i++;\n        }\n        return [min, max];\n    }\n    static pixel2physicalValue(pxval, BSCALE, BZERO) {\n        if (BZERO === null || BSCALE === null) {\n            throw new Error(\"Either BZERO or BSCALE is null\");\n        }\n        return BZERO + BSCALE * pxval;\n    }\n    static extractPixelValue(rawData, offset, BITPIX) {\n        let px_val = null; // pixel value\n        if (BITPIX == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(rawData[offset], rawData[offset + 1]);\n        }\n        else if (BITPIX == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(rawData[offset], rawData[offset + 1], rawData[offset + 2], rawData[offset + 3]);\n        }\n        else if (BITPIX == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(rawData.slice(offset, offset + 4), 8, 23);\n        }\n        else if (BITPIX == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (BITPIX == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(rawData.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FITSWriter } from \"./FITSWriter.js\";\nimport { ParsePayload } from \"./ParsePayload.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\nexport class FITSParser {\n    static loadFITS(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const uint8data = yield FITSParser.getFile(url);\n            if (uint8data === null || uint8data === void 0 ? void 0 : uint8data.byteLength) {\n                const fits = FITSParser.processFits(uint8data);\n                return fits;\n            }\n            return null;\n        });\n    }\n    static processFits(rawdata) {\n        const header = ParseHeader.parse(rawdata);\n        const headerFinalised = ParsePayload.computePhysicalMinAndMax(header, rawdata);\n        if (headerFinalised == null) {\n            return null;\n        }\n        const dataOffset = 2880; // Assuming no additional header blocks\n        const payloadBuffer = new Uint8Array(rawdata.slice(dataOffset));\n        const payloadMatrix = FITSParser.createMatrix(payloadBuffer, header);\n        return {\n            header: headerFinalised,\n            data: payloadMatrix\n        };\n    }\n    static createMatrix(payload, header) {\n        const NAXIS1 = ParseHeader.checkFITSItem(header, \"NAXIS1\");\n        if (NAXIS1 === null) {\n            throw new Error(\"NAXIS1 not defined.\");\n        }\n        const NAXIS2 = ParseHeader.checkFITSItem(header, \"NAXIS2\");\n        if (NAXIS2 === null) {\n            throw new Error(\"NAXIS2 not defined.\");\n        }\n        const BITPIX = ParseHeader.checkFITSItem(header, \"BITPIX\");\n        if (BITPIX === null) {\n            throw new Error(\"BITPIX not defined.\");\n        }\n        const bytesXelem = Math.abs(BITPIX / 8);\n        if (payload.length !== NAXIS1 * NAXIS2 * bytesXelem) {\n            throw new Error(\"Payload size does not match the expected matrix dimensions.\");\n        }\n        // const matrix: Array<Uint8Array> = [];\n        const matrix = [];\n        for (let i = 0; i < NAXIS2; i++) {\n            matrix.push(payload.slice(i * NAXIS1 * bytesXelem, (i + 1) * NAXIS1 * bytesXelem));\n        }\n        return matrix;\n    }\n    static generateFITSForWeb(fitsParsed) {\n        return FITSWriter.typedArrayToURL(fitsParsed);\n    }\n    static saveFITSLocally(fitsParsed, path) {\n        return FITSWriter.writeFITSFile(fitsParsed, path);\n    }\n    static getFile(uri) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!uri.substring(0, 5).toLowerCase().includes(\"http\")) {\n                const p = yield import('./getLocalFile.js');\n                const rawData = yield p.getLocalFile(uri);\n                const uint8 = new Uint8Array(rawData);\n                return uint8;\n            }\n            else {\n                const p = yield import('./getFile.js');\n                const rawData = yield p.getFile(uri);\n                if (rawData === null || rawData === void 0 ? void 0 : rawData.byteLength) {\n                    const uint8 = new Uint8Array(rawData);\n                    return uint8;\n                }\n                return new Uint8Array(0);\n            }\n        });\n    }\n}\n// const url = \"http://skies.esac.esa.int/Herschel/normalized/PACS_hips160//Norder8/Dir40000/Npix47180.fits\"\n// FITSParser.loadFITS(url).then((fits) => {\n//   if (fits == null) {\n//     return null\n//   }\n//   const path = \"./fitsTest1.fits\"\n//   console.log(fits.header)\n//   FITSParser.saveFITSLocally(fits, path)\n//   console.log(\"finished\")\n// })\n// // const file = \"/Users/fabriziogiordano/Desktop/PhD/code/new/FITSParser/tests/inputs/empty.fits\"\n// const file = \"/Users/fabriziogiordano/Desktop/PhD/code/new/FITSParser/tests/inputs/Npix43348.fits\"\n// FITSParser.loadFITS(file).then((fits) => {\n//   if (fits == null) {\n//     return null\n//   }\n//   const path = \"./fitsTest2.fits\"\n//   console.log(fits.header)\n//   FITSParser.saveFITSLocally(fits, path)\n//   console.log(\"finished\")\n// })\n","export enum NumberType {\n    DEGREES,\n    RADIANS,\n    DECIMAL,\n    HMS,\n    DMS\n}","/**\n * @author Fabrizio Giordano (Fab77)\n * Enum for coordinate types.\n * @readonly\n * @enum {{name: string, hex: string}}\n */\n\nexport enum CoordsType {\n  CARTESIAN = \"cartesian\",\n  SPHERICAL = \"spherical\",\n  ASTRO = \"astro\"\n}\n","\nimport { FITSHeader } from 'jsfitsio';\n\nexport class FITS {\n    _header: FITSHeader[]\n    _data: Map<number, Array<Uint8Array>>\n\n    constructor(header: FITSHeader[], data: Map<number, Array<Uint8Array>>) {\n        this._header = header\n        this._data = data\n    }\n\n    get header() {\n        return this._header\n    }\n    \n    get data() {\n        return this._data\n    }\n\n}","import { FITSHeaderManager, FITSHeaderItem } from \"jsfitsio\";\nimport { FITSParsed } from \"jsfitsio\";\n// import { AstroCoords } from \"src/model/AstroCoords\";\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport { Point } from \"../model/Point.js\";\nimport { FITS } from \"../model/FITS.js\";\n\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nexport abstract class AbstractProjection {\n  private _naxis1!: number;\n  private _naxis2!: number;\n  private _pxsize: number;\n  private _ctype1: string;\n  private _ctype2: string;\n\n  constructor(\n    ctype1: string,\n    ctype2: string,\n    naxis1 = 0,\n    naxis2 = 0,\n    pxsize = 0\n  ) {\n    this._ctype1 = ctype1;\n    this._ctype2 = ctype2;\n    this._naxis1 = naxis1;\n    this._naxis2 = naxis2;\n    this._pxsize = pxsize;\n  }\n\n  protected get naxis1() {\n    return this._naxis1;\n  }\n\n  protected set naxis1(value: number) {\n    this._naxis1 = value;\n  }\n\n  protected get naxis2() {\n    return this._naxis2;\n  }\n\n  protected set naxis2(value: number) {\n    this._naxis2 = value;\n  }\n\n  protected get pxsize() {\n    return this._pxsize;\n  }\n\n  protected set pxsize(value: number) {\n    this._pxsize = value;\n  }\n\n  protected get ctype1() {\n    return this._ctype1;\n  }\n\n  protected set ctype1(value: string) {\n    this._ctype1 = value;\n  }\n\n  protected get ctype2() {\n    return this._ctype2;\n  }\n\n  protected set ctype2(value: string) {\n    this._ctype2 = value;\n  }\n\n  public abstract initFromFile(\n    fitsfilepath?: string,\n    hipsURI?: string,\n    pxsize?: number,\n    order?: number\n  ): Promise<FITSParsed | undefined>;\n\n  public abstract prepareFITSHeader(fitsHeaderParams: FITSHeaderManager): FITSHeaderManager[];\n\n  public abstract getFITSHeader(): FITSHeaderManager[];\n\n  public abstract getCommonFitsHeaderParams(): FITSHeaderManager;\n\n  public abstract extractPhysicalValues(fits: FITSParsed): number[][];\n\n  public abstract getPixValues(\n    inputPixelsList: ImagePixel[]\n  ): Promise<Uint8Array | undefined>;\n\n  public abstract setPxsValue(\n    values: Uint8Array,\n    fitsHeaderParams: FITSHeaderManager\n  ): Map<number, Array<Uint8Array>>;\n\n  public abstract getImageRADecList(\n    center: Point,\n    radius: number,\n    pxsize: number\n  ): Array<[number, number]>;\n\n  public abstract pix2world(i: number, j: number): Point;\n\n  public abstract get fitsUsed(): String[];\n\n  public abstract world2pix(radeclist: number[][]): ImagePixel[];\n\n  // public abstract generateFITSWithNaN(): FITS;\n\n  public generateFITSWithNaN(): FITS {\n    if (!this.naxis1 || !this.naxis2) {\n      throw new Error(\n        \"NAXIS1 and NAXIS2 must be initialized before generating FITS.\"\n      );\n    }\n\n    let fitsheaderList: FITSHeaderManager[] = [];\n\n    let fitsheader: FITSHeaderManager = new FITSHeaderManager();\n\n    fitsheader.insert(new FITSHeaderItem(\"NAXIS1\", this.naxis1));\n    fitsheader.insert(new FITSHeaderItem(\"NAXIS2\", this.naxis2));\n    fitsheader.insert(new FITSHeaderItem(\"NAXIS\", 2));\n    fitsheader.insert(new FITSHeaderItem(\"BITPIX\", \"-64\"));\n    fitsheader.insert(new FITSHeaderItem(\"SIMPLE\", \"T\"));\n    fitsheader.insert(new FITSHeaderItem(\"BSCALE\", 1));\n    fitsheader.insert(new FITSHeaderItem(\"BZERO\", 0));\n\n    fitsheader.insert(new FITSHeaderItem(\"CTYPE1\", this.ctype1));\n    fitsheader.insert(new FITSHeaderItem(\"CTYPE2\", this.ctype2));\n    fitsheader.insert(new FITSHeaderItem(\"CDELT1\", this.pxsize)); // ??? Pixel spacing along axis 1 ???\n    fitsheader.insert(new FITSHeaderItem(\"CDELT2\", this.pxsize)); // ??? Pixel spacing along axis 2 ???\n    fitsheader.insert(new FITSHeaderItem(\"CRPIX1\", this.naxis1 / 2)); // central/reference pixel i along naxis1\n    fitsheader.insert(new FITSHeaderItem(\"CRPIX2\", this.naxis2 / 2)); // central/reference pixel j along naxis2\n    fitsheader.insert(new FITSHeaderItem(\"CRVAL1\", NaN)); // central/reference pixel RA\n    fitsheader.insert(new FITSHeaderItem(\"CRVAL2\", NaN)); // central/reference pixel Dec\n\n    fitsheader.insert(new FITSHeaderItem(\"ORIGIN\", \"'WCSLight v.0.x'\"));\n    fitsheader.insert(\n      new FITSHeaderItem(\n        \"COMMENT\",\n        \"'WCSLight v0.x developed by F.Giordano and Y.Ascasibar'\"\n      )\n    );\n    fitsheader.insert(new FITSHeaderItem(\"END\"));\n\n    fitsheaderList.push(fitsheader);\n\n    let bytesXelem = 8;\n    // why not usign a simple arrays?\n    let pv = new Map<number, Array<Uint8Array>>();\n    pv.set(0, new Array<Uint8Array>(this.naxis2))\n    pv.get(0)\n    for (let r = 0; r < this.naxis2; r++) {\n      pv.get(0)[r] = new Uint8Array(this.naxis1 * bytesXelem);\n      pv.get(0)[r].fill(255);\n    }\n\n    const fitsNan: FITS = new FITS(fitsheaderList, pv);\n\n    return fitsNan;\n  }\n\n  public computeSquaredNaxes(d: number, ps: number): void {\n    // first approximation to be checked\n    this._naxis1 = Math.ceil(d / ps);\n    this._naxis2 = this._naxis1;\n    this._pxsize = ps;\n  }\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\n\nexport class ImagePixel {\n    _i: number;     // int i of input projection\n    _j: number;     // int j of input projection\n    _tileno: number;// int\n    \n    constructor (i: number = null, j: number = null, tileno: number = null) {\n        this._i = i;\n        this._j = j;\n        this._tileno = tileno;\n    }\n\n    geti() {\n        return this._i;\n    }\n\n    getj() {\n        return this._j;\n    }\n\n    get tileno() {\n        return this._tileno\n    }\n}\n","/**\n * @author Fabrizio Giordano (Fab)\n */\n// import vec3 from 'gl-matrix';\n\nimport { AstroCoords } from \"./AstroCoords.js\";\nimport { CartesianCoords } from \"./CartesianCoords.js\";\nimport { HMSCoords } from \"./HMSCoords.js\";\nimport { NumberType } from \"./NumberType.js\";\nimport { SexagesimalCoords } from \"./SexagesimalCoords.js\";\nimport { SphericalCoords } from \"./SphericalCoords.js\";\n\nfunction Utils(){\n\t\n}\n\nexport function cartesianToSpherical(xyz: CartesianCoords): SphericalCoords{\n\tlet dotXYZ = dot(xyz, xyz);\n\tlet r = Math.sqrt(dotXYZ);\t\n\tlet thetaRad = Math.acos(xyz[2]/r);\n\tlet thetaDeg = radToDeg(thetaRad);\n\t// NB: in atan(y/x) is written with params switched atan2(x, y)\n\tlet phiRad = Math.atan2(xyz[1],xyz[0]);\n\tlet phiDeg = radToDeg(phiRad);\n\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\treturn {\n\t\tphiDeg: phiDeg, \n\t\tthetaDeg: thetaDeg,\n\t\tphiRad:phiRad,\n\t\tthetaRad: thetaRad\n\t};\n};\n\nexport function sphericalToAstro(phiTheta: SphericalCoords): AstroCoords{\n\tlet raDeg: number;\n\tlet decDeg: number;\n\n\traDeg = phiTheta.phiDeg;\n\tif (raDeg < 0){\n\t\traDeg += 360;\n\t}\n\tdecDeg = 90 - phiTheta.thetaDeg;\n\t\n\treturn {\n\t\t\"raDeg\": raDeg,\n\t\t\"decDeg\": decDeg,\n\t\t\"raRad\": degToRad(raDeg),\n\t\t\"decRad\": degToRad(decDeg)\n\n\t};\n}\n\nexport function astroToSpherical(raDec: AstroCoords): SphericalCoords{\n\t\n\tlet phiDeg: number;\n\tlet thetaDeg: number;\n\n\tphiDeg = raDec.raDeg;\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\t\n\tthetaDeg = 90 - raDec.decDeg;\n\t\n\treturn {\n\t\t\"phiDeg\": phiDeg,\n\t\t\"thetaDeg\": thetaDeg,\n\t\t\"phiRad\": degToRad(phiDeg),\n\t\t\"thetaRad\": degToRad(thetaDeg),\n\t};\n}\n\nexport function sphericalToCartesian(phiTheta: SphericalCoords, r: number): CartesianCoords{\n\tr = (r == undefined) ? 1 : r;\n\tvar x = r * Math.sin(phiTheta.thetaRad) * Math.cos(phiTheta.phiRad);\n\tvar y = r * Math.sin(phiTheta.thetaRad) * Math.sin(phiTheta.phiRad);\n\tvar z = r * Math.cos(phiTheta.thetaRad);\n\n\treturn {\n\t\t\"x\": x, \n\t\t\"y\": y, \n\t\t\"z\": z\n\t};\n};\n\nexport function fillAstro(ra: number, dec: number, unit: NumberType): AstroCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"raDeg\": ra,\n\t\t\t\"decDeg\": dec,\n\t\t\t\"raRad\": degToRad(ra),\n\t\t\t\"decRad\": degToRad(dec)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"raRad\": ra,\n\t\t\t\"decRad\": dec,\n\t\t\t\"raDeg\": radToDeg(ra),\n\t\t\t\"decDeg\": radToDeg(dec)\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n\t\n}\n\n\nexport function fillSpherical(phi: number, theta: number, unit: NumberType):  SphericalCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"phiDeg\": phi,\n\t\t\t\"thetaDeg\": theta,\n\t\t\t\"phiRad\": degToRad(phi),\n\t\t\t\"thetaRad\": degToRad(theta)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"phiDeg\": radToDeg(phi),\n\t\t\t\"thetaDeg\": radToDeg(theta),\n\t\t\t\"phiRad\": phi,\n\t\t\t\"thetaRad\": theta\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n}\n\nfunction dot(a: CartesianCoords, b: CartesianCoords) : number{\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n\nexport function colorHex2RGB(hexColor: string): [number, number, number] {\n\n//\tconsole.log(hexColor);\n\tvar hex1 = hexColor.substring(1,3);\n\tvar hex2 = hexColor.substring(3,5);\n\tvar hex3 = hexColor.substring(5,7);\n\t\n\tvar dec1 = parseInt(hex1, 16);\n\tvar dec2 = parseInt(hex2, 16);\n\tvar dec3 = parseInt(hex3, 16);\n\t\n\tvar rgb1 = (dec1 / 255).toFixed(2);\n\tvar rgb2 = (dec2 / 255).toFixed(2);\n\tvar rgb3 = (dec3 / 255).toFixed(2);\n\t\n\treturn [parseFloat(rgb1), parseFloat(rgb2), parseFloat(rgb3)];\n\n}\n\nexport function degToRad(degrees: number) : number{\n\treturn (degrees / 180 ) * Math.PI ;\n}\n\nexport function radToDeg(radians: number) : number{\n\treturn radians * 180 / Math.PI;\n}\n\nexport function raDegToHMS(raDeg: number): HMSCoords{\n\t\n\tvar h = Math.floor(raDeg/15);\n\tvar m = Math.floor((raDeg/15 - h) * 60);\n\tvar s = (raDeg/15 - h - m/60) * 3600;\n\t\n\treturn {\n\t\th: h, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nexport function decDegToDMS(decDeg: number): SexagesimalCoords{\n\tvar sign = 1;\n\tif (decDeg < 0){\n\t\tsign = -1;\n\t}\n\t\n\tvar decDeg_abs = Math.abs(decDeg);\n\tvar d = Math.trunc(decDeg_abs);\n\t\n\tvar m = Math.trunc( (decDeg_abs - d) * 60);\n\t\n\tvar s = (decDeg_abs - d - m/60) * 3600;\n\td = d * sign;\n\t\n\treturn {\n\t\td: d, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nfunction dms2DecDeg(decDMS: SexagesimalCoords){\n\tvar sign = Math.sign(decDMS.d);\n\tvar deg = (decDMS.d) + sign * (decDMS.m / 60) + sign * (decDMS.s/3600);\n\treturn deg;\n}\n\nfunction hms2RaDeg(raHMS: HMSCoords){\n\tvar sign = Math.sign(raHMS.h);\n\tvar deg = (raHMS.h + sign * (raHMS.m / 60) + sign * (raHMS.s/3600)) * 15;\n\treturn deg;\n}\n\nfunction worldToModel(xy: [number, number], radius: number): [number, number, number]{\n\tvar x = xy[0];\n\tvar y = xy[1];\n\tvar z = Math.sqrt(radius*radius - xy[0]*xy[0] - xy[1]*xy[1]);\n\treturn [x, y, z];\n}\n\n","/**\n * @author Fabrizio Giordano (Fab77)\n */\n\nimport {sphericalToCartesian, cartesianToSpherical, sphericalToAstro, astroToSpherical, fillSpherical, fillAstro} from './Utils.js';\nimport { CartesianCoords } from './CartesianCoords.js';\nimport { AstroCoords} from './AstroCoords.js';\nimport { CoordsType } from './CoordsType.js';\nimport { SphericalCoords } from './SphericalCoords.js';\nimport { NumberType } from './NumberType.js';\nimport { EquatorialCoords } from './EquatorialCoords.js';\nimport { GalacticCoords } from './GalacticCoords.js';\n\nexport class Point{\n\n\t#astro: AstroCoords;\n\t// #equatorial: EquatorialCoords;\n\t// #galactic: GalacticCoords;\n\n\t#spherical: SphericalCoords;\n\t#cartesian: CartesianCoords;\n\n\tconstructor(in_type: CoordsType, unit: NumberType, ...coords: Array<number>) {\n\n\t\tif (in_type == CoordsType.CARTESIAN){\n\t\t\tthis.#cartesian.x = parseFloat(coords[0].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.y = parseFloat(coords[1].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.z = parseFloat(coords[2].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t\t} else if (in_type == CoordsType.ASTRO){\n\t\t\tthis.#astro = fillAstro(coords[0],  coords[1], unit);\n\t\t\tthis.#spherical = astroToSpherical(this.#astro);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\n\t\t} else if (in_type == CoordsType.SPHERICAL){\n\t\t\tthis.#spherical = fillSpherical(coords[0],  coords[1], unit);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\n\t\t} else{\n\t\t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t\t}\n\t\tif (this.#spherical.phiDeg > 360) {\n\t\t\tthis.#spherical.phiDeg -= 360;\n\t\t}\n\t\tif (this.#astro.raDeg > 360) {\n\t\t\tthis.#astro.raDeg -= 360;\n\t\t}\n\t}\n\n\n\t// constructor(in_options: ICoordsFormat, in_type: CoordsType){\n\t\t\n\t// \tif (in_type == CoordsType.CARTESIAN){\n\n\t// \t\tthis.#cartesian.x = parseFloat((in_options as CartesianCoords).x.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.y = parseFloat((in_options as CartesianCoords).y.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.z = parseFloat((in_options as CartesianCoords).z.toFixed(global.MAX_DECIMALS));\n\n\t// \t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else if (in_type == CoordsType.ASTRO){\n\t\t\t\n\t// \t\tif ((in_options as AstroCoords).raDeg && (in_options as AstroCoords).decDeg) {\n\t// \t\t\tthis.#astro = radegDecdegToAstro((in_options as AstroCoords).raDeg,  (in_options as AstroCoords).decDeg );\n\t// \t\t} else if ((in_options as AstroCoords).raRad && (in_options as AstroCoords).decRad) {\n\t// \t\t\tthis.#astro = raradDecradToAstro((in_options as AstroCoords).raRad,  (in_options as AstroCoords).decRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"AstroCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\t// \t\tthis.#spherical = astroToSpherical(this.#astro);\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\t\n\t// \t}else if (in_type == CoordsType.SPHERICAL){\n\n\t// \t\tif ((in_options as SphericalCoords).phiDeg && (in_options as SphericalCoords).thetaDeg) {\n\t// \t\t\tthis.#spherical = phidegThetadegToSpherical((in_options as SphericalCoords).phiDeg,  (in_options as SphericalCoords).thetaDeg );\n\t// \t\t} else if ((in_options as SphericalCoords).phiRad && (in_options as SphericalCoords).thetaRad) {\n\t// \t\t\tthis.#spherical = phiradThetaradToSpherical((in_options as SphericalCoords).phiRad,  (in_options as SphericalCoords).thetaRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"SphericalCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else{\n\t// \t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t// \t}\n\t// }\n\n\tget spherical() {\n\t\treturn this.#spherical;\n\t}\n\n\tget astro() {\n\t\treturn this.#astro;\n\t}\n\n\tget cartesian() {\n\t\treturn this.#cartesian;\n\t}\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// /** Scale the vector by a given factor\n    // @param n the scale factor */\n\t// scale(n: number): Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*n, this.y*n, this.z*n);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// dot(v: Point): number{ \n\t// \treturn this.x*v.x + this.y*v.y + this.z*v.z; \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// cross(v: Point): Point{ \n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.y*v.z - v.y*this.z, this.z*v.x - v.z*this.x, this.x*v.y - v.x*this.y);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// norm() : Point{\n\t// \tlet d = 1./this.length();\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*d, this.y*d, this.z*d);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// length(): number{ \n\t// \treturn Math.sqrt(this.lengthSquared()); \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// lengthSquared(): number{ \n\t// \treturn this.x*this.x + this.y*this.y + this.z*this.z; \n  \t// };\n\n\t// subtract(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x - v.x, this.y - v.y, this.z - v.z);\n\t// }\n\n\t// add(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x + v.x, this.y + v.y, this.z + v.z);\n\t// }\n\t\n\n\t// get x(){\n\t// \treturn this._x;\n\t// }\n\t\n\t// get y(){\n\t// \treturn this._y;\n\t// }\n\t\n\t// get z(){\n\t// \treturn this._z;\n\t// }\n\t\n\t// get xyz(){\n    //     return this._xyz;\n    // }\n\t\n    // get raDeg(){\n    //     return this._raDeg;\n    // }\n    \n    // get decDeg(){\n    //     return this._decDeg;\n    // }\n    \n    // get raDecDeg(){\n    //     return this._raDecDeg;\n    // }\n    \n    // toADQL(){\n    // \treturn this._raDecDeg[0]+\",\"+this._raDecDeg[1];\n    // }\n    \n    // toString(){\n    // \treturn \"(raDeg, decDeg) => (\"+this._raDecDeg[0]+\",\"+this._raDecDeg[1]+\") (x, y,z) => (\"+this._xyz[0]+\",\"+this._xyz[1]+\",\"+this._xyz[2]+\")\";\n    // }\n}\n\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n \n\nimport { FITSParser, FITSHeaderManager, FITSHeaderItem, FITSParsed, ParseUtils } from 'jsfitsio';\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\nimport { FITS } from '../model/FITS.js';\n\n\nexport class MercatorProjection extends AbstractProjection {\n    \n    _minra!: number;\n    _mindec!: number;\n    // _naxis1!: number;\n    // _naxis2!: number;\n    \n    _fitsheader: FITSHeaderManager[];\n    _infile!: string;\n    // _ctype1: string; // TODO should be RA ENUM\n    // _ctype2: string; // TODO should be Dec ENUM\n    _craDeg!: number;\n    _cdecDeg!: number;\n\n    // _pxsize!: number;\n    _pxsize1!: number;\n    _pxsize2!: number;\n\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval!: number;\n    _maxphysicalval!: number;\n    _wcsname: string;\n    _fitsUsed: String[];\n    \n    constructor() {\n        super(\"'RA---CAR'\", \"'DEC--CAR'\")\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this._pxvalues = new Map<number, Array<Uint8Array>>();\n        this._fitsheader = new Array<FITSHeaderManager>();\n    }\n\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n        \n        const fits = await FITSParser.loadFITS(infile);\n        // let fp = new FITSParser(infile);\n        this._infile = infile;\n        this._fitsUsed.push(infile)\n\n        // let promise = fp.loadFITS().then(fits => {\n            \n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            super.naxis1 = fits.header.get(\"NAXIS1\");\n            super.naxis2 = fits.header.get(\"NAXIS2\");\n            // this._naxis1 = fits.header.get(\"NAXIS1\");\n            // this._naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value as number;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value as number;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            // this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            // this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n\n            const pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            const pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n            if (pxsize1 !== pxsize2 || pxsize1 === undefined || pxsize2 === undefined) {\n                throw new Error(\"pxsize1 is not equal to pxsize2\")\n                exit;\n            }\n            super.pxsize = pxsize1;\n\n            // this._minra = this._craDeg - this._pxsize1 * this._naxis1 / 2;\n            this._minra = this._craDeg - super.pxsize * super.naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            // this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n            this._mindec = this._cdecDeg - super.pxsize * super.naxis2 / 2;\n\n            return fits;\n        // });\n        // await promise;\n        // return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeaderManager): FITSHeaderManager[] {\n\n        this._fitsheader[0] = new FITSHeaderManager();\n\n        this._fitsheader[0].insert(new FITSHeaderItem(\"NAXIS1\", super.naxis1));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"NAXIS2\", super.naxis2));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        \n        \n        \n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].insert(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].insert(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].insert(new FITSHeaderItem(\"BZERO\", bzero));\n\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CTYPE1\", super.ctype1));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CTYPE2\", super.ctype2));\n\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CDELT1\", super.pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CDELT2\", super.pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CRPIX1\", super.naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CRPIX2\", super.naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].insert(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].insert(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].insert(new FITSHeaderItem(\"ORIGIN\", \"'WCSLight v.0.x'\"));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"COMMENT\", \"'WCSLight v0.x developed by F.Giordano and Y.Ascasibar'\"));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n    getFITSHeader(): FITSHeaderManager[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeaderManager {\n        let header = new FITSHeaderManager();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                header.insert(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    get fitsUsed(): String[]{\n\t\treturn this._fitsUsed;\n\t}\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= super.naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= super.naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        let pv = this._pxvalues.get(0);\n                        if (pv !== undefined) {\n\n                            for (let b = 0; b < bytesXelem; b++) {\n\n                                values[p * bytesXelem + b] = pv[imgpx._j][(imgpx._i) * bytesXelem + b];\n                            }\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeaderManager): Map<number, Array<Uint8Array>> {\n\n        let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        let maxpixb = minpixb;\n\n        let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        this._minphysicalval = bzero + bscale * minpixb;\n        this._maxphysicalval = bzero + bscale * maxpixb;\n\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n        // this._pxvalues.set(0, new Uint8Array[this._naxis2][this._naxis1 * bytesXelem]);\n\n        this._pxvalues.set(0, new Array<Uint8Array>(super.naxis2));\n        let pv = this._pxvalues.get(0);\n        if (pv !== undefined) {\n            for (let r = 0; r < super.naxis2; r++) {\n                pv[r] = new Uint8Array(super.naxis1 * bytesXelem);\n            }\n\n            let r!: number;\n            let c!: number;\n            let b!: number;\n            for (let p = 0; (p * bytesXelem) < values.length; p++) {\n                // console.log(\"processing \"+p + \" of \"+ (values.length / bytesXelem));\n\n                try {\n                    r = Math.floor(p / super.naxis1);\n                    c = (p - r * super.naxis1) * bytesXelem;\n\n                    for (b = 0; b < bytesXelem; b++) {\n                        pv[r][c + b] = values[p * bytesXelem + b];\n                    }\n\n\n                    let valpixb = ParseUtils.extractPixelValue(0, values.slice(p * bytesXelem, (p * bytesXelem) + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n                    let valphysical = bzero + bscale * valpixb;\n\n                    if (valphysical < this._minphysicalval || isNaN(this._minphysicalval)) {\n                        this._minphysicalval = valphysical;\n                    } else if (valphysical > this._maxphysicalval || isNaN(this._maxphysicalval)) {\n                        this._maxphysicalval = valphysical;\n                    }\n                } catch (err) {\n                    console.log(err)\n                    console.log(\"p \" + p)\n                    console.log(\"r %, c %, b %\" + r, c, b)\n                    console.log(\"this._pxvalues[r][c + b] \" + pv[r][c + b])\n                    console.log(\"values[p * bytesXelem + b] \" + values[p * bytesXelem + b])\n                }\n\n            }\n        }\n\n        this.prepareFITSHeader(fitsHeaderParams);\n        return this._pxvalues;\n\n    }\n\n\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n\n\n        super.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n        super.pxsize = pxsize;\n        this._minra = center.astro.raDeg - radius;\n        if (this._minra < 0) {\n            this._minra += 360;\n        }\n        this._mindec = center.astro.decDeg - radius;\n\n        let radeclist: Array<[number, number]> = new Array<[number, number]>();\n\n        for (let d = 0; d < super.naxis2; d++) {\n            for (let r = 0; r < super.naxis1; r++) {\n                radeclist.push([this._minra + (r * super.pxsize), this._mindec + (d * super.pxsize)]);\n            }\n        }\n\n        let cidx = (super.naxis2 / 2 ) * super.naxis1 + super.naxis1 / 2;\n        if (super.naxis1 % 2 != 0) {\n            cidx = Math.floor(radeclist.length / 2);\n        }\n\n        // let cidx2 = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        \n        // let cidx = Math.ceil(radeclist.length / 2);\n        // let cidx = Math.floor(radeclist.length / 2);\n        this._craDeg = radeclist[cidx][0];\n        this._cdecDeg = radeclist[cidx][1];\n\n        return radeclist;\n\n\n    }\n\n\n\n    /** TODO !!! check and handle RA passing through 360-0 */\n    pix2world(i: number, j: number): Point {\n\n        let ra: number;\n        let dec: number;\n        // ra = i * this._stepra + this._minra;\n        // dec = j * this._stepdec + this._mindec;\n        ra = i * super.pxsize + this._minra;\n        dec = j * super.pxsize + this._mindec;\n        let p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n        return p;\n        // return [ra, dec];\n\n    }\n\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        for (let radecItem of radeclist) {\n            let ra = radecItem[0];\n            let dec = radecItem[1];\n            // let i = Math.floor((ra - this._minra) / this._pxsize1);\n            // let j = Math.floor((dec - this._mindec) / this._pxsize2);\n            let i = Math.floor((ra - this._minra) / super.pxsize);\n            let j = Math.floor((dec - this._mindec) / super.pxsize);\n            imgpxlist.push(new ImagePixel(i, j));\n        }\n\n        return imgpxlist;\n\n    }\n\n}\n","export class Constants {\n}\n//\tstatic halfpi = Math.PI/2.;\nConstants.halfpi = 1.5707963267948966;\nConstants.inv_halfpi = 2. / Math.PI;\n/** The Constant twopi. */\nConstants.twopi = 2 * Math.PI;\nConstants.inv_twopi = 1. / (2 * Math.PI);\n//# sourceMappingURL=Constants.js.map","export class Zphi {\n    /** Creation from individual components */\n    constructor(z_, phi_) {\n        this.z = z_;\n        this.phi = phi_;\n    }\n    ;\n}\n//# sourceMappingURL=Zphi.js.map","import { Vec3 } from './Vec3.js';\nimport { Zphi } from './Zphi.js';\nexport class Hploc {\n    constructor(ptg) {\n        Hploc.PI4_A = 0.7853981554508209228515625;\n        Hploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\n        Hploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n        Hploc.M_1_PI = 0.3183098861837906715377675267450287;\n        if (ptg) {\n            this.sth = 0.0;\n            this.have_sth = false;\n            this.z = Hploc.cos(ptg.theta);\n            this._phi = ptg.phi;\n            if (Math.abs(this.z) > 0.99) {\n                this.sth = Hploc.sin(ptg.theta);\n                this.have_sth = true;\n            }\n        }\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    ;\n    get phi() {\n        return this._phi;\n    }\n    ;\n    set phi(phi) {\n        this._phi = phi;\n    }\n    ;\n    setSth(sth) {\n        this.sth = sth;\n    }\n    ;\n    toVec3() {\n        var st = this.have_sth ? this.sth : Math.sqrt((1.0 - this.z) * (1.0 + this.z));\n        // var vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);\n        var vector = new Vec3(st * Math.cos(this.phi), st * Math.sin(this.phi), this.z);\n        return vector;\n    }\n    ;\n    toZphi() {\n        return new Zphi(this.z, this.phi);\n    }\n    static sin(d) {\n        let u = d * Hploc.M_1_PI;\n        let q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 4.0 * q;\n        d -= x * Hploc.PI4_A;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 1) != 0) {\n            d = -d;\n        }\n        return this.sincoshelper(d);\n    }\n    ;\n    static cos(d) {\n        //\t\tlet u = d * Hploc.M_1_PI - 0.5;\n        let u = d * Hploc.M_1_PI - 0.5;\n        //\t\tu -= 0.5;\n        let q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 2.0 * q;\n        let t = x * Hploc.PI4_A;\n        d = d - t;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 2) == 0) {\n            d = -d;\n        }\n        return Hploc.sincoshelper(d);\n    }\n    ;\n    static sincoshelper(d) {\n        let s = d * d;\n        let u = -7.97255955009037868891952e-18;\n        u = u * s + 2.81009972710863200091251e-15;\n        u = u * s - 7.64712219118158833288484e-13;\n        u = u * s + 1.60590430605664501629054e-10;\n        u = u * s - 2.50521083763502045810755e-08;\n        u = u * s + 2.75573192239198747630416e-06;\n        u = u * s - 0.000198412698412696162806809;\n        u = u * s + 0.00833333333333332974823815;\n        u = u * s - 0.166666666666666657414808;\n        return s * u * d + d;\n    }\n    ;\n    /** This method calculates the arc sine of x in radians. The return\n    value is in the range [-pi/2, pi/2]. The results may have\n    maximum error of 3 ulps. */\n    static asin(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1 + d) * (1 - d))), d);\n    }\n    ;\n    /** This method calculates the arc cosine of x in radians. The\n        return value is in the range [0, pi]. The results may have\n        maximum error of 3 ulps. */\n    static acos(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.sqrt((1 + d) * (1 - d)), Math.abs(d)), d) + (d < 0 ? Math.PI : 0);\n    }\n    ;\n    static mulsign(x, y) {\n        let sign = Hploc.copySign(1, y);\n        return sign * x;\n    }\n    ;\n    static copySign(magnitude, sign) {\n        return sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);\n        // let finalsign = 1;\n        // if (Object.is(finalsign , -0)){\n        // \tsign = -1;\n        // }else if (Object.is(finalsign , 0)){\n        // \tsign = 1;\n        // }else {\n        // \tsign = Math.sign(finalsign);\n        // }\n        // return finalsign * magnitude;\n    }\n    static atanhelper(s) {\n        let t = s * s;\n        let u = -1.88796008463073496563746e-05;\n        u = u * t + (0.000209850076645816976906797);\n        u = u * t + (-0.00110611831486672482563471);\n        u = u * t + (0.00370026744188713119232403);\n        u = u * t + (-0.00889896195887655491740809);\n        u = u * t + (0.016599329773529201970117);\n        u = u * t + (-0.0254517624932312641616861);\n        u = u * t + (0.0337852580001353069993897);\n        u = u * t + (-0.0407629191276836500001934);\n        u = u * t + (0.0466667150077840625632675);\n        u = u * t + (-0.0523674852303482457616113);\n        u = u * t + (0.0587666392926673580854313);\n        u = u * t + (-0.0666573579361080525984562);\n        u = u * t + (0.0769219538311769618355029);\n        u = u * t + (-0.090908995008245008229153);\n        u = u * t + (0.111111105648261418443745);\n        u = u * t + (-0.14285714266771329383765);\n        u = u * t + (0.199999999996591265594148);\n        u = u * t + (-0.333333333333311110369124);\n        return u * t * s + s;\n    }\n    ;\n    static atan2k(y, x) {\n        let q = 0.;\n        if (x < 0) {\n            x = -x;\n            q = -2.;\n        }\n        if (y > x) {\n            let t = x;\n            x = y;\n            y = -t;\n            q += 1.;\n        }\n        return Hploc.atanhelper(y / x) + q * (Math.PI / 2);\n    }\n    ;\n    /** This method calculates the arc tangent of y/x in radians, using\n    the signs of the two arguments to determine the quadrant of the\n    result. The results may have maximum error of 2 ulps. */\n    static atan2(y, x) {\n        let r = Hploc.atan2k(Math.abs(y), x);\n        r = Hploc.mulsign(r, x);\n        if (Hploc.isinf(x) || x == 0) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI / 2)) : 0);\n        }\n        if (Hploc.isinf(y)) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI * 1 / 4)) : 0);\n        }\n        if (y == 0) {\n            r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);\n        }\n        return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);\n    }\n    ;\n    /** Checks if the argument is a NaN or not. */\n    static isnan(d) {\n        return d != d;\n    }\n    ;\n    /** Checks if the argument is either positive or negative infinity. */\n    static isinf(d) {\n        return Math.abs(d) === +Infinity;\n    }\n    ;\n}\nHploc.PI4_A = 0.7853981554508209228515625;\nHploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\nHploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\nHploc.M_1_PI = 0.3183098861837906715377675267450287;\n//# sourceMappingURL=Hploc.js.map","import { Hploc } from './Hploc.js';\nexport class Pointing {\n    /**\n     *\n     * @param {*} vec3 Vec3.js\n     * @param {*} mirror\n     * @param {*} in_theta radians\n     * @param {*} in_phi radians\n     */\n    constructor(vec3, mirror, in_theta, in_phi) {\n        if (vec3 != null) {\n            this.theta = Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);\n            if (mirror) {\n                this.phi = -Hploc.atan2(vec3.y, vec3.x);\n            }\n            else {\n                this.phi = Hploc.atan2(vec3.y, vec3.x);\n            }\n            if (this.phi < 0.0) {\n                this.phi = this.phi + 2 * Math.PI;\n            }\n            if (this.phi >= 2 * Math.PI) {\n                this.phi = this.phi - 2 * Math.PI;\n            }\n        }\n        else {\n            this.theta = in_theta;\n            this.phi = in_phi;\n        }\n    }\n}\n//# sourceMappingURL=Pointing.js.map","/**\n * Partial porting to Javascript of Vec3.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nimport { Pointing } from './Pointing.js';\nexport class Vec3 {\n    constructor(in_x, in_y, in_z) {\n        if (in_x instanceof Pointing) {\n            let ptg = in_x;\n            let sth = Hploc.sin(ptg.theta);\n            this.x = sth * Hploc.cos(ptg.phi);\n            this.y = sth * Hploc.sin(ptg.phi);\n            this.z = Hploc.cos(ptg.theta);\n        }\n        else {\n            this.x = in_x;\n            this.y = in_y;\n            this.z = in_z;\n        }\n    }\n    getX() {\n        return this.x;\n    }\n    ;\n    getY() {\n        return this.y;\n    }\n    ;\n    getZ() {\n        return this.z;\n    }\n    ;\n    /** Scale the vector by a given factor\n    @param n the scale factor */\n    scale(n) {\n        this.x *= n;\n        this.y *= n;\n        this.z *= n;\n    }\n    ;\n    /** Vector cross product.\n    @param v another vector\n    @return the vector cross product between this vector and {@code v} */\n    cross(v) {\n        return new Vec3(this.y * v.z - v.y * this.z, this.z * v.x - v.z * this.x, this.x * v.y - v.x * this.y);\n    }\n    ;\n    /** Vector addition\n        * @param v the vector to be added\n        * @return addition result */\n    add(v) {\n        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    ;\n    /** Normalize the vector */\n    normalize() {\n        let d = 1. / this.length();\n        this.x *= d;\n        this.y *= d;\n        this.z *= d;\n    }\n    ;\n    /** Return normalized vector */\n    norm() {\n        let d = 1. / this.length();\n        return new Vec3(this.x * d, this.y * d, this.z * d);\n    }\n    ;\n    /** Vector length\n    @return the length of the vector. */\n    length() {\n        return Math.sqrt(this.lengthSquared());\n    }\n    ;\n    /** Squared vector length\n        @return the squared length of the vector. */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    ;\n    /** Computes the dot product of the this vector and {@code v1}.\n     * @param v1 another vector\n     * @return dot product */\n    dot(v1) {\n        return this.x * v1.x + this.y * v1.y + this.z * v1.z;\n    }\n    ;\n    /** Vector subtraction\n     * @param v the vector to be subtracted\n     * @return subtraction result */\n    sub(v) {\n        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    ;\n    /** Angle between two vectors.\n    @param v1 another vector\n    @return the angle in radians between this vector and {@code v1};\n      constrained to the range [0,PI]. */\n    angle(v1) {\n        return Hploc.atan2(this.cross(v1).length(), this.dot(v1));\n    }\n    /** Invert the signs of all components */\n    flip() {\n        this.x *= -1.0;\n        this.y *= -1.0;\n        this.z *= -1.0;\n    }\n    static pointing2Vec3(pointing) {\n        let sth = Hploc.sin(pointing.theta);\n        let x = sth * Hploc.cos(pointing.phi);\n        let y = sth * Hploc.sin(pointing.phi);\n        let z = Hploc.cos(pointing.theta);\n        return new Vec3(x, y, z);\n    }\n    ;\n}\n//# sourceMappingURL=Vec3.js.map","import { Vec3 } from './Vec3.js';\nexport class CircleFinder {\n    /**\n     * @param point: Vec3\n     */\n    constructor(point) {\n        let np = point.length;\n        //HealpixUtils.check(np>=2,\"too few points\");\n        if (!(np >= 2)) {\n            console.log(\"too few points\");\n            return;\n        }\n        this.center = point[0].add(point[1]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 2; i < np; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle(point, i);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q: int\n     */\n    getCircle(point, q) {\n        this.center = point[0].add(point[q]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 1; i < q; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle2(point, i, q);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q1: int\n     * @param q2: int\n     */\n    getCircle2(point, q1, q2) {\n        this.center = point[q1].add(point[q2]);\n        this.center.normalize();\n        this.cosrad = point[q1].dot(this.center);\n        for (let i = 0; i < q1; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.center = (point[q1].sub(point[i])).cross(point[q2].sub(point[i]));\n                this.center.normalize();\n                this.cosrad = point[i].dot(this.center);\n                if (this.cosrad < 0) {\n                    this.center.flip();\n                    this.cosrad = -this.cosrad;\n                }\n            }\n        }\n    }\n    ;\n    getCenter() {\n        return new Vec3(this.center.x, this.center.y, this.center.z);\n    }\n    getCosrad() {\n        return this.cosrad;\n    }\n    ;\n}\n//# sourceMappingURL=CircleFinder.js.map","/**\n * Partial porting to Javascript of Fxyf.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nexport class Fxyf {\n    constructor(x, y, f) {\n        this.fx = x;\n        this.fy = y;\n        this.face = f;\n        // coordinate of the lowest corner of each face\n        this.jrll = new Uint8Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Uint8Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.halfpi = Math.PI / 2.;\n    }\n    toHploc() {\n        let loc = new Hploc();\n        let jr = this.jrll[this.face] - this.fx - this.fy;\n        let nr;\n        if (jr < 1) {\n            nr = jr;\n            let tmp = nr * nr / 3.;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > 3) {\n            nr = 4 - jr;\n            let tmp = nr * nr / 3.;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = 1;\n            loc.z = (2 - jr) * 2.0 / 3.;\n        }\n        let tmp = this.jpll[this.face] * nr + this.fx - this.fy;\n        if (tmp < 0) {\n            tmp += 8;\n        }\n        if (tmp >= 8) {\n            tmp -= 8;\n        }\n        loc.phi = (nr < 1e-15) ? 0 : (0.5 * this.halfpi * tmp) / nr;\n        return loc;\n    }\n    ;\n    toVec3() {\n        return this.toHploc().toVec3();\n    }\n    ;\n}\n//# sourceMappingURL=Fxyf.js.map","export class pstack {\n    /** Creation from individual components */\n    constructor(sz) {\n        this.p = new Array(sz);\n        this.o = new Int32Array(sz);\n        this.s = 0;\n        this.m = 0;\n    }\n    ;\n    /**\n     * @param p long\n     * @param o int\n     */\n    push(p_, o_) {\n        this.p[this.s] = p_;\n        this.o[this.s] = o_;\n        ++this.s;\n    }\n    ;\n    pop() {\n        --this.s;\n    }\n    ;\n    popToMark() {\n        this.s = this.m;\n    }\n    ;\n    size() {\n        return this.s;\n    }\n    ;\n    mark() {\n        this.m = this.s;\n    }\n    ;\n    otop() {\n        return this.o[this.s - 1];\n    }\n    ;\n    ptop() {\n        return this.p[this.s - 1];\n    }\n    ;\n}\n//# sourceMappingURL=pstack.js.map","export class RangeSet {\n    /**\n     * @param int cap: initial capacity\n     */\n    constructor(cap) {\n        if (cap < 0)\n            console.error(\"capacity must be positive\");\n        this.r = new Int32Array(cap << 1);\n        this.sz = 0;\n    }\n    ;\n    /** Append a single-value range to the object.\n    @param val value to append */\n    append(val) {\n        this.append1(val, val + 1);\n    }\n    ;\n    /** Append a range to the object.\n   @param a first long in range\n   @param b one-after-last long in range */\n    append1(a, b) {\n        if (a >= b)\n            return;\n        if ((this.sz > 0) && (a <= this.r[this.sz - 1])) {\n            if (a < this.r[this.sz - 2])\n                console.error(\"bad append operation\");\n            if (b > this.r[this.sz - 1])\n                this.r[this.sz - 1] = b;\n            return;\n        }\n        // this.ensureCapacity(this.sz+2);\n        let cap = this.sz + 2;\n        if (this.r.length < cap) {\n            let newsize = Math.max(2 * this.r.length, cap);\n            let rnew = new Int32Array(newsize);\n            rnew.set(this.r);\n            this.r = rnew;\n        }\n        this.r[this.sz] = a;\n        this.r[this.sz + 1] = b;\n        this.sz += 2;\n    }\n    ;\n    /** Make sure the object can hold at least the given number of entries.\n     * @param cap int\n     * */\n    ensureCapacity(cap) {\n        if (this.r.length < cap)\n            this.resize(Math.max(2 * this.r.length, cap));\n    }\n    ;\n    /**\n     * @param newsize int\n     */\n    resize(newsize) {\n        if (newsize < this.sz)\n            console.error(\"requested array size too small\");\n        if (newsize == this.r.length)\n            return;\n        let rnew = new Int32Array(newsize);\n        let sliced = this.r.slice(0, this.sz + 1);\n        //\t\tthis.arrayCopy(this.r, 0, rnew, 0, this.sz);\n        this.r = sliced;\n    }\n    ;\n}\n//# sourceMappingURL=RangeSet.js.map","/**\n * Partial porting to Javascript of Xyf.java from Healpix3.30\n */\nexport class Xyf {\n    constructor(x, y, f) {\n        this.ix = x;\n        this.iy = y;\n        this.face = f;\n    }\n}\n//# sourceMappingURL=Xyf.js.map","\"use strict\";\nimport { CircleFinder } from \"./CircleFinder.js\";\nimport { Constants } from \"./Constants.js\";\nimport { Fxyf } from \"./Fxyf.js\";\nimport { Hploc } from \"./Hploc.js\";\nimport { Pointing } from \"./Pointing.js\";\nimport { pstack } from \"./pstack.js\";\nimport { RangeSet } from \"./RangeSet.js\";\nimport { Vec3 } from \"./Vec3.js\";\nimport { Xyf } from \"./Xyf.js\";\nimport { Zphi } from \"./Zphi.js\";\n/**\n * Partial porting to Javascript of HealpixBase.java from Healpix3.30\n */\n// import Fxyf from './Fxyf.js';\n// import Hploc from './Hploc.js';\n// import Xyf from './Xyf.js';\n// import Vec3 from './Vec3.js';\n// import Pointing from './Pointing.js';\n// import CircleFinder from './CircleFinder.js';\n// import Zphi from './Zphi.js';\n// import pstack from './pstack.js';\n// import Constants from './Constants.js';\n// import RangeSet from './RangeSet.js';\nexport class Healpix {\n    constructor(nside_in) {\n        this.order_max = 29;\n        this.inv_halfpi = 2.0 / Math.PI;\n        this.twothird = 2.0 / 3.;\n        // console.log(\"twothird \"+this.twothird);\n        // this.ns_max=1L<<order_max;\n        this.ns_max = Math.pow(2, this.order_max);\n        this.ctab = new Uint16Array([\n            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,\n            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,\n            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,\n            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,\n            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,\n            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,\n            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,\n            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,\n            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,\n            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,\n            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,\n            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,\n            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,\n            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,\n            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,\n            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855\n        ]);\n        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,\n            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,\n            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,\n            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,\n            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,\n            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,\n            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,\n            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,\n            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,\n            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,\n            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,\n            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,\n            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,\n            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,\n            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,\n            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,\n            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,\n            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);\n        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);\n        this.facearray = [\n            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),\n            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),\n            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),\n            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]),\n            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),\n            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),\n            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),\n            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),\n            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]) // N\n        ];\n        // questo forse deve essere un UInt8Array. Viene usato da neighbours\n        this.swaparray = [\n            new Int16Array([0, 0, 3]),\n            new Int16Array([0, 0, 6]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([0, 0, 5]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([5, 0, 0]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([6, 0, 0]),\n            new Int16Array([3, 0, 0]) // N\n        ];\n        if (nside_in <= this.ns_max && nside_in > 0) {\n            this.nside = nside_in;\n            this.npface = this.nside * this.nside;\n            this.npix = 12 * this.npface;\n            this.order = this.nside2order(this.nside);\n            this.nl2 = 2 * this.nside;\n            this.nl3 = 3 * this.nside;\n            this.nl4 = 4 * this.nside;\n            this.fact2 = 4.0 / this.npix;\n            this.fact1 = (this.nside << 1) * this.fact2;\n            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap\n            // console.log(\"order: \"+this.order);\n            // console.log(\"nside: \"+this.nside);\n        }\n        this.bn = [];\n        this.mpr = [];\n        this.cmpr = [];\n        this.smpr = [];\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // Uncaught RangeError: Maximum call stack size exceeded\n        // MOVED TO computeBn()\n        //        for (let i=0; i <= this.order_max; ++i) {\n        //        \tthis.bn[i]=new Healpix(1<<i);\n        //        \tthis.mpr[i]=bn[i].maxPixrad();\n        //        \tthis.cmpr[i]=Math.cos(mpr[i]);\n        //        \tthis.smpr[i]=Math.sin(mpr[i]);\n        //        }\n    }\n    computeBn() {\n        for (let i = 0; i <= this.order_max; ++i) {\n            this.bn[i] = new Healpix(1 << i);\n            this.mpr[i] = this.bn[i].maxPixrad();\n            this.cmpr[i] = Hploc.cos(this.mpr[i]);\n            this.smpr[i] = Hploc.sin(this.mpr[i]);\n        }\n    }\n    getNPix() {\n        return this.npix;\n    }\n    ;\n    getBoundaries(pix) {\n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        // console.log(\"PIXEL: \"+pix);\n        // console.log(\"XYF \"+xyf.ix+\" \"+xyf.iy+\" \"+xyf.face);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        // let d = 1.0/(this.nside);\n        // console.log(\"------------------------\");\n        // console.log(\"xc, yc, dc \"+xc+\",\"+ yc+\",\"+ dc);\n        // console.log(\"xc+dc-d, yc+dc, xyf.face, d \"+(xc+dc) +\",\"+ (yc+dc)+\",\"+\n        // xyf.face+\",\"+ d);\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        // console.log(\"Points for npix: \"+pix);\n        // console.log(points);\n        // if (pix > 750){\n        // console.log(\"pix: \"+pix);\n        // console.log(\"dc: \"+dc);\n        // console.log(\"xyf.ix: \"+xyf.ix);\n        // console.log(\"xyf.iy: \"+xyf.iy);\n        // console.log(\"xc: \"+xc);\n        // console.log(\"yc: \"+yc);\n        // console.log(\"d: \"+d);\n        // }\n        return points;\n    }\n    ;\n    /** Returns a set of points along the boundary of the given pixel.\n     * Step 1 gives 4 points on the corners. The first point corresponds\n     * to the northernmost corner, the subsequent points follow the pixel\n     * boundary through west, south and east corners.\n     *\n     * @param pix pixel index number\n     * @param step the number of returned points is 4*step\n     * @return {@link Vec3} for each point\n     */\n    getBoundariesWithStep(pix, step) {\n        // var points = new Array(); \n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        let d = 1.0 / (this.nside * step);\n        for (let i = 0; i < step; i++) {\n            points[i] = new Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();\n            points[i + step] = new Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();\n            points[i + 2 * step] = new Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();\n            points[i + 3 * step] = new Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();\n        }\n        return points;\n    }\n    ;\n    getPointsForXyfNoStep(x, y, face) {\n        let nside = Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    getPointsForXyf(x, y, step, face) {\n        let nside = step * Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    /** Returns the neighboring pixels of ipix.\n    This method works in both RING and NEST schemes, but is\n    considerably faster in the NEST scheme.\n    @param ipix the requested pixel number.\n    @return array with indices of the neighboring pixels.\n      The returned array contains (in this order)\n      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor\n      of ipix. If a neighbor does not exist (this can only happen\n      for the W, N, E and S neighbors), its entry is set to -1. */\n    neighbours(ipix) {\n        let result = new Int32Array(8);\n        let xyf = this.nest2xyf(ipix);\n        let ix = xyf.ix;\n        let iy = xyf.iy;\n        let face_num = xyf.face;\n        var nsm1 = this.nside - 1;\n        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {\n            let fpix = Math.floor(face_num << (2 * this.order));\n            let px0 = this.spread_bits(ix);\n            let py0 = this.spread_bits(iy) << 1;\n            let pxp = this.spread_bits(ix + 1);\n            let pyp = this.spread_bits(iy + 1) << 1;\n            let pxm = this.spread_bits(ix - 1);\n            let pym = this.spread_bits(iy - 1) << 1;\n            result[0] = fpix + pxm + py0;\n            result[1] = fpix + pxm + pyp;\n            result[2] = fpix + px0 + pyp;\n            result[3] = fpix + pxp + pyp;\n            result[4] = fpix + pxp + py0;\n            result[5] = fpix + pxp + pym;\n            result[6] = fpix + px0 + pym;\n            result[7] = fpix + pxm + pym;\n        }\n        else {\n            for (let i = 0; i < 8; ++i) {\n                let x = ix + this.xoffset[i];\n                let y = iy + this.yoffset[i];\n                let nbnum = 4;\n                if (x < 0) {\n                    x += this.nside;\n                    nbnum -= 1;\n                }\n                else if (x >= this.nside) {\n                    x -= this.nside;\n                    nbnum += 1;\n                }\n                if (y < 0) {\n                    y += this.nside;\n                    nbnum -= 3;\n                }\n                else if (y >= this.nside) {\n                    y -= this.nside;\n                    nbnum += 3;\n                }\n                let f = this.facearray[nbnum][face_num];\n                if (f >= 0) {\n                    let bits = this.swaparray[nbnum][face_num >>> 2];\n                    if ((bits & 1) > 0) {\n                        x = Math.floor(this.nside - x - 1);\n                    }\n                    if ((bits & 2) > 0) {\n                        y = Math.floor(this.nside - y - 1);\n                    }\n                    if ((bits & 4) > 0) {\n                        let tint = x;\n                        x = y;\n                        y = tint;\n                    }\n                    result[i] = this.xyf2nest(x, y, f);\n                }\n                else {\n                    result[i] = -1;\n                }\n            }\n        }\n        return result;\n    }\n    ;\n    nside2order(nside) {\n        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);\n    }\n    ;\n    nest2xyf(ipix) {\n        let pix = Math.floor(ipix & (this.npface - 1));\n        let xyf = new Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1), Math.floor((ipix >> (2 * this.order))));\n        return xyf;\n    }\n    ;\n    xyf2nest(ix, iy, face_num) {\n        return Math.floor(face_num << (2 * this.order))\n            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);\n    }\n    ;\n    loc2pix(hploc) {\n        let z = hploc.z;\n        let phi = hploc.phi;\n        let za = Math.abs(z);\n        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0); // in [0,4)\n        let pixNo;\n        if (za <= this.twothird) { // Equatorial region\n            let temp1 = this.nside * (0.5 + tt);\n            let temp2 = this.nside * (z * 0.75);\n            let jp = Math.floor(temp1 - temp2); // index of ascending edge line\n            let jm = Math.floor(temp1 + temp2); // index of descending edge line\n            let ifp = Math.floor(jp >>> this.order); // in {0,4}\n            let ifm = Math.floor(jm >>> this.order);\n            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));\n            let ix = Math.floor(jm & (this.nside - 1));\n            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);\n            pixNo = this.xyf2nest(ix, iy, face_num);\n        }\n        else { // polar region, za > 2/3\n            let ntt = Math.min(3, Math.floor(tt));\n            let tp = tt - ntt;\n            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?\n                this.nside * Math.sqrt(3 * (1 - za)) :\n                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);\n            let jp = Math.floor(tp * tmp); // increasing edge line index\n            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index\n            if (jp >= this.nside) {\n                jp = this.nside - 1; // for points too close to the boundary\n            }\n            if (jm >= this.nside) {\n                jm = this.nside - 1;\n            }\n            if (z >= 0) {\n                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);\n            }\n            else {\n                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);\n            }\n        }\n        return pixNo;\n    }\n    ;\n    /** Returns the normalized 3-vector corresponding to the center of the\n    supplied pixel.\n    @param pix long the requested pixel number.\n    @return the pixel's center coordinates. */\n    pix2vec(pix) {\n        return this.pix2loc(pix).toVec3();\n    }\n    ;\n    /** Returns the Zphi corresponding to the center of the supplied pixel.\n     @param pix the requested pixel number.\n     @return the pixel's center coordinates. */\n    pix2zphi(pix) {\n        return this.pix2loc(pix).toZphi();\n    }\n    /**\n     * @param pix long\n     * @return Hploc\n     */\n    pix2loc(pix) {\n        let loc = new Hploc(undefined);\n        let xyf = this.nest2xyf(pix);\n        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;\n        let nr;\n        if (jr < this.nside) {\n            nr = jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > this.nl3) {\n            nr = this.nl4 - jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = this.nside;\n            loc.z = (this.nl2 - jr) * this.fact1;\n        }\n        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;\n        //      \tassert(tmp<8*nr); // must not happen\n        if (tmp < 0) {\n            tmp += 8 * nr;\n        }\n        loc.phi = (nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp) / nr;\n        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);\n        return loc;\n    }\n    ;\n    ang2pix(ptg, mirror) {\n        return this.loc2pix(new Hploc(ptg));\n    }\n    ;\n    fmodulo(v1, v2) {\n        if (v1 >= 0) {\n            return (v1 < v2) ? v1 : v1 % v2;\n        }\n        var tmp = v1 % v2 + v2;\n        return (tmp === v2) ? 0.0 : tmp;\n    }\n    ;\n    compress_bits(v) {\n        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));\n        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);\n        return compressed;\n    }\n    ;\n    spread_bits(v) {\n        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))\n            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));\n    }\n    ;\n    /**\n     * Returns a range set of pixels that overlap with the convex polygon\n     * defined by the {@code vertex} array.\n     * <p>\n     * This method is more efficient in the RING scheme.\n     * <p>\n     * This method may return some pixels which don't overlap with the polygon\n     * at all. The higher {@code fact} is chosen, the fewer false positives are\n     * returned, at the cost of increased run time.\n     *\n     * @param vertex\n     *            an array containing the vertices of the requested convex\n     *            polygon.\n     * @param fact\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return the requested set of pixel number ranges\n     */\n    queryPolygonInclusive(vertex, fact) {\n        let inclusive = (fact != 0);\n        let nv = vertex.length;\n        //        let ncirc = inclusive ? nv+1 : nv;\n        if (!(nv >= 3)) {\n            console.log(\"not enough vertices in polygon\");\n            return;\n        }\n        let vv = new Array();\n        for (let i = 0; i < nv; ++i) {\n            vv[i] = Vec3.pointing2Vec3(vertex[i]);\n        }\n        let normal = new Array();\n        let flip = 0;\n        let index = 0;\n        let back = false;\n        while (index < vv.length) {\n            let first = vv[index];\n            let medium = null;\n            let last = null;\n            if (index == vv.length - 1) {\n                last = vv[1];\n                medium = vv[0];\n            }\n            else if (index == vv.length - 2) {\n                last = vv[0];\n                medium = vv[index + 1];\n            }\n            else {\n                medium = vv[index + 1];\n                last = vv[index + 2];\n            }\n            normal[index] = first.cross(medium).norm();\n            let hnd = normal[index].dot(last);\n            if (index == 0) {\n                flip = (hnd < 0.) ? -1 : 1;\n                let tmp = new Pointing(first); // TODO not used\n                back = false;\n            }\n            else {\n                let flipThnd = flip * hnd;\n                if (flipThnd < 0) {\n                    let tmp = new Pointing(medium);\n                    vv.splice(index + 1, 1);\n                    normal.splice(index, 1);\n                    back = true;\n                    index -= 1;\n                    continue;\n                }\n                else {\n                    let tmp = new Pointing(first);\n                    back = false;\n                }\n            }\n            normal[index].scale(flip);\n            index += 1;\n        }\n        nv = vv.length;\n        let ncirc = inclusive ? nv + 1 : nv;\n        let rad = new Array(ncirc);\n        rad = rad.fill(Constants.halfpi);\n        //        rad = rad.fill(1.5707963267948966);\n        //        let p = \"1.5707963267948966\";\n        //        rad = rad.fill(parseFloat(p));\n        if (inclusive) {\n            let cf = new CircleFinder(vv);\n            normal[nv] = cf.getCenter();\n            rad[nv] = Hploc.acos(cf.getCosrad());\n        }\n        return this.queryMultiDisc(normal, rad, fact);\n    }\n    ;\n    /**\n     * For NEST schema only\n     *\n     * @param normal:\n     *            Vec3[]\n     * @param rad:\n     *            Float32Array\n     * @param fact:\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return RangeSet the requested set of pixel number ranges\n     */\n    queryMultiDisc(norm, rad, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let nv = norm.length;\n        // HealpixUtils.check(nv==rad.lengt0,\"inconsistent input arrays\");\n        if (!(nv == rad.length)) {\n            console.error(\"inconsistent input arrays\");\n            return;\n        }\n        let res = new RangeSet(4 << 1);\n        // Removed code for Scheme.RING\n        let oplus = 0;\n        if (inclusive) {\n            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {\n                console.error(\"invalid oversampling factor\");\n            }\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = this.order + oplus; // the order up to which we test\n        // TODO: ignore all disks with radius>=pi\n        //        let crlimit = new Float32Array[omax+1][nv][3];\n        let crlimit = new Array(omax + 1);\n        let o;\n        let i;\n        for (o = 0; o <= omax; ++o) { // prepare data at the required orders\n            crlimit[o] = new Array(nv);\n            let dr = this.bn[o].maxPixrad(); // safety distance\n            for (i = 0; i < nv; ++i) {\n                crlimit[o][i] = new Float64Array(3);\n                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Hploc.cos(rad[i] + dr);\n                crlimit[o][i][1] = (o == 0) ? Hploc.cos(rad[i]) : crlimit[0][i][1];\n                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : Hploc.cos(rad[i] - dr);\n            }\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse\n            // order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let o = stk.otop();\n            stk.pop();\n            let pv = this.bn[o].pix2vec(pix);\n            let zone = 3;\n            for (let i = 0; (i < nv) && (zone > 0); ++i) {\n                let crad = pv.dot(norm[i]);\n                for (let iz = 0; iz < zone; ++iz) {\n                    if (crad < crlimit[o][i][iz]) {\n                        zone = iz;\n                    }\n                }\n            }\n            if (zone > 0) {\n                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);\n            }\n        }\n        return res;\n    }\n    ;\n    /** Integer base 2 logarithm.\n    @param arg\n    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.\n    For negative arguments and zero, 0 is returned. */\n    ilog2(arg) {\n        let max = Math.max(arg, 1);\n        return 31 - Math.clz32(max);\n    }\n    ;\n    /** Computes the cosine of the angular distance between two z, phi positions\n      on the unit sphere. */\n    cosdist_zphi(z1, phi1, z2, phi2) {\n        return z1 * z2 + Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));\n    }\n    /**\n     * @param int o\n     * @param int omax\n     * @param int zone\n     * @param RangeSet pixset\n     * @param long pix\n     * @param pstack stk\n     * @param boolean inclusive\n     */\n    check_pixel(o, omax, zone, pixset, pix, stk, inclusive) {\n        if (zone == 0)\n            return;\n        if (o < this.order) {\n            if (zone >= 3) { // output all subpixels\n                let sdist = 2 * (this.order - o); // the \"bit-shift distance\" between map orders\n                pixset.append1(pix << sdist, ((pix + 1) << sdist));\n            }\n            else { // (zone>=1)\n                for (let i = 0; i < 4; ++i) {\n                    stk.push(4 * pix + 3 - i, o + 1); // add children\n                }\n            }\n        }\n        else if (o > this.order) { // this implies that inclusive==true\n            if (zone >= 2) { // pixel center in shape\n                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                stk.popToMark(); // unwind the stack\n            }\n            else { // (zone>=1): pixel center in safety range\n                if (o < omax) { // check sublevels\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                    stk.popToMark(); // unwind the stack\n                }\n            }\n        }\n        else { // o==order\n            if (zone >= 2) {\n                pixset.append(pix);\n            }\n            else if (inclusive) { // and (zone>=1)\n                if (this.order < omax) { // check sublevels\n                    stk.mark(); // remember current stack position\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix); // output the pixel\n                }\n            }\n        }\n    }\n    /** Returns the maximum angular distance between a pixel center and its\n    corners.\n    @return maximum angular distance between a pixel center and its\n      corners. */\n    maxPixrad() {\n        let zphia = new Zphi(2. / 3., Math.PI / this.nl4);\n        let xyz1 = this.convertZphi2xyz(zphia);\n        let va = new Vec3(xyz1[0], xyz1[1], xyz1[2]);\n        let t1 = 1. - 1. / this.nside;\n        t1 *= t1;\n        let zphib = new Zphi(1 - t1 / 3, 0);\n        let xyz2 = this.convertZphi2xyz(zphib);\n        let vb = new Vec3(xyz2[0], xyz2[1], xyz2[2]);\n        return va.angle(vb);\n    }\n    ;\n    /**\n     * this is a workaround replacing the Vec3(Zphi) constructor.\n     */\n    convertZphi2xyz(zphi) {\n        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));\n        let x = sth * Hploc.cos(zphi.phi);\n        let y = sth * Hploc.sin(zphi.phi);\n        let z = zphi.z;\n        return [x, y, z];\n    }\n    ;\n    /** Returns a range set of pixels which overlap with a given disk. <p>\n      This method is more efficient in the RING scheme. <p>\n      This method may return some pixels which don't overlap with\n      the polygon at all. The higher {@code fact} is chosen, the fewer false\n      positives are returned, at the cost of increased run time.\n      @param ptg the angular coordinates of the disk center\n      @param radius the radius (in radians) of the disk\n      @param fact The overlapping test will be done at the resolution\n        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power\n        of 2, else it can be any positive integer. A typical choice would be 4.\n      @return the requested set of pixel number ranges  */\n    queryDiscInclusive(ptg, radius, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let pixset = new RangeSet();\n        if (radius >= Math.PI) { // disk covers the whole sphere\n            pixset.append1(0, this.npix);\n            return pixset;\n        }\n        let oplus = 0;\n        if (inclusive) {\n            // HealpixUtils.check ((1L<<order_max)>=fact,\"invalid oversampling factor\");\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test\n        let vptg = Vec3.pointing2Vec3(ptg);\n        let crpdr = new Array(omax + 1);\n        let crmdr = new Array(omax + 1);\n        let cosrad = Hploc.cos(radius);\n        let sinrad = Hploc.sin(radius);\n        for (let o = 0; o <= omax; o++) { // prepare data at the required orders\n            let dr = this.mpr[o]; // safety distance\n            let cdr = this.cmpr[o];\n            let sdr = this.smpr[o];\n            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;\n            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let curro = stk.otop();\n            stk.pop();\n            let pos = this.bn[curro].pix2zphi(pix);\n            // cosine of angular distance between pixel center and disk center\n            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);\n            if (cangdist > crpdr[curro]) {\n                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);\n                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);\n            }\n        }\n        return pixset;\n    }\n}\n//# sourceMappingURL=Healpix.js.map","\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { Healpix } from 'healpixjs';\nimport { Pointing } from \"healpixjs\";\nimport { Hploc } from \"healpixjs\";\n\nimport { radToDeg } from '../model/Utils.js'; // TODO change package\nimport { CoordsType } from \"../model/CoordsType.js\";\nimport { HEALPixXYSpace } from \"../model/HEALPixXYSpace.js\";\nimport { Point } from \"../model/Point.js\";\nimport { NumberType } from '../model/NumberType.js';\nimport { AstroCoords } from \"../model/AstroCoords.js\";\n\nexport class HiPSHelper {\n\n\n\t// static pxXtile: number = 512; // TODO in some cases it is different\n\tstatic DEFAULT_Naxis1_2: number = 512;\n\t// static RES_ORDER_0: number = 58.6 / HiPSHelper.pxXtile;\n\tstatic RES_ORDER_0: number = 58.6;\n\tstatic H: number = 4;\n\tstatic K: number = 3;\n\tstatic THETAX: number = Hploc.asin((HiPSHelper.K - 1) / HiPSHelper.K);\n\t/**\n\t * Table 1 - ref paper HEALPix — a Framework for High Resolution Discretization,\n\t * and Fast Analysis of Data Distributed on the Sphere\n\t * K. M. G´orski1,2, E. Hivon3,4, A. J. Banday5, B. D. Wandelt6,7, F. K. Hansen8, M.\n\t * Reinecke5, M. Bartelman9\n\t */\n\t/**\n\t * \n\t * @param {decimal degrees} pxsize \n\t * @returns {int} nside\n\t */\n\tstatic computeHiPSOrder(pxsize: number, pxXtile: number): number {\n\t\t/**\n\t\t * with same order k (table 1), HIPS angular resolution is higher of order of 512 (2^9) pixels than \n\t\t * the HEALPix. This is because each tile in a HiPS is represented by default by 512x512 pixels.\\\n\t\t * Angular resolution of different HEALPix orders in respect to the order 0, can be calculated this\n\t\t * way:\n\t\t * \n\t\t * \tL(k) = L(0) / 2^k = 58.6 / 2^k\n\t\t * \n\t\t * Therefore, in the case of HiPS we need to take into account the extra resolution given by the \n\t\t * 512x512 (2^9) tiles. In this case the above becomes:\n\t\t * \t\n\t\t * \tL(k) = L(0) / (2^k * 2^9) \n\t\t * \n\t\t * Though, in order to compute the required order starting from the pxsize desired (in input) we\n\t\t * need to perform these steps:\n\t\t * \n\t\t * \tpxsize = L(k) = L(0) / (2^k * 2^9)\n\t\t * \t2^k = L(0) / (pxsize * 2^9)\n\t\t *  k * Log2 2 = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \tk = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \n\t\t */\n\n\n\t\tlet k = Math.log2( (HiPSHelper.RES_ORDER_0 / pxXtile) / pxsize);\n\t\t// let k = Math.log2(HiPSHelper.RES_ORDER_0 / (pxXtile * pxsize));\n\t\tk = Math.round(k);\n\t\t// let theta0px = HiPSHelper.RES_ORDER_0;\n\t\t// let k = Math.log2(theta0px) - Math.log2(pxsize * 2**9);\n\t\t// k = Match.round(k);\n\t\t// let nside = 2**k;\n\t\t// return {\n\t\t//     \"nside\" : nside,\n\t\t//     \"norder\" : k\n\t\t// };\n\t\treturn k;\n\n\t}\n\tstatic computeHiPSOrder2(pxsize: number, pxXtile: number): number {\n\t\t\n\t\tconst k = Math.log2( Math.sqrt(Math.PI/ 3) / ( pxsize * pxXtile) )\n\t\tconst order = Math.round(k);\n\t\tconsole.warn(k)\n \n\t\treturn order;\n\n\t}\n\n\n\t// based on \"HiPS – Hierarchical Progressive Survey\" IVOA recomandation (formula on table 5)\n\tstatic computeOrder(pxAngSizeDeg: number, pxTileWidth: number): number {\n\t\tconsole.log(`Computing HiPS order having pixel angular size of ${pxAngSizeDeg} in degrees`)\n\t\tconst deg2rad = Math.PI / 180\n\t\tconst pxAngSizeRad = pxAngSizeDeg * deg2rad\n\t\tconsole.log(`pixel angular res in radians ${pxAngSizeRad}`)\n\t\tconst computedOrder = 0.5 * Math.log2 ( Math.PI / (3 * pxAngSizeRad * pxAngSizeRad * pxTileWidth * pxTileWidth) )\n\t\tconsole.log(`Order ${computedOrder}`)\n\t\tif (computedOrder < 0) {\n\t\t\treturn 0\n\t\t}\n\t\treturn Math.floor(computedOrder)\n\t}\n\n\t// based on \"HiPS – Hierarchical Progressive Survey\" IVOA recomandation (formula on table 5)\n\tstatic computePxAngularSize(pxTileWidth: number, order: number) {\n\t\tconst computedPxAngSizeRadiant = Math.sqrt( 4 * Math.PI / (12 * (pxTileWidth * (2**order) )**2 ) )\n\t\tconsole.log(`Computing Pixel size with tile of ${pxTileWidth} pixels and order ${order}`)\n\t\tconst rad2deg = 180 / Math.PI\n\t\tconst deg = computedPxAngSizeRadiant * rad2deg\n\t\tconst arcmin = computedPxAngSizeRadiant * rad2deg * 60\n\t\tconst arcsec = computedPxAngSizeRadiant * rad2deg * 3600\n\t\tconsole.log (\"Pixel size in radiant:\" + computedPxAngSizeRadiant)\n\t\tconsole.log (\"Pixel size in degrees:\" + deg)\n\t\tconsole.log (\"Pixel size in arcmin:\" + arcmin)\n\t\tconsole.log (\"Pixel size in arcsec:\" + arcsec)\n\t\treturn {\n\t\t\t\"rad\": computedPxAngSizeRadiant,\n\t\t\t\"deg\": deg,\n\t\t\t\"arcmin\": arcmin,\n\t\t\t\"arcsec\": arcsec\n\t\t}\n\t}\n\n\n\t/**\n\t * Reference: HiPS – Hierarchical Progressive Survey page 11\n\t * pxsize =~ sqrt[4 * PI / (12 * (512 * 2^order)^2)]\n\t * @param {*} order \n\t */\n\tstatic computePxSize(order: number, pxXtile: number): number {\n\t\t// TODO CHECK IT\n\t\t// let pxsize = 1 / (512 * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\tlet pxsize = 1 / (pxXtile * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\treturn pxsize;\n\t}\n\n\t// /**\n\t//  * \n\t//  * @param {Object {ra, dec}} point  decimal degrees\n\t//  * @returns {Object {phi_rad, theta_rad}} in radians\n\t//  */\n\t// static convert2PhiTheta (point: Point) {\n\t// \tlet phitheta_rad = {};\n\t// \tlet phiTheta_deg = HiPSHelper.astroDegToSpherical(point.ra, point.dec);\n\t// \tphitheta_rad.phi_rad = HiPSHelper.degToRad(phiTheta_deg.phi);\n\t//     phitheta_rad.theta_rad = HiPSHelper.degToRad(phiTheta_deg.theta);\n\t// \treturn phitheta_rad;\n\t// }\n\n\t// static astroDegToSphericalRad(raDeg: number, decDeg: number) {\n\t// \tlet phiThetaDeg = HiPSHelper.astroDegToSpherical(raDeg, decDeg);\n\t// \tlet phiThetaRad = {\n\t// \t\tphi_rad: HiPSHelper.degToRad(phiThetaDeg.phi),\n\t// \t\ttheta_rad: HiPSHelper.degToRad(phiThetaDeg.theta)\n\t// \t}\n\t// \treturn phiThetaRad;\n\t// }\n\n\t// static degToRad(degrees: number): number {\n\t// \treturn (degrees / 180 ) * Math.PI ;\n\t// }\n\n\t// static radToDeg(rad: number): number {\n\t// \treturn (rad / Math.PI ) * 180 ;\n\t// }\n\n\t// static astroDegToSpherical(raDeg: number, decDeg: number): Point{\n\n\t// \tlet phiDeg: number;\n\t// \tlet thetaDeg: number;\n\t// \tphiDeg = raDeg;\n\t// \tif (phiDeg < 0){\n\t// \t\tphiDeg += 360;\n\t// \t}\n\n\t// \tthetaDeg = 90 - decDeg;\n\n\t// \treturn {\n\t// \t\tphi: phiDeg,\n\t// \t\ttheta: thetaDeg\n\t// \t};\n\t// }\n\n\t/**\n\t * \n\t * @param {Object {phi_rad, theta_rad}} phiTheta_rad Center of the circle in radians\n\t * @param {decimal} r Radius of the circle in radians\n\t * @returns \n\t */\n\tstatic computeBbox(point: Point, r: number): number[] {\n\n\t\tlet bbox = [];\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad + r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\n\t\treturn bbox;\n\t}\n\n\tstatic setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n\n\t\tlet xyGridProj: HEALPixXYSpace = {\n\t\t\t\"min_y\": NaN,\n\t\t\t\"max_y\": NaN,\n\t\t\t\"min_x\": NaN,\n\t\t\t\"max_x\": NaN,\n\t\t\t\"gridPointsDeg\": []\n\t\t}\n\n\n\t\tlet cornersVec3 = hp.getBoundariesWithStep(tileno, 1);\n\t\tlet pointings = [];\n\n\t\tfor (let i = 0; i < cornersVec3.length; i++) {\n\t\t\tpointings[i] = new Pointing(cornersVec3[i]);\n\t\t\tif (i >= 1) {\n\t\t\t\tlet a = pointings[i - 1].phi;\n\t\t\t\tlet b = pointings[i].phi;\n\t\t\t\t// case when RA is just crossing the origin (e.g. 357deg - 3deg)\n\t\t\t\tif (Math.abs(a - b) > Math.PI) {\n\t\t\t\t\tif (pointings[i - 1].phi < pointings[i].phi) {\n\t\t\t\t\t\tpointings[i - 1].phi += 2 * Math.PI;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpointings[i].phi += 2 * Math.PI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let j = 0; j < pointings.length; j++) {\n\t\t\tlet coThetaRad = pointings[j].theta;\n\t\t\t// HEALPix works with colatitude (0 North Pole, 180 South Pole)\n\t\t\t// converting the colatitude in latitude (dec)\n\t\t\tlet decRad = Math.PI / 2 - coThetaRad;\n\n\t\t\tlet raRad = pointings[j].phi;\n\n\t\t\t// projection on healpix grid\n\t\t\tlet p = new Point(CoordsType.ASTRO, NumberType.RADIANS, raRad, decRad);\n\t\t\tlet xyDeg = HiPSHelper.world2intermediate(p.astro);\n\t\t\txyGridProj.gridPointsDeg[j * 2] = xyDeg[0];\n\t\t\txyGridProj.gridPointsDeg[j * 2 + 1] = xyDeg[1];\n\n\t\t\tif (isNaN(xyGridProj.max_y) || xyDeg[1] > xyGridProj.max_y) {\n\t\t\t\txyGridProj.max_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_y) || xyDeg[1] < xyGridProj.min_y) {\n\t\t\t\txyGridProj.min_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.max_x) || xyDeg[0] > xyGridProj.max_x) {\n\t\t\t\txyGridProj.max_x = xyDeg[0];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_x) || xyDeg[0] < xyGridProj.min_x) {\n\t\t\t\txyGridProj.min_x = xyDeg[0];\n\t\t\t}\n\n\t\t}\n\t\treturn xyGridProj;\n\t}\n\n\tstatic world2intermediate(ac: AstroCoords): [number, number] {\n\n\t\tlet x_grid: number;\n\t\tlet y_grid: number;\n\n\t\tif (Math.abs(ac.decRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t\t\tx_grid = ac.raDeg;\n\n\t\t\ty_grid = Hploc.sin(ac.decRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t\t} else if (Math.abs(ac.decRad) > HiPSHelper.THETAX) { // polar zones\n\n\t\t\tlet raDeg = ac.raDeg;\n\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\n\t\t\tlet sigma = Math.sqrt(HiPSHelper.K * (1 - Math.abs(Hploc.sin(ac.decRad))));\n\t\t\tlet phi_c = - 180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSHelper.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSHelper.H);\n\n\t\t\tx_grid = phi_c + (raDeg - phi_c) * sigma;\n\t\t\ty_grid = (180 / HiPSHelper.H) * (((HiPSHelper.K + 1) / 2) - sigma);\n\n\t\t\tif (ac.decRad < 0) {\n\t\t\t\ty_grid *= -1;\n\t\t\t}\n\t\t}\n\n\t\treturn [x_grid, y_grid];\n\n\t}\n\n\t// static world2intermediate(sc: SphericalCoords): [number, number] {\n\t//     let x_grid: number;\n\t// \tlet y_grid: number;\n\n\t// \tif ( Math.abs(sc.thetaRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t// \t\tx_grid = sc.phiDeg;\n\n\t// \t\ty_grid = Hploc.sin(sc.thetaRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t// \t} else if ( Math.abs(sc.thetaRad) > HiPSHelper.THETAX) { // polar zones\n\n\t// \t\tlet phiDeg = sc.phiDeg;\n\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || sc.thetaRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\n\t// \t\tlet sigma = Math.sqrt( HiPSHelper.K * (1 - Math.abs(Hploc.sin(sc.thetaRad)) ) );\n\t// \t\tlet phi_c = - 180 + ( 2 * Math.floor( ((sc.phiRad + 180) * HiPSHelper.H/360) + ((1 - w)/2) ) + w ) * ( 180 / HiPSHelper.H );\n\n\t// \t\tx_grid = phi_c + (phiDeg - phi_c) * sigma;\n\t// \t\ty_grid = (180  / HiPSHelper.H) * ( ((HiPSHelper.K + 1)/2) - sigma);\n\n\t// \t\tif (sc.thetaRad < 0) {\n\t// \t\t\ty_grid *= -1;\n\t// \t\t}\n\t// \t}\n\n\t// \treturn [x_grid, y_grid];\n\n\t// }\n\n\tstatic intermediate2pix(x: number, y: number, xyGridProj: HEALPixXYSpace, pxXtile: number): [number, number] {\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);\n\n\t\tlet i_norm: number;\n\t\tlet j_norm: number;\n\t\tif ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {\n\t\t\ti_norm = (x + 360 - xyGridProj.min_x) / xInterval;\n\t\t} else {\n\t\t\ti_norm = (x - xyGridProj.min_x) / xInterval;\n\t\t}\n\t\tj_norm = (y - xyGridProj.min_y) / yInterval;\n\n\n\t\tlet i = 0.5 - (i_norm - j_norm);\n\t\tlet j = (i_norm + j_norm) - 0.5;\n\n\t\t// TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);\n\t\tpxXtile\n\t\t// i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];\n\t\t\n\t\ti = Math.floor(i * pxXtile);\n\t\tj = Math.floor(j * pxXtile);\n\t\treturn [i, pxXtile - j - 1];\n\n\n\n\t}\n\n\n\tstatic pix2intermediate(i: number, j: number, xyGridProj: HEALPixXYSpace, naxis1: number, naxis2: number): [number, number] {\n\t\t/**\n\t\t   * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image\n\t\t * (i_norm,w_pixel) = (1,1) is the upper right corner\n\t\t * dimamond in figure 1 from \"Mapping on the HEalpix grid\" paper\n\t\t * (0,0) leftmost corner\n\t\t * (1,0) upper corner\n\t\t * (0,1) lowest corner\n\t\t * (1,1) rightmost corner\n\t\t * Thanks YAGO! :p\n\t\t */\n\t\t// let cnaxis1 = HiPSHelper.pxXtile;\n\t\t// let cnaxis2 = HiPSHelper.pxXtile;\n\n\t\tlet cnaxis1 = naxis1;\n\t\tlet cnaxis2 = naxis2;\n\t\tif (naxis1) {\n\t\t\tcnaxis1 = naxis1;\n\t\t}\n\t\tif (naxis2) {\n\t\t\tcnaxis2 = naxis2;\n\t\t}\n\t\tlet i_norm = (i + 0.5) / cnaxis1;\n\t\tlet j_norm = (j + 0.5) / cnaxis2;\n\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;\n\t\tlet yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;\n\n\t\t// bi-linear interpolation\n\t\tlet x = xyGridProj.max_x - xInterval * (i_norm + j_norm);\n\t\tlet y = yMean - yInterval * (j_norm - i_norm);\n\n\t\treturn [x, y];\n\t}\n\n\n\tstatic intermediate2world(x: number, y: number): Point {\n\n\t\tlet phiDeg: number;\n\t\tlet thetaDeg: number;\n\t\tlet Yx = 90 * (HiPSHelper.K - 1) / HiPSHelper.H;\n\n\n\n\t\tif (Math.abs(y) <= Yx) { // equatorial belts\n\n\t\t\tphiDeg = x;\n\t\t\tthetaDeg = radToDeg(Math.asin((y * HiPSHelper.H) / (90 * HiPSHelper.K)));\n\n\t\t} else if (Math.abs(y) > Yx) { // polar regions\n\n\t\t\tlet sigma = (HiPSHelper.K + 1) / 2 - Math.abs(y * HiPSHelper.H) / 180;\n\t\t\tlet thetaRad = Hploc.asin(1 - (sigma * sigma) / HiPSHelper.K);\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\t\t\tlet x_c = -180 + (2 * Math.floor((x + 180) * HiPSHelper.H / 360 + (1 - w) / 2) + w) * (180 / HiPSHelper.H);\n\t\t\tphiDeg = x_c + (x - x_c) / sigma;\n\t\t\tthetaDeg = radToDeg(thetaRad);\n\t\t\tif (y <= 0) {\n\t\t\t\tthetaDeg *= -1;\n\t\t\t}\n\t\t}\n\t\t// return [phiDeg, thetaDeg];\n\t\t// TODO CHECK THIS!\n\t\t// let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);\n\t\tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, phiDeg, thetaDeg);\n\n\t\treturn p;\n\n\t}\n\n}\n","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeaderManager } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\n\nimport { Healpix } from \"healpixjs\";\nimport { Pointing } from \"healpixjs\";\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { HEALPixXYSpace } from '../model/HEALPixXYSpace.js';\n\nimport { HiPSHelper } from './HiPSHelper.js';\n\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { astroToSpherical, degToRad, fillAstro, radToDeg } from '../model/Utils.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\nimport { INSPECT_MAX_BYTES } from 'buffer';\nimport { FITS } from '../model/FITS.js';\n\n\n\nexport class HiPSProjection extends AbstractProjection {\n\t\n\t_isGalactic: boolean = false;\n\t_pixno!: number;\n\t_tileslist!: number[];\n\t_hp!: Healpix;\n\t_fh_common!: FITSHeaderManager;\n\t_wcsname: string;\n\t_hipsBaseURI!: string;\n\t_fitsheaderlist: FITSHeaderManager[];\n\t_pxvalues: Map<number, Array<Uint8Array>>;\n\t_xyGridProj!: HEALPixXYSpace;\n\t_norder!: number;\n\t_nside!: number;\n\t_radeclist: Array<[number, number]>;\n\t_HIPS_TILE_WIDTH: number;\n\t_fitsUsed: String[] = [];\n\t_HIPS_MAX_ORDER: number;\n\n\t/**\n\t * \n\t * * ex with single local file:\n\t * let hp = new HiPSProjection('/mylocaldir/myfile.fits', null, null, null);\n\t * hp.initFromFile()\n\t * \n\t * * ex with single remote file:\n\t * let hp = new HiPSProjection('http://<hips-server>/Norder7/DirN/NpixXYZ.fits', null, null, null);\n\t * hp.initFromFile()\n\t *\n\t * * ex with HiPS server base local dir:\n\t * let hp = new HiPSProjection(null, <hips-local-root-dir>, pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t * * ex with HiPS server base URL:\n\t * let hp = new HiPSProjection(null, 'http://<hips-server>/<hips-root-dir>', pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t */\n\n\n\t//  constructor(fitsfilepath?: string, hipsBaseURI?: string, pxsize?: number, order?: number) {\n\tconstructor() {\n\t\tsuper(\"'RA---HPX'\", \"'DEC--HPX'\")\n\t\tthis._wcsname = \"HPX\"; // TODO check WCS standard\n\t\t// this._ctype1 = \"RA---HPX\";\n\t\t// this._ctype2 = \"DEC--HPX\";\n\n\t\tthis._pxvalues = new Map<number, Array<Uint8Array>>();\n\t\tthis._fitsheaderlist = new Array<FITSHeaderManager>();\n\t\tthis._radeclist = new Array<[number, number]>();\n\n\t}\n\n\tasync parsePropertiesFile(baseUrl: string): Promise<any> {\n\n\t\tconst propFile = await fetch(baseUrl + \"/properties\")\n\t\t// const fp = new FITSParser(null);\n\n\t\t// const promise = fp.getFile(baseUrl + \"/properties\").then((propFile: ArrayBuffer | Buffer) => {\n\t\t\tlet prop: string;\n\t\t\tif (propFile instanceof ArrayBuffer) {\n\t\t\t\tconst textDecoder = new TextDecoder(\"iso-8859-1\");\n\t\t\t\tprop = textDecoder.decode(new Uint8Array(propFile));\n\t\t\t} else {\n\t\t\t\t// prop = propFile.toString('utf8');\n\t\t\t\tprop = propFile.toString();\n\t\t\t}\n\t\t\t/**\n\t\t\t \tHiPS – Hierarchical Progressive Survey\n\t\t\t\tVersion 1.0\n\t\t\t\tIVOA Proposed Recommendation\n\t\t\t\t3rd April 2017\n\t\t\t\thttps://www.ivoa.net/documents/HiPS/20170403/PR-HIPS-1.0-20170403.pdf\n\t\t\t */\n\t\t\tconst txtArr = prop.split('\\n');\n\t\t\tthis._HIPS_TILE_WIDTH = 512;\n\t\t\tfor (let line of txtArr) {\n\t\t\t\tif (!line.includes(\"=\")){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst tokens = line.split(\"=\");\n\t\t\t\tif (tokens[1] === undefined){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst key = tokens[0].trim()\n\t\t\t\tconst val = tokens[1].trim()\n\n\t\t\t\tif (key == \"hips_order\") {\n\t\t\t\t\tthis._HIPS_MAX_ORDER = parseInt(val);\n\t\t\t\t\tconsole.log(\"hips_order \"+this._HIPS_MAX_ORDER)\n\t\t\t\t} else if (key == \"hips_tile_width\") {\n\t\t\t\t\tthis._HIPS_TILE_WIDTH = parseInt(val);\n\t\t\t\t\tsuper.naxis1 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tsuper.naxis2 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tconsole.log(\"hips_tile_width \"+this._HIPS_TILE_WIDTH)\n\t\t\t\t} else if (key == \"hips_frame\" && val == \"galactic\") {\n\t\t\t\t\tthis._isGalactic = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn propFile;\n\t\t// });\n\n\t\t// await promise;\n\t\t// return promise;\n\t}\n\n\tasync initFromFile(fitsfilepath: string): Promise<FITSParsed> {\n\t\tconst fits = await FITSParser.loadFITS(fitsfilepath)\n\t\t// let fp = new FITSParser(fitsfilepath);\n\n\t\t// let promise = fp.loadFITS().then(fits => {\n\t\t\tthis._pxvalues.set(0, fits.data);\n\t\t\tthis._fitsheaderlist[0] = fits.header;\n\n\t\t\tlet order = fits.header.get(\"ORDER\");\n\t\t\tthis.init(order);\n\n\t\t\tsuper.naxis1 = fits.header.get(\"NAXIS1\");\n\t\t\tsuper.naxis2 = fits.header.get(\"NAXIS2\");\n\t\t\tthis._HIPS_TILE_WIDTH = super.naxis1;\n\n\t\t\tthis._pixno = fits.header.get(\"NPIX\");\n\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(this._pixno, this._hp);\n\t\t\treturn fits;\n\t\t// });\n\t\t// await promise;\n\t\t// return promise;\n\t}\n\n\n\n\tasync initFromHiPSLocationAndPxSize(baseUrl: string, pxsize: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tsuper.pxsize = pxsize;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\t// let order = HiPSHelper.computeHiPSOrder(pxsize, this._HIPS_TILE_WIDTH);\n\t\t// let order2 = HiPSHelper.computeHiPSOrder2(pxsize, this._HIPS_TILE_WIDTH);\n\t\tlet order = HiPSHelper.computeOrder(pxsize, this._HIPS_TILE_WIDTH);\n\t\tif (order > this._HIPS_MAX_ORDER) {\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tthis.init(order);\n\t}\n\n\tasync initFromHiPSLocationAndOrder(baseUrl: string, order: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\tif (order > this._HIPS_MAX_ORDER){\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tsuper.pxsize = HiPSHelper.computePxSize(order, this._HIPS_TILE_WIDTH);\n\t\tthis.init(order);\n\t}\n\n\tinit(order: number) {\n\t\tthis._norder = order;\n\t\tthis._nside = 2 ** order;\n\t\tthis._hp = new Healpix(this._nside);\n\t}\n\n\tprepareFITSHeader(fitsHeaderParams: FITSHeaderManager): FITSHeaderManager[] {\n\t\tfor (let header of this._fitsheaderlist) {\n\n\t\t\theader.insert(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n\t\t\theader.insert(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n\t\t\tif (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n\t\t\t\theader.insert(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n\t\t\t}\n\t\t\tlet bscale = 1.0;\n\t\t\tif (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n\t\t\t\tbscale = fitsHeaderParams.get(\"BSCALE\");\n\t\t\t\theader.insert(new FITSHeaderItem(\"BSCALE\", bscale));\n\t\t\t}\n\n\n\t\t\tlet bzero = 0.0;\n\t\t\tif (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n\t\t\t\tbzero = fitsHeaderParams.get(\"BZERO\");\n\t\t\t\theader.insert(new FITSHeaderItem(\"BZERO\", bzero));\n\t\t\t}\n\n\t\t\theader.insert(new FITSHeaderItem(\"NAXIS\", 2));\n\t\t\theader.insert(new FITSHeaderItem(\"NAXIS1\", HiPSHelper.DEFAULT_Naxis1_2));\n\t\t\theader.insert(new FITSHeaderItem(\"NAXIS2\", HiPSHelper.DEFAULT_Naxis1_2));\n\n\t\t\theader.insert(new FITSHeaderItem(\"ORDER\", this._norder));\n\n\t\t\theader.insert(new FITSHeaderItem(\"CTYPE1\", super.ctype1));\n\t\t\theader.insert(new FITSHeaderItem(\"CTYPE2\", super.ctype2));\n\n\t\t\t// header.insert(new FITSHeaderItem(\"CRPIX1\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel i along naxis1\n\t\t\t// header.insert(new FITSHeaderItem(\"CRPIX2\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel j along naxis2\n\n\t\t\theader.insert(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n\t\t\theader.insert(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n\n\t\t}\n\t\treturn this._fitsheaderlist;\n\t}\n\n\n\tgetFITSHeader(): FITSHeaderManager[] {\n\t\treturn this._fitsheaderlist;\n\t}\n\n\tgetCommonFitsHeaderParams(): FITSHeaderManager {\n\t\treturn this._fh_common;\n\t}\n\n\textractPhysicalValues(fits: FITSParsed): number[][] {\n\n\t\tlet bzero = fits.header.get(\"BZERO\");\n\t\tlet bscale = fits.header.get(\"BSCALE\");\n\t\tlet naxis1 = fits.header.get(\"NAXIS1\");\n\t\tlet naxis2 = fits.header.get(\"NAXIS2\");\n\t\tlet bitpix = fits.header.get(\"BITPIX\");\n\t\tlet bytesXelem = Math.abs(bitpix / 8);\n\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n\t\t// let physicalvalues = new Array[naxis2][naxis1];\n\t\tlet physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n\t\tfor (let n2 = 0; n2 < naxis2; n2++) {\n\t\t\tphysicalvalues[n2] = new Array<number>(naxis1);\n\t\t\tfor (let n1 = 0; n1 < naxis1; n1++) {\n\t\t\t\tlet pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n\t\t\t\tlet physicalVal = bzero + bscale * pixval;\n\t\t\t\tphysicalvalues[n2][n1] = physicalVal;\n\t\t\t}\n\t\t}\n\t\treturn physicalvalues;\n\n\t}\n\n\tasync getFITSFiles(inputPixelsList: ImagePixel[], destPath: string): Promise<Map<string, FITSParsed>> {\n\n\t\tconst fitsFilesGenerated = new Map<string, FITSParsed>();\n\t\tlet promises = [];\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\t\tfor (let hipstileno of tilesset) {\n\t\t\tlet tileno = hipstileno;\n\t\t\tlet dir = Math.floor(tileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + tileno + \".fits\";\n\t\t\t// let fp = new FITSParser(fitsurl);\n\n\n\t\t\t// promises.push(fp.loadFITS().then((fits) => {\n\t\t\tpromises.push(FITSParser.loadFITS(fitsurl).then((fits) => {\n\t\t\t\tif (fits !== null) {\n\t\t\t\t\tlet pixno = (fits.header.get(\"NPIX\") !== undefined) ? fits.header.get(\"NPIX\") : tileno;\n\t\t\t\t\t// FITSParser.writeFITS(fits.header, fits.data, destPath+\"/Npix\"+pixno+\".fits\");\n\t\t\t\t\t// fitsFilesGenerated.set(destPath+\"/Npix\"+pixno+\".fits\",FITSParser.generateFITS(fits.header, fits.data) );\n\t\t\t\t\tfitsFilesGenerated.set(destPath + \"/Npix\" + pixno + \".fits\", fits);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\treturn fitsFilesGenerated;\n\t}\n\n\n\tget fitsUsed(): String[] {\n\t\treturn this._fitsUsed;\n\t}\n\n\tasync getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array | undefined> {\n\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\n\t\tlet pixcount = inputPixelsList.length;\n\t\tlet values: Uint8Array | undefined = undefined;\n\t\tlet fitsheaderlist: (FITSHeaderManager | undefined)[] = [];\n\t\tlet promises = [];\n\n\t\tlet self = this;\n\t\tfor (let hipstileno of tilesset) {\n\n\t\t\tlet dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + hipstileno + \".fits\";\n\t\t\tconsole.log(`Identified source file ${fitsurl}`)\n\t\t\t\n\t\t\t// let fp = new FITSParser(fitsurl);\n\t\t\t// promises.push(fp.loadFITS().then((fits) => {\n\t\t\tpromises.push(FITSParser.loadFITS(fitsurl).then((fits) => {\n\n\t\t\t\tif (fits === null) {\n\t\t\t\t\tfitsheaderlist.push(undefined);\n\t\t\t\t} else {\n\t\t\t\t\tself._fitsUsed.push(fitsurl);\n\n\t\t\t\t\tlet bytesXelem = Math.abs(fits.header.get(\"BITPIX\") / 8);\n\t\t\t\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // => ???????\n\t\t\t\t\tif (values === undefined) {\n\t\t\t\t\t\tvalues = new Uint8Array(pixcount * bytesXelem);\n\t\t\t\t\t}\n\n\t\t\t\t\t// console.log(fitsurl + \" loaded\");\n\t\t\t\t\tfitsheaderlist.push(fits.header);\n\n\t\t\t\t\tfor (let p = 0; p < pixcount; p++) {\n\t\t\t\t\t\tlet imgpx = inputPixelsList[p];\n\n\t\t\t\t\t\tif (imgpx.tileno === hipstileno) {\n\n\n\t\t\t\t\t\t\t// if (imgpx._j < HiPSHelper.DEFAULT_Naxis1_2 && imgpx._i < HiPSHelper.DEFAULT_Naxis1_2) {\n\t\t\t\t\t\t\tif (imgpx._j < fits.header.get(\"NAXIS1\") && imgpx._i < fits.header.get(\"NAXIS2\")) {\n\t\t\t\t\t\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\t\t\t\t\t\tvalues[p * bytesXelem + b] = fits.data[imgpx._j][imgpx._i * bytesXelem + b];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\tif (fitsheaderlist !== undefined) {\n\t\t\tthis.prepareCommonHeader(fitsheaderlist);\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tprepareCommonHeader(fitsheaderlist: (FITSHeaderManager | undefined)[]): void {\n\t\tif (fitsheaderlist === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fh_common) {\n\t\t\tthis._fh_common = new FITSHeaderManager();\n\t\t}\n\n\t\tfor (let i = 0; i < fitsheaderlist.length; i++) {\n\t\t\tlet header = fitsheaderlist[i];\n\t\t\tif (header !== undefined) {\n\n\t\t\t\tfor (let item of header.getItems()) {\n\t\t\t\t\tif ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\"].includes(item.key)) {\n\t\t\t\t\t\tif (!this._fh_common.getItemListOf(item.key)[0]) {\n\t\t\t\t\t\t\tthis._fh_common.insert(new FITSHeaderItem(item.key, item.value));\n\t\t\t\t\t\t} else if (this._fh_common.getItemListOf(item.key)[0].value !== item.value) { // this should not happen \n\t\t\t\t\t\t\tthrow new Error(\"Error parsing headers. \" + item.key + \" was \" + this._fh_common.getItemListOf(item.key)[0] + \" and now is \" + item.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\n\t// // TODO MOVE THIS IN AN UTILITY FILE\n\t// pixel2Physical(value, bzero, bscale) {\n\t// \tlet pval = bzero + bscale * value;\n\t// \treturn pval;\n\t// }\n\n\tsetPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeaderManager): Map<number, Array<Uint8Array>> {\n\n\t\t// let vidx = 0; // <------ ERROR!!!!! pixel are not organized by tile!!!\n\n\t\t// let pxXTile = HiPSHelper.DEFAULT_Naxis1_2 * HiPSHelper.DEFAULT_Naxis1_2;\n\t\tlet bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n\t\tlet bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n\t\tlet bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n\t\tif (bytesXelem === undefined || bscale === undefined || bzero === undefined) {\n\t\t\tthrow new Error(\"BITPIX, BSCALE or BZERO are undefined\");\n\t\t}\n\n\n\t\t// let minmaxmap = new Array();\n\t\tlet minmaxmap = new Map();\n\t\tlet nodata = new Map();\n\n\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\t// this._pxvalues.set(tileno, new Array(HiPSHelper.DEFAULT_Naxis1_2));  // <- bidimensional\n\t\t\t// for (let row = 0; row < HiPSHelper.DEFAULT_Naxis1_2; row++) {\n\n\t\t\tthis._pxvalues.set(tileno, new Array(this._HIPS_TILE_WIDTH));  // <- bidimensional\n\t\t\tfor (let row = 0; row < this._HIPS_TILE_WIDTH; row++) {\n\t\t\t\tif (this._pxvalues.has(tileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(tileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\t// p[row] = new Uint8Array(HiPSHelper.DEFAULT_Naxis1_2 * bytesXelem);\n\t\t\t\t\t\tp[row] = new Uint8Array(this._HIPS_TILE_WIDTH * bytesXelem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tminmaxmap.set(\"\" + tileno + \"\", new Array(2));\n\t\t\tnodata.set(\"\" + tileno + \"\", true);\n\t\t});\n\t\tlet ra: number;\n\t\tlet dec: number;\n\t\tlet col: number;\n\t\tlet row: number;\n\n\t\tfor (let rdidx = 0; rdidx < this._radeclist.length; rdidx++) {\n\t\t\t[ra, dec] = this._radeclist[rdidx];\n\t\t\tlet ac = fillAstro(ra, dec, NumberType.DEGREES);\n\t\t\tlet sc = astroToSpherical(ac);\n\t\t\tlet ptg = new Pointing(null, false, sc.thetaRad, sc.phiRad);\n\t\t\tlet pixtileno: number = this._hp.ang2pix(ptg);\n\n\t\t\tlet xyGridProj = HiPSHelper.setupByTile(pixtileno, this._hp);\n\t\t\t// let rarad = degToRad(ra);\n\t\t\t// let decrad = degToRad(dec);\n\t\t\t// TODO CHECK THIS POINT before it was with ra and dec in radians\n\t\t\tlet xy = HiPSHelper.world2intermediate(ac);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tlet ij = HiPSHelper.intermediate2pix(xy[0], xy[1], xyGridProj, this._HIPS_TILE_WIDTH);\n\t\t\tcol = ij[0];\n\t\t\trow = ij[1];\n\n\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\tlet byte = values[rdidx * bytesXelem + b];\n\t\t\t\t// this._pxvalues.get(pixtileno)[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\tp[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nodata.get(\"\" + pixtileno + \"\")) {\n\t\t\t\t\tif (byte != 0) {\n\t\t\t\t\t\tnodata.set(\"\" + pixtileno + \"\", false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet min = minmaxmap.get(\"\" + pixtileno + \"\")[0];\n\t\t\tlet max = minmaxmap.get(\"\" + pixtileno + \"\")[1];\n\n\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\tif (p !== undefined) {\n\t\t\t\t\tlet valpixb = ParseUtils.extractPixelValue(0, p[row].slice(col * bytesXelem, col * bytesXelem + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n\t\t\t\t\tlet valphysical = bzero + bscale * valpixb;\n\t\t\t\t\tif (valphysical < min || isNaN(min)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[0] = valphysical;\n\t\t\t\t\t} else if (valphysical > max || isNaN(max)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[1] = valphysical;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Object.keys(this._pxvalues.keys()).forEach((tileno) => {\n\t\tconst fhKeys = Array.from(this._pxvalues.keys());\n\n\t\tfhKeys.forEach((tileno) => {\n\t\t\tif (nodata.get(\"\" + tileno + \"\") == false) { // there are data\n\t\t\t\t// tileno = parseInt(tileno);\n\t\t\t\tlet header = new FITSHeaderManager();\n\t\t\t\theader.set(\"NPIX\", tileno);\n\t\t\t\t// TODO CONVERT minval and maxval to physical values!\n\t\t\t\t// header.insert(new FITSHeaderItem(\"DATAMIN\", minmaxmap[\"\" + tileno + \"\"][0]));\n\t\t\t\t// header.insert(new FITSHeaderItem(\"DATAMAX\", minmaxmap[\"\" + tileno + \"\"][1]));\n\t\t\t\theader.insert(new FITSHeaderItem(\"DATAMIN\", minmaxmap.get(\"\" + tileno + \"\")[0]));\n\t\t\t\theader.insert(new FITSHeaderItem(\"DATAMAX\", minmaxmap.get(\"\" + tileno + \"\")[1]));\n\t\t\t\theader.insert(new FITSHeaderItem(\"NPIX\", tileno));\n\n\t\t\t\tlet vec3 = this._hp.pix2vec(tileno);\n\t\t\t\tlet ptg = new Pointing(vec3);\n\t\t\t\tlet crval1 = radToDeg(ptg.phi);\n\t\t\t\tlet crval2 = 90 - radToDeg(ptg.theta);\n\n\t\t\t\theader.insert(new FITSHeaderItem(\"CRVAL1\", crval1));\n\t\t\t\theader.insert(new FITSHeaderItem(\"CRVAL2\", crval2));\n\n\t\t\t\tthis._fitsheaderlist.push(header);\n\t\t\t} else { // no data\n\t\t\t\t// this._pxvalues.delete(parseInt(tileno));\n\t\t\t\tthis._pxvalues.delete(tileno);\n\t\t\t\t// delete this._pxvalues[\"\" + tileno + \"\"];\n\t\t\t}\n\n\t\t});\n\t\tthis.prepareFITSHeader(fitsHeaderParams);\n\t\treturn this._pxvalues;\n\n\t}\n\n\tgetImageRADecList(center: Point, radiusDeg: number): Array<[number, number]> {\n\n\t\tlet ptg = new Pointing(null, false, center.spherical.thetaRad, center.spherical.phiRad);\n\t\tlet radius_rad = degToRad(radiusDeg);\n\n\t\t// with fact 8 the original Java code starts returning the the ptg pixel. with my JS porting only from fact 16\n\t\tlet rangeset = this._hp.queryDiscInclusive(ptg, radius_rad, 4); // <= check it \n\n\t\tthis._tileslist = [];\n\t\tfor (let p = 0; p < rangeset.r.length; p++) {\n\n\t\t\tif (!this._tileslist.includes(rangeset.r[p]) && rangeset.r[p] != 0) {\n\t\t\t\tthis._tileslist.push(rangeset.r[p]);\n\t\t\t}\n\n\t\t}\n\n\t\tlet cpix = this._hp.ang2pix(ptg);\n\t\tif (!this._tileslist.includes(cpix)) {\n\t\t\tthis._tileslist.push(cpix);\n\t\t}\n\n\n\t\tlet minra = center.astro.raDeg - radiusDeg;\n\t\tlet maxra = center.astro.raDeg + radiusDeg;\n\t\tlet mindec = center.astro.decDeg - radiusDeg;\n\t\tlet maxdec = center.astro.decDeg + radiusDeg;\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t// for (let j = 0; j < HiPSHelper.DEFAULT_Naxis1_2; j++) {\n\t\t\t// \tfor (let i = 0; i < HiPSHelper.DEFAULT_Naxis1_2; i++) {\n\t\t\tfor (let j = 0; j < this._HIPS_TILE_WIDTH; j++) {\n\t\t\t\tfor (let i = 0; i < this._HIPS_TILE_WIDTH; i++) {\n\t\t\t\t\tlet p = this.pix2world(i, j);\n\t\t\t\t\tif (p.astro.raDeg < minra || p.astro.raDeg > maxra ||\n\t\t\t\t\t\tp.astro.decDeg < mindec || p.astro.decDeg > maxdec) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis._radeclist.push([p.astro.raDeg, p.astro.decDeg]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this._radeclist;\n\n\n\t}\n\n\n\tpix2world(i: number, j: number): Point {\n\n\t\tlet xy = HiPSHelper.pix2intermediate(i, j, this._xyGridProj, super.naxis1, super.naxis2);\n\t\t// TODO CHECK BELOW before it was only which is supposed to be wrong since intermediate2world returns SphericalCoords, not AstroCoords\n\t\t/**  \n\t\tlet raDecDeg = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\tif (raDecDeg[0] > 360){\n\t\t\traDecDeg[0] -= 360;\n\t\t}\n\t\treturn raDecDeg;\n\t\t*/\n\t\tlet p = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\t// if (p.spherical.phiDeg > 360){\n\t\t// \tsc.phiDeg -= 360;\n\t\t// }\n\t\treturn p;\n\t}\n\n\n\t// conversion taken from https://astrophysicsandpython.com/2022/03/15/html-js-equatorial-to-galactic-coordinates/\n\tconvertToGalactic(radeclist: number[][]): number[][] {\n\t\tlet finalradeclist: number[][] = [];\n\t\tconst deg2rad = Math.PI / 180\n\t\tconst rad2deg = 180 / Math.PI\n\t\tconst l_NCP = deg2rad * 122.930\n\t\tconst d_NGP = deg2rad * 27.1284\n\t\tconst a_NGP = deg2rad * 192.8595\n\t\tradeclist.forEach(([ra, dec]) => {\n\t\t\tconst ra_rad = deg2rad * ra\n\t\t\tconst dec_rad = deg2rad * dec\n\t\t\t// sin(b)\n\t\t\tconst sin_b = Math.sin(d_NGP) * Math.sin(dec_rad) + \n\t\t\t\t\t\t\tMath.cos(d_NGP) * Math.cos(dec_rad) * Math.cos(ra_rad - a_NGP);\n\t\t\tconst b = Math.asin(sin_b)\n\t\t\tconst b_deg = b * rad2deg\n\n\t\t\t// l_NCP - l\n\t\t\tconst lNCP_minus_l = Math.atan ( ( Math.cos(dec_rad) * Math.sin(ra_rad - a_NGP)) /\n\t\t\t\t\t\t\t(Math.sin(dec_rad) * Math.cos(d_NGP) - Math.cos(dec_rad) * Math.sin(d_NGP) * Math.cos(ra_rad - a_NGP)) );\n\t\t\tconst l = l_NCP - lNCP_minus_l\n\t\t\tconst l_deg = l * rad2deg\n\t\t\t\n\t\t\tfinalradeclist.push([l_deg, b_deg])\n\t\t});\n\t\treturn finalradeclist;\n\t}\n\n\tworld2pix(radeclist: number[][]): ImagePixel[] {\n\n\t\t// let imgpxlist = new ImagePixel[radeclist.length];\n\t\tlet imgpxlist: ImagePixel[] = [];\n\t\tlet tileno: number;\n\t\tlet prevTileno: number | undefined = undefined;\n\t\t// let k = 0;\n\n\t\t/*\n\t\t\tif HiPS in galactic => convert the full list of (RA, Dec) to Galactic  (l, b)\n\t\t*/\n\n\t\tif (this._isGalactic){\n\t\t\tradeclist = this.convertToGalactic(radeclist);\n\t\t}\n\n\t\tradeclist.forEach(([ra, dec]) => {\n\n\t\t\tconst p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n\t\t\t// let phiTheta_rad = HiPSHelper.astroDegToSphericalRad(ra, dec);\n\t\t\tconst ptg = new Pointing(null, false, p.spherical.thetaRad, p.spherical.phiRad);\n\n\t\t\ttileno = this._hp.ang2pix(ptg);\n\t\t\tif (prevTileno !== tileno || prevTileno === undefined) {\n\t\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t\tprevTileno = tileno;\n\t\t\t}\n\t\t\t// let rarad =  HiPSHelper.degToRad(ra);\n\t\t\t// let decrad = HiPSHelper.degToRad(dec);\n\t\t\tconst xy = HiPSHelper.world2intermediate(p.astro);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tconst ij = HiPSHelper.intermediate2pix(xy[0], xy[1], this._xyGridProj, this._HIPS_TILE_WIDTH);\n\n\t\t\timgpxlist.push(new ImagePixel(ij[0], ij[1], tileno));\n\t\t});\n\n\t\treturn imgpxlist;\n\t}\n\n\n}\n","\nimport { FITSHeaderManager } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport {Point} from \"../model/Point.js\";\nimport {AbstractProjection} from \"./AbstractProjection.js\";\n\n\nexport class HEALPixProjection extends AbstractProjection {\n    \n    constructor() {\n        super(\"'RA---HPX'\", \"'DEC--HPX'\")\n    }\n    \n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeaderManager): FITSHeaderManager[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeaderManager[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeaderManager {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    \n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeaderManager): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n    \n\n}","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeaderManager } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\nimport {Point} from '../model/Point.js';\n\n\nexport class GnomonicProjection extends AbstractProjection {\n\n\n\n\n    _minra: number;\n    _mindec: number;\n    _pxmatrix;\n    _fitsheader: FITSHeaderManager[];\n    _inflie: string;\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n\n    constructor(infile?: string) {\n        super(\"'RA---TAN'\", \"'DEC--TAN'\");\n        if (infile) {\n            this._inflie = infile;\n        }\n    }\n\n\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n\n        const fits = await FITSParser.loadFITS(infile)\n        // let fp = new FITSParser(infile);\n\n        // let promise = fp.loadFITS().then(fits => {\n\n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            super.naxis1 = fits.header.get(\"NAXIS1\");\n            super.naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value;\n            this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value;\n\n            this._minra = this._craDeg - this._pxsize1 * super.naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            this._mindec = this._cdecDeg - this._pxsize2 * super.naxis2 / 2;\n\n            return fits;\n\n        // });\n        // await promise;\n        // return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeaderManager): FITSHeaderManager[] {\n\n        this._fitsheader[0] = new FITSHeaderManager();\n\n\n        this._fitsheader[0].insert(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].insert(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].insert(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].insert(new FITSHeaderItem(\"BZERO\", bzero));\n\n\n        this._fitsheader[0].insert(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"NAXIS1\", super.naxis1));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"NAXIS2\", super.naxis2));\n\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CTYPE1\", super.ctype1));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CTYPE2\", super.ctype2));\n\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CDELT1\", super.pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CDELT2\", super.pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CRPIX1\", super.naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CRPIX2\", super.naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].insert(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].insert(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].insert(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].insert(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n        this._fitsheader[0].insert(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n\n    getFITSHeader(): FITSHeaderManager[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeaderManager {\n        let header = new FITSHeaderManager();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                // header.set(key, value);\n                header.insert(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= super.naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= super.naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = (this._pxvalues.get(0))[imgpx._j][(imgpx._i) * bytesXelem + b];\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeaderManager): Map<number, Array<Uint8Array>> {\n        // let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        // let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        // let maxpixb = minpixb;\n\n        // let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        // let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        // this._minphysicalval = bzero + bscale * minpixb;\n        // this._maxphysicalval = bzero + bscale * maxpixb;\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n\n        // TODO ...\n        return null;\n    }\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]>{\n\n        // let promise = new Promise((resolve, reject) => {\n        //     this.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n\n        //     this._pxsize = pxsize;\n        //     this._minra = center.ra - radius;\n        //     if (this._minra < 0) {\n        //         this._minra += 360;\n        //     }\n        //     this._mindec = center.dec - radius;\n\n        //     let radeclist = [];\n        //     let pra, pdec;\n\n        // TODO ...\n        /*\n        basing on naxis1 and naxis2 call pix2world!!!\n        */\n\n\n\n        /*\n        \n\n        mindec = center.dec - radius;\n        maxdec = center.dec + radius;\n        below pixel size should  depend on the distance from the center\n        let l =  0;\n        let factor = 1;\n        \n        for (let d = mindec; d < maxdec; d+=pxsize) { <--ERROR the external loop must be over RA\n            factor = 1 + 2**l;\n            rapxsize = pxsize/factor;\n            for (let r = 0; r < 360; r+=rapxsize) {\n                radeclist.push(r, d); \n            }\n            l++;\n        }\n        */\n\n\n\n\n\n        // let cidx = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        // this._cra = radeclist[cidx][0];\n        // this._cdec = radeclist[cidx][1];\n\n        // resolve(radeclist);\n        // });\n        // return promise;\n        return null;\n\n    }\n\n    pix2world(i: number, j: number): Point {\n\n        // TODO ...\n        let x, y;\n        let CDELT1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0];\n        let CDELT2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0];\n        let PC1_1 = this._fitsheader[0].getItemListOf(\"PC1_1\")[0];\n        let PC1_2 = this._fitsheader[0].getItemListOf(\"PC1_2\")[0];\n        let PC2_1 = this._fitsheader[0].getItemListOf(\"PC2_1\")[0];\n        let PC2_2 = this._fitsheader[0].getItemListOf(\"PC2_2\")[0];\n\n        let CD1_1 = this._fitsheader[0].getItemListOf(\"CD1_1\")[0];\n        let CD1_2 = this._fitsheader[0].getItemListOf(\"CD1_2\")[0];\n        let CD2_1 = this._fitsheader[0].getItemListOf(\"CD2_1\")[0];\n        let CD2_2 = this._fitsheader[0].getItemListOf(\"CD2_2\")[0];\n\n        let CRPIX1 = this._fitsheader[0].getItemListOf(\"CRPIX1\")[0];\n        let CRPIX2 = this._fitsheader[0].getItemListOf(\"CRPIX2\")[0];\n\n\n        if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            PC1_1 !== undefined && PC1_2 !== undefined &&\n            PC2_1 !== undefined && PC2_2 !== undefined\n        ) { // if CDELTia and PCi_ja notation\n            x = CDELT1 * (PC1_1 * (i - CRPIX1) + PC1_2 * (j - CRPIX2));\n            y = CDELT2 * (PC2_1 * (i - CRPIX1) + PC2_2 * (j - CRPIX2));\n        } else { // else CDi_ja notation\n            x = CD1_1 * (i - CRPIX1) + CD1_2 * (j - CRPIX2);\n            y = CD2_1 * (i - CRPIX1) + CD2_2 * (j - CRPIX2);\n        }\n\n\n\n\n        // let phi = math.arg(-y / x);\n        // let R_theta = Math.sqrt(x * x + y * y);\n        // let theta = Math.atan2(180 / (Math.PI * R_theta));\n\n        // let ra, dec;\n        // ra = phi;\n        // dec = theta;\n        // // TODO check if phi, theta match with ra, dec or they need to be (linearly) converted \n\n        // return [ra, dec];\n\n        return null;\n    }\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        let CDELT1 = (this._fitsheader[0].getItemListOf(\"CDELT1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT1\")[0] : undefined;\n        let CDELT2 = (this._fitsheader[0].getItemListOf(\"CDELT2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT2\")[0] : undefined;\n        let PC1_1 = (this._fitsheader[0].getItemListOf(\"PC1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_1\")[0] : undefined;\n        let PC1_2 = (this._fitsheader[0].getItemListOf(\"PC1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_2\")[0] : undefined;\n        let PC2_1 = (this._fitsheader[0].getItemListOf(\"PC2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_1\")[0] : undefined;\n        let PC2_2 = (this._fitsheader[0].getItemListOf(\"PC2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_2\")[0] : undefined;\n\n        let CD1_1 = (this._fitsheader[0].getItemListOf(\"CD1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_1\")[0] : undefined;\n        let CD1_2 = (this._fitsheader[0].getItemListOf(\"CD1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_2\")[0] : undefined;\n        let CD2_1 = (this._fitsheader[0].getItemListOf(\"CD2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_1\")[0] : undefined;\n        let CD2_2 = (this._fitsheader[0].getItemListOf(\"CD2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_2\")[0] : undefined;\n\n        let CRPIX1 = (this._fitsheader[0].getItemListOf(\"CRPIX1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX1\")[0] : undefined;\n        let CRPIX2 = (this._fitsheader[0].getItemListOf(\"CRPIX2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX2\")[0] : undefined;\n\n        radeclist.forEach(([ra, dec]) => {\n\n            // TODO ...\n            // let i, j;\n            // // (linearly) convert ra, dec into phi, theta\n            // let theta = dec;\n            // let phi = ra;\n            // let R_theta = (180 / Math.PI) * math.cot(theta);\n            // let x = R_theta * Math.sin(phi);\n            // let y = - R_theta * Math.cos(phi);\n            // if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            //     PC1_1 !== undefined && PC1_2 !== undefined &&\n            //     PC2_1 !== undefined && PC2_2 !== undefined\n            // ) { // if CDELTia and PCi_ja notation\n            //     j = y * CDELT1 * PC1_1 / (CDELT1 * CDELT2 * (PC1_1 * PC2_2 - PC2_1 * PC1_2)) + PC1_1 * CRPIX2 * (PC2_2 - PC2_1) / (PC1_1 * PC2_2 - PC2_1 * PC1_2);\n            //     i = x / (CDELT1 * PC1_1) + CRPIX1 - j * PC1_2 / PC1_1 + CRPIX2 * PC1_2 / PC1_1;\n            // } else { // else CDi_ja notation\n            //     j = y * CD1_1 / (CD1_1 * CD2_2 - CD1_2 * CD2_1) + CRPIX2 * CD1_1 * (CD2_2 - CD2_1) / (CD1_1 * CD2_2 - CD1_2 * CD2_1);\n            //     i = (x + CD1_1 * CRPIX1 - CD1_2 * j + CD1_2 * CRPIX2) / CD1_1;\n            // }\n            // imgpxlist.push(new ImagePixel(i, j));\n\n        });\n        return imgpxlist;\n\n    }\n\n    // getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n    //     let canvas2d = new Canvas2D(this._pxvalues, this._fitsheader, this, tfunction, colormap, inverse);\n    //     return canvas2d;\n    // }\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nimport { FITSParser } from 'jsfitsio';\nimport { MercatorProjection } from './projections/MercatorProjection.js';\nimport { HiPSProjection } from './projections/HiPSProjection.js';\nimport { Point } from './model/Point.js';\nimport { AbstractProjection } from './projections/AbstractProjection.js';\nimport { CutoutResult } from './model/CutoutResult.js';\n\nimport { HEALPixProjection } from './projections/HEALPixProjection.js';\nimport { GnomonicProjection } from './projections/GnomonicProjection.js';\nimport { FITS } from './model/FITS.js';\n\nexport class WCSLight {\n\n    static async cutout(center: Point, radius: number,\n        pxsize: number, inproj: AbstractProjection, outproj: AbstractProjection): Promise<CutoutResult> {\n\n        const outRADecList: Array<Array<number>> = outproj.getImageRADecList(center, radius, pxsize);\n        if (outRADecList.length == 0) {\n            const res: CutoutResult = {\n                fitsheader: null,\n                fitsdata: null,\n                inproj: inproj,\n                outproj: outproj,\n                fitsused: inproj.fitsUsed\n            };\n            return res;\n        }\n        const inputPixelsList = inproj.world2pix(outRADecList);\n        try {\n\n            const invalues = await inproj.getPixValues(inputPixelsList);\n            const fitsHeaderParams = inproj.getCommonFitsHeaderParams();\n            if (invalues !== undefined) {\n                const fitsdata = outproj.setPxsValue(invalues, fitsHeaderParams);\n                const fitsheader = outproj.getFITSHeader();\n                const fits = new FITS(fitsheader, fitsdata)\n                \n                const res: CutoutResult = {\n                    fitsheader: fits.header,\n                    fitsdata: fits.data,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            } else {\n                const nanFits = outproj.generateFITSWithNaN()\n                const res: CutoutResult = {\n                    fitsheader: nanFits.header,\n                    fitsdata: nanFits.data,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            }\n\n        } catch (err) {\n            console.error(\"[WCSLight] ERROR: \" + err);\n            return null;\n        }\n\n    }\n\n    /**\n     * \n     * @param {*} fitsheader \n     * @param {*} fitsdata \n     * @returns {URL}\n     */\n    static generateFITS(fitsheader: any, fitsdata: any): string {\n        const fitsParsed = {\n            header: fitsheader,\n            data: fitsdata\n        }\n        // const blobUrl = FITSParser.generateFITSForWeb(fitsheader, fitsdata);\n        const blobUrl = FITSParser.generateFITSForWeb(fitsParsed);\n        return blobUrl;\n    }\n\n\n\n\n    static changeProjection(filepath, outprojname) {\n        // TODO\n    }\n\n\n    static getProjection(projectionName: string) {\n        if (projectionName === \"Mercator\") {\n            return new MercatorProjection();\n        } else if (projectionName === \"HiPS\") {\n            return new HiPSProjection();\n        } else if (projectionName === \"HEALPix\") {\n            return new HEALPixProjection();\n        } else if (projectionName === \"Gnomonic\") {\n            return new GnomonicProjection();\n        } else {\n            return null;\n            // throw new ProjectionNotFound(projectionName);\n        }\n    }\n\n    static getAvaillableProjections() {\n        return [\"Mercator\", \"HiPS\", \"HEALPix\"];\n    }\n\n}\n\n","\n\n\n// import { FITSParser } from 'fitsparser/FITSParser-node';\n// import { FITSHeader } from 'fitsparser/model/FITSHeader';\n// import { FITSHeaderItem } from 'fitsparser/model/FITSHeaderItem';\n// import { FITSParsed } from 'fitsparser/model/FITSParsed';\n\n\n\nimport { FITSHeaderManager } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { AbstractProjection } from './AbstractProjection.js';\nimport {Point} from '../model/Point.js';\n\nexport class TestProj extends AbstractProjection{\n    \n    _minra: number;\n    _mindec: number;\n    _fitsheader: FITSHeaderManager[];\n    _infile: string;\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n    constructor() {\n        super(\"RA---TST\", \"DEC--TST\")\n        // this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        // this._pxvalues = new Map<number, Array<Uint8Array>>();\n        // const fh = new FITSHeader();\n        // const fp = new FITSParser(\"./notexistent/\");\n        // const fp = FITSParser.loadFITS(\"./notexistent/\");\n        // const fhi = new FITSHeaderItem(\"mykey\", \"myvalue\", \"mycomment\");\n\n\n    }\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    \n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeaderManager): FITSHeaderManager[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeaderManager[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeaderManager {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    public computeSquaredNaxes(d: number, ps: number): void {\n        throw new Error('Method not implemented.');\n    }\n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeaderManager): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number):  Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n}"],"names":["root","factory","exports","module","define","amd","self","inProgress","dataWebpackPrefix","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call","m","d","definition","key","o","Object","defineProperty","enumerable","get","f","e","chunkId","Promise","all","keys","reduce","promises","u","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","l","url","done","push","script","needAttach","scripts","document","getElementsByTagName","i","length","s","getAttribute","createElement","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","event","onerror","onload","clearTimeout","doneFns","parentNode","removeChild","forEach","fn","setTimeout","bind","type","target","head","appendChild","r","Symbol","toStringTag","value","scriptUrl","importScripts","location","currentScript","test","Error","replace","p","installedChunks","j","installedChunkData","promise","resolve","reject","error","errorType","realSrc","message","name","request","webpackJsonpCallback","parentChunkLoadingFunction","data","chunkIds","moreModules","runtime","some","id","chunkLoadingGlobal","FITSHeaderItem","constructor","comment","_key","_value","_comment","FITSHeaderManager","items","insert","item","position","splice","getItems","remove","filter","findById","find","FITSWriter","createFITS","fitsParsed","headerBytes","createHeader","header","dataBytes","createData","fitsFile","Uint8Array","set","headerString","padEnd","TextEncoder","encode","totalLength","sum","row","offset","paddingSize","paddedData","typedArrayToURL","blob","Blob","URL","createObjectURL","console","log","revokeTimeout_sec","writeFITSFile","filePath","ParseHeader","checkFITSItem","VALUE","Number","parse","rawdata","headerText","TextDecoder","decode","slice","lines","match","line","trim","rawValue","split","isNaN","includes","ParseUtils","getStringAt","chars","String","fromCharCode","charCodeAt","join","byteString","n","toString","substr","parse32bitSinglePrecisionFloatingPoint","byte1","byte2","byte3","byte4","long","Math","pow","convertBlankToBytes","blank","nbytes","str","abs","buffer","ArrayBuffer","uint8","parseInt","parseFloatingPointFormat","bytes","ebits","fbits","bits","byte","reverse","bias","substring","Infinity","generate16bit2sComplement","val","TypeError","parse16bit2sComplement","unsigned","parse32bit2sComplement","res","getByteAt","extractPixelValue","bitpix","px_val","ParsePayload","computePhysicalMinAndMax","rawData","BITPIX","NAXIS1","NAXIS2","DATAMIN","DATAMAX","min","max","computePhysicalValues","maxitem","minitem","endItem","BLANK","BZERO","BSCALE","bytesXelem","pxLength","byteLength","physicalblank","pixel2physicalValue","ph_val","pxval","NumberType","CoordsType","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","result","then","apply","FITSParser","loadFITS","uint8data","getFile","processFits","headerFinalised","payloadBuffer","createMatrix","payload","matrix","generateFITSForWeb","saveFITSLocally","path","uri","toLowerCase","getLocalFile","FITS","_header","_data","AbstractProjection","ctype1","ctype2","naxis1","naxis2","pxsize","_ctype1","_ctype2","_naxis1","_naxis2","_pxsize","generateFITSWithNaN","fitsheaderList","fitsheader","NaN","pv","Map","Array","fill","computeSquaredNaxes","ps","ceil","ImagePixel","tileno","_i","_j","_tileno","geti","getj","cartesianToSpherical","xyz","dotXYZ","b","a","x","y","z","sqrt","thetaRad","acos","thetaDeg","radToDeg","phiRad","atan2","phiDeg","sphericalToAstro","phiTheta","raDeg","decDeg","degToRad","astroToSpherical","raDec","sphericalToCartesian","sin","cos","fillAstro","ra","dec","unit","DEGREES","RADIANS","fillSpherical","phi","theta","degrees","PI","radians","Point","in_type","coords","CARTESIAN","parseFloat","toFixed","MAX_DECIMALS","ASTRO","SPHERICAL","spherical","astro","cartesian","MercatorProjection","super","_wcsname","_pxvalues","_fitsheader","initFromFile","infile","fits","_infile","_fitsUsed","_craDeg","getItemListOf","_cdecDeg","pxsize1","pxsize2","_minra","_mindec","extractPhysicalValues","bzero","bscale","physicalvalues","n2","n1","physicalVal","prepareFITSHeader","fitsHeaderParams","_minphysicalval","_maxphysicalval","getFITSHeader","getCommonFitsHeaderParams","fitsUsed","getPixValues","inputPixelsList","blankBytes","pixcount","values","imgpx","err","setPxsValue","minpixb","maxpixb","c","floor","valphysical","getImageRADecList","center","radius","radeclist","cidx","pix2world","world2pix","imgpxlist","radecItem","Constants","halfpi","inv_halfpi","twopi","inv_twopi","Zphi","z_","phi_","Hploc","ptg","PI4_A","PI4_B","PI4_C","M_1_PI","sth","have_sth","_phi","setZ","setSth","toVec3","st","Vec3","toZphi","q","sincoshelper","asin","mulsign","atan2k","copySign","magnitude","sign","atanhelper","t","isinf","isnan","Pointing","vec3","mirror","in_theta","in_phi","in_x","in_y","in_z","getX","getY","getZ","scale","cross","v","add","normalize","norm","lengthSquared","dot","v1","sub","angle","flip","pointing2Vec3","pointing","CircleFinder","point","np","cosrad","getCircle","getCircle2","q1","q2","getCenter","getCosrad","Fxyf","fx","fy","face","jrll","jpll","toHploc","nr","loc","jr","tmp","pstack","sz","Int32Array","p_","o_","pop","popToMark","size","mark","otop","ptop","RangeSet","cap","append","append1","newsize","rnew","ensureCapacity","resize","sliced","Xyf","ix","iy","Healpix","nside_in","order_max","twothird","ns_max","ctab","Uint16Array","utab","Int16Array","xoffset","yoffset","facearray","swaparray","nside","npface","npix","order","nside2order","nl2","nl3","nl4","fact2","fact1","ncap","bn","mpr","cmpr","smpr","computeBn","maxPixrad","getNPix","getBoundaries","pix","points","xyf","nest2xyf","dc","xc","yc","getBoundariesWithStep","getPointsForXyfNoStep","getPointsForXyf","neighbours","ipix","face_num","nsm1","fpix","px0","spread_bits","py0","pxp","pyp","pxm","pym","nbnum","tint","xyf2nest","log2","compress_bits","loc2pix","hploc","pixNo","za","tt","fmodulo","temp1","temp2","jp","jm","ifp","ifm","ntt","tp","pix2vec","pix2loc","pix2zphi","ang2pix","v2","raw","queryPolygonInclusive","vertex","fact","inclusive","nv","vv","normal","index","back","first","medium","last","hnd","rad","cf","queryMultiDisc","oplus","ilog2","omax","crlimit","dr","Float64Array","stk","zone","crad","iz","check_pixel","arg","clz32","cosdist_zphi","z1","phi1","z2","phi2","pixset","sdist","zphia","xyz1","convertZphi2xyz","va","t1","zphib","xyz2","vb","zphi","queryDiscInclusive","vptg","crpdr","crmdr","sinrad","cdr","sdr","curro","pos","cangdist","HiPSHelper","computeHiPSOrder","pxXtile","k","RES_ORDER_0","round","computeHiPSOrder2","warn","computeOrder","pxAngSizeDeg","pxTileWidth","pxAngSizeRad","computedOrder","computePxAngularSize","computedPxAngSizeRadiant","rad2deg","deg","arcmin","arcsec","computePxSize","computeBbox","bbox","setupByTile","hp","xyGridProj","cornersVec3","pointings","coThetaRad","decRad","raRad","xyDeg","world2intermediate","gridPointsDeg","max_y","min_y","max_x","min_x","ac","x_grid","y_grid","THETAX","K","H","w","sigma","phi_c","intermediate2pix","i_norm","j_norm","xInterval","yInterval","pix2intermediate","cnaxis1","cnaxis2","yMean","intermediate2world","Yx","x_c","DEFAULT_Naxis1_2","HiPSProjection","_isGalactic","_fitsheaderlist","_radeclist","parsePropertiesFile","baseUrl","propFile","fetch","txtArr","_HIPS_TILE_WIDTH","tokens","_HIPS_MAX_ORDER","fitsfilepath","init","_pixno","_xyGridProj","_hp","initFromHiPSLocationAndPxSize","_hipsBaseURI","initFromHiPSLocationAndOrder","_norder","_nside","_fh_common","getFITSFiles","destPath","fitsFilesGenerated","tilesset","Set","hipstileno","dir","fitsurl","pixno","fitsheaderlist","prepareCommonHeader","col","minmaxmap","nodata","_tileslist","has","rdidx","sc","pixtileno","xy","ij","from","crval1","crval2","delete","radiusDeg","radius_rad","rangeset","cpix","minra","maxra","mindec","maxdec","convertToGalactic","finalradeclist","deg2rad","l_NCP","d_NGP","a_NGP","ra_rad","dec_rad","sin_b","b_deg","lNCP_minus_l","atan","l_deg","prevTileno","HEALPixProjection","hipsURI","GnomonicProjection","_inflie","_pxsize1","_pxsize2","CDELT1","CDELT2","PC1_1","PC1_2","PC2_1","PC2_2","CD1_1","CD1_2","CD2_1","CD2_2","CRPIX1","CRPIX2","WCSLight","cutout","inproj","outproj","outRADecList","fitsdata","fitsused","invalues","nanFits","generateFITS","changeProjection","filepath","outprojname","getProjection","projectionName","getAvaillableProjections","TestProj"],"sourceRoot":""}