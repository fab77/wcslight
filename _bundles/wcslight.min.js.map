{"version":3,"file":"wcslight.min.js","mappings":"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","sources":["webpack://wcslight/webpack/universalModuleDefinition","webpack://wcslight/webpack/runtime/load script","webpack://wcslight/./node_modules/blob-polyfill/Blob.js","webpack://wcslight/webpack/bootstrap","webpack://wcslight/webpack/runtime/define property getters","webpack://wcslight/webpack/runtime/ensure chunk","webpack://wcslight/webpack/runtime/get javascript chunk filename","webpack://wcslight/webpack/runtime/global","webpack://wcslight/webpack/runtime/hasOwnProperty shorthand","webpack://wcslight/webpack/runtime/make namespace object","webpack://wcslight/webpack/runtime/publicPath","webpack://wcslight/webpack/runtime/jsonp chunk loading","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseUtils.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSWriter.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParsePayload.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSParser.js","webpack://wcslight/./src/model/NumberType.ts","webpack://wcslight/./src/model/CoordsType.ts","webpack://wcslight/./src/model/ImagePixel.ts","webpack://wcslight/./src/model/Utils.ts","webpack://wcslight/./src/model/Point.ts","webpack://wcslight/./src/projections/MercatorProjection.ts","webpack://wcslight/./node_modules/healpixjs/lib-esm/Constants.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Zphi.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Hploc.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Pointing.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Vec3.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/CircleFinder.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Fxyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/pstack.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/RangeSet.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Xyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Healpix.js","webpack://wcslight/./src/projections/HiPSHelper.ts","webpack://wcslight/./src/projections/HiPSProjection.ts","webpack://wcslight/./src/projections/AbstractProjection.ts","webpack://wcslight/./src/projections/HEALPixProjection.ts","webpack://wcslight/./src/projections/GnomonicProjection.ts","webpack://wcslight/./src/WCSLight.ts","webpack://wcslight/./src/projections/TestProj.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"wcslight\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wcslight\"] = factory();\n\telse\n\t\troot[\"wcslight\"] = factory();\n})(self, () => {\nreturn ","var inProgress = {};\nvar dataWebpackPrefix = \"wcslight:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","/* Blob.js\n * A Blob, File, FileReader & URL implementation.\n * 2020-02-01\n *\n * By Eli Grey, https://eligrey.com\n * By Jimmy Wrting, https://github.com/jimmywarting\n * License: MIT\n *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md\n */\n\n(function(global) {\n\t(function (factory) {\n\t\tif (typeof define === \"function\" && define.amd) {\n\t\t\t// AMD. Register as an anonymous module.\n\t\t\tdefine([\"exports\"], factory);\n\t\t} else if (typeof exports === \"object\" && typeof exports.nodeName !== \"string\") {\n\t\t\t// CommonJS\n\t\t\tfactory(exports);\n\t\t} else {\n\t\t\t// Browser globals\n\t\t\tfactory(global);\n\t\t}\n\t})(function (exports) {\n\t\t\"use strict\";\n\n\t\tvar BlobBuilder = global.BlobBuilder\n\t\t\t|| global.WebKitBlobBuilder\n\t\t\t|| global.MSBlobBuilder\n\t\t\t|| global.MozBlobBuilder;\n\n\t\tvar URL = global.URL || global.webkitURL || function (href, a) {\n\t\t\ta = document.createElement(\"a\");\n\t\t\ta.href = href;\n\t\t\treturn a;\n\t\t};\n\n\t\tvar origBlob = global.Blob;\n\t\tvar createObjectURL = URL.createObjectURL;\n\t\tvar revokeObjectURL = URL.revokeObjectURL;\n\t\tvar strTag = global.Symbol && global.Symbol.toStringTag;\n\t\tvar blobSupported = false;\n\t\tvar blobSupportsArrayBufferView = false;\n\t\tvar blobBuilderSupported = BlobBuilder\n\t\t\t&& BlobBuilder.prototype.append\n\t\t\t&& BlobBuilder.prototype.getBlob;\n\n\t\ttry {\n\t\t\t// Check if Blob constructor is supported\n\t\t\tblobSupported = new Blob([\"\"]).size === 2;\n\n\t\t\t// Check if Blob constructor supports ArrayBufferViews\n\t\t\t// Fails in Safari 6, so we need to map to ArrayBuffers there.\n\t\t\tblobSupportsArrayBufferView = new Blob([new Uint8Array([1, 2])]).size === 2;\n\t\t} catch (e) {/**/}\n\n\n\t\t// Helper function that maps ArrayBufferViews to ArrayBuffers\n\t\t// Used by BlobBuilder constructor and old browsers that didn't\n\t\t// support it in the Blob constructor.\n\t\tfunction mapArrayBufferViews (ary) {\n\t\t\treturn ary.map(function (chunk) {\n\t\t\t\tif (chunk.buffer instanceof ArrayBuffer) {\n\t\t\t\t\tvar buf = chunk.buffer;\n\n\t\t\t\t\t// if this is a subarray, make a copy so we only\n\t\t\t\t\t// include the subarray region from the underlying buffer\n\t\t\t\t\tif (chunk.byteLength !== buf.byteLength) {\n\t\t\t\t\t\tvar copy = new Uint8Array(chunk.byteLength);\n\t\t\t\t\t\tcopy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n\t\t\t\t\t\tbuf = copy.buffer;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn buf;\n\t\t\t\t}\n\n\t\t\t\treturn chunk;\n\t\t\t});\n\t\t}\n\n\t\tfunction BlobBuilderConstructor (ary, options) {\n\t\t\toptions = options || {};\n\n\t\t\tvar bb = new BlobBuilder();\n\t\t\tmapArrayBufferViews(ary).forEach(function (part) {\n\t\t\t\tbb.append(part);\n\t\t\t});\n\n\t\t\treturn options.type ? bb.getBlob(options.type) : bb.getBlob();\n\t\t}\n\n\t\tfunction BlobConstructor (ary, options) {\n\t\t\treturn new origBlob(mapArrayBufferViews(ary), options || {});\n\t\t}\n\n\t\tif (global.Blob) {\n\t\t\tBlobBuilderConstructor.prototype = Blob.prototype;\n\t\t\tBlobConstructor.prototype = Blob.prototype;\n\t\t}\n\n\t\t/********************************************************/\n\t\t/*               String Encoder fallback                */\n\t\t/********************************************************/\n\t\tfunction stringEncode (string) {\n\t\t\tvar pos = 0;\n\t\t\tvar len = string.length;\n\t\t\tvar Arr = global.Uint8Array || Array; // Use byte array when possible\n\n\t\t\tvar at = 0; // output position\n\t\t\tvar tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n\t\t\tvar target = new Arr((tlen >> 3) << 3); // ... but at 8 byte offset\n\n\t\t\twhile (pos < len) {\n\t\t\t\tvar value = string.charCodeAt(pos++);\n\t\t\t\tif (value >= 0xd800 && value <= 0xdbff) {\n\t\t\t\t\t// high surrogate\n\t\t\t\t\tif (pos < len) {\n\t\t\t\t\t\tvar extra = string.charCodeAt(pos);\n\t\t\t\t\t\tif ((extra & 0xfc00) === 0xdc00) {\n\t\t\t\t\t\t\t++pos;\n\t\t\t\t\t\t\tvalue = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (value >= 0xd800 && value <= 0xdbff) {\n\t\t\t\t\t\tcontinue; // drop lone surrogate\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// expand the buffer if we couldn't write 4 bytes\n\t\t\t\tif (at + 4 > target.length) {\n\t\t\t\t\ttlen += 8; // minimum extra\n\t\t\t\t\ttlen *= (1.0 + (pos / string.length) * 2); // take 2x the remaining\n\t\t\t\t\ttlen = (tlen >> 3) << 3; // 8 byte offset\n\n\t\t\t\t\tvar update = new Uint8Array(tlen);\n\t\t\t\t\tupdate.set(target);\n\t\t\t\t\ttarget = update;\n\t\t\t\t}\n\n\t\t\t\tif ((value & 0xffffff80) === 0) { // 1-byte\n\t\t\t\t\ttarget[at++] = value; // ASCII\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if ((value & 0xfffff800) === 0) { // 2-byte\n\t\t\t\t\ttarget[at++] = ((value >> 6) & 0x1f) | 0xc0;\n\t\t\t\t} else if ((value & 0xffff0000) === 0) { // 3-byte\n\t\t\t\t\ttarget[at++] = ((value >> 12) & 0x0f) | 0xe0;\n\t\t\t\t\ttarget[at++] = ((value >> 6) & 0x3f) | 0x80;\n\t\t\t\t} else if ((value & 0xffe00000) === 0) { // 4-byte\n\t\t\t\t\ttarget[at++] = ((value >> 18) & 0x07) | 0xf0;\n\t\t\t\t\ttarget[at++] = ((value >> 12) & 0x3f) | 0x80;\n\t\t\t\t\ttarget[at++] = ((value >> 6) & 0x3f) | 0x80;\n\t\t\t\t} else {\n\t\t\t\t\t// FIXME: do we care\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttarget[at++] = (value & 0x3f) | 0x80;\n\t\t\t}\n\n\t\t\treturn target.slice(0, at);\n\t\t}\n\n\t\t/********************************************************/\n\t\t/*               String Decoder fallback                */\n\t\t/********************************************************/\n\t\tfunction stringDecode (buf) {\n\t\t\tvar end = buf.length;\n\t\t\tvar res = [];\n\n\t\t\tvar i = 0;\n\t\t\twhile (i < end) {\n\t\t\t\tvar firstByte = buf[i];\n\t\t\t\tvar codePoint = null;\n\t\t\t\tvar bytesPerSequence = (firstByte > 0xEF) ? 4\n\t\t\t\t\t: (firstByte > 0xDF) ? 3\n\t\t\t\t\t\t: (firstByte > 0xBF) ? 2\n\t\t\t\t\t\t\t: 1;\n\n\t\t\t\tif (i + bytesPerSequence <= end) {\n\t\t\t\t\tvar secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t\t\t\t\tswitch (bytesPerSequence) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (firstByte < 0x80) {\n\t\t\t\t\t\t\tcodePoint = firstByte;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tsecondByte = buf[i + 1];\n\t\t\t\t\t\tif ((secondByte & 0xC0) === 0x80) {\n\t\t\t\t\t\t\ttempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t\t\t\t\t\t\tif (tempCodePoint > 0x7F) {\n\t\t\t\t\t\t\t\tcodePoint = tempCodePoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tsecondByte = buf[i + 1];\n\t\t\t\t\t\tthirdByte = buf[i + 2];\n\t\t\t\t\t\tif ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t\t\t\t\t\t\ttempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t\t\t\t\t\t\tif (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t\t\t\t\t\t\t\tcodePoint = tempCodePoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tsecondByte = buf[i + 1];\n\t\t\t\t\t\tthirdByte = buf[i + 2];\n\t\t\t\t\t\tfourthByte = buf[i + 3];\n\t\t\t\t\t\tif ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t\t\t\t\t\t\ttempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t\t\t\t\t\t\tif (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t\t\t\t\t\t\t\tcodePoint = tempCodePoint;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (codePoint === null) {\n\t\t\t\t\t// we did not generate a valid codePoint so insert a\n\t\t\t\t\t// replacement char (U+FFFD) and advance only 1 byte\n\t\t\t\t\tcodePoint = 0xFFFD;\n\t\t\t\t\tbytesPerSequence = 1;\n\t\t\t\t} else if (codePoint > 0xFFFF) {\n\t\t\t\t\t// encode to utf16 (surrogate pair dance)\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\tres.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t\t\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\n\t\t\t\t}\n\n\t\t\t\tres.push(codePoint);\n\t\t\t\ti += bytesPerSequence;\n\t\t\t}\n\n\t\t\tvar len = res.length;\n\t\t\tvar str = \"\";\n\t\t\tvar j = 0;\n\n\t\t\twhile (j < len) {\n\t\t\t\tstr += String.fromCharCode.apply(String, res.slice(j, j += 0x1000));\n\t\t\t}\n\n\t\t\treturn str;\n\t\t}\n\n\t\t// string -> buffer\n\t\tvar textEncode = typeof TextEncoder === \"function\"\n\t\t\t? TextEncoder.prototype.encode.bind(new TextEncoder())\n\t\t\t: stringEncode;\n\n\t\t// buffer -> string\n\t\tvar textDecode = typeof TextDecoder === \"function\"\n\t\t\t? TextDecoder.prototype.decode.bind(new TextDecoder())\n\t\t\t: stringDecode;\n\n\t\tfunction FakeBlobBuilder () {\n\t\t\tfunction bufferClone (buf) {\n\t\t\t\tvar view = new Array(buf.byteLength);\n\t\t\t\tvar array = new Uint8Array(buf);\n\t\t\t\tvar i = view.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tview[i] = array[i];\n\t\t\t\t}\n\t\t\t\treturn view;\n\t\t\t}\n\t\t\tfunction array2base64 (input) {\n\t\t\t\tvar byteToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n\t\t\t\tvar output = [];\n\n\t\t\t\tfor (var i = 0; i < input.length; i += 3) {\n\t\t\t\t\tvar byte1 = input[i];\n\t\t\t\t\tvar haveByte2 = i + 1 < input.length;\n\t\t\t\t\tvar byte2 = haveByte2 ? input[i + 1] : 0;\n\t\t\t\t\tvar haveByte3 = i + 2 < input.length;\n\t\t\t\t\tvar byte3 = haveByte3 ? input[i + 2] : 0;\n\n\t\t\t\t\tvar outByte1 = byte1 >> 2;\n\t\t\t\t\tvar outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n\t\t\t\t\tvar outByte3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);\n\t\t\t\t\tvar outByte4 = byte3 & 0x3F;\n\n\t\t\t\t\tif (!haveByte3) {\n\t\t\t\t\t\toutByte4 = 64;\n\n\t\t\t\t\t\tif (!haveByte2) {\n\t\t\t\t\t\t\toutByte3 = 64;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tbyteToCharMap[outByte1], byteToCharMap[outByte2],\n\t\t\t\t\t\tbyteToCharMap[outByte3], byteToCharMap[outByte4]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn output.join(\"\");\n\t\t\t}\n\n\t\t\tvar create = Object.create || function (a) {\n\t\t\t\tfunction c () {}\n\t\t\t\tc.prototype = a;\n\t\t\t\treturn new c();\n\t\t\t};\n\n\t\t\tfunction getObjectTypeName (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t}\n\n\t\t\tfunction isPrototypeOf(c, o) {\n\t\t\t\treturn typeof c === \"object\" && Object.prototype.isPrototypeOf.call(c.prototype, o);\n\t\t\t}\n\n\t\t\tfunction isDataView (o) {\n\t\t\t\treturn getObjectTypeName(o) === \"DataView\" || isPrototypeOf(global.DataView, o);\n\t\t\t}\n\n\t\t\tvar arrayBufferClassNames = [\n\t\t\t\t\"Int8Array\",\n\t\t\t\t\"Uint8Array\",\n\t\t\t\t\"Uint8ClampedArray\",\n\t\t\t\t\"Int16Array\",\n\t\t\t\t\"Uint16Array\",\n\t\t\t\t\"Int32Array\",\n\t\t\t\t\"Uint32Array\",\n\t\t\t\t\"Float32Array\",\n\t\t\t\t\"Float64Array\",\n\t\t\t\t\"ArrayBuffer\"\n\t\t\t];\n\n\t\t\tfunction includes(a, v) {\n\t\t\t\treturn a.indexOf(v) !== -1;\n\t\t\t}\n\n\t\t\tfunction isArrayBuffer(o) {\n\t\t\t\treturn includes(arrayBufferClassNames, getObjectTypeName(o)) || isPrototypeOf(global.ArrayBuffer, o);\n\t\t\t}\n\n\t\t\tfunction concatTypedarrays (chunks) {\n\t\t\t\tvar size = 0;\n\t\t\t\tvar j = chunks.length;\n\t\t\t\twhile (j--) { size += chunks[j].length; }\n\t\t\t\tvar b = new Uint8Array(size);\n\t\t\t\tvar offset = 0;\n\t\t\t\tfor (var i = 0; i < chunks.length; i++) {\n\t\t\t\t\tvar chunk = chunks[i];\n\t\t\t\t\tb.set(chunk, offset);\n\t\t\t\t\toffset += chunk.byteLength || chunk.length;\n\t\t\t\t}\n\n\t\t\t\treturn b;\n\t\t\t}\n\n\t\t\t/********************************************************/\n\t\t\t/*                   Blob constructor                   */\n\t\t\t/********************************************************/\n\t\t\tfunction Blob (chunks, opts) {\n\t\t\t\tchunks = chunks ? chunks.slice() : [];\n\t\t\t\topts = opts == null ? {} : opts;\n\t\t\t\tfor (var i = 0, len = chunks.length; i < len; i++) {\n\t\t\t\t\tvar chunk = chunks[i];\n\t\t\t\t\tif (chunk instanceof Blob) {\n\t\t\t\t\t\tchunks[i] = chunk._buffer;\n\t\t\t\t\t} else if (typeof chunk === \"string\") {\n\t\t\t\t\t\tchunks[i] = textEncode(chunk);\n\t\t\t\t\t} else if (isDataView(chunk)) {\n\t\t\t\t\t\tchunks[i] = bufferClone(chunk.buffer);\n\t\t\t\t\t} else if (isArrayBuffer(chunk)) {\n\t\t\t\t\t\tchunks[i] = bufferClone(chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunks[i] = textEncode(String(chunk));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._buffer = global.Uint8Array\n\t\t\t\t\t? concatTypedarrays(chunks)\n\t\t\t\t\t: [].concat.apply([], chunks);\n\t\t\t\tthis.size = this._buffer.length;\n\n\t\t\t\tthis.type = opts.type || \"\";\n\t\t\t\tif (/[^\\u0020-\\u007E]/.test(this.type)) {\n\t\t\t\t\tthis.type = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tthis.type = this.type.toLowerCase();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tBlob.prototype.arrayBuffer = function () {\n\t\t\t\treturn Promise.resolve(this._buffer.buffer || this._buffer);\n\t\t\t};\n\n\t\t\tBlob.prototype.text = function () {\n\t\t\t\treturn Promise.resolve(textDecode(this._buffer));\n\t\t\t};\n\n\t\t\tBlob.prototype.slice = function (start, end, type) {\n\t\t\t\tvar slice = this._buffer.slice(start || 0, end || this._buffer.length);\n\t\t\t\treturn new Blob([slice], {type: type});\n\t\t\t};\n\n\t\t\tBlob.prototype.toString = function () {\n\t\t\t\treturn \"[object Blob]\";\n\t\t\t};\n\n\t\t\t/********************************************************/\n\t\t\t/*                   File constructor                   */\n\t\t\t/********************************************************/\n\t\t\tfunction File (chunks, name, opts) {\n\t\t\t\topts = opts || {};\n\t\t\t\tvar a = Blob.call(this, chunks, opts) || this;\n\t\t\t\ta.name = name.replace(/\\//g, \":\");\n\t\t\t\ta.lastModifiedDate = opts.lastModified ? new Date(opts.lastModified) : new Date();\n\t\t\t\ta.lastModified = +a.lastModifiedDate;\n\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tFile.prototype = create(Blob.prototype);\n\t\t\tFile.prototype.constructor = File;\n\n\t\t\tif (Object.setPrototypeOf) {\n\t\t\t\tObject.setPrototypeOf(File, Blob);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFile.__proto__ = Blob;\n\t\t\t\t} catch (e) {/**/}\n\t\t\t}\n\n\t\t\tFile.prototype.toString = function () {\n\t\t\t\treturn \"[object File]\";\n\t\t\t};\n\n\t\t\t/********************************************************/\n\t\t\t/*                FileReader constructor                */\n\t\t\t/********************************************************/\n\t\t\tfunction FileReader () {\n\t\t\t\tif (!(this instanceof FileReader)) {\n\t\t\t\t\tthrow new TypeError(\"Failed to construct 'FileReader': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n\t\t\t\t}\n\n\t\t\t\tvar delegate = document.createDocumentFragment();\n\t\t\t\tthis.addEventListener = delegate.addEventListener;\n\t\t\t\tthis.dispatchEvent = function (evt) {\n\t\t\t\t\tvar local = this[\"on\" + evt.type];\n\t\t\t\t\tif (typeof local === \"function\") local(evt);\n\t\t\t\t\tdelegate.dispatchEvent(evt);\n\t\t\t\t};\n\t\t\t\tthis.removeEventListener = delegate.removeEventListener;\n\t\t\t}\n\n\t\t\tfunction _read (fr, blob, kind) {\n\t\t\t\tif (!(blob instanceof Blob)) {\n\t\t\t\t\tthrow new TypeError(\"Failed to execute '\" + kind + \"' on 'FileReader': parameter 1 is not of type 'Blob'.\");\n\t\t\t\t}\n\n\t\t\t\tfr.result = \"\";\n\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tthis.readyState = FileReader.LOADING;\n\t\t\t\t\tfr.dispatchEvent(new Event(\"load\"));\n\t\t\t\t\tfr.dispatchEvent(new Event(\"loadend\"));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tFileReader.EMPTY = 0;\n\t\t\tFileReader.LOADING = 1;\n\t\t\tFileReader.DONE = 2;\n\t\t\tFileReader.prototype.error = null;\n\t\t\tFileReader.prototype.onabort = null;\n\t\t\tFileReader.prototype.onerror = null;\n\t\t\tFileReader.prototype.onload = null;\n\t\t\tFileReader.prototype.onloadend = null;\n\t\t\tFileReader.prototype.onloadstart = null;\n\t\t\tFileReader.prototype.onprogress = null;\n\n\t\t\tFileReader.prototype.readAsDataURL = function (blob) {\n\t\t\t\t_read(this, blob, \"readAsDataURL\");\n\t\t\t\tthis.result = \"data:\" + blob.type + \";base64,\" + array2base64(blob._buffer);\n\t\t\t};\n\n\t\t\tFileReader.prototype.readAsText = function (blob) {\n\t\t\t\t_read(this, blob, \"readAsText\");\n\t\t\t\tthis.result = textDecode(blob._buffer);\n\t\t\t};\n\n\t\t\tFileReader.prototype.readAsArrayBuffer = function (blob) {\n\t\t\t\t_read(this, blob, \"readAsText\");\n\t\t\t\t// return ArrayBuffer when possible\n\t\t\t\tthis.result = (blob._buffer.buffer || blob._buffer).slice();\n\t\t\t};\n\n\t\t\tFileReader.prototype.abort = function () {};\n\n\t\t\t/********************************************************/\n\t\t\t/*                         URL                          */\n\t\t\t/********************************************************/\n\t\t\tURL.createObjectURL = function (blob) {\n\t\t\t\treturn blob instanceof Blob\n\t\t\t\t\t? \"data:\" + blob.type + \";base64,\" + array2base64(blob._buffer)\n\t\t\t\t\t: createObjectURL.call(URL, blob);\n\t\t\t};\n\n\t\t\tURL.revokeObjectURL = function (url) {\n\t\t\t\trevokeObjectURL && revokeObjectURL.call(URL, url);\n\t\t\t};\n\n\t\t\t/********************************************************/\n\t\t\t/*                         XHR                          */\n\t\t\t/********************************************************/\n\t\t\tvar _send = global.XMLHttpRequest && global.XMLHttpRequest.prototype.send;\n\t\t\tif (_send) {\n\t\t\t\tXMLHttpRequest.prototype.send = function (data) {\n\t\t\t\t\tif (data instanceof Blob) {\n\t\t\t\t\t\tthis.setRequestHeader(\"Content-Type\", data.type);\n\t\t\t\t\t\t_send.call(this, textDecode(data._buffer));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_send.call(this, data);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\texports.Blob = Blob;\n\t\t\texports.File = File;\n\t\t\texports.FileReader = FileReader;\n\t\t\texports.URL = URL;\n\t\t}\n\n\t\tfunction fixFileAndXHR () {\n\t\t\tvar isIE = !!global.ActiveXObject || (\n\t\t\t\t\"-ms-scroll-limit\" in document.documentElement.style &&\n\t\t\t\t\"-ms-ime-align\" in document.documentElement.style\n\t\t\t);\n\n\t\t\t// Monkey patched\n\t\t\t// IE doesn't set Content-Type header on XHR whose body is a typed Blob\n\t\t\t// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/6047383\n\t\t\tvar _send = global.XMLHttpRequest && global.XMLHttpRequest.prototype.send;\n\t\t\tif (isIE && _send) {\n\t\t\t\tXMLHttpRequest.prototype.send = function (data) {\n\t\t\t\t\tif (data instanceof Blob) {\n\t\t\t\t\t\tthis.setRequestHeader(\"Content-Type\", data.type);\n\t\t\t\t\t\t_send.call(this, data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_send.call(this, data);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tnew File([], \"\");\n\t\t\t\texports.File = global.File;\n\t\t\t\texports.FileReader = global.FileReader;\n\t\t\t} catch (e) {\n\t\t\t\ttry {\n\t\t\t\t\texports.File = new Function(\"class File extends Blob {\" +\n\t\t\t\t\t\t\"constructor(chunks, name, opts) {\" +\n\t\t\t\t\t\t\t\"opts = opts || {};\" +\n\t\t\t\t\t\t\t\"super(chunks, opts || {});\" +\n\t\t\t\t\t\t\t\"this.name = name.replace(/\\\\//g, \\\":\\\");\" +\n\t\t\t\t\t\t\t\"this.lastModifiedDate = opts.lastModified ? new Date(opts.lastModified) : new Date();\" +\n\t\t\t\t\t\t\t\"this.lastModified = +this.lastModifiedDate;\" +\n\t\t\t\t\t\t\"}};\" +\n\t\t\t\t\t\t\"return new File([], \\\"\\\"), File\"\n\t\t\t\t\t)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\texports.File = function (b, d, c) {\n\t\t\t\t\t\tvar blob = new Blob(b, c);\n\t\t\t\t\t\tvar t = c && void 0 !== c.lastModified ? new Date(c.lastModified) : new Date();\n\n\t\t\t\t\t\tblob.name = d.replace(/\\//g, \":\");\n\t\t\t\t\t\tblob.lastModifiedDate = t;\n\t\t\t\t\t\tblob.lastModified = +t;\n\t\t\t\t\t\tblob.toString = function () {\n\t\t\t\t\t\t\treturn \"[object File]\";\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (strTag) {\n\t\t\t\t\t\t\tblob[strTag] = \"File\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn blob;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (blobSupported) {\n\t\t\tfixFileAndXHR();\n\t\t\texports.Blob = blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n\t\t} else if (blobBuilderSupported) {\n\t\t\tfixFileAndXHR();\n\t\t\texports.Blob = BlobBuilderConstructor;\n\t\t} else {\n\t\t\tFakeBlobBuilder();\n\t\t}\n\n\t\tif (strTag) {\n\t\t\tif (!exports.File.prototype[strTag]) exports.File.prototype[strTag] = \"File\";\n\t\t\tif (!exports.Blob.prototype[strTag]) exports.Blob.prototype[strTag] = \"Blob\";\n\t\t\tif (!exports.FileReader.prototype[strTag]) exports.FileReader.prototype[strTag] = \"FileReader\";\n\t\t}\n\n\t\tvar blob = exports.Blob.prototype;\n\t\tvar stream;\n\n\t\ttry {\n\t\t\tnew ReadableStream({ type: \"bytes\" });\n\t\t\tstream = function stream() {\n\t\t\t\tvar position = 0;\n\t\t\t\tvar blob = this;\n\n\t\t\t\treturn new ReadableStream({\n\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\tautoAllocateChunkSize: 524288,\n\n\t\t\t\t\tpull: function (controller) {\n\t\t\t\t\t\tvar v = controller.byobRequest.view;\n\t\t\t\t\t\tvar chunk = blob.slice(position, position + v.byteLength);\n\t\t\t\t\t\treturn chunk.arrayBuffer()\n\t\t\t\t\t\t\t.then(function (buffer) {\n\t\t\t\t\t\t\t\tvar uint8array = new Uint8Array(buffer);\n\t\t\t\t\t\t\t\tvar bytesRead = uint8array.byteLength;\n\n\t\t\t\t\t\t\t\tposition += bytesRead;\n\t\t\t\t\t\t\t\tv.set(uint8array);\n\t\t\t\t\t\t\t\tcontroller.byobRequest.respond(bytesRead);\n\n\t\t\t\t\t\t\t\tif(position >= blob.size)\n\t\t\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t} catch (e) {\n\t\t\ttry {\n\t\t\t\tnew ReadableStream({});\n\t\t\t\tstream = function stream(blob){\n\t\t\t\t\tvar position = 0;\n\n\t\t\t\t\treturn new ReadableStream({\n\t\t\t\t\t\tpull: function (controller) {\n\t\t\t\t\t\t\tvar chunk = blob.slice(position, position + 524288);\n\n\t\t\t\t\t\t\treturn chunk.arrayBuffer().then(function (buffer) {\n\t\t\t\t\t\t\t\tposition += buffer.byteLength;\n\t\t\t\t\t\t\t\tvar uint8array = new Uint8Array(buffer);\n\t\t\t\t\t\t\t\tcontroller.enqueue(uint8array);\n\n\t\t\t\t\t\t\t\tif (position == blob.size)\n\t\t\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} catch (e) {\n\t\t\t\ttry {\n\t\t\t\t\tnew Response(\"\").body.getReader().read();\n\t\t\t\t\tstream = function stream() {\n\t\t\t\t\t\treturn (new Response(this)).body;\n\t\t\t\t\t};\n\t\t\t\t} catch (e) {\n\t\t\t\t\tstream = function stream() {\n\t\t\t\t\t\tthrow new Error(\"Include https://github.com/MattiasBuelens/web-streams-polyfill\");\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction promisify(obj) {\n\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\tobj.onload = obj.onerror = function(evt) {\n\t\t\t\t\tobj.onload = obj.onerror = null;\n\n\t\t\t\t\tevt.type === \"load\" ?\n\t\t\t\t\t\tresolve(obj.result || obj) :\n\t\t\t\t\t\treject(new Error(\"Failed to read the blob/file\"));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\tif (!blob.arrayBuffer) {\n\t\t\tblob.arrayBuffer = function arrayBuffer() {\n\t\t\t\tvar fr = new FileReader();\n\t\t\t\tfr.readAsArrayBuffer(this);\n\t\t\t\treturn promisify(fr);\n\t\t\t};\n\t\t}\n\n\t\tif (!blob.text) {\n\t\t\tblob.text = function text() {\n\t\t\t\tvar fr = new FileReader();\n\t\t\t\tfr.readAsText(this);\n\t\t\t\treturn promisify(fr);\n\t\t\t};\n\t\t}\n\n\t\tif (!blob.stream) {\n\t\t\tblob.stream = stream;\n\t\t}\n\t});\n})(\n\ttypeof self !== \"undefined\" && self ||\n\t\ttypeof window !== \"undefined\" && window ||\n\t\ttypeof global !== \"undefined\" && global ||\n\t\tthis\n);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t190: 0,\n\t499: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkwcslight\"] = self[\"webpackChunkwcslight\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class FITSHeaderItem {\n    constructor(key, value, comment) {\n        this._key = key !== undefined ? key : undefined;\n        this._value = value !== undefined ? value : undefined;\n        this._comment = comment !== undefined ? comment : undefined;\n    }\n    get key() {\n        return this._key;\n    }\n    get comment() {\n        return this._comment;\n    }\n    get value() {\n        return this._value;\n    }\n}\n//# sourceMappingURL=FITSHeaderItem.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n// reference FTIS standard doc https://heasarc.gsfc.nasa.gov/docs/fcg/standard_dict.html\nexport class FITSHeader extends Map {\n    constructor() {\n        super();\n        this._offset = undefined;\n        this._items = [];\n    }\n    set offset(offset) {\n        this._offset = offset;\n    }\n    get offset() {\n        return this._offset;\n    }\n    getItemList() {\n        return this._items;\n    }\n    getItemListOf(key) {\n        const res = [];\n        for (let i = 0; i < this._items.length; i++) {\n            const item = this._items[i];\n            if (item.key == key) {\n                res.push(item);\n            }\n        }\n        return res;\n    }\n    addItemAtTheBeginning(item) {\n        if (item.key !== undefined) {\n            if ([\n                \"SIMPLE\",\n                \"BITPIX\",\n                \"NAXIS\",\n                \"NAXIS1\",\n                \"NAXIS2\",\n                \"BLANK\",\n                \"BZERO\",\n                \"BSCALE\",\n                \"DATAMIN\",\n                \"DATAMAX\",\n                \"NPIX\",\n                \"ORDER\",\n                \"CRPIX1\",\n                \"CRPIX2\",\n                \"CDELT1\",\n                \"CDELT2\",\n                \"CRVAL1\",\n                \"CRVAL2\",\n            ].includes(item.key)) {\n                this.set(item.key, item.value);\n            }\n        }\n        const newitemlist = [item].concat(this._items);\n        this._items = newitemlist;\n    }\n    addItem(item) {\n        if (item.key !== undefined) {\n            if ([\n                \"SIMPLE\",\n                \"BITPIX\",\n                \"NAXIS\",\n                \"NAXIS1\",\n                \"NAXIS2\",\n                \"BLANK\",\n                \"BZERO\",\n                \"BSCALE\",\n                \"DATAMIN\",\n                \"DATAMAX\",\n                \"NPIX\",\n                \"ORDER\",\n                \"CRPIX1\",\n                \"CRPIX2\",\n                \"CDELT1\",\n                \"CDELT2\",\n                \"CRVAL1\",\n                \"CRVAL2\",\n            ].includes(item.key)) {\n                this.set(item.key, item.value);\n            }\n        }\n        this._items.push(item);\n    }\n    getNumRows() {\n        return this._items.length;\n    }\n}\n//# sourceMappingURL=FITSHeader.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseUtils {\n    static getStringAt(data, offset, length) {\n        const chars = [];\n        for (let i = offset, j = 0; i < offset + length; i++, j++) {\n            chars[j] = String.fromCharCode(data.charCodeAt(i) & 0xff);\n        }\n        return chars.join(\"\");\n    }\n    static byteString(n) {\n        if (n < 0 || n > 255 || n % 1 !== 0) {\n            throw new Error(n + \" does not fit in a byte\");\n        }\n        return (\"000000000\" + n.toString(2)).substr(-8);\n    }\n    static parse32bitSinglePrecisionFloatingPoint(byte1, byte2, byte3, byte4) {\n        let long = (((((byte1 << 8) + byte2) << 8) + byte3) << 8) + byte4;\n        if (long < 0)\n            long += 4294967296;\n        const float = (1.0 + (long & 0x007fffff) / 0x0800000) *\n            Math.pow(2, ((long & 0x7f800000) >> 23) - 127);\n        return float;\n    }\n    static convertBlankToBytes(blank, nbytes) {\n        let str = Math.abs(blank).toString(2);\n        while (str.length / 8 < nbytes) {\n            str += \"0\";\n        }\n        const buffer = new ArrayBuffer(nbytes);\n        const uint8 = new Uint8Array(buffer);\n        for (let i = 0; i < nbytes; i++) {\n            uint8[i] = parseInt(str.substr(8 * i, 8 * (i + 1)), 2);\n        }\n        return uint8;\n    }\n    /** https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac */\n    static parseFloatingPointFormat(bytes, ebits, fbits) {\n        // Bytes to bits\n        const bits = [];\n        for (let i = bytes.length; i; i -= 1) {\n            let byte = bytes[i - 1];\n            for (let j = 8; j; j -= 1) {\n                bits.push(byte % 2 ? 1 : 0);\n                byte = byte >> 1;\n            }\n        }\n        bits.reverse();\n        const str = bits.join(\"\");\n        // Unpack sign, exponent, fraction\n        const bias = (1 << (ebits - 1)) - 1;\n        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n        const e = parseInt(str.substring(1, 1 + ebits), 2);\n        const f = parseInt(str.substring(1 + ebits), 2);\n        // Produce number\n        if (e === (1 << ebits) - 1) {\n            return f !== 0 ? undefined : s * Infinity;\n        }\n        else if (e > 0) {\n            return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));\n        }\n        else if (f !== 0) {\n            return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));\n        }\n        else {\n            return s * 0;\n        }\n    }\n    static generate16bit2sComplement(val) {\n        throw new TypeError(\"not implemented yet\" + val);\n    }\n    static parse16bit2sComplement(byte1, byte2) {\n        const unsigned = (byte1 << 8) | byte2;\n        if (unsigned & 0x8000) {\n            return unsigned | 0xffff0000;\n        }\n        else {\n            return unsigned;\n        }\n    }\n    static parse32bit2sComplement(byte1, byte2, byte3, byte4) {\n        const unsigned = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;\n        const s = (unsigned & 0x80000000) >> 31;\n        let res = unsigned & 0xffffffff;\n        if (s) {\n            res = (~unsigned & 0xffffffff) + 1;\n            return -1 * res;\n        }\n        return res;\n    }\n    /**\n     *\n     * @param {*} data string?\n     * @param {*} offset offset in the data\n     * @returns returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index.\n     */\n    static getByteAt(data, offset) {\n        const dataOffset = 0;\n        return data.charCodeAt(offset + dataOffset) & 0xff;\n    }\n    static extractPixelValue(offset, bytes, bitpix) {\n        let px_val = undefined; // pixel value\n        // let px_val1, px_val2, px_val3, px_val4;\n        if (bitpix == 8) {\n            px_val = bytes[0];\n        }\n        else if (bitpix == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(bytes[offset], bytes[offset + 1]);\n        }\n        else if (bitpix == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]);\n        }\n        else if (bitpix == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 8, 23);\n        }\n        else if (bitpix == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (bitpix == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n// export default ParseUtils;\n//# sourceMappingURL=ParseUtils.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/fitsontheweb\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n * import GnomonicProjection from './GnomonicProjection';\n * BITPIX definition from https://archive.stsci.edu/fits/fits_standard/node39.html\n * and \"Definition of the Flexible Image Transport System (FITS)\" standard document\n * defined by FITS Working Group from the International Astronomical Union\n * http://fits.gsfc.nasa.gov/iaufwg/\n * 8\t8-bit Character or unsigned binary integer\n * 16\t16-bit twos-complement binary integer\n * 32\t32-bit twos-complement binary integer\n * -32\t32-bit IEEE single precision floating point\n * -64\t64-bit IEEE double precision floating point\n *\n */\nimport { Blob } from 'blob-polyfill';\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\n// import fs from 'node:fs/promises';\nexport class FITSWriter {\n    constructor() {\n        this._headerArray = new Uint8Array();\n        this._payloadArray = new Array();\n        this._fitsData = new Uint8Array();\n    }\n    run(header, rawdata) {\n        this.prepareHeader(header);\n        this._payloadArray = rawdata;\n        this.prepareFITS();\n    }\n    prepareHeader(headerDetails) {\n        const item = new FITSHeaderItem(\"END\");\n        headerDetails.addItem(item);\n        let str = \"\";\n        for (let i = 0; i < headerDetails.getItemList().length; i++) {\n            const item = headerDetails.getItemList()[i];\n            let s = this.formatHeaderLine(item);\n            if (s !== undefined) {\n                str += s;\n            }\n        }\n        const strBytelen = new TextEncoder().encode(str).length;\n        const nhdu = Math.ceil(strBytelen / 2880);\n        const offset = nhdu * 2880;\n        for (let j = 0; j < offset - strBytelen; j++) {\n            str += \" \";\n        }\n        const ab = new ArrayBuffer(str.length);\n        // Javascript character occupies 2 16-bit -> reducing it to 1 byte\n        this._headerArray = new Uint8Array(ab);\n        for (let i = 0; i < str.length; i++) {\n            this._headerArray[i] = ParseUtils.getByteAt(str, i);\n        }\n    }\n    // formatHeaderLine(item: string | undefined, value: string | number, comment: string) {\n    formatHeaderLine(item) {\n        let str;\n        let keyword = item.key;\n        let value = item.value;\n        let comment = item.comment;\n        if (keyword !== null && keyword !== undefined) {\n            str = keyword;\n            if (keyword == \"END\") {\n                for (let j = 80; j > keyword.length; j--) {\n                    str += \" \";\n                }\n                return str;\n            }\n            if (keyword == \"COMMENT\" || keyword == \"HISTORY\") {\n                for (let i = 0; i < 10 - keyword.length; i++) {\n                    str += \" \";\n                }\n                str += value;\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n                return str;\n            }\n            for (let i = 0; i < 8 - keyword.length; i++) {\n                str += \" \";\n            }\n            str += \"= \";\n            if (value !== null && value !== undefined) {\n                // value\n                str += value;\n                if (comment !== null && comment !== undefined) {\n                    str += comment;\n                }\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n            else {\n                if (comment !== null && comment !== undefined) {\n                    str += comment;\n                }\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n        }\n        else {\n            // keyword null\n            str = \"\";\n            for (let j = 0; j < 18; j++) {\n                str += \" \";\n            }\n            if (comment !== null && comment !== undefined) {\n                str += comment;\n                const len = str.length;\n                for (let j = 80; j > len; j--) {\n                    str += \" \";\n                }\n            }\n            else {\n                str = \"\";\n                for (let j = 80; j > 0; j--) {\n                    str += \" \";\n                }\n            }\n        }\n        return str;\n    }\n    prepareFITS() {\n        const bytes = new Uint8Array(this._headerArray.length +\n            this._payloadArray[0].length * this._payloadArray.length);\n        bytes.set(this._headerArray, 0);\n        for (let i = 0; i < this._payloadArray.length; i++) {\n            const uint8 = this._payloadArray[i];\n            bytes.set(uint8, this._headerArray.length + i * uint8.length);\n        }\n        this._fitsData = bytes;\n    }\n    // writeFITS(fileuri: string) {\n    //   // const dirname = path.dirname(fileuri);\n    //   // fs.mkdir(dirname, { recursive: true });\n    //   fs.writeFile(fileuri, this._fitsData);\n    //   // if (fs.existsSync(dirname)) {\n    //   //   fs.writeFileSync(fileuri, this._fitsData);\n    //   // } else {\n    //   //   console.error(dirname + \" doesn't exist\");\n    //   // }\n    // }\n    typedArrayToURL() {\n        const b = new Blob([this._fitsData], { type: \"application/fits\" });\n        // console.log(`<html><body><img src='${URL.createObjectURL(b)}'</body></html>`);\n        return URL.createObjectURL(b);\n    }\n}\n//# sourceMappingURL=FITSWriter.js.map","// \"use strict\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\n// let colorsMap = new Map();\n// colorsMap.set(\"grayscale\",\"grayscale\");\n// colorsMap.set(\"planck\",\"planck\");\n// colorsMap.set(\"eosb\",\"eosb\");\n// colorsMap.set(\"rainbow\",\"rainbow\");\n// colorsMap.set(\"cmb\",\"cmb\");\n// colorsMap.set(\"cubehelix\",\"cubehelix\");\nexport class ParsePayload {\n    constructor(fitsheader, rawdata) {\n        this._u8data = new Uint8Array();\n        this._BZERO = undefined;\n        this._BSCALE = undefined;\n        this._BLANK = undefined;\n        this._BITPIX = undefined;\n        this._NAXIS1 = undefined;\n        this._NAXIS2 = undefined;\n        this._DATAMIN = undefined;\n        this._DATAMAX = undefined;\n        this._physicalblank = undefined;\n        const buffer = rawdata.slice(fitsheader.offset);\n        this._u8data = new Uint8Array(buffer);\n        this.init(fitsheader);\n    }\n    init(fitsheader) {\n        this._BZERO = fitsheader.get(\"BZERO\");\n        if (this._BZERO === undefined) {\n            this._BZERO = 0;\n        }\n        this._BSCALE = fitsheader.get(\"BSCALE\");\n        if (this._BSCALE === undefined) {\n            this._BSCALE = 1;\n        }\n        this._BLANK = fitsheader.get(\"BLANK\"); // undefined in case it's not present in the header\n        // this._BLANK_pv = this._BZERO + this._BSCALE * this._BLANK || undefined;\n        this._BITPIX = fitsheader.get(\"BITPIX\");\n        this._NAXIS1 = fitsheader.get(\"NAXIS1\");\n        this._NAXIS2 = fitsheader.get(\"NAXIS2\");\n        this._DATAMIN = fitsheader.get(\"DATAMIN\");\n        this._DATAMAX = fitsheader.get(\"DATAMAX\");\n        this._physicalblank = undefined;\n        if (this._DATAMAX === undefined || this._DATAMIN === undefined) {\n            const [min, max] = this.computePhysicalMinAndMax();\n            this._DATAMAX = max;\n            this._DATAMIN = min;\n            const maxitem = new FITSHeaderItem(\"DATAMAX\", max, \" / computed with FITSParser\");\n            const minitem = new FITSHeaderItem(\"DATAMIN\", min, \" / computed with FITSParser\");\n            fitsheader.addItem(maxitem);\n            fitsheader.addItem(minitem);\n            // fitsheader.set(\"DATAMAX\", max);\n            // fitsheader.set(\"DATAMIN\", min);\n        }\n        // let item = new FITSHeaderItem(\"END\", null, null);\n        // fitsheader.addItem(item);\n    }\n    computePhysicalMinAndMax() {\n        let i = 0;\n        if (this._BITPIX === undefined) {\n            throw new Error(\"BITPIX is not defined\");\n        }\n        const bytesXelem = Math.abs(this._BITPIX / 8);\n        const pxLength = this._u8data.byteLength / bytesXelem;\n        let px_val, ph_val;\n        let min = undefined;\n        let max = undefined;\n        if (this._BLANK !== undefined) {\n            this._physicalblank = this.pixel2physicalValue(this._BLANK);\n        }\n        while (i < pxLength) {\n            // px_val = this.extractPixelValue(bytesXelem*i);\n            px_val = this.extractPixelValue(bytesXelem * i);\n            if (px_val === undefined) {\n                i++;\n                continue;\n            }\n            ph_val = this.pixel2physicalValue(px_val);\n            if (min === undefined) {\n                min = ph_val;\n            }\n            if (max === undefined) {\n                max = ph_val;\n            }\n            //TODO check below if\n            if (this._physicalblank === undefined || this._physicalblank !== ph_val) {\n                if (ph_val !== undefined && (ph_val < min || min === undefined)) {\n                    min = ph_val;\n                }\n                if (ph_val !== undefined && (ph_val > max || max === undefined)) {\n                    max = ph_val;\n                }\n            }\n            i++;\n        }\n        return [min, max];\n    }\n    parse() {\n        // let px_val; // pixel array value\n        // let ph_val = undefined; // pixel physical value\n        if (this._BITPIX === undefined) {\n            throw new Error(\"BITPIX is undefined\");\n        }\n        if (this._NAXIS1 === undefined) {\n            throw new Error(\"NAXIS1 is undefined\");\n        }\n        if (this._NAXIS2 === undefined) {\n            throw new Error(\"NAXIS2 is undefined\");\n        }\n        const bytesXelem = Math.abs(this._BITPIX / 8);\n        let pxLength = this._u8data.byteLength / bytesXelem;\n        pxLength = this._NAXIS1 * this._NAXIS2;\n        let k = 0;\n        let c, r;\n        const pixelvalues = [];\n        //  let pixv, pv;\n        while (k < pxLength) {\n            r = Math.floor(k / this._NAXIS1); // row\n            c = (k - r * this._NAXIS1) * bytesXelem; // col\n            if (c === 0) {\n                pixelvalues[r] = new Uint8Array(this._NAXIS1 * bytesXelem);\n            }\n            // px_val = this.extractPixelValue(bytesXelem * k);\n            // ph_val = this.pixel2physicalValue(px_val);\n            // TODO check if ph_val == blank\n            // if not then use ph_val to compute datamin and datamax\n            for (let i = 0; i < bytesXelem; i++) {\n                pixelvalues[r][c + i] = this._u8data[k * bytesXelem + i];\n            }\n            // if (k == 232) {\n            // \tpixv = this.extractPixelValue(k * bytesXelem);\n            // \tpv = this._BZERO + this._BSCALE * pixv;\n            // }\n            k++;\n        }\n        return pixelvalues;\n    }\n    /** this can be deleted */\n    extractPixelValue(offset) {\n        let px_val = undefined; // pixel value\n        if (this._BITPIX == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(this._u8data[offset], this._u8data[offset + 1]);\n        }\n        else if (this._BITPIX == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(this._u8data[offset], this._u8data[offset + 1], this._u8data[offset + 2], this._u8data[offset + 3]);\n        }\n        else if (this._BITPIX == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 4), 8, 23);\n        }\n        else if (this._BITPIX == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (this._BITPIX == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(this._u8data.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n    pixel2physicalValue(pxval) {\n        if (this._BZERO === undefined || this._BSCALE === undefined) {\n            throw new Error(\"Either BZERO or BSCALE is undefined\");\n        }\n        return this._BZERO + this._BSCALE * pxval;\n    }\n}\n//# sourceMappingURL=ParsePayload.js.map","import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseHeader {\n    static parse(rawdata) {\n        // only one header block (2880) allowed atm.\n        // TODO handle multiple header blocks\n        // let headerByteData = new Uint8Array(rawdata, 0, 2880);\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const header = new FITSHeader();\n        let nline = 0;\n        let key = \"\";\n        let val;\n        let u8line;\n        let u8key;\n        let u8val;\n        let u8ind;\n        // let ind: string;\n        let item;\n        let fitsLine;\n        item = null;\n        while (key !== \"END\" && rawdata.length > 0) {\n            // line 80 characters\n            u8line = new Uint8Array(rawdata.slice(nline * 80, nline * 80 + 80));\n            nline++;\n            // key\n            u8key = new Uint8Array(u8line.slice(0, 8));\n            key = textDecoder.decode(u8key).trim();\n            // value indicator\n            u8ind = new Uint8Array(u8line.slice(8, 10));\n            // ind = textDecoder.decode(u8ind);\n            // reading value\n            u8val = new Uint8Array(u8line.slice(10, 80));\n            val = textDecoder.decode(u8val).trim();\n            // ascii 61 -> =\n            // ascii 32 -> [space]\n            if (u8ind[0] == 61 && u8ind[1] == 32) {\n                let firstchar = 32;\n                for (let i = 0; i < u8val.length; i++) {\n                    if (u8val[i] != 32) {\n                        firstchar = u8val[i];\n                        break;\n                    }\n                }\n                // ascii 39 -> '\n                if (firstchar == 39 || !Number(val)) {\n                    // [ival, icomment]\n                    // fitsLine = ParseHeader.parseStringValue(u8val);\n                    fitsLine = ParseHeader.parseLogicalValue(u8val);\n                }\n                else {\n                    // ascii 84 -> T\n                    // ascii 70 -> F\n                    if (firstchar == 84 || firstchar == 70) {\n                        // T or F\n                        fitsLine = ParseHeader.parseLogicalValue(u8val);\n                    }\n                    else {\n                        val = textDecoder.decode(u8val).trim();\n                        if (val.includes(\".\")) {\n                            fitsLine = ParseHeader.parseFloatValue(u8val);\n                        }\n                        else {\n                            fitsLine = ParseHeader.parseIntValue(u8val);\n                        }\n                    }\n                }\n                item = new FITSHeaderItem(key, fitsLine.val, fitsLine.comment);\n            }\n            else {\n                if (key == \"COMMENT\" || key == \"HISTORY\") {\n                    item = new FITSHeaderItem(key, undefined, val);\n                }\n                else {\n                    let firstchar = 32;\n                    for (let i = 0; i < u8val.length; i++) {\n                        if (u8val[i] != 32) {\n                            firstchar = u8val[i];\n                            break;\n                        }\n                    }\n                    if (firstchar == 47) {\n                        // single / this is the case when no key nor value indicator is defined\n                        item = new FITSHeaderItem(undefined, undefined, val);\n                    }\n                    else if (firstchar == 32) {\n                        // case when there's a line with only spaces\n                        item = new FITSHeaderItem(undefined, undefined, undefined);\n                    }\n                }\n            }\n            if (item != null) {\n                header.addItem(item);\n            }\n        }\n        item = new FITSHeaderItem(\"COMMENT\", \"FITS generated with FITSParser on \", undefined);\n        header.addItem(item);\n        const now = new Date();\n        item = new FITSHeaderItem(\"COMMENT\", now.toString());\n        header.addItem(item);\n        const nblock = Math.ceil(nline / 36);\n        const offset = nblock * 2880;\n        header.offset = offset;\n        return header;\n    }\n    static parseStringValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const decoded = textDecoder.decode(u8buffer).trim();\n        const idx = decoded.lastIndexOf(\"/\");\n        const val = decoded.substring(0, idx);\n        let comment = decoded.substring(idx);\n        // if (comment === undefined) {\n        //   comment = null;\n        // }\n        return {\n            val: val,\n            comment: comment,\n        };\n    }\n    static parseLogicalValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: tokens[0].trim(),\n                comment: undefined,\n            };\n        }\n        return {\n            val: tokens[0].trim(),\n            comment: \" /\" + tokens[1],\n        };\n    }\n    static parseIntValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: parseInt(tokens[0].trim()),\n                comment: undefined,\n            };\n        }\n        return {\n            val: parseInt(tokens[0].trim()),\n            comment: \" /\" + tokens[1],\n        };\n    }\n    static parseFloatValue(u8buffer) {\n        const textDecoder = new TextDecoder(\"iso-8859-1\");\n        const val = textDecoder.decode(u8buffer).trim();\n        const tokens = val.split(\"/\");\n        if (tokens[1] === undefined) {\n            return {\n                val: parseFloat(tokens[0].trim()),\n                comment: undefined,\n            };\n        }\n        return {\n            val: parseFloat(tokens[0].trim()),\n            comment: \" /\" + tokens[1],\n        };\n    }\n}\n//# sourceMappingURL=ParseHeader.js.map","/**\n\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FITSWriter } from \"./FITSWriter.js\";\nimport { ParsePayload } from \"./ParsePayload.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\n// import fetch from 'cross-fetch';\n// import { readFile } from \"node:fs/promises\";\nexport class FITSParser {\n    constructor(url) {\n        this._url = url;\n    }\n    loadFITS() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getFile(this._url)\n                .then((rawdata) => {\n                if (rawdata !== null && rawdata.byteLength > 0) {\n                    const uint8 = new Uint8Array(rawdata);\n                    const fits = this.processFits(uint8);\n                    return fits;\n                }\n                return null;\n            })\n                .catch((error) => {\n                var _a, _b;\n                if ((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) {\n                    throw new Error(\"[FITSParser->loadFITS] \" + error.response.data.message);\n                }\n                throw error;\n            });\n        });\n    }\n    processFits(rawdata) {\n        const header = ParseHeader.parse(rawdata);\n        const payloadParser = new ParsePayload(header, rawdata);\n        const pixelvalues = payloadParser.parse();\n        // if (rawdata.length > (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length))) {\n        // let leftover = rawdata.length - (header.getNumRows() + (pixelvalues.length * pixelvalues[0].length));\n        // \tthrow new Error(\"[FITSParser->processFits] It seems that there's at least one more HDU since there are \" + leftover + \" bytes not processed.\");\n        // \tconsole.warn(\"It seems that there's at least one more HDU since there are \" + leftover + \" bytes not processed.\")\n        // }\n        return {\n            header: header,\n            data: pixelvalues,\n        };\n    }\n    static generateFITS(header, rawdata) {\n        const writer = new FITSWriter();\n        writer.run(header, rawdata);\n        return writer.typedArrayToURL();\n    }\n    getFile(uri) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let data;\n            if (!uri.substring(0, 5).toLowerCase().includes(\"http\")) {\n                let p = yield import('./getLocalFile.js');\n                // data = await p.getLocalFile(uri);\n                return yield p.getLocalFile(uri);\n            }\n            else {\n                let p = yield import('./getFile.js');\n                return p.getFile(uri).then((data) => {\n                    return data;\n                }).catch((err) => {\n                    // console.error(\"Error in FITSParser getFile \", uri, err);\n                    return null;\n                });\n                // data = await p.getFile(uri);\n                // return await p.getFile(uri).catch((err) => {\n                //   console.error(err);\n                // });\n            }\n            // return data;\n        });\n    }\n}\n//# sourceMappingURL=FITSParser.js.map","export enum NumberType {\n    DEGREES,\n    RADIANS,\n    DECIMAL,\n    HMS,\n    DMS\n}","/**\n * @author Fabrizio Giordano (Fab77)\n * Enum for coordinate types.\n * @readonly\n * @enum {{name: string, hex: string}}\n */\n\nexport enum CoordsType {\n  CARTESIAN = \"cartesian\",\n  SPHERICAL = \"spherical\",\n  ASTRO = \"astro\"\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\n\nexport class ImagePixel {\n    _i: number;     // int i of input projection\n    _j: number;     // int j of input projection\n    _tileno: number;// int\n    \n    constructor (i: number = null, j: number = null, tileno: number = null) {\n        this._i = i;\n        this._j = j;\n        this._tileno = tileno;\n    }\n\n    geti() {\n        return this._i;\n    }\n\n    getj() {\n        return this._j;\n    }\n\n    get tileno() {\n        return this._tileno\n    }\n}\n","/**\n * @author Fabrizio Giordano (Fab)\n */\n// import vec3 from 'gl-matrix';\n\nimport { AstroCoords } from \"./AstroCoords.js\";\nimport { CartesianCoords } from \"./CartesianCoords.js\";\nimport { HMSCoords } from \"./HMSCoords.js\";\nimport { NumberType } from \"./NumberType.js\";\nimport { SexagesimalCoords } from \"./SexagesimalCoords.js\";\nimport { SphericalCoords } from \"./SphericalCoords.js\";\n\nfunction Utils(){\n\t\n}\n\nexport function cartesianToSpherical(xyz: CartesianCoords): SphericalCoords{\n\tlet dotXYZ = dot(xyz, xyz);\n\tlet r = Math.sqrt(dotXYZ);\t\n\tlet thetaRad = Math.acos(xyz[2]/r);\n\tlet thetaDeg = radToDeg(thetaRad);\n\t// NB: in atan(y/x) is written with params switched atan2(x, y)\n\tlet phiRad = Math.atan2(xyz[1],xyz[0]);\n\tlet phiDeg = radToDeg(phiRad);\n\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\treturn {\n\t\tphiDeg: phiDeg, \n\t\tthetaDeg: thetaDeg,\n\t\tphiRad:phiRad,\n\t\tthetaRad: thetaRad\n\t};\n};\n\nexport function sphericalToAstro(phiTheta: SphericalCoords): AstroCoords{\n\tlet raDeg: number;\n\tlet decDeg: number;\n\n\traDeg = phiTheta.phiDeg;\n\tif (raDeg < 0){\n\t\traDeg += 360;\n\t}\n\tdecDeg = 90 - phiTheta.thetaDeg;\n\t\n\treturn {\n\t\t\"raDeg\": raDeg,\n\t\t\"decDeg\": decDeg,\n\t\t\"raRad\": degToRad(raDeg),\n\t\t\"decRad\": degToRad(decDeg)\n\n\t};\n}\n\nexport function astroToSpherical(raDec: AstroCoords): SphericalCoords{\n\t\n\tlet phiDeg: number;\n\tlet thetaDeg: number;\n\n\tphiDeg = raDec.raDeg;\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\t\n\tthetaDeg = 90 - raDec.decDeg;\n\t\n\treturn {\n\t\t\"phiDeg\": phiDeg,\n\t\t\"thetaDeg\": thetaDeg,\n\t\t\"phiRad\": degToRad(phiDeg),\n\t\t\"thetaRad\": degToRad(thetaDeg),\n\t};\n}\n\nexport function sphericalToCartesian(phiTheta: SphericalCoords, r: number): CartesianCoords{\n\tr = (r == undefined) ? 1 : r;\n\tvar x = r * Math.sin(phiTheta.thetaRad) * Math.cos(phiTheta.phiRad);\n\tvar y = r * Math.sin(phiTheta.thetaRad) * Math.sin(phiTheta.phiRad);\n\tvar z = r * Math.cos(phiTheta.thetaRad);\n\n\treturn {\n\t\t\"x\": x, \n\t\t\"y\": y, \n\t\t\"z\": z\n\t};\n};\n\nexport function fillAstro(ra: number, dec: number, unit: NumberType): AstroCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"raDeg\": ra,\n\t\t\t\"decDeg\": dec,\n\t\t\t\"raRad\": degToRad(ra),\n\t\t\t\"decRad\": degToRad(dec)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"raRad\": ra,\n\t\t\t\"decRad\": dec,\n\t\t\t\"raDeg\": radToDeg(ra),\n\t\t\t\"decDeg\": radToDeg(dec)\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n\t\n}\n\n\nexport function fillSpherical(phi: number, theta: number, unit: NumberType):  SphericalCoords{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"phiDeg\": phi,\n\t\t\t\"thetaDeg\": theta,\n\t\t\t\"phiRad\": degToRad(phi),\n\t\t\t\"thetaRad\": degToRad(theta)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"phiDeg\": radToDeg(phi),\n\t\t\t\"thetaDeg\": radToDeg(theta),\n\t\t\t\"phiRad\": phi,\n\t\t\t\"thetaRad\": theta\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t}\n}\n\nfunction dot(a: CartesianCoords, b: CartesianCoords) : number{\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n\nexport function colorHex2RGB(hexColor: string): [number, number, number] {\n\n//\tconsole.log(hexColor);\n\tvar hex1 = hexColor.substring(1,3);\n\tvar hex2 = hexColor.substring(3,5);\n\tvar hex3 = hexColor.substring(5,7);\n\t\n\tvar dec1 = parseInt(hex1, 16);\n\tvar dec2 = parseInt(hex2, 16);\n\tvar dec3 = parseInt(hex3, 16);\n\t\n\tvar rgb1 = (dec1 / 255).toFixed(2);\n\tvar rgb2 = (dec2 / 255).toFixed(2);\n\tvar rgb3 = (dec3 / 255).toFixed(2);\n\t\n\treturn [parseFloat(rgb1), parseFloat(rgb2), parseFloat(rgb3)];\n\n}\n\nexport function degToRad(degrees: number) : number{\n\treturn (degrees / 180 ) * Math.PI ;\n}\n\nexport function radToDeg(radians: number) : number{\n\treturn radians * 180 / Math.PI;\n}\n\nexport function raDegToHMS(raDeg: number): HMSCoords{\n\t\n\tvar h = Math.floor(raDeg/15);\n\tvar m = Math.floor((raDeg/15 - h) * 60);\n\tvar s = (raDeg/15 - h - m/60) * 3600;\n\t\n\treturn {\n\t\th: h, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nexport function decDegToDMS(decDeg: number): SexagesimalCoords{\n\tvar sign = 1;\n\tif (decDeg < 0){\n\t\tsign = -1;\n\t}\n\t\n\tvar decDeg_abs = Math.abs(decDeg);\n\tvar d = Math.trunc(decDeg_abs);\n\t\n\tvar m = Math.trunc( (decDeg_abs - d) * 60);\n\t\n\tvar s = (decDeg_abs - d - m/60) * 3600;\n\td = d * sign;\n\t\n\treturn {\n\t\td: d, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nfunction dms2DecDeg(decDMS: SexagesimalCoords){\n\tvar sign = Math.sign(decDMS.d);\n\tvar deg = (decDMS.d) + sign * (decDMS.m / 60) + sign * (decDMS.s/3600);\n\treturn deg;\n}\n\nfunction hms2RaDeg(raHMS: HMSCoords){\n\tvar sign = Math.sign(raHMS.h);\n\tvar deg = (raHMS.h + sign * (raHMS.m / 60) + sign * (raHMS.s/3600)) * 15;\n\treturn deg;\n}\n\nfunction worldToModel(xy: [number, number], radius: number): [number, number, number]{\n\tvar x = xy[0];\n\tvar y = xy[1];\n\tvar z = Math.sqrt(radius*radius - xy[0]*xy[0] - xy[1]*xy[1]);\n\treturn [x, y, z];\n}\n\n","/**\n * @author Fabrizio Giordano (Fab77)\n */\n\nimport {sphericalToCartesian, cartesianToSpherical, sphericalToAstro, astroToSpherical, fillSpherical, fillAstro} from './Utils.js';\nimport { CartesianCoords } from './CartesianCoords.js';\nimport { AstroCoords} from './AstroCoords.js';\nimport { CoordsType } from './CoordsType.js';\nimport { SphericalCoords } from './SphericalCoords.js';\nimport { NumberType } from './NumberType.js';\nimport { EquatorialCoords } from './EquatorialCoords.js';\nimport { GalacticCoords } from './GalacticCoords.js';\n\nexport class Point{\n\n\t#astro: AstroCoords;\n\t// #equatorial: EquatorialCoords;\n\t// #galactic: GalacticCoords;\n\n\t#spherical: SphericalCoords;\n\t#cartesian: CartesianCoords;\n\n\tconstructor(in_type: CoordsType, unit: NumberType, ...coords: Array<number>) {\n\n\t\tif (in_type == CoordsType.CARTESIAN){\n\t\t\tthis.#cartesian.x = parseFloat(coords[0].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.y = parseFloat(coords[1].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#cartesian.z = parseFloat(coords[2].toFixed(global.MAX_DECIMALS));\n\t\t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t\t} else if (in_type == CoordsType.ASTRO){\n\t\t\tthis.#astro = fillAstro(coords[0],  coords[1], unit);\n\t\t\tthis.#spherical = astroToSpherical(this.#astro);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\n\t\t} else if (in_type == CoordsType.SPHERICAL){\n\t\t\tthis.#spherical = fillSpherical(coords[0],  coords[1], unit);\n\t\t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\tthis.#astro = sphericalToAstro(this.#spherical);\n\n\t\t} else{\n\t\t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t\t}\n\t\tif (this.#spherical.phiDeg > 360) {\n\t\t\tthis.#spherical.phiDeg -= 360;\n\t\t}\n\t\tif (this.#astro.raDeg > 360) {\n\t\t\tthis.#astro.raDeg -= 360;\n\t\t}\n\t}\n\n\n\t// constructor(in_options: ICoordsFormat, in_type: CoordsType){\n\t\t\n\t// \tif (in_type == CoordsType.CARTESIAN){\n\n\t// \t\tthis.#cartesian.x = parseFloat((in_options as CartesianCoords).x.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.y = parseFloat((in_options as CartesianCoords).y.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.#cartesian.z = parseFloat((in_options as CartesianCoords).z.toFixed(global.MAX_DECIMALS));\n\n\t// \t\tthis.#spherical = cartesianToSpherical(this.#cartesian);\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else if (in_type == CoordsType.ASTRO){\n\t\t\t\n\t// \t\tif ((in_options as AstroCoords).raDeg && (in_options as AstroCoords).decDeg) {\n\t// \t\t\tthis.#astro = radegDecdegToAstro((in_options as AstroCoords).raDeg,  (in_options as AstroCoords).decDeg );\n\t// \t\t} else if ((in_options as AstroCoords).raRad && (in_options as AstroCoords).decRad) {\n\t// \t\t\tthis.#astro = raradDecradToAstro((in_options as AstroCoords).raRad,  (in_options as AstroCoords).decRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"AstroCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\t// \t\tthis.#spherical = astroToSpherical(this.#astro);\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\t\n\t// \t}else if (in_type == CoordsType.SPHERICAL){\n\n\t// \t\tif ((in_options as SphericalCoords).phiDeg && (in_options as SphericalCoords).thetaDeg) {\n\t// \t\t\tthis.#spherical = phidegThetadegToSpherical((in_options as SphericalCoords).phiDeg,  (in_options as SphericalCoords).thetaDeg );\n\t// \t\t} else if ((in_options as SphericalCoords).phiRad && (in_options as SphericalCoords).thetaRad) {\n\t// \t\t\tthis.#spherical = phiradThetaradToSpherical((in_options as SphericalCoords).phiRad,  (in_options as SphericalCoords).thetaRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"SphericalCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\n\t// \t\tthis.#cartesian = sphericalToCartesian(this.#spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t// \t\tthis.#astro = sphericalToAstro(this.#spherical);\n\t\t\t\n\t// \t}else{\n\t// \t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t// \t}\n\t// }\n\n\tget spherical() {\n\t\treturn this.#spherical;\n\t}\n\n\tget astro() {\n\t\treturn this.#astro;\n\t}\n\n\tget cartesian() {\n\t\treturn this.#cartesian;\n\t}\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// /** Scale the vector by a given factor\n    // @param n the scale factor */\n\t// scale(n: number): Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*n, this.y*n, this.z*n);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// dot(v: Point): number{ \n\t// \treturn this.x*v.x + this.y*v.y + this.z*v.z; \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// cross(v: Point): Point{ \n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.y*v.z - v.y*this.z, this.z*v.x - v.z*this.x, this.x*v.y - v.x*this.y);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// norm() : Point{\n\t// \tlet d = 1./this.length();\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*d, this.y*d, this.z*d);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// length(): number{ \n\t// \treturn Math.sqrt(this.lengthSquared()); \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// lengthSquared(): number{ \n\t// \treturn this.x*this.x + this.y*this.y + this.z*this.z; \n  \t// };\n\n\t// subtract(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x - v.x, this.y - v.y, this.z - v.z);\n\t// }\n\n\t// add(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x + v.x, this.y + v.y, this.z + v.z);\n\t// }\n\t\n\n\t// get x(){\n\t// \treturn this._x;\n\t// }\n\t\n\t// get y(){\n\t// \treturn this._y;\n\t// }\n\t\n\t// get z(){\n\t// \treturn this._z;\n\t// }\n\t\n\t// get xyz(){\n    //     return this._xyz;\n    // }\n\t\n    // get raDeg(){\n    //     return this._raDeg;\n    // }\n    \n    // get decDeg(){\n    //     return this._decDeg;\n    // }\n    \n    // get raDecDeg(){\n    //     return this._raDecDeg;\n    // }\n    \n    // toADQL(){\n    // \treturn this._raDecDeg[0]+\",\"+this._raDecDeg[1];\n    // }\n    \n    // toString(){\n    // \treturn \"(raDeg, decDeg) => (\"+this._raDecDeg[0]+\",\"+this._raDecDeg[1]+\") (x, y,z) => (\"+this._xyz[0]+\",\"+this._xyz[1]+\",\"+this._xyz[2]+\")\";\n    // }\n}\n\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n \n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\n\n\nexport class MercatorProjection implements AbstractProjection {\n\n    _minra!: number;\n    _mindec!: number;\n    _naxis1!: number;\n    _naxis2!: number;\n    \n    _fitsheader: FITSHeader[];\n    _infile!: string;\n    _ctype1: string; // TODO should be RA ENUM\n    _ctype2: string; // TODO should be Dec ENUM\n    _craDeg!: number;\n    _cdecDeg!: number;\n\n    _pxsize!: number;\n    _pxsize1!: number;\n    _pxsize2!: number;\n\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval!: number;\n    _maxphysicalval!: number;\n    _wcsname: string;\n    _fitsUsed: String[];\n    constructor() {\n\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this._ctype1 = \"RA---MER\";\n        this._ctype2 = \"DEC--MER\";\n        this._pxvalues = new Map<number, Array<Uint8Array>>();\n        this._fitsheader = new Array<FITSHeader>();\n    }\n\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n        \n        let fp = new FITSParser(infile);\n        this._infile = infile;\n        this._fitsUsed.push(infile)\n\n        let promise = fp.loadFITS().then(fits => {\n            \n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            this._naxis1 = fits.header.get(\"NAXIS1\");\n            this._naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value as number;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value as number;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            // this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            // this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n\n            const pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value as number;\n            const pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value as number;\n            if (pxsize1 !== pxsize2 || pxsize1 === undefined || pxsize2 === undefined) {\n                throw new Error(\"pxsize1 is not equal to pxsize2\")\n                exit;\n            }\n            this._pxsize = pxsize1;\n\n            // this._minra = this._craDeg - this._pxsize1 * this._naxis1 / 2;\n            this._minra = this._craDeg - this._pxsize * this._naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            // this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n            this._mindec = this._cdecDeg - this._pxsize * this._naxis2 / 2;\n\n            return fits;\n        });\n        await promise;\n        return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\n        this._fitsheader[0] = new FITSHeader();\n\n\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS1\", this._naxis1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS2\", this._naxis2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE1\", \"'\"+this._ctype1+\"'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE2\", \"'\"+this._ctype2+\"'\"));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT1\", this._pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT2\", this._pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX1\", this._naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX2\", this._naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"ORIGIN\", \"'WCSLight v.0.x'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"COMMENT\", \"'WCSLight v0.x developed by F.Giordano and Y.Ascasibar'\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n    getFITSHeader(): FITSHeader[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeader {\n        let header = new FITSHeader();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                header.addItem(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    get fitsUsed(): String[]{\n\t\treturn this._fitsUsed;\n\t}\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= this._naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= this._naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        let pv = this._pxvalues.get(0);\n                        if (pv !== undefined) {\n\n                            for (let b = 0; b < bytesXelem; b++) {\n\n                                values[p * bytesXelem + b] = pv[imgpx._j][(imgpx._i) * bytesXelem + b];\n                            }\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n\n    computeSquaredNaxes(d: number, ps: number): void {\n        // first aprroximation to be checked\n        this._naxis1 = Math.ceil(d / ps);\n        this._naxis2 = this._naxis1;\n        this._pxsize = ps;\n    }\n\n\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n\n        let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        let maxpixb = minpixb;\n\n        let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        this._minphysicalval = bzero + bscale * minpixb;\n        this._maxphysicalval = bzero + bscale * maxpixb;\n\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n        // this._pxvalues.set(0, new Uint8Array[this._naxis2][this._naxis1 * bytesXelem]);\n\n        this._pxvalues.set(0, new Array<Uint8Array>(this._naxis2));\n        let pv = this._pxvalues.get(0);\n        if (pv !== undefined) {\n            for (let r = 0; r < this._naxis2; r++) {\n                pv[r] = new Uint8Array(this._naxis1 * bytesXelem);\n            }\n\n            let r!: number;\n            let c!: number;\n            let b!: number;\n            for (let p = 0; (p * bytesXelem) < values.length; p++) {\n                // console.log(\"processing \"+p + \" of \"+ (values.length / bytesXelem));\n\n                try {\n                    r = Math.floor(p / this._naxis1);\n                    c = (p - r * this._naxis1) * bytesXelem;\n\n                    for (b = 0; b < bytesXelem; b++) {\n                        pv[r][c + b] = values[p * bytesXelem + b];\n                    }\n\n\n                    let valpixb = ParseUtils.extractPixelValue(0, values.slice(p * bytesXelem, (p * bytesXelem) + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n                    let valphysical = bzero + bscale * valpixb;\n\n                    if (valphysical < this._minphysicalval || isNaN(this._minphysicalval)) {\n                        this._minphysicalval = valphysical;\n                    } else if (valphysical > this._maxphysicalval || isNaN(this._maxphysicalval)) {\n                        this._maxphysicalval = valphysical;\n                    }\n                } catch (err) {\n                    console.log(err)\n                    console.log(\"p \" + p)\n                    console.log(\"r %, c %, b %\" + r, c, b)\n                    console.log(\"this._pxvalues[r][c + b] \" + pv[r][c + b])\n                    console.log(\"values[p * bytesXelem + b] \" + values[p * bytesXelem + b])\n                }\n\n            }\n        }\n\n        this.prepareFITSHeader(fitsHeaderParams);\n        return this._pxvalues;\n\n    }\n\n\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n\n\n        this.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n        this._pxsize = pxsize;\n        this._minra = center.astro.raDeg - radius;\n        if (this._minra < 0) {\n            this._minra += 360;\n        }\n        this._mindec = center.astro.decDeg - radius;\n\n        let radeclist: Array<[number, number]> = new Array<[number, number]>();\n\n        for (let d = 0; d < this._naxis2; d++) {\n            for (let r = 0; r < this._naxis1; r++) {\n                radeclist.push([this._minra + (r * this._pxsize), this._mindec + (d * this._pxsize)]);\n            }\n        }\n\n        // let cidx = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        let cidx = (this._naxis2 / 2 ) * this._naxis1 + this._naxis1 / 2;\n        this._craDeg = radeclist[cidx][0];\n        this._cdecDeg = radeclist[cidx][1];\n\n        return radeclist;\n\n\n    }\n\n\n    // getImageRADecList(center: AstroCoords, radius: number, pxsize: number): Promise<number[][]> {\n\n    //     let promise = new Promise<[]> ( (resolve, reject) => {\n    //         this.computeSquaredNaxes (2 * radius, pxsize); // compute naxis[1, 2]\n    //         this._pxsize = pxsize;\n    //         this._minra = center.raDeg - radius;\n    //         if (this._minra < 0) {\n    //             this._minra += 360;\n    //         }\n    //         this._mindec = center.decDeg - radius;\n\n    //         let radeclist:number[][] = new Array<Array<number>>();\n\n    //         for (let d = 0; d < this._naxis2; d++) {\n    //             for (let r = 0; r < this._naxis1; r++) {\n    //                 radeclist.push([ this._minra + (r * this._pxsize), this._mindec + (d * this._pxsize)]);\n    //             }    \n    //         }\n\n    //         let cidx = (this._naxis2/2 - 1) * this._naxis1 +  this._naxis1/2;\n    //         this._craDeg = radeclist[ cidx ][0];\n    //         this._cdecDeg = radeclist[ cidx ][1];\n\n    //         resolve(radeclist);\n    //     });\n    //     return promise;\n\n    // }\n\n    /** TODO !!! check and handle RA passing through 360-0 */\n    pix2world(i: number, j: number): Point {\n\n        let ra: number;\n        let dec: number;\n        // ra = i * this._stepra + this._minra;\n        // dec = j * this._stepdec + this._mindec;\n        ra = i * this._pxsize + this._minra;\n        dec = j * this._pxsize + this._mindec;\n        let p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n        return p;\n        // return [ra, dec];\n\n    }\n\n    // world2pix (radeclist: number[][]): Promise<ImagePixel[]> {\n\n    //     let promise = new Promise<ImagePixel[]> ( (resolve, reject) => {\n\n    //         this.initFromFile(this._infile).then( (data) => {\n    //             let imgpxlist = [];\n\n    //             for (let radecItem of radeclist) {\n    //                 let ra = radecItem[0];\n    //                 let dec = radecItem[1];\n    //                 let i = Math.floor((ra - this._minra) / this._pxsize1);\n    //                 let j = Math.floor((dec - this._mindec) / this._pxsize2);\n    //                 imgpxlist.push(new ImagePixel(i, j));\n    //             }\n\n    //             resolve(imgpxlist);\n    //         });\n\n    //     });\n    //     return promise;\n    // }\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        for (let radecItem of radeclist) {\n            let ra = radecItem[0];\n            let dec = radecItem[1];\n            // let i = Math.floor((ra - this._minra) / this._pxsize1);\n            // let j = Math.floor((dec - this._mindec) / this._pxsize2);\n            let i = Math.floor((ra - this._minra) / this._pxsize);\n            let j = Math.floor((dec - this._mindec) / this._pxsize);\n            imgpxlist.push(new ImagePixel(i, j));\n        }\n\n        return imgpxlist;\n\n    }\n\n    // getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n    // \tlet canvas2d =  new Canvas2D(this._pxvalues, this._fitsheader, this, tfunction, colormap, inverse);\n    // \treturn canvas2d;\n    // }\n\n\n}\n","export class Constants {\n}\n//\tstatic halfpi = Math.PI/2.;\nConstants.halfpi = 1.5707963267948966;\nConstants.inv_halfpi = 2. / Math.PI;\n/** The Constant twopi. */\nConstants.twopi = 2 * Math.PI;\nConstants.inv_twopi = 1. / (2 * Math.PI);\n//# sourceMappingURL=Constants.js.map","export class Zphi {\n    /** Creation from individual components */\n    constructor(z_, phi_) {\n        this.z = z_;\n        this.phi = phi_;\n    }\n    ;\n}\n//# sourceMappingURL=Zphi.js.map","import { Vec3 } from './Vec3.js';\nimport { Zphi } from './Zphi.js';\nexport class Hploc {\n    constructor(ptg) {\n        Hploc.PI4_A = 0.7853981554508209228515625;\n        Hploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\n        Hploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n        Hploc.M_1_PI = 0.3183098861837906715377675267450287;\n        if (ptg) {\n            this.sth = 0.0;\n            this.have_sth = false;\n            this.z = Hploc.cos(ptg.theta);\n            this._phi = ptg.phi;\n            if (Math.abs(this.z) > 0.99) {\n                this.sth = Hploc.sin(ptg.theta);\n                this.have_sth = true;\n            }\n        }\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    ;\n    get phi() {\n        return this._phi;\n    }\n    ;\n    set phi(phi) {\n        this._phi = phi;\n    }\n    ;\n    setSth(sth) {\n        this.sth = sth;\n    }\n    ;\n    toVec3() {\n        var st = this.have_sth ? this.sth : Math.sqrt((1.0 - this.z) * (1.0 + this.z));\n        // var vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);\n        var vector = new Vec3(st * Math.cos(this.phi), st * Math.sin(this.phi), this.z);\n        return vector;\n    }\n    ;\n    toZphi() {\n        return new Zphi(this.z, this.phi);\n    }\n    static sin(d) {\n        let u = d * Hploc.M_1_PI;\n        let q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 4.0 * q;\n        d -= x * Hploc.PI4_A;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 1) != 0) {\n            d = -d;\n        }\n        return this.sincoshelper(d);\n    }\n    ;\n    static cos(d) {\n        //\t\tlet u = d * Hploc.M_1_PI - 0.5;\n        let u = d * Hploc.M_1_PI - 0.5;\n        //\t\tu -= 0.5;\n        let q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 2.0 * q;\n        let t = x * Hploc.PI4_A;\n        d = d - t;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 2) == 0) {\n            d = -d;\n        }\n        return Hploc.sincoshelper(d);\n    }\n    ;\n    static sincoshelper(d) {\n        let s = d * d;\n        let u = -7.97255955009037868891952e-18;\n        u = u * s + 2.81009972710863200091251e-15;\n        u = u * s - 7.64712219118158833288484e-13;\n        u = u * s + 1.60590430605664501629054e-10;\n        u = u * s - 2.50521083763502045810755e-08;\n        u = u * s + 2.75573192239198747630416e-06;\n        u = u * s - 0.000198412698412696162806809;\n        u = u * s + 0.00833333333333332974823815;\n        u = u * s - 0.166666666666666657414808;\n        return s * u * d + d;\n    }\n    ;\n    /** This method calculates the arc sine of x in radians. The return\n    value is in the range [-pi/2, pi/2]. The results may have\n    maximum error of 3 ulps. */\n    static asin(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1 + d) * (1 - d))), d);\n    }\n    ;\n    /** This method calculates the arc cosine of x in radians. The\n        return value is in the range [0, pi]. The results may have\n        maximum error of 3 ulps. */\n    static acos(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.sqrt((1 + d) * (1 - d)), Math.abs(d)), d) + (d < 0 ? Math.PI : 0);\n    }\n    ;\n    static mulsign(x, y) {\n        let sign = Hploc.copySign(1, y);\n        return sign * x;\n    }\n    ;\n    static copySign(magnitude, sign) {\n        return sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);\n        // let finalsign = 1;\n        // if (Object.is(finalsign , -0)){\n        // \tsign = -1;\n        // }else if (Object.is(finalsign , 0)){\n        // \tsign = 1;\n        // }else {\n        // \tsign = Math.sign(finalsign);\n        // }\n        // return finalsign * magnitude;\n    }\n    static atanhelper(s) {\n        let t = s * s;\n        let u = -1.88796008463073496563746e-05;\n        u = u * t + (0.000209850076645816976906797);\n        u = u * t + (-0.00110611831486672482563471);\n        u = u * t + (0.00370026744188713119232403);\n        u = u * t + (-0.00889896195887655491740809);\n        u = u * t + (0.016599329773529201970117);\n        u = u * t + (-0.0254517624932312641616861);\n        u = u * t + (0.0337852580001353069993897);\n        u = u * t + (-0.0407629191276836500001934);\n        u = u * t + (0.0466667150077840625632675);\n        u = u * t + (-0.0523674852303482457616113);\n        u = u * t + (0.0587666392926673580854313);\n        u = u * t + (-0.0666573579361080525984562);\n        u = u * t + (0.0769219538311769618355029);\n        u = u * t + (-0.090908995008245008229153);\n        u = u * t + (0.111111105648261418443745);\n        u = u * t + (-0.14285714266771329383765);\n        u = u * t + (0.199999999996591265594148);\n        u = u * t + (-0.333333333333311110369124);\n        return u * t * s + s;\n    }\n    ;\n    static atan2k(y, x) {\n        let q = 0.;\n        if (x < 0) {\n            x = -x;\n            q = -2.;\n        }\n        if (y > x) {\n            let t = x;\n            x = y;\n            y = -t;\n            q += 1.;\n        }\n        return Hploc.atanhelper(y / x) + q * (Math.PI / 2);\n    }\n    ;\n    /** This method calculates the arc tangent of y/x in radians, using\n    the signs of the two arguments to determine the quadrant of the\n    result. The results may have maximum error of 2 ulps. */\n    static atan2(y, x) {\n        let r = Hploc.atan2k(Math.abs(y), x);\n        r = Hploc.mulsign(r, x);\n        if (Hploc.isinf(x) || x == 0) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI / 2)) : 0);\n        }\n        if (Hploc.isinf(y)) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI * 1 / 4)) : 0);\n        }\n        if (y == 0) {\n            r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);\n        }\n        return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);\n    }\n    ;\n    /** Checks if the argument is a NaN or not. */\n    static isnan(d) {\n        return d != d;\n    }\n    ;\n    /** Checks if the argument is either positive or negative infinity. */\n    static isinf(d) {\n        return Math.abs(d) === +Infinity;\n    }\n    ;\n}\nHploc.PI4_A = 0.7853981554508209228515625;\nHploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\nHploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\nHploc.M_1_PI = 0.3183098861837906715377675267450287;\n//# sourceMappingURL=Hploc.js.map","import { Hploc } from './Hploc.js';\nexport class Pointing {\n    /**\n     *\n     * @param {*} vec3 Vec3.js\n     * @param {*} mirror\n     * @param {*} in_theta radians\n     * @param {*} in_phi radians\n     */\n    constructor(vec3, mirror, in_theta, in_phi) {\n        if (vec3 != null) {\n            this.theta = Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);\n            if (mirror) {\n                this.phi = -Hploc.atan2(vec3.y, vec3.x);\n            }\n            else {\n                this.phi = Hploc.atan2(vec3.y, vec3.x);\n            }\n            if (this.phi < 0.0) {\n                this.phi = this.phi + 2 * Math.PI;\n            }\n            if (this.phi >= 2 * Math.PI) {\n                this.phi = this.phi - 2 * Math.PI;\n            }\n        }\n        else {\n            this.theta = in_theta;\n            this.phi = in_phi;\n        }\n    }\n}\n//# sourceMappingURL=Pointing.js.map","/**\n * Partial porting to Javascript of Vec3.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nimport { Pointing } from './Pointing.js';\nexport class Vec3 {\n    constructor(in_x, in_y, in_z) {\n        if (in_x instanceof Pointing) {\n            let ptg = in_x;\n            let sth = Hploc.sin(ptg.theta);\n            this.x = sth * Hploc.cos(ptg.phi);\n            this.y = sth * Hploc.sin(ptg.phi);\n            this.z = Hploc.cos(ptg.theta);\n        }\n        else {\n            this.x = in_x;\n            this.y = in_y;\n            this.z = in_z;\n        }\n    }\n    getX() {\n        return this.x;\n    }\n    ;\n    getY() {\n        return this.y;\n    }\n    ;\n    getZ() {\n        return this.z;\n    }\n    ;\n    /** Scale the vector by a given factor\n    @param n the scale factor */\n    scale(n) {\n        this.x *= n;\n        this.y *= n;\n        this.z *= n;\n    }\n    ;\n    /** Vector cross product.\n    @param v another vector\n    @return the vector cross product between this vector and {@code v} */\n    cross(v) {\n        return new Vec3(this.y * v.z - v.y * this.z, this.z * v.x - v.z * this.x, this.x * v.y - v.x * this.y);\n    }\n    ;\n    /** Vector addition\n        * @param v the vector to be added\n        * @return addition result */\n    add(v) {\n        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    ;\n    /** Normalize the vector */\n    normalize() {\n        let d = 1. / this.length();\n        this.x *= d;\n        this.y *= d;\n        this.z *= d;\n    }\n    ;\n    /** Return normalized vector */\n    norm() {\n        let d = 1. / this.length();\n        return new Vec3(this.x * d, this.y * d, this.z * d);\n    }\n    ;\n    /** Vector length\n    @return the length of the vector. */\n    length() {\n        return Math.sqrt(this.lengthSquared());\n    }\n    ;\n    /** Squared vector length\n        @return the squared length of the vector. */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    ;\n    /** Computes the dot product of the this vector and {@code v1}.\n     * @param v1 another vector\n     * @return dot product */\n    dot(v1) {\n        return this.x * v1.x + this.y * v1.y + this.z * v1.z;\n    }\n    ;\n    /** Vector subtraction\n     * @param v the vector to be subtracted\n     * @return subtraction result */\n    sub(v) {\n        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    ;\n    /** Angle between two vectors.\n    @param v1 another vector\n    @return the angle in radians between this vector and {@code v1};\n      constrained to the range [0,PI]. */\n    angle(v1) {\n        return Hploc.atan2(this.cross(v1).length(), this.dot(v1));\n    }\n    /** Invert the signs of all components */\n    flip() {\n        this.x *= -1.0;\n        this.y *= -1.0;\n        this.z *= -1.0;\n    }\n    static pointing2Vec3(pointing) {\n        let sth = Hploc.sin(pointing.theta);\n        let x = sth * Hploc.cos(pointing.phi);\n        let y = sth * Hploc.sin(pointing.phi);\n        let z = Hploc.cos(pointing.theta);\n        return new Vec3(x, y, z);\n    }\n    ;\n}\n//# sourceMappingURL=Vec3.js.map","import { Vec3 } from './Vec3.js';\nexport class CircleFinder {\n    /**\n     * @param point: Vec3\n     */\n    constructor(point) {\n        let np = point.length;\n        //HealpixUtils.check(np>=2,\"too few points\");\n        if (!(np >= 2)) {\n            console.log(\"too few points\");\n            return;\n        }\n        this.center = point[0].add(point[1]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 2; i < np; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle(point, i);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q: int\n     */\n    getCircle(point, q) {\n        this.center = point[0].add(point[q]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 1; i < q; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle2(point, i, q);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q1: int\n     * @param q2: int\n     */\n    getCircle2(point, q1, q2) {\n        this.center = point[q1].add(point[q2]);\n        this.center.normalize();\n        this.cosrad = point[q1].dot(this.center);\n        for (let i = 0; i < q1; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.center = (point[q1].sub(point[i])).cross(point[q2].sub(point[i]));\n                this.center.normalize();\n                this.cosrad = point[i].dot(this.center);\n                if (this.cosrad < 0) {\n                    this.center.flip();\n                    this.cosrad = -this.cosrad;\n                }\n            }\n        }\n    }\n    ;\n    getCenter() {\n        return new Vec3(this.center.x, this.center.y, this.center.z);\n    }\n    getCosrad() {\n        return this.cosrad;\n    }\n    ;\n}\n//# sourceMappingURL=CircleFinder.js.map","/**\n * Partial porting to Javascript of Fxyf.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nexport class Fxyf {\n    constructor(x, y, f) {\n        this.fx = x;\n        this.fy = y;\n        this.face = f;\n        // coordinate of the lowest corner of each face\n        this.jrll = new Uint8Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Uint8Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.halfpi = Math.PI / 2.;\n    }\n    toHploc() {\n        let loc = new Hploc();\n        let jr = this.jrll[this.face] - this.fx - this.fy;\n        let nr;\n        if (jr < 1) {\n            nr = jr;\n            let tmp = nr * nr / 3.;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > 3) {\n            nr = 4 - jr;\n            let tmp = nr * nr / 3.;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = 1;\n            loc.z = (2 - jr) * 2.0 / 3.;\n        }\n        let tmp = this.jpll[this.face] * nr + this.fx - this.fy;\n        if (tmp < 0) {\n            tmp += 8;\n        }\n        if (tmp >= 8) {\n            tmp -= 8;\n        }\n        loc.phi = (nr < 1e-15) ? 0 : (0.5 * this.halfpi * tmp) / nr;\n        return loc;\n    }\n    ;\n    toVec3() {\n        return this.toHploc().toVec3();\n    }\n    ;\n}\n//# sourceMappingURL=Fxyf.js.map","export class pstack {\n    /** Creation from individual components */\n    constructor(sz) {\n        this.p = new Array(sz);\n        this.o = new Int32Array(sz);\n        this.s = 0;\n        this.m = 0;\n    }\n    ;\n    /**\n     * @param p long\n     * @param o int\n     */\n    push(p_, o_) {\n        this.p[this.s] = p_;\n        this.o[this.s] = o_;\n        ++this.s;\n    }\n    ;\n    pop() {\n        --this.s;\n    }\n    ;\n    popToMark() {\n        this.s = this.m;\n    }\n    ;\n    size() {\n        return this.s;\n    }\n    ;\n    mark() {\n        this.m = this.s;\n    }\n    ;\n    otop() {\n        return this.o[this.s - 1];\n    }\n    ;\n    ptop() {\n        return this.p[this.s - 1];\n    }\n    ;\n}\n//# sourceMappingURL=pstack.js.map","export class RangeSet {\n    /**\n     * @param int cap: initial capacity\n     */\n    constructor(cap) {\n        if (cap < 0)\n            console.error(\"capacity must be positive\");\n        this.r = new Int32Array(cap << 1);\n        this.sz = 0;\n    }\n    ;\n    /** Append a single-value range to the object.\n    @param val value to append */\n    append(val) {\n        this.append1(val, val + 1);\n    }\n    ;\n    /** Append a range to the object.\n   @param a first long in range\n   @param b one-after-last long in range */\n    append1(a, b) {\n        if (a >= b)\n            return;\n        if ((this.sz > 0) && (a <= this.r[this.sz - 1])) {\n            if (a < this.r[this.sz - 2])\n                console.error(\"bad append operation\");\n            if (b > this.r[this.sz - 1])\n                this.r[this.sz - 1] = b;\n            return;\n        }\n        // this.ensureCapacity(this.sz+2);\n        let cap = this.sz + 2;\n        if (this.r.length < cap) {\n            let newsize = Math.max(2 * this.r.length, cap);\n            let rnew = new Int32Array(newsize);\n            rnew.set(this.r);\n            this.r = rnew;\n        }\n        this.r[this.sz] = a;\n        this.r[this.sz + 1] = b;\n        this.sz += 2;\n    }\n    ;\n    /** Make sure the object can hold at least the given number of entries.\n     * @param cap int\n     * */\n    ensureCapacity(cap) {\n        if (this.r.length < cap)\n            this.resize(Math.max(2 * this.r.length, cap));\n    }\n    ;\n    /**\n     * @param newsize int\n     */\n    resize(newsize) {\n        if (newsize < this.sz)\n            console.error(\"requested array size too small\");\n        if (newsize == this.r.length)\n            return;\n        let rnew = new Int32Array(newsize);\n        let sliced = this.r.slice(0, this.sz + 1);\n        //\t\tthis.arrayCopy(this.r, 0, rnew, 0, this.sz);\n        this.r = sliced;\n    }\n    ;\n}\n//# sourceMappingURL=RangeSet.js.map","/**\n * Partial porting to Javascript of Xyf.java from Healpix3.30\n */\nexport class Xyf {\n    constructor(x, y, f) {\n        this.ix = x;\n        this.iy = y;\n        this.face = f;\n    }\n}\n//# sourceMappingURL=Xyf.js.map","\"use strict\";\nimport { CircleFinder } from \"./CircleFinder.js\";\nimport { Constants } from \"./Constants.js\";\nimport { Fxyf } from \"./Fxyf.js\";\nimport { Hploc } from \"./Hploc.js\";\nimport { Pointing } from \"./Pointing.js\";\nimport { pstack } from \"./pstack.js\";\nimport { RangeSet } from \"./RangeSet.js\";\nimport { Vec3 } from \"./Vec3.js\";\nimport { Xyf } from \"./Xyf.js\";\nimport { Zphi } from \"./Zphi.js\";\n/**\n * Partial porting to Javascript of HealpixBase.java from Healpix3.30\n */\n// import Fxyf from './Fxyf.js';\n// import Hploc from './Hploc.js';\n// import Xyf from './Xyf.js';\n// import Vec3 from './Vec3.js';\n// import Pointing from './Pointing.js';\n// import CircleFinder from './CircleFinder.js';\n// import Zphi from './Zphi.js';\n// import pstack from './pstack.js';\n// import Constants from './Constants.js';\n// import RangeSet from './RangeSet.js';\nexport class Healpix {\n    constructor(nside_in) {\n        this.order_max = 29;\n        this.inv_halfpi = 2.0 / Math.PI;\n        this.twothird = 2.0 / 3.;\n        // console.log(\"twothird \"+this.twothird);\n        // this.ns_max=1L<<order_max;\n        this.ns_max = Math.pow(2, this.order_max);\n        this.ctab = new Uint16Array([\n            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,\n            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,\n            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,\n            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,\n            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,\n            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,\n            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,\n            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,\n            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,\n            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,\n            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,\n            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,\n            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,\n            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,\n            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,\n            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855\n        ]);\n        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,\n            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,\n            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,\n            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,\n            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,\n            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,\n            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,\n            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,\n            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,\n            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,\n            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,\n            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,\n            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,\n            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,\n            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,\n            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,\n            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,\n            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);\n        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);\n        this.facearray = [\n            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),\n            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),\n            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),\n            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]),\n            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),\n            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),\n            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),\n            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),\n            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]) // N\n        ];\n        // questo forse deve essere un UInt8Array. Viene usato da neighbours\n        this.swaparray = [\n            new Int16Array([0, 0, 3]),\n            new Int16Array([0, 0, 6]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([0, 0, 5]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([5, 0, 0]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([6, 0, 0]),\n            new Int16Array([3, 0, 0]) // N\n        ];\n        if (nside_in <= this.ns_max && nside_in > 0) {\n            this.nside = nside_in;\n            this.npface = this.nside * this.nside;\n            this.npix = 12 * this.npface;\n            this.order = this.nside2order(this.nside);\n            this.nl2 = 2 * this.nside;\n            this.nl3 = 3 * this.nside;\n            this.nl4 = 4 * this.nside;\n            this.fact2 = 4.0 / this.npix;\n            this.fact1 = (this.nside << 1) * this.fact2;\n            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap\n            // console.log(\"order: \"+this.order);\n            // console.log(\"nside: \"+this.nside);\n        }\n        this.bn = [];\n        this.mpr = [];\n        this.cmpr = [];\n        this.smpr = [];\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // Uncaught RangeError: Maximum call stack size exceeded\n        // MOVED TO computeBn()\n        //        for (let i=0; i <= this.order_max; ++i) {\n        //        \tthis.bn[i]=new Healpix(1<<i);\n        //        \tthis.mpr[i]=bn[i].maxPixrad();\n        //        \tthis.cmpr[i]=Math.cos(mpr[i]);\n        //        \tthis.smpr[i]=Math.sin(mpr[i]);\n        //        }\n    }\n    computeBn() {\n        for (let i = 0; i <= this.order_max; ++i) {\n            this.bn[i] = new Healpix(1 << i);\n            this.mpr[i] = this.bn[i].maxPixrad();\n            this.cmpr[i] = Hploc.cos(this.mpr[i]);\n            this.smpr[i] = Hploc.sin(this.mpr[i]);\n        }\n    }\n    getNPix() {\n        return this.npix;\n    }\n    ;\n    getBoundaries(pix) {\n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        // console.log(\"PIXEL: \"+pix);\n        // console.log(\"XYF \"+xyf.ix+\" \"+xyf.iy+\" \"+xyf.face);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        // let d = 1.0/(this.nside);\n        // console.log(\"------------------------\");\n        // console.log(\"xc, yc, dc \"+xc+\",\"+ yc+\",\"+ dc);\n        // console.log(\"xc+dc-d, yc+dc, xyf.face, d \"+(xc+dc) +\",\"+ (yc+dc)+\",\"+\n        // xyf.face+\",\"+ d);\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        // console.log(\"Points for npix: \"+pix);\n        // console.log(points);\n        // if (pix > 750){\n        // console.log(\"pix: \"+pix);\n        // console.log(\"dc: \"+dc);\n        // console.log(\"xyf.ix: \"+xyf.ix);\n        // console.log(\"xyf.iy: \"+xyf.iy);\n        // console.log(\"xc: \"+xc);\n        // console.log(\"yc: \"+yc);\n        // console.log(\"d: \"+d);\n        // }\n        return points;\n    }\n    ;\n    /** Returns a set of points along the boundary of the given pixel.\n     * Step 1 gives 4 points on the corners. The first point corresponds\n     * to the northernmost corner, the subsequent points follow the pixel\n     * boundary through west, south and east corners.\n     *\n     * @param pix pixel index number\n     * @param step the number of returned points is 4*step\n     * @return {@link Vec3} for each point\n     */\n    getBoundariesWithStep(pix, step) {\n        // var points = new Array(); \n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        let d = 1.0 / (this.nside * step);\n        for (let i = 0; i < step; i++) {\n            points[i] = new Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();\n            points[i + step] = new Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();\n            points[i + 2 * step] = new Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();\n            points[i + 3 * step] = new Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();\n        }\n        return points;\n    }\n    ;\n    getPointsForXyfNoStep(x, y, face) {\n        let nside = Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    getPointsForXyf(x, y, step, face) {\n        let nside = step * Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    /** Returns the neighboring pixels of ipix.\n    This method works in both RING and NEST schemes, but is\n    considerably faster in the NEST scheme.\n    @param ipix the requested pixel number.\n    @return array with indices of the neighboring pixels.\n      The returned array contains (in this order)\n      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor\n      of ipix. If a neighbor does not exist (this can only happen\n      for the W, N, E and S neighbors), its entry is set to -1. */\n    neighbours(ipix) {\n        let result = new Int32Array(8);\n        let xyf = this.nest2xyf(ipix);\n        let ix = xyf.ix;\n        let iy = xyf.iy;\n        let face_num = xyf.face;\n        var nsm1 = this.nside - 1;\n        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {\n            let fpix = Math.floor(face_num << (2 * this.order));\n            let px0 = this.spread_bits(ix);\n            let py0 = this.spread_bits(iy) << 1;\n            let pxp = this.spread_bits(ix + 1);\n            let pyp = this.spread_bits(iy + 1) << 1;\n            let pxm = this.spread_bits(ix - 1);\n            let pym = this.spread_bits(iy - 1) << 1;\n            result[0] = fpix + pxm + py0;\n            result[1] = fpix + pxm + pyp;\n            result[2] = fpix + px0 + pyp;\n            result[3] = fpix + pxp + pyp;\n            result[4] = fpix + pxp + py0;\n            result[5] = fpix + pxp + pym;\n            result[6] = fpix + px0 + pym;\n            result[7] = fpix + pxm + pym;\n        }\n        else {\n            for (let i = 0; i < 8; ++i) {\n                let x = ix + this.xoffset[i];\n                let y = iy + this.yoffset[i];\n                let nbnum = 4;\n                if (x < 0) {\n                    x += this.nside;\n                    nbnum -= 1;\n                }\n                else if (x >= this.nside) {\n                    x -= this.nside;\n                    nbnum += 1;\n                }\n                if (y < 0) {\n                    y += this.nside;\n                    nbnum -= 3;\n                }\n                else if (y >= this.nside) {\n                    y -= this.nside;\n                    nbnum += 3;\n                }\n                let f = this.facearray[nbnum][face_num];\n                if (f >= 0) {\n                    let bits = this.swaparray[nbnum][face_num >>> 2];\n                    if ((bits & 1) > 0) {\n                        x = Math.floor(this.nside - x - 1);\n                    }\n                    if ((bits & 2) > 0) {\n                        y = Math.floor(this.nside - y - 1);\n                    }\n                    if ((bits & 4) > 0) {\n                        let tint = x;\n                        x = y;\n                        y = tint;\n                    }\n                    result[i] = this.xyf2nest(x, y, f);\n                }\n                else {\n                    result[i] = -1;\n                }\n            }\n        }\n        return result;\n    }\n    ;\n    nside2order(nside) {\n        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);\n    }\n    ;\n    nest2xyf(ipix) {\n        let pix = Math.floor(ipix & (this.npface - 1));\n        let xyf = new Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1), Math.floor((ipix >> (2 * this.order))));\n        return xyf;\n    }\n    ;\n    xyf2nest(ix, iy, face_num) {\n        return Math.floor(face_num << (2 * this.order))\n            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);\n    }\n    ;\n    loc2pix(hploc) {\n        let z = hploc.z;\n        let phi = hploc.phi;\n        let za = Math.abs(z);\n        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0); // in [0,4)\n        let pixNo;\n        if (za <= this.twothird) { // Equatorial region\n            let temp1 = this.nside * (0.5 + tt);\n            let temp2 = this.nside * (z * 0.75);\n            let jp = Math.floor(temp1 - temp2); // index of ascending edge line\n            let jm = Math.floor(temp1 + temp2); // index of descending edge line\n            let ifp = Math.floor(jp >>> this.order); // in {0,4}\n            let ifm = Math.floor(jm >>> this.order);\n            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));\n            let ix = Math.floor(jm & (this.nside - 1));\n            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);\n            pixNo = this.xyf2nest(ix, iy, face_num);\n        }\n        else { // polar region, za > 2/3\n            let ntt = Math.min(3, Math.floor(tt));\n            let tp = tt - ntt;\n            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?\n                this.nside * Math.sqrt(3 * (1 - za)) :\n                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);\n            let jp = Math.floor(tp * tmp); // increasing edge line index\n            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index\n            if (jp >= this.nside) {\n                jp = this.nside - 1; // for points too close to the boundary\n            }\n            if (jm >= this.nside) {\n                jm = this.nside - 1;\n            }\n            if (z >= 0) {\n                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);\n            }\n            else {\n                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);\n            }\n        }\n        return pixNo;\n    }\n    ;\n    /** Returns the normalized 3-vector corresponding to the center of the\n    supplied pixel.\n    @param pix long the requested pixel number.\n    @return the pixel's center coordinates. */\n    pix2vec(pix) {\n        return this.pix2loc(pix).toVec3();\n    }\n    ;\n    /** Returns the Zphi corresponding to the center of the supplied pixel.\n     @param pix the requested pixel number.\n     @return the pixel's center coordinates. */\n    pix2zphi(pix) {\n        return this.pix2loc(pix).toZphi();\n    }\n    /**\n     * @param pix long\n     * @return Hploc\n     */\n    pix2loc(pix) {\n        let loc = new Hploc(undefined);\n        let xyf = this.nest2xyf(pix);\n        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;\n        let nr;\n        if (jr < this.nside) {\n            nr = jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > this.nl3) {\n            nr = this.nl4 - jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = this.nside;\n            loc.z = (this.nl2 - jr) * this.fact1;\n        }\n        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;\n        //      \tassert(tmp<8*nr); // must not happen\n        if (tmp < 0) {\n            tmp += 8 * nr;\n        }\n        loc.phi = (nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp) / nr;\n        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);\n        return loc;\n    }\n    ;\n    ang2pix(ptg, mirror) {\n        return this.loc2pix(new Hploc(ptg));\n    }\n    ;\n    fmodulo(v1, v2) {\n        if (v1 >= 0) {\n            return (v1 < v2) ? v1 : v1 % v2;\n        }\n        var tmp = v1 % v2 + v2;\n        return (tmp === v2) ? 0.0 : tmp;\n    }\n    ;\n    compress_bits(v) {\n        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));\n        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);\n        return compressed;\n    }\n    ;\n    spread_bits(v) {\n        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))\n            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));\n    }\n    ;\n    /**\n     * Returns a range set of pixels that overlap with the convex polygon\n     * defined by the {@code vertex} array.\n     * <p>\n     * This method is more efficient in the RING scheme.\n     * <p>\n     * This method may return some pixels which don't overlap with the polygon\n     * at all. The higher {@code fact} is chosen, the fewer false positives are\n     * returned, at the cost of increased run time.\n     *\n     * @param vertex\n     *            an array containing the vertices of the requested convex\n     *            polygon.\n     * @param fact\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return the requested set of pixel number ranges\n     */\n    queryPolygonInclusive(vertex, fact) {\n        let inclusive = (fact != 0);\n        let nv = vertex.length;\n        //        let ncirc = inclusive ? nv+1 : nv;\n        if (!(nv >= 3)) {\n            console.log(\"not enough vertices in polygon\");\n            return;\n        }\n        let vv = new Array();\n        for (let i = 0; i < nv; ++i) {\n            vv[i] = Vec3.pointing2Vec3(vertex[i]);\n        }\n        let normal = new Array();\n        let flip = 0;\n        let index = 0;\n        let back = false;\n        while (index < vv.length) {\n            let first = vv[index];\n            let medium = null;\n            let last = null;\n            if (index == vv.length - 1) {\n                last = vv[1];\n                medium = vv[0];\n            }\n            else if (index == vv.length - 2) {\n                last = vv[0];\n                medium = vv[index + 1];\n            }\n            else {\n                medium = vv[index + 1];\n                last = vv[index + 2];\n            }\n            normal[index] = first.cross(medium).norm();\n            let hnd = normal[index].dot(last);\n            if (index == 0) {\n                flip = (hnd < 0.) ? -1 : 1;\n                let tmp = new Pointing(first); // TODO not used\n                back = false;\n            }\n            else {\n                let flipThnd = flip * hnd;\n                if (flipThnd < 0) {\n                    let tmp = new Pointing(medium);\n                    vv.splice(index + 1, 1);\n                    normal.splice(index, 1);\n                    back = true;\n                    index -= 1;\n                    continue;\n                }\n                else {\n                    let tmp = new Pointing(first);\n                    back = false;\n                }\n            }\n            normal[index].scale(flip);\n            index += 1;\n        }\n        nv = vv.length;\n        let ncirc = inclusive ? nv + 1 : nv;\n        let rad = new Array(ncirc);\n        rad = rad.fill(Constants.halfpi);\n        //        rad = rad.fill(1.5707963267948966);\n        //        let p = \"1.5707963267948966\";\n        //        rad = rad.fill(parseFloat(p));\n        if (inclusive) {\n            let cf = new CircleFinder(vv);\n            normal[nv] = cf.getCenter();\n            rad[nv] = Hploc.acos(cf.getCosrad());\n        }\n        return this.queryMultiDisc(normal, rad, fact);\n    }\n    ;\n    /**\n     * For NEST schema only\n     *\n     * @param normal:\n     *            Vec3[]\n     * @param rad:\n     *            Float32Array\n     * @param fact:\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return RangeSet the requested set of pixel number ranges\n     */\n    queryMultiDisc(norm, rad, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let nv = norm.length;\n        // HealpixUtils.check(nv==rad.lengt0,\"inconsistent input arrays\");\n        if (!(nv == rad.length)) {\n            console.error(\"inconsistent input arrays\");\n            return;\n        }\n        let res = new RangeSet(4 << 1);\n        // Removed code for Scheme.RING\n        let oplus = 0;\n        if (inclusive) {\n            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {\n                console.error(\"invalid oversampling factor\");\n            }\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = this.order + oplus; // the order up to which we test\n        // TODO: ignore all disks with radius>=pi\n        //        let crlimit = new Float32Array[omax+1][nv][3];\n        let crlimit = new Array(omax + 1);\n        let o;\n        let i;\n        for (o = 0; o <= omax; ++o) { // prepare data at the required orders\n            crlimit[o] = new Array(nv);\n            let dr = this.bn[o].maxPixrad(); // safety distance\n            for (i = 0; i < nv; ++i) {\n                crlimit[o][i] = new Float64Array(3);\n                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Hploc.cos(rad[i] + dr);\n                crlimit[o][i][1] = (o == 0) ? Hploc.cos(rad[i]) : crlimit[0][i][1];\n                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : Hploc.cos(rad[i] - dr);\n            }\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse\n            // order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let o = stk.otop();\n            stk.pop();\n            let pv = this.bn[o].pix2vec(pix);\n            let zone = 3;\n            for (let i = 0; (i < nv) && (zone > 0); ++i) {\n                let crad = pv.dot(norm[i]);\n                for (let iz = 0; iz < zone; ++iz) {\n                    if (crad < crlimit[o][i][iz]) {\n                        zone = iz;\n                    }\n                }\n            }\n            if (zone > 0) {\n                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);\n            }\n        }\n        return res;\n    }\n    ;\n    /** Integer base 2 logarithm.\n    @param arg\n    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.\n    For negative arguments and zero, 0 is returned. */\n    ilog2(arg) {\n        let max = Math.max(arg, 1);\n        return 31 - Math.clz32(max);\n    }\n    ;\n    /** Computes the cosine of the angular distance between two z, phi positions\n      on the unit sphere. */\n    cosdist_zphi(z1, phi1, z2, phi2) {\n        return z1 * z2 + Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));\n    }\n    /**\n     * @param int o\n     * @param int omax\n     * @param int zone\n     * @param RangeSet pixset\n     * @param long pix\n     * @param pstack stk\n     * @param boolean inclusive\n     */\n    check_pixel(o, omax, zone, pixset, pix, stk, inclusive) {\n        if (zone == 0)\n            return;\n        if (o < this.order) {\n            if (zone >= 3) { // output all subpixels\n                let sdist = 2 * (this.order - o); // the \"bit-shift distance\" between map orders\n                pixset.append1(pix << sdist, ((pix + 1) << sdist));\n            }\n            else { // (zone>=1)\n                for (let i = 0; i < 4; ++i) {\n                    stk.push(4 * pix + 3 - i, o + 1); // add children\n                }\n            }\n        }\n        else if (o > this.order) { // this implies that inclusive==true\n            if (zone >= 2) { // pixel center in shape\n                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                stk.popToMark(); // unwind the stack\n            }\n            else { // (zone>=1): pixel center in safety range\n                if (o < omax) { // check sublevels\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                    stk.popToMark(); // unwind the stack\n                }\n            }\n        }\n        else { // o==order\n            if (zone >= 2) {\n                pixset.append(pix);\n            }\n            else if (inclusive) { // and (zone>=1)\n                if (this.order < omax) { // check sublevels\n                    stk.mark(); // remember current stack position\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix); // output the pixel\n                }\n            }\n        }\n    }\n    /** Returns the maximum angular distance between a pixel center and its\n    corners.\n    @return maximum angular distance between a pixel center and its\n      corners. */\n    maxPixrad() {\n        let zphia = new Zphi(2. / 3., Math.PI / this.nl4);\n        let xyz1 = this.convertZphi2xyz(zphia);\n        let va = new Vec3(xyz1[0], xyz1[1], xyz1[2]);\n        let t1 = 1. - 1. / this.nside;\n        t1 *= t1;\n        let zphib = new Zphi(1 - t1 / 3, 0);\n        let xyz2 = this.convertZphi2xyz(zphib);\n        let vb = new Vec3(xyz2[0], xyz2[1], xyz2[2]);\n        return va.angle(vb);\n    }\n    ;\n    /**\n     * this is a workaround replacing the Vec3(Zphi) constructor.\n     */\n    convertZphi2xyz(zphi) {\n        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));\n        let x = sth * Hploc.cos(zphi.phi);\n        let y = sth * Hploc.sin(zphi.phi);\n        let z = zphi.z;\n        return [x, y, z];\n    }\n    ;\n    /** Returns a range set of pixels which overlap with a given disk. <p>\n      This method is more efficient in the RING scheme. <p>\n      This method may return some pixels which don't overlap with\n      the polygon at all. The higher {@code fact} is chosen, the fewer false\n      positives are returned, at the cost of increased run time.\n      @param ptg the angular coordinates of the disk center\n      @param radius the radius (in radians) of the disk\n      @param fact The overlapping test will be done at the resolution\n        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power\n        of 2, else it can be any positive integer. A typical choice would be 4.\n      @return the requested set of pixel number ranges  */\n    queryDiscInclusive(ptg, radius, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let pixset = new RangeSet();\n        if (radius >= Math.PI) { // disk covers the whole sphere\n            pixset.append1(0, this.npix);\n            return pixset;\n        }\n        let oplus = 0;\n        if (inclusive) {\n            // HealpixUtils.check ((1L<<order_max)>=fact,\"invalid oversampling factor\");\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test\n        let vptg = Vec3.pointing2Vec3(ptg);\n        let crpdr = new Array(omax + 1);\n        let crmdr = new Array(omax + 1);\n        let cosrad = Hploc.cos(radius);\n        let sinrad = Hploc.sin(radius);\n        for (let o = 0; o <= omax; o++) { // prepare data at the required orders\n            let dr = this.mpr[o]; // safety distance\n            let cdr = this.cmpr[o];\n            let sdr = this.smpr[o];\n            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;\n            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let curro = stk.otop();\n            stk.pop();\n            let pos = this.bn[curro].pix2zphi(pix);\n            // cosine of angular distance between pixel center and disk center\n            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);\n            if (cangdist > crpdr[curro]) {\n                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);\n                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);\n            }\n        }\n        return pixset;\n    }\n}\n//# sourceMappingURL=Healpix.js.map","\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { Healpix } from 'healpixjs';\nimport { Pointing } from \"healpixjs\";\nimport { Hploc } from \"healpixjs\";\n\nimport { radToDeg } from '../model/Utils.js'; // TODO change package\nimport { CoordsType } from \"../model/CoordsType.js\";\nimport { HEALPixXYSpace } from \"../model/HEALPixXYSpace.js\";\nimport { Point } from \"../model/Point.js\";\nimport { SphericalCoords } from \"../model/SphericalCoords.js\";\nimport { NumberType } from '../model/NumberType.js';\nimport { AstroCoords } from \"../model/AstroCoords.js\";\nimport { EquatorialCoords } from \"../model/EquatorialCoords.js\";\n\nexport class HiPSHelper {\n\n\n\t// static pxXtile: number = 512; // TODO in some cases it is different\n\tstatic DEFAULT_Naxis1_2: number = 512;\n\t// static RES_ORDER_0: number = 58.6 / HiPSHelper.pxXtile;\n\tstatic RES_ORDER_0: number = 58.6;\n\tstatic H: number = 4;\n\tstatic K: number = 3;\n\tstatic THETAX: number = Hploc.asin((HiPSHelper.K - 1) / HiPSHelper.K);\n\t/**\n\t * Table 1 - ref paper HEALPix  a Framework for High Resolution Discretization,\n\t * and Fast Analysis of Data Distributed on the Sphere\n\t * K. M. Gorski1,2, E. Hivon3,4, A. J. Banday5, B. D. Wandelt6,7, F. K. Hansen8, M.\n\t * Reinecke5, M. Bartelman9\n\t */\n\t/**\n\t * \n\t * @param {decimal degrees} pxsize \n\t * @returns {int} nside\n\t */\n\tstatic computeHiPSOrder(pxsize: number, pxXtile: number): number {\n\t\t/**\n\t\t * with same order k (table 1), HIPS angular resolution is higher of order of 512 (2^9) pixels than \n\t\t * the HEALPix. This is because each tile in a HiPS is represented by default by 512x512 pixels.\\\n\t\t * Angular resolution of different HEALPix orders in respect to the order 0, can be calculated this\n\t\t * way:\n\t\t * \n\t\t * \tL(k) = L(0) / 2^k = 58.6 / 2^k\n\t\t * \n\t\t * Therefore, in the case of HiPS we need to take into account the extra resolution given by the \n\t\t * 512x512 (2^9) tiles. In this case the above becomes:\n\t\t * \t\n\t\t * \tL(k) = L(0) / (2^k * 2^9) \n\t\t * \n\t\t * Though, in order to compute the required order starting from the pxsize desired (in input) we\n\t\t * need to perform these steps:\n\t\t * \n\t\t * \tpxsize = L(k) = L(0) / (2^k * 2^9)\n\t\t * \t2^k = L(0) / (pxsize * 2^9)\n\t\t *  k * Log2 2 = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \tk = Log2 L(0) - Log2 (pxsize * 2^9)\n\t\t * \n\t\t */\n\n\n\t\tlet k = Math.log2( (HiPSHelper.RES_ORDER_0 / pxXtile) / pxsize);\n\t\tk = Math.round(k);\n\t\t// let theta0px = HiPSHelper.RES_ORDER_0;\n\t\t// let k = Math.log2(theta0px) - Math.log2(pxsize * 2**9);\n\t\t// k = Match.round(k);\n\t\t// let nside = 2**k;\n\t\t// return {\n\t\t//     \"nside\" : nside,\n\t\t//     \"norder\" : k\n\t\t// };\n\t\treturn k;\n\n\t}\n\n\t/**\n\t * Reference: HiPS  Hierarchical Progressive Survey page 11\n\t * pxsize =~ sqrt[4 * PI / (12 * (512 * 2^order)^2)]\n\t * @param {*} order \n\t */\n\tstatic computePxSize(order: number, pxXtile: number): number {\n\t\t// TODO CHECK IT\n\t\t// let pxsize = 1 / (512 * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\tlet pxsize = 1 / (pxXtile * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\treturn pxsize;\n\t}\n\n\t// /**\n\t//  * \n\t//  * @param {Object {ra, dec}} point  decimal degrees\n\t//  * @returns {Object {phi_rad, theta_rad}} in radians\n\t//  */\n\t// static convert2PhiTheta (point: Point) {\n\t// \tlet phitheta_rad = {};\n\t// \tlet phiTheta_deg = HiPSHelper.astroDegToSpherical(point.ra, point.dec);\n\t// \tphitheta_rad.phi_rad = HiPSHelper.degToRad(phiTheta_deg.phi);\n\t//     phitheta_rad.theta_rad = HiPSHelper.degToRad(phiTheta_deg.theta);\n\t// \treturn phitheta_rad;\n\t// }\n\n\t// static astroDegToSphericalRad(raDeg: number, decDeg: number) {\n\t// \tlet phiThetaDeg = HiPSHelper.astroDegToSpherical(raDeg, decDeg);\n\t// \tlet phiThetaRad = {\n\t// \t\tphi_rad: HiPSHelper.degToRad(phiThetaDeg.phi),\n\t// \t\ttheta_rad: HiPSHelper.degToRad(phiThetaDeg.theta)\n\t// \t}\n\t// \treturn phiThetaRad;\n\t// }\n\n\t// static degToRad(degrees: number): number {\n\t// \treturn (degrees / 180 ) * Math.PI ;\n\t// }\n\n\t// static radToDeg(rad: number): number {\n\t// \treturn (rad / Math.PI ) * 180 ;\n\t// }\n\n\t// static astroDegToSpherical(raDeg: number, decDeg: number): Point{\n\n\t// \tlet phiDeg: number;\n\t// \tlet thetaDeg: number;\n\t// \tphiDeg = raDeg;\n\t// \tif (phiDeg < 0){\n\t// \t\tphiDeg += 360;\n\t// \t}\n\n\t// \tthetaDeg = 90 - decDeg;\n\n\t// \treturn {\n\t// \t\tphi: phiDeg,\n\t// \t\ttheta: thetaDeg\n\t// \t};\n\t// }\n\n\t/**\n\t * \n\t * @param {Object {phi_rad, theta_rad}} phiTheta_rad Center of the circle in radians\n\t * @param {decimal} r Radius of the circle in radians\n\t * @returns \n\t */\n\tstatic computeBbox(point: Point, r: number): number[] {\n\n\t\tlet bbox = [];\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad + r, point.spherical.phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.spherical.thetaRad - r, point.spherical.phiRad - r));\n\n\t\treturn bbox;\n\t}\n\n\tstatic setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n\n\t\tlet xyGridProj: HEALPixXYSpace = {\n\t\t\t\"min_y\": NaN,\n\t\t\t\"max_y\": NaN,\n\t\t\t\"min_x\": NaN,\n\t\t\t\"max_x\": NaN,\n\t\t\t\"gridPointsDeg\": []\n\t\t}\n\n\n\t\tlet cornersVec3 = hp.getBoundariesWithStep(tileno, 1);\n\t\tlet pointings = [];\n\n\t\tfor (let i = 0; i < cornersVec3.length; i++) {\n\t\t\tpointings[i] = new Pointing(cornersVec3[i]);\n\t\t\tif (i >= 1) {\n\t\t\t\tlet a = pointings[i - 1].phi;\n\t\t\t\tlet b = pointings[i].phi;\n\t\t\t\t// case when RA is just crossing the origin (e.g. 357deg - 3deg)\n\t\t\t\tif (Math.abs(a - b) > Math.PI) {\n\t\t\t\t\tif (pointings[i - 1].phi < pointings[i].phi) {\n\t\t\t\t\t\tpointings[i - 1].phi += 2 * Math.PI;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpointings[i].phi += 2 * Math.PI;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let j = 0; j < pointings.length; j++) {\n\t\t\tlet coThetaRad = pointings[j].theta;\n\t\t\t// HEALPix works with colatitude (0 North Pole, 180 South Pole)\n\t\t\t// converting the colatitude in latitude (dec)\n\t\t\tlet decRad = Math.PI / 2 - coThetaRad;\n\n\t\t\tlet raRad = pointings[j].phi;\n\n\t\t\t// projection on healpix grid\n\t\t\tlet p = new Point(CoordsType.ASTRO, NumberType.RADIANS, raRad, decRad);\n\t\t\tlet xyDeg = HiPSHelper.world2intermediate(p.astro);\n\t\t\txyGridProj.gridPointsDeg[j * 2] = xyDeg[0];\n\t\t\txyGridProj.gridPointsDeg[j * 2 + 1] = xyDeg[1];\n\n\t\t\tif (isNaN(xyGridProj.max_y) || xyDeg[1] > xyGridProj.max_y) {\n\t\t\t\txyGridProj.max_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_y) || xyDeg[1] < xyGridProj.min_y) {\n\t\t\t\txyGridProj.min_y = xyDeg[1];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.max_x) || xyDeg[0] > xyGridProj.max_x) {\n\t\t\t\txyGridProj.max_x = xyDeg[0];\n\t\t\t}\n\t\t\tif (isNaN(xyGridProj.min_x) || xyDeg[0] < xyGridProj.min_x) {\n\t\t\t\txyGridProj.min_x = xyDeg[0];\n\t\t\t}\n\n\t\t}\n\t\treturn xyGridProj;\n\t}\n\n\tstatic world2intermediate(ac: AstroCoords): [number, number] {\n\n\t\tlet x_grid: number;\n\t\tlet y_grid: number;\n\n\t\tif (Math.abs(ac.decRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t\t\tx_grid = ac.raDeg;\n\n\t\t\ty_grid = Hploc.sin(ac.decRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t\t} else if (Math.abs(ac.decRad) > HiPSHelper.THETAX) { // polar zones\n\n\t\t\tlet raDeg = ac.raDeg;\n\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\n\t\t\tlet sigma = Math.sqrt(HiPSHelper.K * (1 - Math.abs(Hploc.sin(ac.decRad))));\n\t\t\tlet phi_c = - 180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSHelper.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSHelper.H);\n\n\t\t\tx_grid = phi_c + (raDeg - phi_c) * sigma;\n\t\t\ty_grid = (180 / HiPSHelper.H) * (((HiPSHelper.K + 1) / 2) - sigma);\n\n\t\t\tif (ac.decRad < 0) {\n\t\t\t\ty_grid *= -1;\n\t\t\t}\n\t\t}\n\n\t\treturn [x_grid, y_grid];\n\n\t}\n\n\t// static world2intermediate(sc: SphericalCoords): [number, number] {\n\t//     let x_grid: number;\n\t// \tlet y_grid: number;\n\n\t// \tif ( Math.abs(sc.thetaRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t// \t\tx_grid = sc.phiDeg;\n\n\t// \t\ty_grid = Hploc.sin(sc.thetaRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t// \t} else if ( Math.abs(sc.thetaRad) > HiPSHelper.THETAX) { // polar zones\n\n\t// \t\tlet phiDeg = sc.phiDeg;\n\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || sc.thetaRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\n\t// \t\tlet sigma = Math.sqrt( HiPSHelper.K * (1 - Math.abs(Hploc.sin(sc.thetaRad)) ) );\n\t// \t\tlet phi_c = - 180 + ( 2 * Math.floor( ((sc.phiRad + 180) * HiPSHelper.H/360) + ((1 - w)/2) ) + w ) * ( 180 / HiPSHelper.H );\n\n\t// \t\tx_grid = phi_c + (phiDeg - phi_c) * sigma;\n\t// \t\ty_grid = (180  / HiPSHelper.H) * ( ((HiPSHelper.K + 1)/2) - sigma);\n\n\t// \t\tif (sc.thetaRad < 0) {\n\t// \t\t\ty_grid *= -1;\n\t// \t\t}\n\t// \t}\n\n\t// \treturn [x_grid, y_grid];\n\n\t// }\n\n\tstatic intermediate2pix(x: number, y: number, xyGridProj: HEALPixXYSpace, pxXtile: number): [number, number] {\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);\n\n\t\tlet i_norm: number;\n\t\tlet j_norm: number;\n\t\tif ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {\n\t\t\ti_norm = (x + 360 - xyGridProj.min_x) / xInterval;\n\t\t} else {\n\t\t\ti_norm = (x - xyGridProj.min_x) / xInterval;\n\t\t}\n\t\tj_norm = (y - xyGridProj.min_y) / yInterval;\n\n\n\t\tlet i = 0.5 - (i_norm - j_norm);\n\t\tlet j = (i_norm + j_norm) - 0.5;\n\n\t\t// TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);\n\t\tpxXtile\n\t\t// i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);\n\t\t// return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];\n\t\t\n\t\ti = Math.floor(i * pxXtile);\n\t\tj = Math.floor(j * pxXtile);\n\t\treturn [i, pxXtile - j - 1];\n\n\n\n\t}\n\n\n\tstatic pix2intermediate(i: number, j: number, xyGridProj: HEALPixXYSpace, naxis1: number, naxis2: number): [number, number] {\n\t\t/**\n\t\t   * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image\n\t\t * (i_norm,w_pixel) = (1,1) is the upper right corner\n\t\t * dimamond in figure 1 from \"Mapping on the HEalpix grid\" paper\n\t\t * (0,0) leftmost corner\n\t\t * (1,0) upper corner\n\t\t * (0,1) lowest corner\n\t\t * (1,1) rightmost corner\n\t\t * Thanks YAGO! :p\n\t\t */\n\t\t// let cnaxis1 = HiPSHelper.pxXtile;\n\t\t// let cnaxis2 = HiPSHelper.pxXtile;\n\n\t\tlet cnaxis1 = naxis1;\n\t\tlet cnaxis2 = naxis2;\n\t\tif (naxis1) {\n\t\t\tcnaxis1 = naxis1;\n\t\t}\n\t\tif (naxis2) {\n\t\t\tcnaxis2 = naxis2;\n\t\t}\n\t\tlet i_norm = (i + 0.5) / cnaxis1;\n\t\tlet j_norm = (j + 0.5) / cnaxis2;\n\n\t\tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;\n\t\tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;\n\t\tlet yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;\n\n\t\t// bi-linear interpolation\n\t\tlet x = xyGridProj.max_x - xInterval * (i_norm + j_norm);\n\t\tlet y = yMean - yInterval * (j_norm - i_norm);\n\n\t\treturn [x, y];\n\t}\n\n\n\tstatic intermediate2world(x: number, y: number): Point {\n\n\t\tlet phiDeg: number;\n\t\tlet thetaDeg: number;\n\t\tlet Yx = 90 * (HiPSHelper.K - 1) / HiPSHelper.H;\n\n\n\n\t\tif (Math.abs(y) <= Yx) { // equatorial belts\n\n\t\t\tphiDeg = x;\n\t\t\tthetaDeg = radToDeg(Math.asin((y * HiPSHelper.H) / (90 * HiPSHelper.K)));\n\n\t\t} else if (Math.abs(y) > Yx) { // polar regions\n\n\t\t\tlet sigma = (HiPSHelper.K + 1) / 2 - Math.abs(y * HiPSHelper.H) / 180;\n\t\t\tlet thetaRad = Hploc.asin(1 - (sigma * sigma) / HiPSHelper.K);\n\t\t\tlet w = 0; // omega\n\t\t\tif (HiPSHelper.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0\n\t\t\t\tw = 1;\n\t\t\t}\n\t\t\tlet x_c = -180 + (2 * Math.floor((x + 180) * HiPSHelper.H / 360 + (1 - w) / 2) + w) * (180 / HiPSHelper.H);\n\t\t\tphiDeg = x_c + (x - x_c) / sigma;\n\t\t\tthetaDeg = radToDeg(thetaRad);\n\t\t\tif (y <= 0) {\n\t\t\t\tthetaDeg *= -1;\n\t\t\t}\n\t\t}\n\t\t// return [phiDeg, thetaDeg];\n\t\t// TODO CHECK THIS!\n\t\t// let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);\n\t\tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, phiDeg, thetaDeg);\n\n\t\treturn p;\n\n\t}\n\n}\n","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\n\nimport { Healpix } from \"healpixjs\";\nimport { Pointing } from \"healpixjs\";\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { HEALPixXYSpace } from '../model/HEALPixXYSpace.js';\n\nimport { HiPSHelper } from './HiPSHelper.js';\n\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { astroToSpherical, degToRad, fillAstro, radToDeg } from '../model/Utils.js';\nimport { Point } from '../model/Point.js';\nimport { CoordsType } from '../model/CoordsType.js';\nimport { NumberType } from '../model/NumberType.js';\nimport { exit } from 'process';\nimport { INSPECT_MAX_BYTES } from 'buffer';\n\n\n\nexport class HiPSProjection implements AbstractProjection {\n\n\t_naxis1!: number;\n\t_naxis2!: number;\n\t_isGalactic: boolean = false;\n\t_pixno!: number;\n\t_tileslist!: number[];\n\t_hp!: Healpix;\n\t_fh_common!: FITSHeader;\n\t_ctype1: string; // TODO should be RA ENUM\n\t_ctype2: string; // TODO should be Dec ENUM\n\t_wcsname: string;\n\t_hipsBaseURI!: string;\n\t_pxsize!: number;\n\t_fitsheaderlist: FITSHeader[];\n\t_pxvalues: Map<number, Array<Uint8Array>>;\n\t_xyGridProj!: HEALPixXYSpace;\n\t_norder!: number;\n\t_nside!: number;\n\t_radeclist: Array<[number, number]>;\n\t_HIPS_TILE_WIDTH: number;\n\t_fitsUsed: String[] = [];\n\t_HIPS_MAX_ORDER: number;\n\n\t/**\n\t * \n\t * * ex with single local file:\n\t * let hp = new HiPSProjection('/mylocaldir/myfile.fits', null, null, null);\n\t * hp.initFromFile()\n\t * \n\t * * ex with single remote file:\n\t * let hp = new HiPSProjection('http://<hips-server>/Norder7/DirN/NpixXYZ.fits', null, null, null);\n\t * hp.initFromFile()\n\t *\n\t * * ex with HiPS server base local dir:\n\t * let hp = new HiPSProjection(null, <hips-local-root-dir>, pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t * * ex with HiPS server base URL:\n\t * let hp = new HiPSProjection(null, 'http://<hips-server>/<hips-root-dir>', pxsize, order);\n\t * hp.initFromBaseHiPSDir()\n\t * \n\t */\n\n\n\t//  constructor(fitsfilepath?: string, hipsBaseURI?: string, pxsize?: number, order?: number) {\n\tconstructor() {\n\n\t\tthis._wcsname = \"HPX\"; // TODO check WCS standard\n\t\tthis._ctype1 = \"RA---HPX\";\n\t\tthis._ctype2 = \"DEC--HPX\";\n\n\t\tthis._pxvalues = new Map<number, Array<Uint8Array>>();\n\t\tthis._fitsheaderlist = new Array<FITSHeader>();\n\t\tthis._radeclist = new Array<[number, number]>();\n\n\t}\n\n\tasync parsePropertiesFile(baseUrl: string): Promise<any> {\n\t\tconst fp = new FITSParser(null);\n\n\t\tconst promise = fp.getFile(baseUrl + \"/properties\").then((propFile: ArrayBuffer | Buffer) => {\n\t\t\tlet prop: string;\n\t\t\tif (propFile instanceof ArrayBuffer) {\n\t\t\t\tconst textDecoder = new TextDecoder(\"iso-8859-1\");\n\t\t\t\tprop = textDecoder.decode(new Uint8Array(propFile));\n\t\t\t} else {\n\t\t\t\tprop = propFile.toString('utf8');\n\t\t\t}\n\t\t\t/**\n\t\t\t \tHiPS  Hierarchical Progressive Survey\n\t\t\t\tVersion 1.0\n\t\t\t\tIVOA Proposed Recommendation\n\t\t\t\t3rd April 2017\n\t\t\t\thttps://www.ivoa.net/documents/HiPS/20170403/PR-HIPS-1.0-20170403.pdf\n\t\t\t */\n\t\t\tconst txtArr = prop.split('\\n');\n\t\t\tthis._HIPS_TILE_WIDTH = 512;\n\t\t\tfor (let line of txtArr) {\n\t\t\t\tif (!line.includes(\"=\")){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst tokens = line.split(\"=\");\n\t\t\t\tif (tokens[1] === undefined){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst key = tokens[0].trim()\n\t\t\t\tconst val = tokens[1].trim()\n\n\t\t\t\tif (key == \"hips_order\") {\n\t\t\t\t\tthis._HIPS_MAX_ORDER = parseInt(val);\n\t\t\t\t\tconsole.log(\"hips_order \"+this._HIPS_MAX_ORDER)\n\t\t\t\t} else if (key == \"hips_tile_width\") {\n\t\t\t\t\tthis._HIPS_TILE_WIDTH = parseInt(val);\n\t\t\t\t\tthis._naxis1 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tthis._naxis2 = this._HIPS_TILE_WIDTH;\n\t\t\t\t\tconsole.log(\"hips_tile_width \"+this._HIPS_TILE_WIDTH)\n\t\t\t\t} else if (key == \"hips_frame\" && val == \"galactic\") {\n\t\t\t\t\tthis._isGalactic = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn propFile;\n\t\t});\n\n\t\tawait promise;\n\t\treturn promise;\n\t}\n\n\tasync initFromFile(fitsfilepath: string): Promise<FITSParsed> {\n\t\tlet fp = new FITSParser(fitsfilepath);\n\n\t\tlet promise = fp.loadFITS().then(fits => {\n\t\t\tthis._pxvalues.set(0, fits.data);\n\t\t\tthis._fitsheaderlist[0] = fits.header;\n\n\t\t\tlet order = fits.header.get(\"ORDER\");\n\t\t\tthis.init(order);\n\n\t\t\tthis._naxis1 = fits.header.get(\"NAXIS1\");\n\t\t\tthis._naxis2 = fits.header.get(\"NAXIS2\");\n\t\t\tthis._HIPS_TILE_WIDTH = this._naxis1;\n\n\t\t\tthis._pixno = fits.header.get(\"NPIX\");\n\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(this._pixno, this._hp);\n\t\t\treturn fits;\n\t\t});\n\t\tawait promise;\n\t\treturn promise;\n\t}\n\n\n\n\tasync initFromHiPSLocationAndPxSize(baseUrl: string, pxsize: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tthis._pxsize = pxsize;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\tlet order = HiPSHelper.computeHiPSOrder(pxsize, this._HIPS_TILE_WIDTH);\n\t\tif (order > this._HIPS_MAX_ORDER) {\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tthis.init(order);\n\t}\n\n\tasync initFromHiPSLocationAndOrder(baseUrl: string, order: number) {\n\t\tthis._hipsBaseURI = baseUrl;\n\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\tawait this.parsePropertiesFile(baseUrl);\n\t\t}\n\t\tif (order > this._HIPS_MAX_ORDER){\n\t\t\torder = this._HIPS_MAX_ORDER\n\t\t}\n\t\tthis._pxsize = HiPSHelper.computePxSize(order, this._HIPS_TILE_WIDTH);\n\t\tthis.init(order);\n\t}\n\n\tinit(order: number) {\n\t\tthis._norder = order;\n\t\tthis._nside = 2 ** order;\n\t\tthis._hp = new Healpix(this._nside);\n\t}\n\n\tprepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\t\tfor (let header of this._fitsheaderlist) {\n\n\t\t\theader.addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n\t\t\theader.addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n\t\t\tif (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n\t\t\t}\n\t\t\tlet bscale = 1.0;\n\t\t\tif (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n\t\t\t\tbscale = fitsHeaderParams.get(\"BSCALE\");\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\t\t\t}\n\n\n\t\t\tlet bzero = 0.0;\n\t\t\tif (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n\t\t\t\tbzero = fitsHeaderParams.get(\"BZERO\");\n\t\t\t\theader.addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\t\t\t}\n\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS\", 2));\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS1\", HiPSHelper.DEFAULT_Naxis1_2));\n\t\t\theader.addItem(new FITSHeaderItem(\"NAXIS2\", HiPSHelper.DEFAULT_Naxis1_2));\n\n\t\t\theader.addItem(new FITSHeaderItem(\"ORDER\", this._norder));\n\n\t\t\theader.addItem(new FITSHeaderItem(\"CTYPE1\", this._ctype1));\n\t\t\theader.addItem(new FITSHeaderItem(\"CTYPE2\", this._ctype2));\n\n\t\t\t// header.addItem(new FITSHeaderItem(\"CRPIX1\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel i along naxis1\n\t\t\t// header.addItem(new FITSHeaderItem(\"CRPIX2\", HiPSHelper.DEFAULT_Naxis1_2/2)); // central/reference pixel j along naxis2\n\n\t\t\theader.addItem(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n\t\t\theader.addItem(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n\n\t\t}\n\t\treturn this._fitsheaderlist;\n\t}\n\n\n\tgetFITSHeader(): FITSHeader[] {\n\t\treturn this._fitsheaderlist;\n\t}\n\n\tgetCommonFitsHeaderParams(): FITSHeader {\n\t\treturn this._fh_common;\n\t}\n\n\textractPhysicalValues(fits: FITSParsed): number[][] {\n\n\t\tlet bzero = fits.header.get(\"BZERO\");\n\t\tlet bscale = fits.header.get(\"BSCALE\");\n\t\tlet naxis1 = fits.header.get(\"NAXIS1\");\n\t\tlet naxis2 = fits.header.get(\"NAXIS2\");\n\t\tlet bitpix = fits.header.get(\"BITPIX\");\n\t\tlet bytesXelem = Math.abs(bitpix / 8);\n\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n\t\t// let physicalvalues = new Array[naxis2][naxis1];\n\t\tlet physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n\t\tfor (let n2 = 0; n2 < naxis2; n2++) {\n\t\t\tphysicalvalues[n2] = new Array<number>(naxis1);\n\t\t\tfor (let n1 = 0; n1 < naxis1; n1++) {\n\t\t\t\tlet pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n\t\t\t\tlet physicalVal = bzero + bscale * pixval;\n\t\t\t\tphysicalvalues[n2][n1] = physicalVal;\n\t\t\t}\n\t\t}\n\t\treturn physicalvalues;\n\n\t}\n\n\tasync getFITSFiles(inputPixelsList: ImagePixel[], destPath: string): Promise<Map<string, FITSParsed>> {\n\n\t\tconst fitsFilesGenerated = new Map<string, FITSParsed>();\n\t\tlet promises = [];\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\t\tfor (let hipstileno of tilesset) {\n\t\t\tlet tileno = hipstileno;\n\t\t\tlet dir = Math.floor(tileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + tileno + \".fits\";\n\t\t\tlet fp = new FITSParser(fitsurl);\n\n\n\t\t\tpromises.push(fp.loadFITS().then((fits) => {\n\t\t\t\tif (fits !== null) {\n\t\t\t\t\tlet pixno = (fits.header.get(\"NPIX\") !== undefined) ? fits.header.get(\"NPIX\") : tileno;\n\t\t\t\t\t// FITSParser.writeFITS(fits.header, fits.data, destPath+\"/Npix\"+pixno+\".fits\");\n\t\t\t\t\t// fitsFilesGenerated.set(destPath+\"/Npix\"+pixno+\".fits\",FITSParser.generateFITS(fits.header, fits.data) );\n\t\t\t\t\tfitsFilesGenerated.set(destPath + \"/Npix\" + pixno + \".fits\", fits);\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\treturn fitsFilesGenerated;\n\t}\n\n\n\tget fitsUsed(): String[] {\n\t\treturn this._fitsUsed;\n\t}\n\n\tasync getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array | undefined> {\n\n\t\tlet tilesset = new Set<number>();\n\t\tinputPixelsList.forEach((imgpx) => {\n\t\t\ttilesset.add(imgpx.tileno);\n\t\t});\n\n\t\tlet pixcount = inputPixelsList.length;\n\t\tlet values: Uint8Array | undefined = undefined;\n\t\tlet fitsheaderlist: (FITSHeader | undefined)[] = [];\n\t\tlet promises = [];\n\n\t\tlet self = this;\n\t\tfor (let hipstileno of tilesset) {\n\n\t\t\tlet dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n\t\t\tlet fitsurl = this._hipsBaseURI + \"/Norder\" + this._norder + \"/Dir\" + dir + \"/Npix\" + hipstileno + \".fits\";\n\t\t\tconsole.log(`Identified source file ${fitsurl}`)\n\t\t\tlet fp = new FITSParser(fitsurl);\n\t\t\tpromises.push(fp.loadFITS().then((fits) => {\n\n\t\t\t\tif (fits === null) {\n\t\t\t\t\tfitsheaderlist.push(undefined);\n\t\t\t\t} else {\n\t\t\t\t\tself._fitsUsed.push(fitsurl);\n\n\t\t\t\t\tlet bytesXelem = Math.abs(fits.header.get(\"BITPIX\") / 8);\n\t\t\t\t\tlet blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // => ???????\n\t\t\t\t\tif (values === undefined) {\n\t\t\t\t\t\tvalues = new Uint8Array(pixcount * bytesXelem);\n\t\t\t\t\t}\n\n\t\t\t\t\t// console.log(fitsurl + \" loaded\");\n\t\t\t\t\tfitsheaderlist.push(fits.header);\n\n\t\t\t\t\tfor (let p = 0; p < pixcount; p++) {\n\t\t\t\t\t\tlet imgpx = inputPixelsList[p];\n\n\t\t\t\t\t\tif (imgpx.tileno === hipstileno) {\n\n\n\t\t\t\t\t\t\t// if (imgpx._j < HiPSHelper.DEFAULT_Naxis1_2 && imgpx._i < HiPSHelper.DEFAULT_Naxis1_2) {\n\t\t\t\t\t\t\tif (imgpx._j < fits.header.get(\"NAXIS1\") && imgpx._i < fits.header.get(\"NAXIS2\")) {\n\t\t\t\t\t\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\t\t\t\t\t\tvalues[p * bytesXelem + b] = fits.data[imgpx._j][imgpx._i * bytesXelem + b];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\tif (fitsheaderlist !== undefined) {\n\t\t\tthis.prepareCommonHeader(fitsheaderlist);\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tcomputeSquaredNaxes(d: number, ps: number): void {\n\t\t// first aprroximation to be checked\n\t\tthis._naxis1 = Math.ceil(d / ps);\n\t\tthis._naxis2 = this._naxis1;\n\t\tthis._pxsize = ps;\n\t}\n\n\tprepareCommonHeader(fitsheaderlist: (FITSHeader | undefined)[]): void {\n\t\tif (fitsheaderlist === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fh_common) {\n\t\t\tthis._fh_common = new FITSHeader();\n\t\t}\n\n\t\tfor (let i = 0; i < fitsheaderlist.length; i++) {\n\t\t\tlet header = fitsheaderlist[i];\n\t\t\tif (header !== undefined) {\n\n\t\t\t\tfor (let item of header.getItemList()) {\n\t\t\t\t\tif ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\"].includes(item.key)) {\n\t\t\t\t\t\tif (!this._fh_common.getItemListOf(item.key)[0]) {\n\t\t\t\t\t\t\tthis._fh_common.addItem(new FITSHeaderItem(item.key, item.value));\n\t\t\t\t\t\t} else if (this._fh_common.getItemListOf(item.key)[0].value !== item.value) { // this should not happen \n\t\t\t\t\t\t\tthrow new Error(\"Error parsing headers. \" + item.key + \" was \" + this._fh_common.getItemListOf(item.key)[0] + \" and now is \" + item.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\n\t// // TODO MOVE THIS IN AN UTILITY FILE\n\t// pixel2Physical(value, bzero, bscale) {\n\t// \tlet pval = bzero + bscale * value;\n\t// \treturn pval;\n\t// }\n\n\tsetPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n\n\t\t// let vidx = 0; // <------ ERROR!!!!! pixel are not organized by tile!!!\n\n\t\t// let pxXTile = HiPSHelper.DEFAULT_Naxis1_2 * HiPSHelper.DEFAULT_Naxis1_2;\n\t\tlet bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n\t\tlet bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n\t\tlet bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n\t\tif (bytesXelem === undefined || bscale === undefined || bzero === undefined) {\n\t\t\tthrow new Error(\"BITPIX, BSCALE or BZERO are undefined\");\n\t\t}\n\n\n\t\t// let minmaxmap = new Array();\n\t\tlet minmaxmap = new Map();\n\t\tlet nodata = new Map();\n\n\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\t// this._pxvalues.set(tileno, new Array(HiPSHelper.DEFAULT_Naxis1_2));  // <- bidimensional\n\t\t\t// for (let row = 0; row < HiPSHelper.DEFAULT_Naxis1_2; row++) {\n\n\t\t\tthis._pxvalues.set(tileno, new Array(this._HIPS_TILE_WIDTH));  // <- bidimensional\n\t\t\tfor (let row = 0; row < this._HIPS_TILE_WIDTH; row++) {\n\t\t\t\tif (this._pxvalues.has(tileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(tileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\t// p[row] = new Uint8Array(HiPSHelper.DEFAULT_Naxis1_2 * bytesXelem);\n\t\t\t\t\t\tp[row] = new Uint8Array(this._HIPS_TILE_WIDTH * bytesXelem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tminmaxmap.set(\"\" + tileno + \"\", new Array(2));\n\t\t\tnodata.set(\"\" + tileno + \"\", true);\n\t\t});\n\t\tlet ra: number;\n\t\tlet dec: number;\n\t\tlet col: number;\n\t\tlet row: number;\n\n\t\tfor (let rdidx = 0; rdidx < this._radeclist.length; rdidx++) {\n\t\t\t[ra, dec] = this._radeclist[rdidx];\n\t\t\tlet ac = fillAstro(ra, dec, NumberType.DEGREES);\n\t\t\tlet sc = astroToSpherical(ac);\n\t\t\tlet ptg = new Pointing(null, false, sc.thetaRad, sc.phiRad);\n\t\t\tlet pixtileno: number = this._hp.ang2pix(ptg);\n\n\t\t\tlet xyGridProj = HiPSHelper.setupByTile(pixtileno, this._hp);\n\t\t\t// let rarad = degToRad(ra);\n\t\t\t// let decrad = degToRad(dec);\n\t\t\t// TODO CHECK THIS POINT before it was with ra and dec in radians\n\t\t\tlet xy = HiPSHelper.world2intermediate(ac);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tlet ij = HiPSHelper.intermediate2pix(xy[0], xy[1], xyGridProj, this._HIPS_TILE_WIDTH);\n\t\t\tcol = ij[0];\n\t\t\trow = ij[1];\n\n\t\t\tfor (let b = 0; b < bytesXelem; b++) {\n\t\t\t\tlet byte = values[rdidx * bytesXelem + b];\n\t\t\t\t// this._pxvalues.get(pixtileno)[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\t\tif (p !== undefined) {\n\t\t\t\t\t\tp[row][col * bytesXelem + b] = byte\t// <- bidimensional\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nodata.get(\"\" + pixtileno + \"\")) {\n\t\t\t\t\tif (byte != 0) {\n\t\t\t\t\t\tnodata.set(\"\" + pixtileno + \"\", false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet min = minmaxmap.get(\"\" + pixtileno + \"\")[0];\n\t\t\tlet max = minmaxmap.get(\"\" + pixtileno + \"\")[1];\n\n\t\t\tif (this._pxvalues.has(pixtileno)) {\n\t\t\t\tlet p = this._pxvalues.get(pixtileno);\n\t\t\t\tif (p !== undefined) {\n\t\t\t\t\tlet valpixb = ParseUtils.extractPixelValue(0, p[row].slice(col * bytesXelem, col * bytesXelem + bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n\t\t\t\t\tlet valphysical = bzero + bscale * valpixb;\n\t\t\t\t\tif (valphysical < min || isNaN(min)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[0] = valphysical;\n\t\t\t\t\t} else if (valphysical > max || isNaN(max)) {\n\t\t\t\t\t\tminmaxmap.get(\"\" + pixtileno + \"\")[1] = valphysical;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Object.keys(this._pxvalues.keys()).forEach((tileno) => {\n\t\tconst fhKeys = Array.from(this._pxvalues.keys());\n\n\t\tfhKeys.forEach((tileno) => {\n\t\t\tif (nodata.get(\"\" + tileno + \"\") == false) { // there are data\n\t\t\t\t// tileno = parseInt(tileno);\n\t\t\t\tlet header = new FITSHeader();\n\t\t\t\theader.set(\"NPIX\", tileno);\n\t\t\t\t// TODO CONVERT minval and maxval to physical values!\n\t\t\t\t// header.addItem(new FITSHeaderItem(\"DATAMIN\", minmaxmap[\"\" + tileno + \"\"][0]));\n\t\t\t\t// header.addItem(new FITSHeaderItem(\"DATAMAX\", minmaxmap[\"\" + tileno + \"\"][1]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"DATAMIN\", minmaxmap.get(\"\" + tileno + \"\")[0]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"DATAMAX\", minmaxmap.get(\"\" + tileno + \"\")[1]));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"NPIX\", tileno));\n\n\t\t\t\tlet vec3 = this._hp.pix2vec(tileno);\n\t\t\t\tlet ptg = new Pointing(vec3);\n\t\t\t\tlet crval1 = radToDeg(ptg.phi);\n\t\t\t\tlet crval2 = 90 - radToDeg(ptg.theta);\n\n\t\t\t\theader.addItem(new FITSHeaderItem(\"CRVAL1\", crval1));\n\t\t\t\theader.addItem(new FITSHeaderItem(\"CRVAL2\", crval2));\n\n\t\t\t\tthis._fitsheaderlist.push(header);\n\t\t\t} else { // no data\n\t\t\t\t// this._pxvalues.delete(parseInt(tileno));\n\t\t\t\tthis._pxvalues.delete(tileno);\n\t\t\t\t// delete this._pxvalues[\"\" + tileno + \"\"];\n\t\t\t}\n\n\t\t});\n\t\tthis.prepareFITSHeader(fitsHeaderParams);\n\t\treturn this._pxvalues;\n\n\t}\n\n\tgetImageRADecList(center: Point, radiusDeg: number): Array<[number, number]> {\n\n\t\tlet ptg = new Pointing(null, false, center.spherical.thetaRad, center.spherical.phiRad);\n\t\tlet radius_rad = degToRad(radiusDeg);\n\n\t\t// with fact 8 the original Java code starts returning the the ptg pixel. with my JS porting only from fact 16\n\t\tlet rangeset = this._hp.queryDiscInclusive(ptg, radius_rad, 4); // <= check it \n\n\t\tthis._tileslist = [];\n\t\tfor (let p = 0; p < rangeset.r.length; p++) {\n\n\t\t\tif (!this._tileslist.includes(rangeset.r[p]) && rangeset.r[p] != 0) {\n\t\t\t\tthis._tileslist.push(rangeset.r[p]);\n\t\t\t}\n\n\t\t}\n\n\t\tlet cpix = this._hp.ang2pix(ptg);\n\t\tif (!this._tileslist.includes(cpix)) {\n\t\t\tthis._tileslist.push(cpix);\n\t\t}\n\n\n\t\tlet minra = center.astro.raDeg - radiusDeg;\n\t\tlet maxra = center.astro.raDeg + radiusDeg;\n\t\tlet mindec = center.astro.decDeg - radiusDeg;\n\t\tlet maxdec = center.astro.decDeg + radiusDeg;\n\n\t\tthis._tileslist.forEach((tileno: number) => {\n\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t// for (let j = 0; j < HiPSHelper.DEFAULT_Naxis1_2; j++) {\n\t\t\t// \tfor (let i = 0; i < HiPSHelper.DEFAULT_Naxis1_2; i++) {\n\t\t\tfor (let j = 0; j < this._HIPS_TILE_WIDTH; j++) {\n\t\t\t\tfor (let i = 0; i < this._HIPS_TILE_WIDTH; i++) {\n\t\t\t\t\tlet p = this.pix2world(i, j);\n\t\t\t\t\tif (p.astro.raDeg < minra || p.astro.raDeg > maxra ||\n\t\t\t\t\t\tp.astro.decDeg < mindec || p.astro.decDeg > maxdec) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis._radeclist.push([p.astro.raDeg, p.astro.decDeg]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this._radeclist;\n\n\n\t}\n\n\n\tpix2world(i: number, j: number): Point {\n\n\t\tlet xy = HiPSHelper.pix2intermediate(i, j, this._xyGridProj, this._naxis1, this._naxis2);\n\t\t// TODO CHECK BELOW before it was only which is supposed to be wrong since intermediate2world returns SphericalCoords, not AstroCoords\n\t\t/**  \n\t\tlet raDecDeg = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\tif (raDecDeg[0] > 360){\n\t\t\traDecDeg[0] -= 360;\n\t\t}\n\t\treturn raDecDeg;\n\t\t*/\n\t\tlet p = HiPSHelper.intermediate2world(xy[0], xy[1]);\n\t\t// if (p.spherical.phiDeg > 360){\n\t\t// \tsc.phiDeg -= 360;\n\t\t// }\n\t\treturn p;\n\t}\n\n\n\t// conversion taken from https://astrophysicsandpython.com/2022/03/15/html-js-equatorial-to-galactic-coordinates/\n\tconvertToGalactic(radeclist: number[][]): number[][] {\n\t\tlet finalradeclist: number[][] = [];\n\t\tconst deg2rad = Math.PI / 180\n\t\tconst rad2deg = 180 / Math.PI\n\t\tconst l_NCP = deg2rad * 122.930\n\t\tconst d_NGP = deg2rad * 27.1284\n\t\tconst a_NGP = deg2rad * 192.8595\n\t\tradeclist.forEach(([ra, dec]) => {\n\t\t\tconst ra_rad = deg2rad * ra\n\t\t\tconst dec_rad = deg2rad * dec\n\t\t\t// sin(b)\n\t\t\tconst sin_b = Math.sin(d_NGP) * Math.sin(dec_rad) + \n\t\t\t\t\t\t\tMath.cos(d_NGP) * Math.cos(dec_rad) * Math.cos(ra_rad - a_NGP);\n\t\t\tconst b = Math.asin(sin_b)\n\t\t\tconst b_deg = b * rad2deg\n\n\t\t\t// l_NCP - l\n\t\t\tconst lNCP_minus_l = Math.atan ( ( Math.cos(dec_rad) * Math.sin(ra_rad - a_NGP)) /\n\t\t\t\t\t\t\t(Math.sin(dec_rad) * Math.cos(d_NGP) - Math.cos(dec_rad) * Math.sin(d_NGP) * Math.cos(ra_rad - a_NGP)) );\n\t\t\tconst l = l_NCP - lNCP_minus_l\n\t\t\tconst l_deg = l * rad2deg\n\t\t\t\n\t\t\tfinalradeclist.push([l_deg, b_deg])\n\t\t});\n\t\treturn finalradeclist;\n\t}\n\n\tworld2pix(radeclist: number[][]): ImagePixel[] {\n\n\t\t// let imgpxlist = new ImagePixel[radeclist.length];\n\t\tlet imgpxlist: ImagePixel[] = [];\n\t\tlet tileno: number;\n\t\tlet prevTileno: number | undefined = undefined;\n\t\t// let k = 0;\n\n\t\t/*\n\t\t\tif HiPS in galactic => convert the full list of (RA, Dec) to Galactic  (l, b)\n\t\t*/\n\n\t\tif (this._isGalactic){\n\t\t\tlet finalradeclist = this.convertToGalactic(radeclist);\n\t\t\tradeclist = finalradeclist;\n\t\t}\n\n\t\tradeclist.forEach(([ra, dec]) => {\n\n\t\t\tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n\t\t\t// let phiTheta_rad = HiPSHelper.astroDegToSphericalRad(ra, dec);\n\t\t\tlet ptg = new Pointing(null, false, p.spherical.thetaRad, p.spherical.phiRad);\n\n\t\t\ttileno = this._hp.ang2pix(ptg);\n\t\t\tif (prevTileno !== tileno || prevTileno === undefined) {\n\t\t\t\tthis._xyGridProj = HiPSHelper.setupByTile(tileno, this._hp);\n\t\t\t\tprevTileno = tileno;\n\t\t\t}\n\t\t\t// let rarad =  HiPSHelper.degToRad(ra);\n\t\t\t// let decrad = HiPSHelper.degToRad(dec);\n\t\t\tlet xy = HiPSHelper.world2intermediate(p.astro);\n\t\t\tif (this._HIPS_TILE_WIDTH === undefined) {\n\t\t\t\tthrow new Error(\"this._HIPS_TILE_WIDTH undefined\");\n\t\t\t}\n\t\t\tlet ij = HiPSHelper.intermediate2pix(xy[0], xy[1], this._xyGridProj, this._HIPS_TILE_WIDTH);\n\n\t\t\timgpxlist.push(new ImagePixel(ij[0], ij[1], tileno));\n\t\t});\n\n\t\treturn imgpxlist;\n\t}\n\n\n\t// getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n\t// \tlet canvaslist = [];\n\t// \tlet i = 0;\n\t// \tObject.keys(this._pxvalues).forEach((tileno) => {\n\t// \t\tlet values = this._pxvalues[\"\" + tileno + \"\"];\n\n\t// \t\t// TODO change this._fitsheaderlist as per this._pxvalues in order to access to the header by \"tileno\"\n\t// \t\tlet header = this._fitsheaderlist[i];\n\n\t// \t\tlet canvas2d = new Canvas2D(values, header, this, tfunction, colormap, inverse);\n\t// \t\tcanvaslist.push(canvas2d);\n\t// \t\ti++;\n\t// \t});\n\n\t// \treturn canvaslist;\n\t// }\n}\n","import { FITSHeader } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\n// import { AstroCoords } from \"src/model/AstroCoords\";\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport {Point} from \"../model/Point.js\";\n\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nexport abstract class AbstractProjection {\n\n    // constructor() { }\n\n    public abstract initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed | undefined>;\n\n    public abstract prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[];\n\n    public abstract getFITSHeader(): FITSHeader[];\n\n    public abstract getCommonFitsHeaderParams(): FITSHeader;\n\n    public abstract extractPhysicalValues(fits: FITSParsed): number[][];\n\n    public abstract getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array | undefined>;\n\n    public abstract computeSquaredNaxes(d: number, ps: number): void;\n\n    // protected abstract prepareCommonHeader(fitsheaderlist: FITSHeader[]): void;\n\n    public abstract setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>>;\n\n    public abstract getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]>;\n\n    public abstract pix2world(i: number, j: number): Point;\n\n    public abstract get fitsUsed(): String[];\n    \n    // public abstract world2pix(radeclist: number[][]): Promise<ImagePixel[]>\n    public abstract world2pix(radeclist: number[][]): ImagePixel[]\n\n}\n","\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ImagePixel } from \"../model/ImagePixel.js\";\nimport {Point} from \"../model/Point.js\";\nimport {AbstractProjection} from \"./AbstractProjection.js\";\n\n\nexport class HEALPixProjection extends AbstractProjection {\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeader {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    public computeSquaredNaxes(d: number, ps: number): void {\n        throw new Error('Method not implemented.');\n    }\n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n    \n\n}","\"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { AbstractProjection } from './AbstractProjection.js';\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\nimport { ParseUtils } from 'jsfitsio';\nimport {Point} from '../model/Point.js';\n\n\nexport class GnomonicProjection extends AbstractProjection {\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n\n    _minra: number;\n    _mindec: number;\n    _naxis1: number;\n    _naxis2: number;\n    _pxsize: number;\n    _pxmatrix;\n    _fitsheader: FITSHeader[];\n    _inflie: string;\n    _ctype1: string; // TODO should be RA ENUM\n    _ctype2: string; // TODO should be Dec ENUM\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n\n    constructor(infile?: string) {\n        super();\n        this._ctype1 = \"RA---TAN\";\n        this._ctype2 = \"DEC--TAN\";\n\n        if (infile) {\n            this._inflie = infile;\n        }\n    }\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n\n        let fp = new FITSParser(infile);\n\n        let promise = fp.loadFITS().then(fits => {\n\n            // console.log(fits.header);\n            this._pxvalues.set(0, fits.data);\n            this._fitsheader[0] = fits.header;\n            this._naxis1 = fits.header.get(\"NAXIS1\");\n            this._naxis2 = fits.header.get(\"NAXIS2\");\n            this._craDeg = fits.header.getItemListOf(\"CRVAL1\")[0].value;\n            this._cdecDeg = fits.header.getItemListOf(\"CRVAL2\")[0].value;\n\n            // TODO CDELT could not be present. In this is the case, \n            // there should be CDi_ja, but I am not handling them atm\n            // [Ref. Representation of celestial coordinates in FITS - equation (1)]\n            this._pxsize1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0].value;\n            this._pxsize2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0].value;\n\n            this._minra = this._craDeg - this._pxsize1 * this._naxis1 / 2;\n            if (this._minra < 0) {\n                this._minra += 360;\n            }\n            this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n\n            return fits;\n\n        });\n        await promise;\n        return promise;\n    }\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        let bzero = fits.header.get(\"BZERO\");\n        let bscale = fits.header.get(\"BSCALE\");\n        let naxis1 = fits.header.get(\"NAXIS1\");\n        let naxis2 = fits.header.get(\"NAXIS2\");\n        let bitpix = fits.header.get(\"BITPIX\");\n        let bytesXelem = Math.abs(bitpix / 8);\n        let blankBytes = ParseUtils.convertBlankToBytes(fits.header.get(\"BLANK\"), bytesXelem); // TODO => ??????? Im not using it. it should be used!\n        // let physicalvalues = new Array[naxis2][naxis1];\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                let pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                let physicalVal = bzero + bscale * pixval;\n                physicalvalues[n2][n1] = physicalVal;\n            }\n        }\n        return physicalvalues;\n\n\n    }\n\n    prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n\n        this._fitsheader[0] = new FITSHeader();\n\n\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"BITPIX\", fitsHeaderParams.get(\"BITPIX\")));\n        this._fitsheader[0].addItemAtTheBeginning(new FITSHeaderItem(\"SIMPLE\", fitsHeaderParams.get(\"SIMPLE\")));\n\n        if (fitsHeaderParams.get(\"BLANK\") !== undefined) {\n            this._fitsheader[0].addItem(new FITSHeaderItem(\"BLANK\", fitsHeaderParams.get(\"BLANK\")));\n        }\n\n        let bscale = 1.0;\n        if (fitsHeaderParams.get(\"BSCALE\") !== undefined) {\n            bscale = fitsHeaderParams.get(\"BSCALE\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BSCALE\", bscale));\n\n        let bzero = 0.0;\n        if (fitsHeaderParams.get(\"BZERO\") !== undefined) {\n            bzero = fitsHeaderParams.get(\"BZERO\");\n        }\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"BZERO\", bzero));\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS\", 2));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS1\", this._naxis1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"NAXIS2\", this._naxis2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE1\", this._ctype1));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CTYPE2\", this._ctype2));\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT1\", this._pxsize)); // ??? Pixel spacing along axis 1 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CDELT2\", this._pxsize)); // ??? Pixel spacing along axis 2 ???\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX1\", this._naxis1 / 2)); // central/reference pixel i along naxis1\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRPIX2\", this._naxis2 / 2)); // central/reference pixel j along naxis2\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL1\", this._craDeg)); // central/reference pixel RA\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"CRVAL2\", this._cdecDeg)); // central/reference pixel Dec\n\n        let min = bzero + bscale * this._minphysicalval;\n        let max = bzero + bscale * this._maxphysicalval;\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMIN\", min)); // min data value\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"DATAMAX\", max)); // max data value\n\n\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"ORIGIN\", \"WCSLight v.0.x\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"COMMENT\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"));\n        this._fitsheader[0].addItem(new FITSHeaderItem(\"END\"));\n\n        return this._fitsheader;\n\n    }\n\n    getFITSHeader(): FITSHeader[] {\n        return this._fitsheader;\n    }\n\n    getCommonFitsHeaderParams(): FITSHeader {\n        let header = new FITSHeader();\n        for (const [key, value] of this._fitsheader[0]) {\n            // I could add a list of used NPIXs to be included in the comment of the output FITS\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n\n                // header.set(key, value);\n                header.addItem(new FITSHeaderItem(key, value));\n\n            }\n        }\n        return header;\n    }\n\n    async getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n\n        let promise = new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                let bytesXelem = Math.abs(this._fitsheader[0].get(\"BITPIX\") / 8);\n                let blankBytes = ParseUtils.convertBlankToBytes(this._fitsheader[0].get(\"BLANK\"), bytesXelem);\n                let pixcount = inputPixelsList.length;\n\n                let values = new Uint8Array(pixcount * bytesXelem);\n\n                for (let p = 0; p < pixcount; p++) {\n\n                    let imgpx = inputPixelsList[p];\n                    // TODO check when input is undefined. atm it puts 0 bur it should be BLANK\n                    // TODO why I am getting negative i and j? check world2pix!!!\n                    if ((imgpx._j) < 0 || (imgpx._j) >= this._naxis2 ||\n                        (imgpx._i) < 0 || (imgpx._i) >= this._naxis1) {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = blankBytes[b];\n                        }\n                    } else {\n                        for (let b = 0; b < bytesXelem; b++) {\n                            values[p * bytesXelem + b] = (this._pxvalues.get(0))[imgpx._j][(imgpx._i) * bytesXelem + b];\n                        }\n\n                    }\n                }\n                resolve(values);\n            } catch (err) {\n                reject(\"[MercatorProjection] ERROR: \" + err);\n            }\n\n        });\n        return promise;\n\n    }\n\n    computeSquaredNaxes(d: number, ps: number): void {\n        // first aprroximation to be checked\n        this._naxis1 = Math.ceil(d / ps);\n        this._naxis2 = this._naxis1;\n        this._pxsize = ps;\n    }\n\n    setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Array<Uint8Array>> {\n        // let bytesXelem = Math.abs(fitsHeaderParams.get(\"BITPIX\") / 8);\n        // let minpixb = ParseUtils.extractPixelValue(0, values.slice(0, bytesXelem), fitsHeaderParams.get(\"BITPIX\"));\n        // let maxpixb = minpixb;\n\n        // let bscale = (fitsHeaderParams.get(\"BSCALE\") !== undefined) ? fitsHeaderParams.get(\"BSCALE\") : 1.0;\n        // let bzero = (fitsHeaderParams.get(\"BZERO\") !== undefined) ? fitsHeaderParams.get(\"BZERO\") : 0.0;\n\n        // this._minphysicalval = bzero + bscale * minpixb;\n        // this._maxphysicalval = bzero + bscale * maxpixb;\n        // this._pxvalues = new Array(this._naxis2);\n        // for (let r = 0; r < this._naxis2; r++) {\n        //     this._pxvalues[r] = new Uint8Array(this._naxis1 * bytesXelem);\n        // }\n\n        // TODO ...\n        return null;\n    }\n\n    getImageRADecList(center: Point, radius: number, pxsize: number): Array<[number, number]>{\n\n        // let promise = new Promise((resolve, reject) => {\n        //     this.computeSquaredNaxes(2 * radius, pxsize); // compute naxis[1, 2]\n\n        //     this._pxsize = pxsize;\n        //     this._minra = center.ra - radius;\n        //     if (this._minra < 0) {\n        //         this._minra += 360;\n        //     }\n        //     this._mindec = center.dec - radius;\n\n        //     let radeclist = [];\n        //     let pra, pdec;\n\n        // TODO ...\n        /*\n        basing on naxis1 and naxis2 call pix2world!!!\n        */\n\n\n\n        /*\n        \n\n        mindec = center.dec - radius;\n        maxdec = center.dec + radius;\n        below pixel size should  depend on the distance from the center\n        let l =  0;\n        let factor = 1;\n        \n        for (let d = mindec; d < maxdec; d+=pxsize) { <--ERROR the external loop must be over RA\n            factor = 1 + 2**l;\n            rapxsize = pxsize/factor;\n            for (let r = 0; r < 360; r+=rapxsize) {\n                radeclist.push(r, d); \n            }\n            l++;\n        }\n        */\n\n\n\n\n\n        // let cidx = (this._naxis2 / 2 - 1) * this._naxis1 + this._naxis1 / 2;\n        // this._cra = radeclist[cidx][0];\n        // this._cdec = radeclist[cidx][1];\n\n        // resolve(radeclist);\n        // });\n        // return promise;\n        return null;\n\n    }\n\n    pix2world(i: number, j: number): Point {\n\n        // TODO ...\n        let x, y;\n        let CDELT1 = this._fitsheader[0].getItemListOf(\"CDELT1\")[0];\n        let CDELT2 = this._fitsheader[0].getItemListOf(\"CDELT2\")[0];\n        let PC1_1 = this._fitsheader[0].getItemListOf(\"PC1_1\")[0];\n        let PC1_2 = this._fitsheader[0].getItemListOf(\"PC1_2\")[0];\n        let PC2_1 = this._fitsheader[0].getItemListOf(\"PC2_1\")[0];\n        let PC2_2 = this._fitsheader[0].getItemListOf(\"PC2_2\")[0];\n\n        let CD1_1 = this._fitsheader[0].getItemListOf(\"CD1_1\")[0];\n        let CD1_2 = this._fitsheader[0].getItemListOf(\"CD1_2\")[0];\n        let CD2_1 = this._fitsheader[0].getItemListOf(\"CD2_1\")[0];\n        let CD2_2 = this._fitsheader[0].getItemListOf(\"CD2_2\")[0];\n\n        let CRPIX1 = this._fitsheader[0].getItemListOf(\"CRPIX1\")[0];\n        let CRPIX2 = this._fitsheader[0].getItemListOf(\"CRPIX2\")[0];\n\n\n        if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            PC1_1 !== undefined && PC1_2 !== undefined &&\n            PC2_1 !== undefined && PC2_2 !== undefined\n        ) { // if CDELTia and PCi_ja notation\n            x = CDELT1 * (PC1_1 * (i - CRPIX1) + PC1_2 * (j - CRPIX2));\n            y = CDELT2 * (PC2_1 * (i - CRPIX1) + PC2_2 * (j - CRPIX2));\n        } else { // else CDi_ja notation\n            x = CD1_1 * (i - CRPIX1) + CD1_2 * (j - CRPIX2);\n            y = CD2_1 * (i - CRPIX1) + CD2_2 * (j - CRPIX2);\n        }\n\n\n\n\n        // let phi = math.arg(-y / x);\n        // let R_theta = Math.sqrt(x * x + y * y);\n        // let theta = Math.atan2(180 / (Math.PI * R_theta));\n\n        // let ra, dec;\n        // ra = phi;\n        // dec = theta;\n        // // TODO check if phi, theta match with ra, dec or they need to be (linearly) converted \n\n        // return [ra, dec];\n\n        return null;\n    }\n\n    world2pix(radeclist: number[][]): ImagePixel[] {\n\n        let imgpxlist: ImagePixel[] = [];\n\n        let CDELT1 = (this._fitsheader[0].getItemListOf(\"CDELT1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT1\")[0] : undefined;\n        let CDELT2 = (this._fitsheader[0].getItemListOf(\"CDELT2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CDELT2\")[0] : undefined;\n        let PC1_1 = (this._fitsheader[0].getItemListOf(\"PC1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_1\")[0] : undefined;\n        let PC1_2 = (this._fitsheader[0].getItemListOf(\"PC1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC1_2\")[0] : undefined;\n        let PC2_1 = (this._fitsheader[0].getItemListOf(\"PC2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_1\")[0] : undefined;\n        let PC2_2 = (this._fitsheader[0].getItemListOf(\"PC2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"PC2_2\")[0] : undefined;\n\n        let CD1_1 = (this._fitsheader[0].getItemListOf(\"CD1_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_1\")[0] : undefined;\n        let CD1_2 = (this._fitsheader[0].getItemListOf(\"CD1_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD1_2\")[0] : undefined;\n        let CD2_1 = (this._fitsheader[0].getItemListOf(\"CD2_1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_1\")[0] : undefined;\n        let CD2_2 = (this._fitsheader[0].getItemListOf(\"CD2_2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CD2_2\")[0] : undefined;\n\n        let CRPIX1 = (this._fitsheader[0].getItemListOf(\"CRPIX1\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX1\")[0] : undefined;\n        let CRPIX2 = (this._fitsheader[0].getItemListOf(\"CRPIX2\").length > 0) ? this._fitsheader[0].getItemListOf(\"CRPIX2\")[0] : undefined;\n\n        radeclist.forEach(([ra, dec]) => {\n\n            // TODO ...\n            // let i, j;\n            // // (linearly) convert ra, dec into phi, theta\n            // let theta = dec;\n            // let phi = ra;\n            // let R_theta = (180 / Math.PI) * math.cot(theta);\n            // let x = R_theta * Math.sin(phi);\n            // let y = - R_theta * Math.cos(phi);\n            // if (CDELT1 !== undefined && CDELT2 !== undefined &&\n            //     PC1_1 !== undefined && PC1_2 !== undefined &&\n            //     PC2_1 !== undefined && PC2_2 !== undefined\n            // ) { // if CDELTia and PCi_ja notation\n            //     j = y * CDELT1 * PC1_1 / (CDELT1 * CDELT2 * (PC1_1 * PC2_2 - PC2_1 * PC1_2)) + PC1_1 * CRPIX2 * (PC2_2 - PC2_1) / (PC1_1 * PC2_2 - PC2_1 * PC1_2);\n            //     i = x / (CDELT1 * PC1_1) + CRPIX1 - j * PC1_2 / PC1_1 + CRPIX2 * PC1_2 / PC1_1;\n            // } else { // else CDi_ja notation\n            //     j = y * CD1_1 / (CD1_1 * CD2_2 - CD1_2 * CD2_1) + CRPIX2 * CD1_1 * (CD2_2 - CD2_1) / (CD1_1 * CD2_2 - CD1_2 * CD2_1);\n            //     i = (x + CD1_1 * CRPIX1 - CD1_2 * j + CD1_2 * CRPIX2) / CD1_1;\n            // }\n            // imgpxlist.push(new ImagePixel(i, j));\n\n        });\n        return imgpxlist;\n\n    }\n\n    // getCanvas2d(tfunction = \"linear\", colormap = \"grayscale\", inverse = false) {\n\n    //     let canvas2d = new Canvas2D(this._pxvalues, this._fitsheader, this, tfunction, colormap, inverse);\n    //     return canvas2d;\n    // }\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nimport { FITSParser } from 'jsfitsio';\nimport { MercatorProjection } from './projections/MercatorProjection.js';\nimport { HiPSProjection } from './projections/HiPSProjection.js';\nimport { Point } from './model/Point.js';\nimport { AbstractProjection } from './projections/AbstractProjection.js';\nimport { CutoutResult } from './model/CutoutResult.js';\n\nimport { HEALPixProjection } from './projections/HEALPixProjection.js';\nimport { GnomonicProjection } from './projections/GnomonicProjection.js';\n\nexport class WCSLight {\n\n    /** @constructs WCSLight */\n    constructor() { }\n\n    static async cutout(center: Point, radius: number,\n        pxsize: number, inproj: AbstractProjection, outproj: AbstractProjection): Promise<CutoutResult> {\n\n        const outRADecList: Array<Array<number>> = outproj.getImageRADecList(center, radius, pxsize);\n        if (outRADecList.length == 0) {\n            const res: CutoutResult = {\n                fitsheader: null,\n                fitsdata: null,\n                inproj: inproj,\n                outproj: outproj,\n                fitsused: inproj.fitsUsed\n            };\n            return res;\n        }\n        const inputPixelsList = inproj.world2pix(outRADecList);\n        try {\n\n            const invalues = await inproj.getPixValues(inputPixelsList);\n            const fitsHeaderParams = inproj.getCommonFitsHeaderParams();\n            if (invalues !== undefined) {\n                const fitsdata = outproj.setPxsValue(invalues, fitsHeaderParams);\n                const fitsheader = outproj.getFITSHeader();\n                // let canvas2d = outproj.getCanvas2d();\n                const res: CutoutResult = {\n                    fitsheader: fitsheader,\n                    fitsdata: fitsdata,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            } else {\n                const res: CutoutResult = {\n                    fitsheader: null,\n                    fitsdata: null,\n                    inproj: inproj,\n                    outproj: outproj,\n                    fitsused: inproj.fitsUsed\n                };\n                return res;\n            }\n\n        } catch (err) {\n            console.error(\"[WCSLight] ERROR: \" + err);\n            return null;\n        }\n\n    }\n\n    /**\n     * \n     * @param {*} fitsheader \n     * @param {*} fitsdata \n     * @returns {URL}\n     */\n    static generateFITS(fitsheader: any, fitsdata: any): string {\n        const blobUrl = FITSParser.generateFITS(fitsheader, fitsdata);\n        return blobUrl;\n    }\n\n\n\n\n    static changeProjection(filepath, outprojname) {\n        // TODO\n    }\n\n\n    static getProjection(projectionName: string) {\n        if (projectionName === \"Mercator\") {\n            return new MercatorProjection();\n        } else if (projectionName === \"HiPS\") {\n            return new HiPSProjection();\n        } else if (projectionName === \"HEALPix\") {\n            return new HEALPixProjection();\n        } else if (projectionName === \"Gnomonic\") {\n            return new GnomonicProjection();\n        } else {\n            return null;\n            // throw new ProjectionNotFound(projectionName);\n        }\n    }\n\n    static getAvaillableProjections() {\n        return [\"Mercator\", \"HiPS\", \"HEALPix\"];\n    }\n\n}\n\n","\n\n\n// import { FITSParser } from 'fitsparser/FITSParser-node';\n// import { FITSHeader } from 'fitsparser/model/FITSHeader';\n// import { FITSHeaderItem } from 'fitsparser/model/FITSHeaderItem';\n// import { FITSParsed } from 'fitsparser/model/FITSParsed';\n\n\nimport { FITSParser } from 'jsfitsio';\nimport { FITSHeader } from 'jsfitsio';\nimport { FITSHeaderItem } from 'jsfitsio';\nimport { FITSParsed } from 'jsfitsio';\n\nimport { ImagePixel } from '../model/ImagePixel.js';\nimport { AbstractProjection } from './AbstractProjection.js';\nimport {Point} from '../model/Point.js';\n\nexport class TestProj implements AbstractProjection{\n    \n    _minra: number;\n    _mindec: number;\n    _naxis1: number;\n    _naxis2: number;\n    _pxsize: number;\n    _fitsheader: FITSHeader[];\n    _infile: string;\n    _ctype1: string; // TODO should be RA ENUM\n    _ctype2: string; // TODO should be Dec ENUM\n    _craDeg: number;\n    _cdecDeg: number;\n    _pxsize1: number;\n    _pxsize2: number;\n    _pxvalues: Map<number, Array<Uint8Array>>;\n    _minphysicalval: number;\n    _maxphysicalval: number;\n    _wcsname: string;\n    constructor() {\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this._ctype1 = \"RA---MER\";\n        this._ctype2 = \"DEC--MER\";\n        this._pxvalues = new Map<number, Array<Uint8Array>>();\n        const fh = new FITSHeader();\n        const fp = new FITSParser(\"./notexistent/\");\n        const fhi = new FITSHeaderItem(\"mykey\", \"myvalue\", \"mycomment\");\n\n\n    }\n    public get fitsUsed(): String[] {\n        throw new Error('Method not implemented.');\n    }\n    \n    public initFromFile(fitsfilepath?: string, hipsURI?: string, pxsize?: number, order?: number): Promise<FITSParsed> {\n        throw new Error('Method not implemented.');\n    }\n    public prepareFITSHeader(fitsHeaderParams: FITSHeader): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getFITSHeader(): FITSHeader[] {\n        throw new Error('Method not implemented.');\n    }\n    public getCommonFitsHeaderParams(): FITSHeader {\n        throw new Error('Method not implemented.');\n    }\n    public extractPhysicalValues(fits: FITSParsed): number[][] {\n        throw new Error('Method not implemented.');\n    }\n    public getPixValues(inputPixelsList: ImagePixel[]): Promise<Uint8Array> {\n        throw new Error('Method not implemented.');\n    }\n    public computeSquaredNaxes(d: number, ps: number): void {\n        throw new Error('Method not implemented.');\n    }\n    public setPxsValue(values: Uint8Array, fitsHeaderParams: FITSHeader): Map<number, Uint8Array[]> {\n        throw new Error('Method not implemented.');\n    }\n    public getImageRADecList(center: Point, radius: number, pxsize: number):  Array<[number, number]> {\n        throw new Error('Method not implemented.');\n    }\n    public pix2world(i: number, j: number): Point {\n        throw new Error('Method not implemented.');\n    }\n    public world2pix(radeclist: number[][]): ImagePixel[] {\n        throw new Error('Method not implemented.');\n    }\n}"],"names":["root","factory","exports","module","define","amd","self","inProgress","dataWebpackPrefix","global","window","g","this","BlobBuilder","WebKitBlobBuilder","MSBlobBuilder","MozBlobBuilder","URL","webkitURL","href","a","document","createElement","origBlob","Blob","createObjectURL","revokeObjectURL","strTag","Symbol","toStringTag","blobSupported","blobSupportsArrayBufferView","blobBuilderSupported","prototype","append","getBlob","size","Uint8Array","e","mapArrayBufferViews","ary","map","chunk","buffer","ArrayBuffer","buf","byteLength","copy","set","byteOffset","BlobBuilderConstructor","options","bb","forEach","part","type","BlobConstructor","textEncode","TextEncoder","encode","bind","string","pos","len","length","Arr","Array","at","tlen","Math","max","target","value","charCodeAt","extra","update","slice","textDecode","TextDecoder","decode","end","res","i","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","push","str","j","String","fromCharCode","apply","fixFileAndXHR","isIE","ActiveXObject","documentElement","style","_send","XMLHttpRequest","send","data","setRequestHeader","call","File","FileReader","Function","b","d","c","blob","t","lastModified","Date","name","replace","lastModifiedDate","toString","bufferClone","view","array","array2base64","input","byteToCharMap","output","byte1","haveByte2","byte2","haveByte3","byte3","outByte1","outByte2","outByte3","outByte4","join","create","Object","getObjectTypeName","o","isPrototypeOf","arrayBufferClassNames","isArrayBuffer","v","indexOf","chunks","opts","_buffer","DataView","offset","concatTypedarrays","concat","test","toLowerCase","arrayBuffer","Promise","resolve","text","start","constructor","setPrototypeOf","__proto__","TypeError","delegate","createDocumentFragment","addEventListener","dispatchEvent","evt","local","removeEventListener","_read","fr","kind","result","setTimeout","readyState","LOADING","Event","EMPTY","DONE","error","onabort","onerror","onload","onloadend","onloadstart","onprogress","readAsDataURL","readAsText","readAsArrayBuffer","abort","url","FakeBlobBuilder","stream","ReadableStream","position","autoAllocateChunkSize","pull","controller","byobRequest","then","uint8array","bytesRead","respond","close","enqueue","Response","body","getReader","read","Error","promisify","obj","reject","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","m","definition","key","defineProperty","enumerable","get","f","chunkId","all","keys","reduce","promises","u","globalThis","prop","hasOwnProperty","l","done","script","needAttach","scripts","getElementsByTagName","s","getAttribute","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","event","clearTimeout","doneFns","parentNode","removeChild","fn","head","appendChild","r","scriptUrl","importScripts","location","currentScript","p","installedChunks","installedChunkData","promise","errorType","realSrc","message","request","webpackJsonpCallback","parentChunkLoadingFunction","chunkIds","moreModules","runtime","some","id","chunkLoadingGlobal","FITSHeaderItem","comment","_key","_value","_comment","FITSHeader","Map","super","_offset","_items","getItemList","getItemListOf","item","addItemAtTheBeginning","includes","newitemlist","addItem","getNumRows","ParseUtils","static","chars","n","substr","byte4","long","pow","blank","nbytes","abs","uint8","parseInt","bytes","ebits","fbits","bits","byte","reverse","bias","substring","Infinity","val","unsigned","bitpix","px_val","parse16bit2sComplement","parse32bit2sComplement","parseFloatingPointFormat","FITSWriter","_headerArray","_payloadArray","_fitsData","run","header","rawdata","prepareHeader","prepareFITS","headerDetails","formatHeaderLine","strBytelen","ceil","ab","getByteAt","keyword","typedArrayToURL","ParsePayload","fitsheader","_u8data","_BZERO","_BSCALE","_BLANK","_BITPIX","_NAXIS1","_NAXIS2","_DATAMIN","_DATAMAX","_physicalblank","init","min","computePhysicalMinAndMax","maxitem","minitem","bytesXelem","pxLength","ph_val","pixel2physicalValue","extractPixelValue","parse","k","pixelvalues","floor","pxval","ParseHeader","textDecoder","u8line","u8key","u8val","u8ind","fitsLine","nline","trim","firstchar","Number","parseLogicalValue","parseFloatValue","parseIntValue","now","u8buffer","decoded","idx","lastIndexOf","tokens","split","parseFloat","NumberType","CoordsType","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","FITSParser","_url","loadFITS","getFile","processFits","catch","_a","_b","response","writer","uri","err","getLocalFile","ImagePixel","tileno","_i","_j","_tileno","geti","getj","cartesianToSpherical","xyz","dotXYZ","x","y","z","sqrt","thetaRad","acos","thetaDeg","radToDeg","phiRad","atan2","phiDeg","sphericalToAstro","phiTheta","raDeg","decDeg","degToRad","astroToSpherical","raDec","sphericalToCartesian","sin","cos","fillAstro","ra","dec","unit","DEGREES","RADIANS","console","fillSpherical","phi","theta","degrees","PI","radians","Point","in_type","coords","CARTESIAN","toFixed","MAX_DECIMALS","ASTRO","SPHERICAL","spherical","astro","cartesian","MercatorProjection","_wcsname","_ctype1","_ctype2","_pxvalues","_fitsheader","initFromFile","infile","fp","_infile","_fitsUsed","fits","_naxis1","_naxis2","_craDeg","_cdecDeg","pxsize1","pxsize2","_pxsize","_minra","_mindec","extractPhysicalValues","bzero","bscale","naxis1","naxis2","physicalvalues","convertBlankToBytes","n2","n1","physicalVal","prepareFITSHeader","fitsHeaderParams","_minphysicalval","_maxphysicalval","getFITSHeader","getCommonFitsHeaderParams","fitsUsed","getPixValues","inputPixelsList","blankBytes","pixcount","values","imgpx","pv","computeSquaredNaxes","ps","setPxsValue","minpixb","maxpixb","valphysical","isNaN","log","getImageRADecList","center","radius","pxsize","radeclist","cidx","pix2world","world2pix","imgpxlist","radecItem","Constants","halfpi","inv_halfpi","twopi","inv_twopi","Zphi","z_","phi_","Hploc","ptg","PI4_A","PI4_B","PI4_C","M_1_PI","sth","have_sth","_phi","setZ","setSth","toVec3","st","Vec3","toZphi","q","sincoshelper","mulsign","atan2k","copySign","magnitude","sign","atanhelper","isinf","isnan","NaN","Pointing","vec3","mirror","in_theta","in_phi","in_x","in_y","in_z","getX","getY","getZ","scale","cross","add","normalize","norm","lengthSquared","dot","v1","sub","angle","flip","pointing","CircleFinder","point","np","cosrad","getCircle","getCircle2","q1","q2","getCenter","getCosrad","Fxyf","fx","fy","face","jrll","jpll","toHploc","nr","loc","jr","tmp","pstack","sz","Int32Array","p_","o_","pop","popToMark","mark","otop","ptop","RangeSet","cap","append1","newsize","rnew","ensureCapacity","resize","sliced","Xyf","ix","iy","Healpix","nside_in","order_max","twothird","ns_max","ctab","Uint16Array","utab","Int16Array","xoffset","yoffset","facearray","swaparray","nside","npface","npix","order","nside2order","nl2","nl3","nl4","fact2","fact1","ncap","bn","mpr","cmpr","smpr","computeBn","maxPixrad","getNPix","getBoundaries","pix","points","xyf","nest2xyf","dc","xc","yc","getBoundariesWithStep","getPointsForXyfNoStep","getPointsForXyf","neighbours","ipix","face_num","nsm1","fpix","px0","spread_bits","py0","pxp","pyp","pxm","pym","nbnum","tint","xyf2nest","log2","compress_bits","loc2pix","hploc","pixNo","za","tt","fmodulo","temp1","temp2","jp","jm","ifp","ifm","ntt","tp","pix2vec","pix2loc","pix2zphi","ang2pix","v2","raw","queryPolygonInclusive","vertex","fact","inclusive","nv","vv","pointing2Vec3","normal","index","back","first","medium","last","hnd","splice","rad","fill","cf","queryMultiDisc","oplus","ilog2","omax","crlimit","dr","Float64Array","stk","zone","crad","iz","check_pixel","arg","clz32","cosdist_zphi","z1","phi1","z2","phi2","pixset","sdist","zphia","xyz1","convertZphi2xyz","va","t1","zphib","xyz2","vb","zphi","queryDiscInclusive","vptg","crpdr","crmdr","sinrad","cdr","sdr","curro","cangdist","HiPSHelper","pxXtile","RES_ORDER_0","round","bbox","hp","xyGridProj","cornersVec3","pointings","coThetaRad","decRad","raRad","xyDeg","world2intermediate","gridPointsDeg","max_y","min_y","max_x","min_x","ac","x_grid","y_grid","THETAX","K","H","w","sigma","phi_c","i_norm","j_norm","xInterval","yInterval","cnaxis1","cnaxis2","yMean","Yx","asin","x_c","DEFAULT_Naxis1_2","HiPSProjection","_isGalactic","_fitsheaderlist","_radeclist","parsePropertiesFile","baseUrl","propFile","txtArr","_HIPS_TILE_WIDTH","line","_HIPS_MAX_ORDER","fitsfilepath","_pixno","_xyGridProj","setupByTile","_hp","initFromHiPSLocationAndPxSize","_hipsBaseURI","computeHiPSOrder","initFromHiPSLocationAndOrder","computePxSize","_norder","_nside","_fh_common","getFITSFiles","destPath","fitsFilesGenerated","tilesset","Set","hipstileno","dir","fitsurl","pixno","fitsheaderlist","prepareCommonHeader","col","row","minmaxmap","nodata","_tileslist","has","rdidx","sc","pixtileno","xy","ij","intermediate2pix","from","crval1","crval2","delete","radiusDeg","radius_rad","rangeset","cpix","minra","maxra","mindec","maxdec","pix2intermediate","intermediate2world","convertToGalactic","finalradeclist","deg2rad","rad2deg","l_NCP","d_NGP","a_NGP","ra_rad","dec_rad","sin_b","b_deg","lNCP_minus_l","atan","l_deg","prevTileno","AbstractProjection","HEALPixProjection","hipsURI","GnomonicProjection","_inflie","_pxsize1","_pxsize2","CDELT1","CDELT2","PC1_1","PC1_2","PC2_1","PC2_2","CD1_1","CD1_2","CD2_1","CD2_2","CRPIX1","CRPIX2","WCSLight","inproj","outproj","outRADecList","fitsdata","fitsused","invalues","generateFITS","filepath","outprojname","projectionName","TestProj"],"sourceRoot":""}