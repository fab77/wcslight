{"version":3,"file":"wcslight.cjs","mappings":";;;;;;AAAA,kBAAkB,mBAAO,CAAC,GAAY;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb,eAAe;AACf,eAAe;AACf,gBAAgB;;AAEhB;AACA,kBAAe;;;;;;;;;ACrBF;;AAEb,eAAe,mBAAO,CAAC,GAAU;AACjC,mBAAmB,mBAAO,CAAC,GAAyB;;AAEpD;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,gDAAgD,4BAA4B;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;;;;;;;;;AChMpB;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,iBAAiB;AACnE,mDAAmD,gBAAgB;;AAEnE,oDAAoD,iBAAiB;AACrE,6DAA6D,gBAAgB;;AAE7E,mDAAmD,iBAAiB;AACpE,4DAA4D,gBAAgB;;AAE5E,wDAAwD,sCAAsC;AAC9F,iEAAiE,qCAAqC;;AAEtG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;AC5La;AACb,YAAY,mBAAO,CAAC,GAAqB;;AAEzC,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,qBAAqB;AACpE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,+CAA+C;AAChF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,uCAAuC;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,2CAA2C;AACtE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,6BAA6B,uCAAuC;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,6CAA6C;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,2CAA2C;AAC1E;;AAEA;AACA;AACA;AACA;;;;;;;;;ACvMa;;AAEb,oBAAoB,mBAAO,CAAC,GAAoB;AAChD,cAAc,mBAAO,CAAC,GAAY;AAClC,aAAa,mBAAO,CAAC,EAAgB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,cAAc,UAAU;AACxB,cAAc;AACd;AACA;;;;;;;;;;AClMa;;AAEb,mDAAwC;AACxC,2DAAkE;AAClE,iEAA8E;AAC9E,4DAAoE;AACpE,6DAAsE;AACtE,6DAAsE;AACtE,4DAAoE;AACpE,+DAA0E;AAC1E,uDAA0D;;;;;;;;;ACV7C;AACb,iBAAiB,mBAAO,CAAC,GAAU;AACnC,aAAa,mBAAO,CAAC,GAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mCAAmC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,8CAA8C;AAC9C;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,+CAA+C,sEAAsE;AACrH;;;;;;;;;AChxCa;;AAEb,oBAAoB;AACpB;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA,4BAA4B;AAC5B,yBAAyB;;AAEzB,6BAA6B;AAC7B;AACA;;AAEA,6BAA6B;AAC7B;AACA;;;;;;;;;;AClBA;;;;;;;;ACAA;;;;;;;;;;;;;ACAgC;AACzB;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,wCAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1B4C;AAC5C;AACA,WAAW,eAAe;AAC1B;AACA;AACO;AACP;AACA;AACA,+BAA+B,0DAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtBA,MAAM,+BAA4B;;ACAlC,MAAM,6BAA4B;;ACAlC,MAAM,4BAA4B;;;;ACAlC,MAAM,8BAA4B;;ACAlC,MAAM,6BAA4B;;ACAN;AACJ;AACF;AACa;AACT;AACF;;AAExB;;AAEA;AACA,iBAAiB,wCAAe;;AAEhC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;;AAEA;AACA,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,oBAAoB,2CAAkB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kFAAkF;AAClF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,yBAAyB,kCAAkC;AAC9D;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,yBAAyB,+BAAM,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,+BAAM;AAC3B;AACA,iHAAiH,UAAU,IAAI,YAAY;AAC3I;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,+EAA+E,YAAY,UAAU,YAAY;AACjH;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,SAAS,kBAAkB;AAC3B,aAAa,kBAAkB;AAC/B,gBAAgB,kBAAkB;AAClC,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAqE,SAAS;AAC9E;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,+BAAM;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,YAAY,QAAQ,eAAe;AACvG,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yEAAyE,WAAW,IAAI,YAAY;AACpG;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,YAAY,cAAc,YAAY;AACnF;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,4EAA4E,WAAW,IAAI,YAAY;AACvG;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,GAAG;AACf,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,+BAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB,GAAG;AACH;AACA,4CAA4C;AAC5C,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,8BAA8B,WAAW,mBAAmB;AAC5D,GAAG,yBAAyB,+BAAM;AAClC;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA,yBAAyB,MAAM;AAC/B;AACA;;AAEA;AACA,YAAY,MAAM;AAClB;AACA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,QAAQ,kBAAkB;AAC1B,YAAY,kBAAkB;AAC9B,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,SAAS,kBAAkB;AAC3B,WAAW,kBAAkB;AAC7B,YAAY;AACZ,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;;AAE9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,0CAAiB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,OAAO,kBAAkB;AACzB,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,YAAY,kBAAkB;AAC9B,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,YAAY,gCAAO,IAAI,cAAa;;AAEpC;AACA,kBAAkB,kCAAS;AAC3B,mBAAmB,mCAAU;;AAE7B;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,+DAAsC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,MAAM;AAClC;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,WAAW,kBAAkB;AAC7B,QAAQ,kBAAkB;AAC1B,YAAY,kBAAkB;AAC9B,aAAa,kBAAkB;AAC/B,UAAU,kBAAkB;AAC5B,WAAW;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,wCAAe;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,gCAAO,IAAI,cAAa;;AAEtC;AACA,sBAAsB,2CAAkB;;AAExC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,8BAAK,GAAG,6BAAI;AAC5D;;AAEA;;AAEA;AACA;AACA;AACA,+CAA+C,wCAAe;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA,uCAAuC,aAAa,kBAAkB,YAAY;;AAElF;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,oFAAoF,SAAS;AAC7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sGAAsG,YAAY;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAiB;AAC5B,iBAAiB,0CAAiB;AAClC;;AAEA;AACA;AACA,qBAAqB,0CAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAkB;AACzC,OAAO;AACP,uBAAuB,8CAAqB;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iCAAiC,oDAA2B;AAC5D,qBAAqB,oDAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAAe,KAAK,EAAC;AACyC;;;;;;;;;;;;;;;UC9uD9D;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA,MAAM,2BAA4B;;ACAlC,YAAY,aAAa;AACA;AAClB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,gDAAgD;AAChD;AACA;AACA,yCAAyC;AACzC;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA,oDAAoD,GAAG,0BAA0B,IAAI;AACrF;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA,4BAA4B,qBAAqB,GAAG;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC,+BAA+B,EAAE;AACjC;AACA;AACA,qDAAqD,IAAI;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC,oDAAoD,EAAE;AACtD;AACA;AACA;AACA;AACA,2CAA2C,aAAa,oCAAoC,kBAAkB,UAAU,OAAO,UAAU,MAAM;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,6CAA6C,0BAA0B;AACvE,iDAAiD,uBAAuB;AACxE;AACA,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAgB;AAC5B,8DAA8D,SAAS;AACvE;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BqD;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C,4BAA4B,cAAc;AAC1C,4BAA4B,cAAc;AAC1C,4BAA4B,cAAc;AAC1C,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA,YAAY,aAAa;AACkC;AACM;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,2BAA2B,iBAAiB;AAC5C,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA,4BAA4B,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACkC;AACM;AAClB;AACF;AACtC;AACP;AACA,uBAAuB,WAAW,0BAA0B,iBAAiB;AAC7E;AACA;AACA;AACA,uBAAuB,WAAW,0BAA0B,iBAAiB;AAC7E;AACA;AACA;AACA,uBAAuB,WAAW,0BAA0B,iBAAiB;AAC7E;AACA;AACA;AACA,wBAAwB,WAAW,0BAA0B,iBAAiB;AAC9E,wBAAwB,WAAW,0BAA0B,iBAAiB;AAC9E;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW,0BAA0B,iBAAiB;AAC7E;AACA;AACA;AACA,sBAAsB,WAAW,0BAA0B,iBAAiB;AAC5E;AACA;AACA;AACA,oBAAoB,WAAW,0BAA0B,iBAAiB;AAC1E;AACA;AACA;AACA,qBAAqB,WAAW,0BAA0B,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;;ACpI6C;AACI;AACF;AACkB;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW,0BAA0B,iBAAiB;AAC7E;AACA;AACA;AACA,uBAAuB,WAAW,0BAA0B,iBAAiB;AAC7E;AACA;AACA;AACA,uBAAuB,WAAW,0BAA0B,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA,4BAA4B,uFAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wFAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AC3GA;;;;;;;GAOG;AAEI,MAAe,kBAAkB;CA6BvC;;;AChDD,IAAY,UAMX;AAND,WAAY,UAAU;IAClB,iDAAO;IACP,iDAAO;IACP,iDAAO;IACP,yCAAG;IACH,yCAAG;AACP,CAAC,EANW,UAAU,KAAV,UAAU,QAMrB;;;ACND;;GAEG;AACH,gCAAgC;AAKa;AAI7C,SAAS,KAAK;AAEd,CAAC;AAEM,SAAS,oBAAoB,CAAC,GAAoB;IACxD,IAAI,MAAM,GAAG,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAC3B,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC1B,IAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAC,CAAC,CAAC,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iBAAM,CAAC;gBACJ,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,WAAW,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC;gBACpF,KAAK,CAAC,QAAQ,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC;YAC7C,CAAC;YACD,SAAS,CAAC,cAAc,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;QAC9C,CAAC;QACD,OAAO,SAAS,CAAC;IAErB,CAAC;CAEJ;;;AC7VM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRiC;AACA;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA,mBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/LmC;AAC5B;AACP;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA,4BAA4B,KAAK;AACjC;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACmC;AACM;AAClC;AACP;AACA,4BAA4B,QAAQ;AACpC;AACA,sBAAsB,KAAK;AAC3B,2BAA2B,KAAK;AAChC,2BAA2B,KAAK;AAChC,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK;AACvB,sBAAsB,KAAK;AAC3B,sBAAsB,KAAK;AAC3B,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;ACpHiC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACmC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;ACVa;AACoC;AACN;AACV;AACE;AACM;AACJ;AACI;AACR;AACF;AACE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,2BAA2B,KAAK;AAChC,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,4BAA4B,IAAI;AAChC,mCAAmC,IAAI;AACvC,uCAAuC,IAAI;AAC3C,uCAAuC,IAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,GAAG;AACzB;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,sBAAsB,GAAG;AACzB;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,mCAAmC;AACnC;AACA;AACA,gDAAgD;AAChD,gDAAgD;AAChD,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,mDAAmD;AACnD;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,8CAA8C,SAAS,oCAAoC,SAAS;AACpG;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB,wBAAwB,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB,wBAAwB,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW,OAAO;AACtC;AACA,6CAA6C;AAC7C,wBAAwB,QAAQ;AAChC;AACA,kEAAkE,KAAK;AACvE,8CAA8C,KAAK;AACnD,6DAA6D,KAAK;AAClE;AACA;AACA,sBAAsB,MAAM;AAC5B,wBAAwB,QAAQ,OAAO;AACvC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,eAAe,eAAe;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,kDAAkD;AAClD;AACA;AACA,mBAAmB;AACnB,gCAAgC,OAAO;AACvC,sDAAsD;AACtD;AACA;AACA;AACA,mCAAmC;AACnC,6BAA6B;AAC7B,+DAA+D;AAC/D,iCAAiC;AACjC;AACA,mBAAmB;AACnB,gCAAgC;AAChC,oCAAoC,OAAO,OAAO;AAClD,0DAA0D;AAC1D;AACA;AACA,uBAAuB;AACvB,mEAAmE;AACnE,qCAAqC;AACrC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,kCAAkC;AAClC,yCAAyC;AACzC,gCAAgC;AAChC,oCAAoC,OAAO,OAAO;AAClD,0DAA0D;AAC1D;AACA;AACA,uBAAuB;AACvB,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA,qBAAqB,IAAI;AACzB;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA,SAAS,iBAAiB,wBAAwB,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,mBAAmB,IAAI;AACvB;AACA;AACA,qBAAqB,KAAK;AAC1B,qBAAqB,KAAK;AAC1B,wBAAwB,WAAW,OAAO;AAC1C,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B,wBAAwB,QAAQ,OAAO;AACvC;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7vB2C;AACN;AACY;AAChB;AACM;AACE;AACA;AACR;AACF;AACE;AACE;AACnC;;ACXA,yBAAyB;AAC4B;AAGE;AACA;AACV;AACG;AAGzC,MAAM,oBAAoB;IAE7B,MAAM,CAAC,WAAW,GAAW,IAAI,CAAC;IAClC,MAAM,CAAC,CAAC,GAAW,CAAC,CAAC;IACrB,MAAM,CAAC,CAAC,GAAW,CAAC,CAAC;IACrB,MAAM,CAAC,MAAM,GAAW,KAAK,CAAC,IAAI,CAAC,CAAC,oBAAoB,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;IAG1F,oEAAoE;IAEpE,yCAAyC;IACzC,wBAAwB;IACxB,wBAAwB;IACxB,wBAAwB;IACxB,wBAAwB;IACxB,8BAA8B;IAC9B,QAAQ;IAGR,6DAA6D;IAC7D,0BAA0B;IAE1B,qDAAqD;IACrD,uDAAuD;IACvD,wBAAwB;IACxB,4CAA4C;IAC5C,wCAAwC;IACxC,+EAA+E;IAC/E,+CAA+C;IAC/C,iEAAiE;IACjE,2DAA2D;IAC3D,2BAA2B;IAC3B,uDAAuD;IACvD,oBAAoB;IACpB,gBAAgB;IAChB,YAAY;IACZ,QAAQ;IAER,mDAAmD;IACnD,+CAA+C;IAC/C,0EAA0E;IAC1E,yDAAyD;IACzD,iDAAiD;IAEjD,wCAAwC;IAExC,wCAAwC;IACxC,qFAAqF;IACrF,gFAAgF;IAChF,uEAAuE;IACvE,oCAAoC;IACpC,6CAA6C;IAC7C,+CAA+C;IAC/C,4BAA4B;IAC5B,gGAAgG;IAEhG,kDAAkD;IAClD,sDAAsD;IAEtD,oEAAoE;IACpE,uCAAuC;IACvC,YAAY;IACZ,oEAAoE;IACpE,uCAAuC;IACvC,YAAY;IACZ,oEAAoE;IACpE,uCAAuC;IACvC,YAAY;IACZ,oEAAoE;IACpE,uCAAuC;IACvC,YAAY;IAEZ,QAAQ;IACR,yBAAyB;IACzB,IAAI;IACJ,MAAM,CAAC,WAAW,CAAC,MAAc,EAAE,EAAW;QAC1C,MAAM,EAAE,GAAmB,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,aAAa,EAAE,EAAE,EAAE,CAAC;QAEjG,MAAM,OAAO,GAAG,EAAE,CAAC,qBAAqB,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QACpD,MAAM,GAAG,GAAe,EAAE,CAAC;QAE3B,qCAAqC;QACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACtC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;YAClC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;gBACT,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;gBACzC,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,EAAE,EAAE,CAAC;oBAC5B,IAAI,CAAC,GAAG,CAAC;wBAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;;wBACpC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;gBACnC,CAAC;YACL,CAAC;QACL,CAAC;QAED,mEAAmE;QACnE,MAAM,EAAE,GAAa,EAAE,CAAC;QACxB,MAAM,EAAE,GAAa,EAAE,CAAC;QACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAClC,MAAM,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;YAC7B,MAAM,MAAM,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,OAAO,CAAC;YACrC,MAAM,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;YACzB,MAAM,EAAE,GAAgB;gBACpB,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,EAAE,KAAK;gBAC7B,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,EAAE,MAAM;aACpB,CAAC;YAEjB,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,oBAAoB,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;YACjE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACd,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAClB,CAAC;QAED,yDAAyD;QACzD,IAAI,IAAI,GAAG,CAAC,QAAQ,EAAE,IAAI,GAAG,CAAC,QAAQ,CAAC;QACvC,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC;YAAC,IAAI,CAAC,GAAG,IAAI;gBAAE,IAAI,GAAG,CAAC,CAAC;YAAC,IAAI,CAAC,GAAG,IAAI;gBAAE,IAAI,GAAG,CAAC,CAAC;QAAC,CAAC;QACvE,MAAM,IAAI,GAAG,GAAG,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC;QAEjC,yEAAyE;QACzE,4CAA4C;QAC5C,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,eAAe;QACjE,IAAI,IAAI,GAAG,CAAC,QAAQ,EAAE,IAAI,GAAG,CAAC,QAAQ,CAAC;QACvC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACjC,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;gBAChC,IAAI,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI;oBAAE,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC/B,IAAI,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI;oBAAE,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;YACnC,CAAC;QACL,CAAC;QAED,mFAAmF;QACnF,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;YACnD,MAAM,KAAK,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;iBAC5C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;YACjE,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,cAAc;YACxE,IAAI,GAAG,CAAC,QAAQ,CAAC;YAAC,IAAI,GAAG,CAAC,QAAQ,CAAC;YACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC5B,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrB,IAAI,CAAC,GAAG,IAAI;oBAAE,IAAI,GAAG,CAAC,CAAC;gBACvB,IAAI,CAAC,GAAG,IAAI;oBAAE,IAAI,GAAG,CAAC,CAAC;YAC3B,CAAC;QACL,CAAC;QAED,wDAAwD;QACxD,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC;QAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC;QACjC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC;QAAC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC;QAEjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACjC,EAAE,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;YAChC,EAAE,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;QACxC,CAAC;QAED,OAAO,EAAE,CAAC;IACd,CAAC;IAGD,gFAAgF;IAChF,sCAAsC;IACtC,2BAA2B;IAC3B,4CAA4C;IAC5C,4BAA4B;IAC5B,mCAAmC;IACnC,0DAA0D;IAC1D,2DAA2D;IAC3D,0BAA0B;IAC1B,QAAQ;IACR,mDAAmD;IACnD,wDAAwD;IACxD,mDAAmD;IACnD,8DAA8D;IAC9D,QAAQ;IACR,kBAAkB;IAClB,IAAI;IAGJ,MAAM,CAAC,kBAAkB,CAAC,EAAe;QACrC,IAAI,MAAM,GAAW,GAAG,CAAC;QACzB,IAAI,MAAM,GAAW,GAAG,CAAC;QAEzB,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,oBAAoB,CAAC,MAAM,EAAE,CAAC,CAAC,mBAAmB;YACzE,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC;YAElB,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,oBAAoB,CAAC,CAAC,GAAG,EAAE,GAAG,oBAAoB,CAAC,CAAC,CAAC;QAGzF,CAAC;aAAM,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC,CAAC,cAAc;YAE1E,IAAI,KAAK,GAAG,EAAE,CAAC,KAAK,CAAC;YAErB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ;YACnB,IAAI,oBAAoB,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC,sBAAsB;gBAC3E,CAAC,GAAG,CAAC,CAAC;YACV,CAAC;YAED,IAAI,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACrF,IAAI,KAAK,GAAG,CAAE,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG,oBAAoB,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;YAE7I,MAAM,GAAG,KAAK,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC;YACzC,MAAM,GAAG,CAAC,GAAG,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,oBAAoB,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;YAEvF,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAChB,MAAM,IAAI,CAAC,CAAC,CAAC;YACjB,CAAC;QACL,CAAC;QAED,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC5B,CAAC;IAED,MAAM,CAAC,gBAAgB,CAAC,CAAS,EAAE,CAAS,EAAE,UAA0B,EAAE,OAAe;QAErF,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;QAChE,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;QAEhE,sBAAsB;QACtB,sBAAsB;QACtB,oFAAoF;QACpF,yDAAyD;QACzD,WAAW;QACX,mDAAmD;QACnD,IAAI;QACJ,+CAA+C;QAG/C,mCAAmC;QACnC,mCAAmC;QAEnC,qFAAqF;QACrF,aAAa;QACb,sDAAsD;QACtD,sDAAsD;QACtD,sDAAsD;QAEtD,+BAA+B;QAC/B,+BAA+B;QAC/B,+BAA+B;QAE/B,oDAAoD;QACpD,IAAI,IAAI,GAAG,CAAC,CAAC;QACb,IAAI,SAAS,GAAG,GAAG,EAAE,CAAC;YAClB,IAAI,UAAU,CAAC,KAAK,GAAG,CAAC,IAAI,IAAI,GAAG,UAAU,CAAC,KAAK;gBAAE,IAAI,IAAI,GAAG,CAAC;YACjE,IAAI,UAAU,CAAC,KAAK,GAAG,GAAG,IAAI,IAAI,GAAG,UAAU,CAAC,KAAK;gBAAE,IAAI,IAAI,GAAG,CAAC;YACnE,IAAI,IAAI,GAAG,UAAU,CAAC,KAAK;gBAAE,IAAI,IAAI,GAAG,CAAC;YACzC,IAAI,IAAI,IAAI,UAAU,CAAC,KAAK;gBAAE,IAAI,IAAI,GAAG,CAAC;QAC9C,CAAC;QAED,MAAM,MAAM,GAAG,CAAC,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC;QACrD,MAAM,MAAM,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC;QAElD,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;QAChC,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,GAAG,GAAG,CAAC;QAEhC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC;QAC5B,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC;QAC5B,OAAO,CAAC,CAAC,EAAE,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAChC,CAAC;IAED,MAAM,CAAC,gBAAgB,CAAC,CAAS,EAAE,CAAS,EAAE,UAA0B,EAAE,MAAc,EAAE,MAAc;QACpG;;;;;;;;;mBASW;QACX,oCAAoC;QACpC,oCAAoC;QAEpC,IAAI,OAAO,GAAG,MAAM,CAAC;QACrB,IAAI,OAAO,GAAG,MAAM,CAAC;QACrB,IAAI,MAAM,EAAE,CAAC;YACT,OAAO,GAAG,MAAM,CAAC;QACrB,CAAC;QACD,IAAI,MAAM,EAAE,CAAC;YACT,OAAO,GAAG,MAAM,CAAC;QACrB,CAAC;QACD,MAAM,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,OAAO,CAAC;QACnC,MAAM,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,OAAO,CAAC;QAEnC,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;QACtE,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;QACtE,MAAM,KAAK,GAAG,CAAC,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;QAE1D,0BAA0B;QAC1B,8DAA8D;QAC9D,MAAM,CAAC,GAAG,UAAU,CAAC,KAAK,GAAG,SAAS,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;QAC3D,MAAM,CAAC,GAAG,KAAK,GAAG,SAAS,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;QAEhD,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAClB,CAAC;IAED,iGAAiG;IACjG,MAAM,CAAC,kBAAkB,CAAC,CAAS,EAAE,CAAS;QAE1C,IAAI,KAAK,GAAW,GAAG;QACvB,IAAI,MAAM,GAAW,GAAG;QACxB,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,oBAAoB,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC,oBAAoB;QAI3F,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,mBAAmB;YACxC,6BAA6B;YAC7B,qCAAqC;YACrC,YAAY;YACZ,6FAA6F;YAC7F,KAAK,GAAG,CAAC,CAAC;YACV,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;YACvE,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAC9C,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAE3C,CAAC;aAAM,CAAC,CAAC,gBAAgB;YACrB,wBAAwB;YACxB,4BAA4B;YAC5B,MAAM,KAAK,GAAG,CAAC,oBAAoB,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,GAAG;YAC7F,8CAA8C;YAC9C,MAAM,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC,aAAa;YACxE,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;YACnC,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAC9C,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAEvC,4EAA4E;YAC5E,qBAAqB;YACrB,iFAAiF;YACjF,YAAY;YACZ,IAAI;YAEJ,sCAAsC;YACtC,MAAM,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAE,0BAA0B;YAC1F,uBAAuB;YACvB,MAAM,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,oBAAoB,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,oBAAoB,CAAC,CAAC,CAAC;YAChI,KAAK,GAAG,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,CAAC,EAAC,wBAAwB;YAC/D,+BAA+B;YAC/B,KAAK,GAAG,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC;YAEpC,8BAA8B;YAC9B,gBAAgB;YAChB,mBAAmB;YACnB,IAAI;QACR,CAAC;QACD,6BAA6B;QAC7B,mBAAmB;QACnB,iFAAiF;QACjF,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,UAAU,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;QAEzE,OAAO,CAAC,CAAC;IACb,CAAC;;;;AChWL;;;;;;;GAOG;AAGiC;AACC;AACH;AAS3B,MAAM,UAAU;IAGtB,sEAAsE;IACtE,MAAM,CAAC,gBAAgB,GAAW,GAAG,CAAC;IACtC,0DAA0D;IAC1D,MAAM,CAAC,WAAW,GAAW,IAAI,CAAC;IAClC,MAAM,CAAC,CAAC,GAAW,CAAC,CAAC;IACrB,MAAM,CAAC,CAAC,GAAW,CAAC,CAAC;IACrB,MAAM,CAAC,MAAM,GAAW,KAAK,CAAC,IAAI,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;IACtE;;;;;OAKG;IACH;;;;OAIG;IACH,qEAAqE;IACrE,OAAO;IACP,wGAAwG;IACxG,qGAAqG;IACrG,uGAAuG;IACvG,WAAW;IACX,OAAO;IACP,sCAAsC;IACtC,OAAO;IACP,qGAAqG;IACrG,2DAA2D;IAC3D,QAAQ;IACR,kCAAkC;IAClC,OAAO;IACP,oGAAoG;IACpG,mCAAmC;IACnC,OAAO;IACP,0CAA0C;IAC1C,mCAAmC;IACnC,oDAAoD;IACpD,2CAA2C;IAC3C,OAAO;IACP,OAAO;IAGP,oEAAoE;IACpE,sEAAsE;IACtE,sBAAsB;IACtB,6CAA6C;IAC7C,8DAA8D;IAC9D,0BAA0B;IAC1B,wBAAwB;IACxB,eAAe;IACf,2BAA2B;IAC3B,uBAAuB;IACvB,SAAS;IACT,aAAa;IAEb,IAAI;IAEJ,sEAAsE;IAEtE,sEAAsE;IACtE,gCAAgC;IAChC,mBAAmB;IAEnB,iBAAiB;IAEjB,IAAI;IAGJ,4FAA4F;IAC5F,MAAM,CAAC,YAAY,CAAC,YAAoB,EAAE,WAAmB;QAC5D,OAAO,CAAC,GAAG,CAAC,qDAAqD,YAAY,aAAa,CAAC;QAC3F,MAAM,OAAO,GAAG,IAAI,CAAC,EAAE,GAAG,GAAG;QAC7B,MAAM,YAAY,GAAG,YAAY,GAAG,OAAO;QAC3C,OAAO,CAAC,GAAG,CAAC,gCAAgC,YAAY,EAAE,CAAC;QAC3D,MAAM,aAAa,GAAG,GAAG,GAAG,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,YAAY,GAAG,YAAY,GAAG,WAAW,GAAG,WAAW,CAAC,CAAE;QACjH,OAAO,CAAC,GAAG,CAAC,SAAS,aAAa,EAAE,CAAC;QACrC,IAAI,aAAa,GAAG,CAAC,EAAE,CAAC;YACvB,OAAO,CAAC;QACT,CAAC;QACD,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC;IACjC,CAAC;IAED,MAAM,CAAC,gBAAgB,CAAC,KAAa;QACpC,MAAM,KAAK,GAAG,CAAC,IAAI,KAAK;QAClB,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,KAAK,CAAC;QACxC,OAAO,OAAO;IACf,CAAC;IAED,MAAM,CAAC,oBAAoB,CAAC,eAAuB,EAAE,UAAkB,EAAE,eAA8B,IAAI;QAC1G,IAAI,YAAY,GAAG,UAAU,CAAC,YAAY,CAAC,eAAe,EAAE,UAAU,CAAC;QACvE,IAAI,YAAY,IAAI,YAAY,GAAG,CAAC,EAAE,CAAC;YACtC,IAAI,YAAY,GAAG,YAAY,EAAE,CAAC;gBACjC,YAAY,GAAG,YAAY;YAC5B,CAAC;QACF,CAAC;QACK,MAAM,KAAK,GAAG,CAAC,IAAI,YAAY;QAC/B,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,KAAK,CAAC;QACxC,OAAO,OAAO;IACf,CAAC;IAED,4FAA4F;IAC5F,MAAM,CAAC,oBAAoB,CAAC,WAAmB,EAAE,KAAa;QAC7D,MAAM,wBAAwB,GAAG,IAAI,CAAC,IAAI,CAAE,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,WAAW,GAAG,CAAC,CAAC,IAAE,KAAK,CAAC,CAAE,IAAE,CAAC,CAAE,CAAE;QAClG,OAAO,CAAC,GAAG,CAAC,qCAAqC,WAAW,qBAAqB,KAAK,EAAE,CAAC;QACzF,MAAM,OAAO,GAAG,GAAG,GAAG,IAAI,CAAC,EAAE;QAC7B,MAAM,GAAG,GAAG,wBAAwB,GAAG,OAAO;QAC9C,MAAM,MAAM,GAAG,wBAAwB,GAAG,OAAO,GAAG,EAAE;QACtD,MAAM,MAAM,GAAG,wBAAwB,GAAG,OAAO,GAAG,IAAI;QACxD,OAAO,CAAC,GAAG,CAAE,wBAAwB,GAAG,wBAAwB,CAAC;QACjE,OAAO,CAAC,GAAG,CAAE,wBAAwB,GAAG,GAAG,CAAC;QAC5C,OAAO,CAAC,GAAG,CAAE,uBAAuB,GAAG,MAAM,CAAC;QAC9C,OAAO,CAAC,GAAG,CAAE,uBAAuB,GAAG,MAAM,CAAC;QAC9C,OAAO;YACN,KAAK,EAAE,wBAAwB;YAC/B,KAAK,EAAE,GAAG;YACV,QAAQ,EAAE,MAAM;YAChB,QAAQ,EAAE,MAAM;SAChB;IACF,CAAC;IAGD;;;;OAIG;IACH,MAAM,CAAC,aAAa,CAAC,KAAa,EAAE,OAAe;QAClD,gBAAgB;QAChB,gEAAgE;QAChE,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC,OAAO,GAAG,CAAC,IAAI,KAAK,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;QACjE,OAAO,MAAM,CAAC;IACf,CAAC;IAED,MAAM;IACN,MAAM;IACN,sDAAsD;IACtD,uDAAuD;IACvD,MAAM;IACN,2CAA2C;IAC3C,0BAA0B;IAC1B,2EAA2E;IAC3E,iEAAiE;IACjE,wEAAwE;IACxE,wBAAwB;IACxB,IAAI;IAEJ,iEAAiE;IACjE,oEAAoE;IACpE,uBAAuB;IACvB,mDAAmD;IACnD,sDAAsD;IACtD,KAAK;IACL,uBAAuB;IACvB,IAAI;IAEJ,6CAA6C;IAC7C,uCAAuC;IACvC,IAAI;IAEJ,yCAAyC;IACzC,mCAAmC;IACnC,IAAI;IAEJ,oEAAoE;IAEpE,uBAAuB;IACvB,yBAAyB;IACzB,mBAAmB;IACnB,oBAAoB;IACpB,mBAAmB;IACnB,KAAK;IAEL,2BAA2B;IAE3B,YAAY;IACZ,iBAAiB;IACjB,oBAAoB;IACpB,MAAM;IACN,IAAI;IAEJ;;;;;OAKG;IACH,MAAM,CAAC,WAAW,CAAC,KAAY,EAAE,CAAS;QAEzC,IAAI,IAAI,GAAG,EAAE,CAAC;QACd,IAAI,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,YAAY,EAAE,CAAC,QAAQ,GAAG,CAAC,EAAE,KAAK,CAAC,YAAY,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QACzG,IAAI,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,YAAY,EAAE,CAAC,QAAQ,GAAG,CAAC,EAAE,KAAK,CAAC,YAAY,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QACzG,IAAI,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,YAAY,EAAE,CAAC,QAAQ,GAAG,CAAC,EAAE,KAAK,CAAC,YAAY,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QACzG,IAAI,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,YAAY,EAAE,CAAC,QAAQ,GAAG,CAAC,EAAE,KAAK,CAAC,YAAY,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAEzG,OAAO,IAAI,CAAC;IACb,CAAC;;;;AC7NK,MAAM,cAAc;IAEvB,MAAM,CAAC,UAAU,GAAU,iBAAiB;IAC5C,MAAM,CAAC,KAAK,GAAU,YAAY;IAClC,MAAM,CAAC,KAAK,GAAU,YAAY;IAClC,MAAM,CAAC,QAAQ,GAAU,UAAU;IACnC,MAAM,CAAC,KAAK,GAAU,kBAAkB;IACxC,MAAM,CAAC,MAAM,GAAU,mBAAmB;IAGlC,OAAO,GAAqB,IAAI,GAAG,EAAe;IAE1D,gBAAc,CAAC;IAEf,OAAO,CAAC,GAAU,EAAE,KAAS;QACzB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC;IAChC,CAAC;IAED,OAAO,CAAC,GAAW;QACf,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC;IAChC,CAAC;IAED,UAAU;QACN,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,QAAQ;IAC5E,CAAC;;;;ACxB2F;AAEhC;AACnB;AAE+B;AACtB;AACT;AACO;AAG7C,MAAM,QAAQ;IAET,OAAO,GAAsB,EAAE;IAC/B,MAAM,CAAoB;IAC1B,MAAM,CAAS;IACf,KAAK,CAAS;IACd,SAAS,CAAS;IAClB,OAAO,CAAU;IACjB,kBAAkB,CAAiB;IACnC,GAAG,GAAW,GAAG;IACjB,GAAG,GAAW,GAAG;IACjB,MAAM,CAAC,MAAM,GAAG,UAAU;IAC1B,MAAM,CAAC,MAAM,GAAG,UAAU;IAC1B,MAAM,CAAC,IAAI,GAAW,MAAM;IAGpC,YAAY,UAA6B,EAAE,MAAqB,EAAE,QAA+B;QAE7F,IAAI,UAAU,EAAE,CAAC;YACb,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC;QACvC,CAAC;aAAM,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC9B,OAAO,CAAC,KAAK,CAAC,oCAAoC,CAAC;YACnD,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC;QACzD,CAAC;aAAM,CAAC;YACJ,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC;YACnD,MAAM,MAAM,GAAG,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC;YAC1D,MAAM,MAAM,GAAG,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC;YAC1D,IAAI,CAAC,MAAM,GAAG,MAAM;YACpB,IAAI,MAAM,IAAI,MAAM,EAAE,CAAC;gBACnB,OAAO,CAAC,KAAK,CAAC,iCAAiC,CAAC;gBAChD,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC;YACtD,CAAC;YACD,IAAI,CAAC,SAAS,GAAG,MAAM;YACvB,IAAI,CAAC,MAAM,GAAG,MAAM;YACpB,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAK,CAAC;YACtD,IAAI,CAAC,kBAAkB,GAAG,oBAAoB,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC;QAEzF,CAAC;IAEL,CAAC;IAED,kBAAkB,CAAC,cAA4B,EAAE,gBAAmC,EAAE,SAAiB;QACnG,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,gBAAgB,EAAE,SAAS,CAAC;QAC5D,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC;IACpC,CAAC;IACD,uHAAuH;IACvH,mEAAmE;IACnE,uCAAuC;IACvC,IAAI;IAEJ,SAAS;QACL,OAAO,IAAI,CAAC,MAAM;IACtB,CAAC;IAED,UAAU;QACN,OAAO,IAAI,CAAC,OAAO;IACvB,CAAC;IAED,kBAAkB,CAAC,UAAsB;QAErC,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,IAAI;QAE9B,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC;QAC5E,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC;QAClF,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC;QAClF,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC;QAEtE,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;YAC5E,OAAO,CAAC,IAAI,CAAC,qCAAqC,CAAC;YACnD,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC;QAC1D,CAAC;QACD,IAAI,MAAM,IAAI,MAAM,EAAE,CAAC;YACnB,OAAO,CAAC,KAAK,CAAC,iCAAiC,CAAC;YAChD,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC;QACtD,CAAC;QACD,IAAI,CAAC,SAAS,GAAG,MAAM;QACvB,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC;QAC9B,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC;IAErC,CAAC;IAED,SAAS;QACL,OAAO,IAAI,CAAC,MAAM;IACtB,CAAC;IAEO,aAAa,CAAC,UAAsB;QAExC,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC;QAClF,MAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC;QAChF,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC;QAElF,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;QAEvC,KAAK,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,CAAC;YACvD,MAAM,GAAG,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;YACjC,KAAK,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,CAAC;gBAC3C,MAAM,OAAO,GAAG,UAAU,CAAC,iBAAiB,CAAC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,GAAG,UAAU,EAAE,IAAI,GAAG,UAAU,GAAG,UAAU,CAAC,EAAE,MAAM,CAAC;gBACpI,IAAI,OAAO,IAAI,IAAI,EAAE,CAAC;oBAClB,SAAQ;gBACZ,CAAC;gBACD,MAAM,WAAW,GAAG,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;gBAC7C,IAAI,WAAW,GAAG,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;oBAC5C,IAAI,CAAC,GAAG,GAAG,WAAW,CAAC;gBAC3B,CAAC;qBAAM,IAAI,WAAW,GAAG,IAAI,CAAC,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;oBACnD,IAAI,CAAC,GAAG,GAAG,WAAW,CAAC;gBAC3B,CAAC;YACL,CAAC;QACL,CAAC;IACL,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,IAAY;QACtC,MAAM,IAAI,GAAG,MAAM,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC;QAC5C,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;YACf,OAAO,CAAC,IAAI,CAAC,QAAQ,IAAI,gBAAgB,CAAC;YAC1C,OAAO,IAAI;QACf,CAAC;QACD,OAAO,IAAI;IACf,CAAC;IAGD,OAAO;QACH,OAAO,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE;IACtD,CAAC;IAEO,UAAU,CAAC,cAA4B,EAAE,gBAAmC,EAAE,SAAiB;QAGnG,MAAM,MAAM,GAAG,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC;QACjF,MAAM,KAAK,GAAG,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC;QAC/E,MAAM,MAAM,GAAG,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC;QAEjF,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;QACvC,IAAI,CAAC,UAAU,EAAE,CAAC;YACd,OAAO,CAAC,KAAK,CAAC,oBAAoB,CAAC;YACnC,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC;QACzC,CAAC;QAED,IAAI,CAAC,OAAO,GAAG,IAAI,KAAK,CAAC,SAAS,CAAC;QACnC,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;YACvC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,UAAU,CAAC,SAAS,GAAG,UAAU,CAAC;QAC9D,CAAC;QAGD,cAAc,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;YAE7B,MAAM,EAAE,GAAG,KAAK,CAAC,QAAQ,EAAE;YAC3B,MAAM,GAAG,GAAG,KAAK,CAAC,SAAS,EAAE;YAC7B,MAAM,EAAE,GAAG,SAAS,CAAC,EAAE,EAAE,GAAG,EAAE,UAAU,CAAC,OAAO,CAAC;YACjD,IAAI,EAAE,IAAI,IAAI,EAAE,CAAC;gBACb,OAAO,CAAC,KAAK,CAAC,oBAAoB,EAAE,KAAK,GAAG,0BAA0B,CAAC,CAAC;gBACxE,OAAO;YACX,CAAC;YACD,MAAM,EAAE,GAAG,oBAAoB,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;YACvD,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,oBAAoB,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,kBAAkB,EAAE,SAAS,CAAC,CAAC;YAE3G,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,IAAI,SAAS,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,IAAI,SAAS;gBAAE,OAAO;YAEvE,MAAM,UAAU,GAAG,KAAK,CAAC,aAAa,EAAE,CAAC;YACzC,IAAI,CAAC,UAAU;gBAAE,OAAO,CAAC,oCAAoC;YAE7D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE,CAAC;gBAClC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,UAAU,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAC5D,CAAC;YAED,MAAM,OAAO,GAAG,UAAU,CAAC,iBAAiB,CAAC,CAAC,EAAE,UAAU,EAAE,MAAM,CAAC,CAAC;YACpE,IAAI,OAAO,IAAI,IAAI;gBAAE,OAAO;YAE5B,MAAM,WAAW,GAAG,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;YAC7C,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,WAAW,GAAG,IAAI,CAAC,GAAG;gBAAE,IAAI,CAAC,GAAG,GAAG,WAAW,CAAC;YACtE,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,WAAW,GAAG,IAAI,CAAC,GAAG;gBAAE,IAAI,CAAC,GAAG,GAAG,WAAW,CAAC;QAE1E,CAAC,CAAC,CAAC;IAGP,CAAC;IACD,uHAAuH;IAGvH,wFAAwF;IACxF,sFAAsF;IACtF,wFAAwF;IAExF,8CAA8C;IAC9C,yBAAyB;IACzB,8CAA8C;IAC9C,gDAAgD;IAChD,QAAQ;IAER,+CAA+C;IAC/C,uDAAuD;IACvD,0EAA0E;IAC1E,QAAQ;IAIR,+DAA+D;IAE/D,6CAA6C;IAE7C,4DAA4D;IAC5D,4BAA4B;IAC5B,sFAAsF;IACtF,uBAAuB;IACvB,YAAY;IAEZ,0CAA0C;IAC1C,wEAAwE;IACxE,8DAA8D;IAC9D,0CAA0C;IAC1C,uBAAuB;IACvB,YAAY;IAEZ,kEAAkE;IAClE,iHAAiH;IACjH,6BAA6B;IAC7B,6BAA6B;IAE7B,iDAAiD;IACjD,mEAAmE;IACnE,6DAA6D;IAC7D,2CAA2C;IAC3C,wDAAwD;IACxD,mCAAmC;IACnC,2DAA2D;IAC3D,oBAAoB;IACpB,mBAAmB;IAEnB,iJAAiJ;IACjJ,qCAAqC;IACrC,2BAA2B;IAC3B,gBAAgB;IAEhB,4DAA4D;IAC5D,+DAA+D;IAC/D,0CAA0C;IAC1C,sEAAsE;IACtE,0CAA0C;IAC1C,gBAAgB;IAChB,YAAY;IACZ,QAAQ;IACR,IAAI;IAEI,wBAAwB,CAAC,GAAW,EAAE,gBAAmC;QAC7E,MAAM,KAAK,GAAG,gBAAgB,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,KAAK;QACnD,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;YACvC,OAAO,CAAC,KAAK,CAAC,GAAG,GAAG,cAAc,CAAC;YACnC,MAAM,IAAI,KAAK,CAAC,GAAG,GAAG,iBAAiB,CAAC;QAC5C,CAAC;QACD,MAAM,IAAI,GAAG,IAAI,cAAc,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC;QAC/C,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;IAC5B,CAAC;IAEO,eAAe,CAAC,GAAW,EAAE,gBAAmC;QACpE,MAAM,KAAK,GAAG,gBAAgB,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,KAAK;QACnD,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;YACvC,MAAM,IAAI,GAAG,IAAI,cAAc,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC;YAC/C,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;QAC5B,CAAC;IACL,CAAC;IAIO,SAAS,CAAC,gBAAmC;QAEjD,IAAI,CAAC,MAAM,GAAG,IAAI,iBAAiB,EAAE;QAErC,IAAI,CAAC,wBAAwB,CAAC,iBAAiB,CAAC,MAAM,EAAE,gBAAgB,CAAC;QACzE,IAAI,CAAC,wBAAwB,CAAC,iBAAiB,CAAC,MAAM,EAAE,gBAAgB,CAAC;QAEzE,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,KAAK,EAAE,gBAAgB,CAAC;QAC/D,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,MAAM,EAAE,gBAAgB,CAAC;QAChE,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,KAAK,EAAE,gBAAgB,CAAC;QAE/D,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QAE9E,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC;QAE5F,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC;QAE5F,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAErF,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAErF,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;QAE/E,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;QAE/E,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,cAAc,CAAC,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;QAEpF,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;QAE9E,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC;QAC7B,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;QAE3E,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;QAE3E,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,gBAAgB,EAAE,EAAE,CAAC,CAAC;QAEtF,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,OAAO,EAAE,EAAE,EAAE,uDAAuD,CAAC,CAAC;QAE9H,IAAI,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC7C,IAAI,GAAG,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/B,IAAI,MAAM,GAAG,EAAE,GAAG,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAEtC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;QAC7E,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;QAE7E,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IAGzD,CAAC;;;;AClUiC;AACG;AAElC,MAAM,QAAQ;IACT,QAAQ,GAA0B,IAAI,GAAG,EAAE;IAEnD,gBAAc,CAAC;IAEf,WAAW;QACP,OAAO,IAAI,CAAC,QAAQ;IACxB,CAAC;IAED,OAAO,CAAC,MAAc;QAClB,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC;QACtC,OAAO,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI;IAC3C,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,GAAW;QAC1B,MAAM,IAAI,GAAG,MAAM,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC;QAC3C,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAE;QAChD,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAS,EAAE,EAAE,QAAQ,CAAC;IACrD,CAAC;IAED,OAAO,CAAC,IAAc;QAClB,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE;QAC/B,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC;IACnC,CAAC;CACJ;;;;;AC3B2C;AACS;AAG9C,MAAM,eAAe;IAExB,MAAM,CAAC,KAAK,CAAC,iBAAiB,CAAC,OAAc;QACzC,IAAI,YAAY,GAAG,EAAE;QACrB,IAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,gBAAgB;YAC5C,YAAY,GAAG,MAAM,eAAe,CAAC,kBAAkB,CAAC,OAAO,CAAC;QACpE,CAAC;aAAM,CAAC,CAAC,aAAa;YAClB,YAAY,GAAG,MAAM,eAAe,CAAC,iBAAiB,CAAC,OAAO,CAAC;QACnE,CAAC;QACD,MAAM,QAAQ,GAAkB,eAAe,CAAC,uBAAuB,CAAC,YAAY,CAAC;QACrF,OAAO,QAAQ;IACnB,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC,YAAoB;QACxD,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,YAAY,GAAG,aAAa,CAAC;QAC1D,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CAAC,uBAAuB,QAAQ,CAAC,MAAM,EAAE,CAAC;QAC7D,CAAC;aAAM,CAAC;YACJ,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE;YACtC,OAAO,QAAQ;QACnB,CAAC;QACD,uBAAuB;QACvB,yCAAyC;QACzC,wDAAwD;QACxD,8DAA8D;QAC9D,WAAW;QACX,qCAAqC;QACrC,IAAI;QACJ,kBAAkB;IACtB,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,iBAAiB,CAAC,YAAoB;QAEvD,MAAM,QAAQ,GAAG,YAAY,GAAG,aAAa;QAC7C,MAAM,OAAO,GAAW,MAAM,sBAAQ,CAAC,QAAQ,CAAC;QAChD,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,OAAO,CAAC;QACrC,MAAM,WAAW,GAAG,IAAI,WAAW,CAAC,OAAO,CAAC;QAC5C,MAAM,QAAQ,GAAG,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAE3C,OAAO,QAAQ;IACnB,CAAC;IAEO,MAAM,CAAC,uBAAuB,CAAC,YAAoB;QACvD,IAAI,QAAQ,GAAG,IAAI,cAAc,EAAE;QACnC,MAAM,MAAM,GAAG,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAExC,KAAK,IAAI,IAAI,IAAI,MAAM,EAAE,CAAC;YACtB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC;gBACtB,SAAS;YACb,CAAC;YAED,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC/B,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE,CAAC;gBAC1B,SAAS;YACb,CAAC;YACD,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;YAC5B,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;YAC5B,IAAI,KAAK,GAAkB,GAAG;YAC9B,IAAI,GAAG,IAAI,cAAc,CAAC,KAAK,IAAI,GAAG,IAAI,cAAc,CAAC,UAAU,IAAI,GAAG,IAAI,cAAc,CAAC,KAAK,IAAI,GAAG,IAAI,cAAc,CAAC,MAAM,EAAE,CAAC;gBACjI,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC;YACzB,CAAC;YACD,QAAQ,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC;QAChC,CAAC;QACD,OAAO,QAAQ;IACnB,CAAC;CACJ;;;ACrEwC;AACW;AACG;AACV;AACW;AACR;AACiB;AACR;AAChB;AACI;AACC;AACS;AACA;AAEA;AAIhD,MAAM,cAAc;IAEf,OAAO,CAAQ;IACf,OAAO,GAAmB,IAAI;IAC9B,QAAQ,GAA0B,IAAI;IAE9C,YAAY,YAAoB;QAC5B,IAAI,CAAC,OAAO,GAAG,YAAY;QAC3B,IAAI,CAAC,IAAI,EAAE;QACX,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;YACvB,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC;YAC/B,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC;QACtC,CAAC;QACD,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,EAAE,CAAC;YACxB,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC;YAChC,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC;QACvC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,IAAI;QACN,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE;QAC/C,MAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC;QACpD,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,gBAAgB,CAAC,KAAK,CAAC;IACrD,CAAC;IAEO,KAAK,CAAC,iBAAiB;QAC3B,MAAM,QAAQ,GAAG,eAAe,CAAC,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC;QAChE,OAAO,QAAQ;IACnB,CAAC;IAED,MAAM,CAAC,iBAAiB,CAAC,MAAa,EAAE,SAAiB,EAAE,YAAoB,EAAE,UAAkB;QAI/F,MAAM,OAAO,GAAG,UAAU,CAAC,oBAAoB,CAAC,YAAY,EAAE,UAAU,CAAC;QAEzE,2DAA2D;QAC3D,IAAI,eAAe,GAAG,IAAI,eAAe,EAAE;QAG3C,MAAM,GAAG,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,YAAY,EAAE,CAAC,QAAQ,EAAE,MAAM,CAAC,YAAY,EAAE,CAAC,MAAM,CAAC,CAAC;QACpG,MAAM,UAAU,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;QAEvC,kHAAkH;QAClH,MAAM,QAAQ,GAAa,OAAO,CAAC,kBAAkB,CAAC,GAAG,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,eAAe;QAE1F,iDAAiD;QACjD,uCAAuC;QACvC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAEzC,kEAAkE;YAClE,qCAAqC;YACrC,IAAI;YACJ,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC;gBAChF,eAAe,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC5C,iCAAiC;YACrC,CAAC;QAEL,CAAC;QAED,MAAM,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAClC,mCAAmC;QACnC,4BAA4B;QAC5B,IAAI;QACJ,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;YACjD,eAAe,CAAC,YAAY,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;QAGD,8CAA8C;QAC9C,IAAI,KAAK,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC;QAChD,IAAI,KAAK,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,KAAK,GAAG,SAAS,CAAC;QAChD,IAAI,MAAM,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,MAAM,GAAG,SAAS,CAAC;QAClD,IAAI,MAAM,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,MAAM,GAAG,SAAS,CAAC;QAElD,eAAe,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC,MAAc,EAAE,EAAE;YACtD,0CAA0C;YAE1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE,CAAC;gBAClC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE,CAAC;oBAElC,MAAM,KAAK,GAAiB,cAAc,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;oBAExF,IAAI,KAAK,IAAI,IAAI;wBAAE,SAAQ;oBAC3B,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC,KAAK,GAAG,KAAK;wBAChE,KAAK,CAAC,QAAQ,EAAE,CAAC,MAAM,GAAG,MAAM,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC,MAAM,GAAG,MAAM,EAAE,CAAC;wBACvE,SAAS;oBACb,CAAC;oBACD,eAAe,CAAC,aAAa,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC,QAAQ,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;oBACtG,qEAAqE;gBACzE,CAAC;YACL,CAAC;QACL,CAAC,CAAC;QAEF,kEAAkE;QAClE,wBAAwB;QACxB,OAAO,eAAe;IAC1B,CAAC;IAEO,MAAM,CAAC,YAAY,GAAgC,IAAI,GAAG,EAAE,CAAC;IAGrE,MAAM,CAAC,SAAS,CAAC,CAAS,EAAE,CAAS,EAAE,MAAc,EAAE,OAAgB,EAAE,UAAkB;QACvF,MAAM,KAAK,GAAI,OAAe,CAAC,KAAK,IAAI,IAAI,CAAC,IAAI,CAAE,OAAe,CAAC,KAAK,CAAC,CAAC,CAAC,0BAA0B;QACrG,MAAM,QAAQ,GAAG,GAAG,KAAK,IAAI,MAAM,EAAE,CAAC;QAEtC,IAAI,UAAU,GAAG,cAAc,CAAC,YAAY,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAC3D,IAAI,CAAC,UAAU,EAAE,CAAC;YACd,UAAU,GAAG,oBAAoB,CAAC,WAAW,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YAC/D,MAAM,EAAE,GAAG,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK;YAC9C,MAAM,EAAE,GAAG,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK;YAC9C,OAAO,CAAC,GAAG,CAAC,WAAW,EAAE,YAAY,EAAE,UAAU,KAAK,WAAW,MAAM,EAAE,CAAC;YAC1E,cAAc,CAAC,YAAY,CAAC,GAAG,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;QAC1D,CAAC;QAED,IAAI,CAAC,OAAO;YAAE,OAAO,IAAI,CAAC;QAC1B,wEAAwE;QACxE,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,oBAAoB,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;QAC/F,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;YAAE,OAAO,IAAI,CAAC;QAC5D,MAAM,CAAC,GAAG,oBAAoB,CAAC,kBAAkB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACxD,MAAM,EAAE,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC;QAC9B,MAAM,GAAG,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,MAAM,CAAC;QAEhC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC;YAAE,OAAO,IAAI,CAAC;QAC/D,OAAO,CAAC,CAAC;IAEb,CAAC;IAED,2KAA2K;IAC3K,MAAM,CAAC,YAAY,CAAC,cAA+B,EAAE,gBAAmC,EAAE,YAAoB,EAAE,UAAkB;QAE9H,MAAM,OAAO,GAAG,UAAU,CAAC,oBAAoB,CAAC,YAAY,EAAE,UAAU,CAAC;QAEzE,IAAI,QAAQ,GAAG,IAAI,QAAQ,EAAE;QAE7B,cAAc,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC,MAAc,EAAE,EAAE;YACrD,IAAI,QAAQ,GAAG,IAAI,cAAc,EAAE;YACnC,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC;YACrD,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,EAAE,UAAU,CAAC;YACvD,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC;YAErD,MAAM,oBAAoB,GAAG,cAAc,CAAC,oBAAoB,CAAC,MAAM,CAAC;YAExE,QAAQ,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,gBAAgB,EAAE,UAAU,CAAC;YAC/E,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC;QAC9B,CAAC,CAAC;QACF,OAAO,QAAQ;IAEnB,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,SAA0B,EAAE,SAAiB,EAAE,UAAmB,EAAE,UAAkB,EAAE,WAAmB;QAE9H,MAAM,OAAO,GAAG,UAAU,CAAC,gBAAgB,CAAC,SAAS,CAAC;QAEtD,IAAI,MAAc,CAAC;QACnB,IAAI,UAAU,GAAkB,IAAI,CAAC;QACrC,mFAAmF;QACnF,IAAI,UAAU,EAAE,CAAC;YACb,cAAc,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;QAChD,CAAC;QACD,IAAI,UAAU,GAA0B,IAAI;QAI5C,SAAS,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;YAC5C,MAAM,EAAE,GAAG,KAAK,CAAC,QAAQ,EAAE;YAC3B,MAAM,GAAG,GAAG,KAAK,CAAC,SAAS,EAAE;YAE7B,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,UAAU,CAAC,OAAO,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC;YACnE,MAAM,GAAG,GAAG,IAAI,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,YAAY,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC,YAAY,EAAE,CAAC,MAAM,CAAC,CAAC;YAE1F,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAE9B,IAAI,UAAU,KAAK,MAAM,IAAI,UAAU,IAAI,IAAI,EAAE,CAAC;gBAC9C,UAAU,GAAG,oBAAoB,CAAC,WAAW,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;gBAC/D,UAAU,GAAG,MAAM,CAAC;YACxB,CAAC;YACD,IAAI,UAAU,EAAE,CAAC;gBACb,MAAM,EAAE,GAAG,oBAAoB,CAAC,kBAAkB,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;gBACjE,MAAM,EAAE,GAAG,oBAAoB,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;gBACvF,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;gBACzB,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC;YAC/B,CAAC;YACD,SAAS,CAAC,aAAa,CAAC,MAAM,CAAC;QACnC,CAAC,CAAC,CAAC;QACH,IAAI,MAAM,GAAG,MAAM,cAAc,CAAC,cAAc,CAAC,SAAS,EAAE,WAAW,EAAE,SAAS,CAAC;QACnF,OAAO,MAAM;IACjB,CAAC;IAED,6BAA6B;IAC7B,MAAM,CAAC,iBAAiB,CAAC,SAA0B;QAC/C,uCAAuC;QACvC,MAAM,OAAO,GAAG,IAAI,CAAC,EAAE,GAAG,GAAG;QAC7B,MAAM,OAAO,GAAG,GAAG,GAAG,IAAI,CAAC,EAAE;QAC7B,MAAM,KAAK,GAAG,OAAO,GAAG,OAAO;QAC/B,MAAM,KAAK,GAAG,OAAO,GAAG,OAAO;QAC/B,MAAM,KAAK,GAAG,OAAO,GAAG,QAAQ;QAChC,SAAS,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;YAC5C,MAAM,EAAE,GAAG,KAAK,CAAC,QAAQ,EAAE;YAC3B,MAAM,GAAG,GAAG,KAAK,CAAC,SAAS,EAAE;YAC7B,MAAM,MAAM,GAAG,OAAO,GAAG,EAAE;YAC3B,MAAM,OAAO,GAAG,OAAO,GAAG,GAAG;YAC7B,SAAS;YACT,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC;gBAC7C,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;YACnE,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;YAC1B,MAAM,KAAK,GAAG,CAAC,GAAG,OAAO;YAEzB,YAAY;YACZ,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;gBACzE,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAC5G,MAAM,CAAC,GAAG,KAAK,GAAG,YAAY;YAC9B,MAAM,KAAK,GAAG,CAAC,GAAG,OAAO;YACzB,KAAK,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC;YAC/B,sCAAsC;QAC1C,CAAC,CAAC,CAAC;QACH,yBAAyB;IAC7B,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,SAA0B,EAAE,WAAmB,EAAE,SAAiB;QAE1F,MAAM,QAAQ,GAAG,SAAS,CAAC,YAAY,EAAE;QACzC,IAAI,QAAQ,GAAG,EAAE,CAAC;QAElB,KAAK,IAAI,UAAU,IAAI,QAAQ,EAAE,CAAC;YAE9B,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,mDAAmD;YACvG,MAAM,OAAO,GAAG,WAAW,GAAG,SAAS,GAAG,SAAS,GAAG,MAAM,GAAG,GAAG,GAAG,OAAO,GAAG,UAAU,GAAG,OAAO,CAAC;YACpG,OAAO,CAAC,GAAG,CAAC,0BAA0B,OAAO,EAAE,CAAC;YAEhD,oEAAoE;YACpE,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE;gBAE3D,IAAI,UAAU,EAAE,CAAC;oBAEb,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,KAAK,CAAC;oBAClE,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,KAAK,CAAC;oBAClE,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,KAAK,CAAC;oBAClE,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,EAAE,CAAC;wBAChC,OAAO,CAAC,KAAK,CAAC,WAAW,MAAM,aAAa,MAAM,aAAa,MAAM,kBAAkB,OAAO,EAAE,CAAC;wBACjG,OAAM;oBACV,CAAC;oBACD,IAAI,SAAS,CAAC,QAAQ,EAAE,IAAI,IAAI,EAAE,CAAC;wBAC/B,MAAM,QAAQ,GAAG,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,KAAK;wBAC3D,IAAI,QAAQ,EAAE,CAAC;4BACX,MAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC;4BAC9B,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC;gCAChB,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC;4BAC7B,CAAC;wBACL,CAAC;oBACL,CAAC;oBACD,IAAI,SAAS,CAAC,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC;wBAChC,MAAM,SAAS,GAAG,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,KAAK;wBAC7D,IAAI,SAAS,EAAE,CAAC;4BACZ,MAAM,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC;4BAChC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC;gCACjB,SAAS,CAAC,SAAS,CAAC,MAAM,CAAC;4BAC/B,CAAC;wBACL,CAAC;oBACL,CAAC;oBACD,IAAI,SAAS,CAAC,QAAQ,EAAE,IAAI,IAAI,EAAE,CAAC;wBAC/B,MAAM,QAAQ,GAAG,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,KAAK;wBAC3D,IAAI,QAAQ,EAAE,CAAC;4BACX,MAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC;4BAC9B,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC;gCAChB,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC;4BAC7B,CAAC;wBACL,CAAC;oBACL,CAAC;oBAED,0EAA0E;oBAC1E,kKAAkK;oBAClK,aAAa;oBACb,IAAI;oBAEJ,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;oBAExC,SAAS,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;wBACzD,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC;wBAC9C,IAAI,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,IAAI,SAAS,EAAE,CAAC;4BAC7C,OAAO,CAAC,IAAI,CAAC,WAAW,KAAK,CAAC,IAAI,EAAE,iCAAiC,MAAM,GAAG,CAAC,kBAAkB,OAAO,EAAE,CAAC;4BAC3G,OAAM;wBACV,CAAC;wBACD,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,GAAG,UAAU,GAAG,UAAU,CAAC,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC;4BAClF,OAAO,CAAC,IAAI,CAAC,WAAW,KAAK,CAAC,IAAI,EAAE,iCAAiC,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC,kBAAkB,OAAO,EAAE,CAAC;4BACxJ,OAAM;wBACV,CAAC;wBACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE,CAAC;4BAClC,UAAU,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC;wBACjF,CAAC;wBACD,KAAK,CAAC,QAAQ,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;wBACnC,SAAS,CAAC,cAAc,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;oBAC9C,CAAC,CAAC;gBACN,CAAC;YACL,CAAC,CAAC,CAAC,CAAC;QACR,CAAC;QACD,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAC5B,IAAI,SAAS,CAAC,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC;YAChC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1B,CAAC;QACD,IAAI,SAAS,CAAC,QAAQ,EAAE,IAAI,IAAI,EAAE,CAAC;YAC/B,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;QACzB,CAAC;QACD,IAAI,SAAS,CAAC,QAAQ,EAAE,IAAI,IAAI,EAAE,CAAC;YAC/B,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;QACzB,CAAC;QACD,OAAO,SAAS;IACpB,CAAC;;;;ACjUE,MAAM,YAAY;IACrB,IAAI,CAAM;IACV,QAAQ,CAAU;IAClB,UAAU,CAAoB;IAC9B,kBAAkB,CAAoB;IACtC,MAAM,CAAQ;IAGd,YAAY,IAAU,EAAE,QAAkB,EAAE,UAA8B,EAAE,kBAAsC,EAAE,MAAc;QAC9H,IAAI,CAAC,IAAI,GAAG,IAAI;QAChB,IAAI,CAAC,QAAQ,GAAG,QAAQ;QACxB,IAAI,CAAC,UAAU,GAAG,UAAU;QAC5B,IAAI,CAAC,kBAAkB,GAAG,kBAAkB;QAC5C,IAAI,CAAC,MAAM,GAAG,MAAM;IACxB,CAAC;CAEJ;;;ACpBD;;;;;;;GAOG;AAE+C;AACgC;AACZ;AAME;AACF;AACb;AAES;AAE3D,MAAM,QAAQ;IAEjB;;;;;;;OAOG;IACH,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,MAAa,EAAE,MAAc,EACvD,MAAc,EAAE,QAAgB;QAEhC,MAAM,eAAe,GAAG,GAAG;QAE3B,6GAA6G;QAE7G,+IAA+I;QAC/I,MAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,qBAAqB,CAAC,QAAQ,CAAC;QACnE,IAAI,CAAC,YAAY;YAAE,OAAO,IAAI;QAC9B,0CAA0C;QAE1C,6IAA6I;QAC7I,MAAM,iBAAiB,GAAyB,cAAc,CAAC,iBAAiB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,eAAe,CAAC;QACzH,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACrB,OAAO,IAAI;QACf,CAAC;QAED,iLAAiL;QACjL,YAAY,CAAC,SAAS,CAAC,iBAAiB,CAAC;QACzC,mEAAmE;QAEnE,kFAAkF;QAClF,qEAAqE;QAErE,yCAAyC;QACzC,uCAAuC;QACvC,MAAM,YAAY,GAAG,cAAc,CAAC,YAAY,CAAC,iBAAiB,EAAE,YAAY,CAAC,aAAa,EAAE,EAAE,MAAM,EAAE,eAAe,CAAC,CAAC;QAC3H,KAAK,IAAI,aAAa,IAAI,YAAY,CAAC,WAAW,EAAE,EAAE,CAAC;YACnD,MAAM,MAAM,GAAG,aAAa,CAAC,CAAC,CAAC;YAC/B,MAAM,QAAQ,GAAG,aAAa,CAAC,CAAC,CAAC;YACjC,MAAM,IAAI,GAAG,QAAQ,CAAC,UAAU,EAAE;YAClC,MAAM,MAAM,GAAG,QAAQ,CAAC,SAAS,EAAE;YACnC,MAAM,cAAc,GAAG,UAAU,MAAM,OAAO;YAE9C,MAAM,UAAU,GAAG,EAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAC;YAC/C,UAAU,CAAC,eAAe,CAAC,UAAU,EAAE,cAAc,CAAC;QAC1D,CAAC;QACD,OAAO,YAAY;IAEvB,CAAC;IAED,wCAAwC;IACxC,MAAM,CAAC,KAAK,CAAC,qBAAqB,CAAC,QAAgB;QAC/C,IAAI,IAAI,GAAsB,MAAM,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC;QACjE,IAAI,CAAC,IAAI;YAAE,OAAO,IAAI;QAEtB,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,KAAK,CAAC;QAE3D,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAC,CAAC;YACvB,IAAI,UAAU,GAAG,IAAI,kBAAkB,EAAE;YACzC,MAAM,UAAU,CAAC,YAAY,CAAC,QAAQ,CAAC;YACvC,OAAO,UAAU;QACrB,CAAC;QACD,OAAO,IAAI;IAEf,CAAC;IAED,iGAAiG;IACjG,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,MAAa,EAAE,MAAc,EACvD,YAAoB,EAAE,WAAmB,EAAE,OAA2B,EAAE,YAA2B,IAAI;QAEvG,MAAM,QAAQ,GAAG,MAAM,eAAe,CAAC,iBAAiB,CAAC,WAAW,CAAC;QACrE,MAAM,YAAY,GAAW,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC;QACnE,MAAM,SAAS,GAAG,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC;QACxD,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC;QAG9D,IAAI,UAAU,GAAY,KAAK;QAC/B,IAAI,SAAS,CAAC,WAAW,EAAE,IAAI,UAAU,EAAE,CAAC;YACxC,UAAU,GAAG,IAAI;QACrB,CAAC;QAED,IAAI,CAAC,SAAS,EAAE,CAAC;YACb,MAAM,OAAO,GAAG,UAAU,CAAC,oBAAoB,CAAC,YAAY,EAAE,UAAU,EAAE,YAAY,CAAC;YACvF,SAAS,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;QACrC,CAAC;QAED;;;UAGE;QACF,MAAM,UAAU,GAAW,OAAO,CAAC,iBAAiB,CAAC,MAAM,EAAE,YAAY,CAAC;QAC1E,MAAM,YAAY,GAAoB,OAAO,CAAC,iBAAiB,CAAC,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,UAAU,CAAC;QACzG,IAAI,CAAC,YAAY;YAAE,OAAO,IAAI;QAG9B,MAAM,kBAAkB,GAAG,YAAY,CAAC,yBAAyB,EAAE;QACnE,IAAI,kBAAkB,IAAI,IAAI;YAAE,OAAO,IAAI;QAC3C,MAAM,GAAG,GAAG,kBAAkB,EAAE,YAAY,EAAE;QAC9C,MAAM,IAAI,GAAG,kBAAkB,EAAE,aAAa,EAAE;QAChD,IAAI,GAAG,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS;YAAE,OAAO,IAAI;QAExD,8GAA8G;QAC9G,MAAM,eAAe,GAAG,MAAM,cAAc,CAAC,SAAS,CAAC,YAAY,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,CAAC;QACpH,IAAI,CAAC,eAAe;YAAE,OAAO,IAAI;QACjC,MAAM,QAAQ,GAAG,eAAe,CAAC,eAAe,EAAE,EAAE,WAAW,EAAE;QACjE,MAAM,QAAQ,GAAG,eAAe,CAAC,eAAe,EAAE,EAAE,WAAW,EAAE;QACjE,IAAI,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAK,SAAS;YAAE,OAAO,IAAI;QAEjE;;;;;;;;;;;;;;;;;;;;;WAqBG;QACH,8FAA8F;QAC9F,MAAM,KAAK,GAAG,eAAe,CAAC,QAAQ,EAAE;QACxC,MAAM,KAAK,GAAG,eAAe,CAAC,QAAQ,EAAE;QACxC,MAAM,MAAM,GAAG,eAAe,CAAC,SAAS,EAAE;QAC1C,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,MAAM,KAAK,IAAI;YAAE,OAAO,IAAI;QACpE,OAAO,CAAC,GAAG,CAAC,UAAU,KAAK,YAAY,KAAK,aAAa,MAAM,EAAE,CAAC;QAElE,kBAAkB;QAClB,MAAM,MAAM,GAAW,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;QACxE,IAAI,MAAM,IAAI,CAAC,IAAI,MAAM,IAAI,EAAE,IAAI,MAAM,IAAI,EAAE,IAAI,MAAM,IAAI,CAAC,EAAE,IAAI,MAAM,IAAI,CAAC,EAAE,EAAE,CAAC;YAChF,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC;QAC/C,CAAC;QAED,MAAM,IAAI,GAAS,OAAO,CAAC,gBAAgB,CACvC,YAAY,EACZ,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,EACvC,UAAU,EACV,KAAK,EAAE,KAAK,EAAE,MAAM,EACpB,GAAG,EAAE,IAAI,EACT,QAAQ,EAAE,QAAQ,EAAE,eAAe,CAAC;QAExC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC;QAEjB,MAAM,cAAc,GAAG,mBAAmB;QAC1C,MAAM,UAAU,GAAc,EAAC,MAAM,EAAE,IAAI,CAAC,SAAS,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,EAAC;QAC9E,UAAU,CAAC,eAAe,CAAC,UAAU,EAAE,cAAc,CAAC;QAEtD,IAAI,QAAQ,GAAG,KAAK,EAAU;QAC9B,eAAe,CAAC,YAAY,EAAE,CAAC,OAAO,CAAE,CAAC,UAAU,EAAE,EAAE;YACnD,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,mDAAmD;YACvG,MAAM,OAAO,GAAG,WAAW,GAAG,SAAS,GAAG,SAAS,GAAG,MAAM,GAAG,GAAG,GAAG,OAAO,GAAG,UAAU,GAAG,OAAO,CAAC;YACpG,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC;QAC1B,CAAC,CAAC;QAEF,MAAM,MAAM,GAAG,IAAI,YAAY,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,kBAAkB,EAAE,YAAY,CAAC;QAE1F,OAAO,MAAM;IACjB,CAAC;IAED,MAAM,CAAC,wBAAwB;QAE3B,OAAO,IAAI;IACf,CAAC;IAGD;;;;;OAKG;IACH,gEAAgE;IAChE,2BAA2B;IAC3B,8BAA8B;IAC9B,yBAAyB;IACzB,QAAQ;IACR,8EAA8E;IAC9E,iEAAiE;IACjE,sBAAsB;IACtB,IAAI;IAGJ,MAAM,CAAC,wBAAwB;QAC3B,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;IAC3C,CAAC;CAEJ;;;AC7ND;;;;;;;GAOG;AAII,MAAM,qBAAU;IACnB,EAAE,CAAS,CAAK,4BAA4B;IAC5C,EAAE,CAAS,CAAK,4BAA4B;IAC5C,OAAO,CAAS,OAAM;IAEtB,YAAa,CAAS,EAAE,CAAS,EAAE,SAAiB,GAAG;QACnD,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAED,IAAI;QACA,OAAO,IAAI,CAAC,EAAE,CAAC;IACnB,CAAC;IAED,IAAI;QACA,OAAO,IAAI,CAAC,EAAE,CAAC;IACnB,CAAC;IAED,IAAI,MAAM;QACN,OAAO,IAAI,CAAC,OAAO;IACvB,CAAC;CACJ;;;AChCqC;AAIU;AAOA;AACA;AACV;AAWA;AACgC;AAChB;AACa;AACY;AAEtB","sources":["webpack://wcslight/./node_modules/cross-fetch/dist/node-ponyfill.js","webpack://wcslight/./node_modules/tr46/index.js","webpack://wcslight/./node_modules/webidl-conversions/lib/index.js","webpack://wcslight/./node_modules/whatwg-url/lib/URL-impl.js","webpack://wcslight/./node_modules/whatwg-url/lib/URL.js","webpack://wcslight/./node_modules/whatwg-url/lib/public-api.js","webpack://wcslight/./node_modules/whatwg-url/lib/url-state-machine.js","webpack://wcslight/./node_modules/whatwg-url/lib/utils.js","webpack://wcslight/external node-commonjs \"node:fs/promises\"","webpack://wcslight/external node-commonjs \"punycode\"","webpack://wcslight/./node_modules/jsfitsio/lib-esm/getFile.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/getLocalFile.js","webpack://wcslight/external node-commonjs \"stream\"","webpack://wcslight/external node-commonjs \"http\"","webpack://wcslight/external node-commonjs \"url\"","webpack://wcslight/external node-commonjs \"https\"","webpack://wcslight/external node-commonjs \"zlib\"","webpack://wcslight/./node_modules/node-fetch/lib/index.mjs","webpack://wcslight/webpack/bootstrap","webpack://wcslight/webpack/runtime/define property getters","webpack://wcslight/webpack/runtime/hasOwnProperty shorthand","webpack://wcslight/webpack/runtime/make namespace object","webpack://wcslight/external node-commonjs \"fs\"","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSWriter.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeaderManager.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseUtils.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParsePayload.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSParser.js","webpack://wcslight/./src/projections/AbstractProjection.ts","webpack://wcslight/./src/model/NumberType.ts","webpack://wcslight/./src/model/Utils.ts","webpack://wcslight/./src/model/CoordsType.ts","webpack://wcslight/./src/Config.ts","webpack://wcslight/./src/model/Point.ts","webpack://wcslight/./src/projections/MinMaxValue.ts","webpack://wcslight/./src/projections/RADecMinMaxCentral.ts","webpack://wcslight/./src/projections/hips/TilesRaDecList2.ts","webpack://wcslight/./src/projections/hips/ImagePixel.ts","webpack://wcslight/./src/model/FITS.ts","webpack://wcslight/./src/Version.ts","webpack://wcslight/./src/projections/mercator/MercatorProjection.ts","webpack://wcslight/./node_modules/healpixjs/lib-esm/Constants.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Zphi.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Hploc.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Pointing.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Vec3.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/CircleFinder.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Fxyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/pstack.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/RangeSet.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Xyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Healpix.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/index.js","webpack://wcslight/./src/projections/hips/HiPSIntermediateProj.ts","webpack://wcslight/./src/projections/HiPSHelper.ts","webpack://wcslight/./src/projections/hips/HiPSProperties.ts","webpack://wcslight/./src/projections/hips/HiPSFITS.ts","webpack://wcslight/./src/projections/hips/FITSList.ts","webpack://wcslight/./src/projections/hips/HiPSPropManager.ts","webpack://wcslight/./src/projections/hips/HiPSProjection.ts","webpack://wcslight/./src/projections/hips/CutoutResult.ts","webpack://wcslight/./src/WCSLight.ts","webpack://wcslight/./src/model/ImagePixel.ts","webpack://wcslight/./src/index.ts"],"sourcesContent":["const nodeFetch = require('node-fetch')\nconst realFetch = nodeFetch.default || nodeFetch\n\nconst fetch = function (url, options) {\n  // Support schemaless URIs on the server for parity with the browser.\n  // Ex: //github.com/ -> https://github.com/\n  if (/^\\/\\//.test(url)) {\n    url = 'https:' + url\n  }\n  return realFetch.call(this, url, options)\n}\n\nfetch.ponyfill = true\n\nmodule.exports = exports = fetch\nexports.fetch = fetch\nexports.Headers = nodeFetch.Headers\nexports.Request = nodeFetch.Request\nexports.Response = nodeFetch.Response\n\n// Needed for TypeScript consumers without esModuleInterop.\nexports.default = fetch\n","\"use strict\";\n\nvar punycode = require(\"punycode\");\nvar mappingTable = require(\"./lib/mappingTable.json\");\n\nvar PROCESSING_OPTIONS = {\n  TRANSITIONAL: 0,\n  NONTRANSITIONAL: 1\n};\n\nfunction normalize(str) { // fix bug in v8\n  return str.split('\\u0000').map(function (s) { return s.normalize('NFC'); }).join('\\u0000');\n}\n\nfunction findStatus(val) {\n  var start = 0;\n  var end = mappingTable.length - 1;\n\n  while (start <= end) {\n    var mid = Math.floor((start + end) / 2);\n\n    var target = mappingTable[mid];\n    if (target[0][0] <= val && target[0][1] >= val) {\n      return target;\n    } else if (target[0][0] > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\nfunction countSymbols(string) {\n  return string\n    // replace every surrogate pair with a BMP symbol\n    .replace(regexAstralSymbols, '_')\n    // then get the length\n    .length;\n}\n\nfunction mapChars(domain_name, useSTD3, processing_option) {\n  var hasError = false;\n  var processed = \"\";\n\n  var len = countSymbols(domain_name);\n  for (var i = 0; i < len; ++i) {\n    var codePoint = domain_name.codePointAt(i);\n    var status = findStatus(codePoint);\n\n    switch (status[1]) {\n      case \"disallowed\":\n        hasError = true;\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"ignored\":\n        break;\n      case \"mapped\":\n        processed += String.fromCodePoint.apply(String, status[2]);\n        break;\n      case \"deviation\":\n        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        } else {\n          processed += String.fromCodePoint(codePoint);\n        }\n        break;\n      case \"valid\":\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"disallowed_STD3_mapped\":\n        if (useSTD3) {\n          hasError = true;\n          processed += String.fromCodePoint(codePoint);\n        } else {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        }\n        break;\n      case \"disallowed_STD3_valid\":\n        if (useSTD3) {\n          hasError = true;\n        }\n\n        processed += String.fromCodePoint(codePoint);\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nvar combiningMarksRegex = /[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2D]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD804[\\uDC00-\\uDC02\\uDC38-\\uDC46\\uDC7F-\\uDC82\\uDCB0-\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD34\\uDD73\\uDD80-\\uDD82\\uDDB3-\\uDDC0\\uDE2C-\\uDE37\\uDEDF-\\uDEEA\\uDF01-\\uDF03\\uDF3C\\uDF3E-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF62\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDCB0-\\uDCC3\\uDDAF-\\uDDB5\\uDDB8-\\uDDC0\\uDE30-\\uDE40\\uDEAB-\\uDEB7]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF51-\\uDF7E\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD83A[\\uDCD0-\\uDCD6]|\\uDB40[\\uDD00-\\uDDEF]/;\n\nfunction validateLabel(label, processing_option) {\n  if (label.substr(0, 4) === \"xn--\") {\n    label = punycode.toUnicode(label);\n    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;\n  }\n\n  var error = false;\n\n  if (normalize(label) !== label ||\n      (label[3] === \"-\" && label[4] === \"-\") ||\n      label[0] === \"-\" || label[label.length - 1] === \"-\" ||\n      label.indexOf(\".\") !== -1 ||\n      label.search(combiningMarksRegex) === 0) {\n    error = true;\n  }\n\n  var len = countSymbols(label);\n  for (var i = 0; i < len; ++i) {\n    var status = findStatus(label.codePointAt(i));\n    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== \"valid\") ||\n        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&\n         status[1] !== \"valid\" && status[1] !== \"deviation\")) {\n      error = true;\n      break;\n    }\n  }\n\n  return {\n    label: label,\n    error: error\n  };\n}\n\nfunction processing(domain_name, useSTD3, processing_option) {\n  var result = mapChars(domain_name, useSTD3, processing_option);\n  result.string = normalize(result.string);\n\n  var labels = result.string.split(\".\");\n  for (var i = 0; i < labels.length; ++i) {\n    try {\n      var validation = validateLabel(labels[i]);\n      labels[i] = validation.label;\n      result.error = result.error || validation.error;\n    } catch(e) {\n      result.error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error: result.error\n  };\n}\n\nmodule.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {\n  var result = processing(domain_name, useSTD3, processing_option);\n  var labels = result.string.split(\".\");\n  labels = labels.map(function(l) {\n    try {\n      return punycode.toASCII(l);\n    } catch(e) {\n      result.error = true;\n      return l;\n    }\n  });\n\n  if (verifyDnsLength) {\n    var total = labels.slice(0, labels.length - 1).join(\".\").length;\n    if (total.length > 253 || total.length === 0) {\n      result.error = true;\n    }\n\n    for (var i=0; i < labels.length; ++i) {\n      if (labels.length > 63 || labels.length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) return null;\n  return labels.join(\".\");\n};\n\nmodule.exports.toUnicode = function(domain_name, useSTD3) {\n  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n};\n\nmodule.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;\n","\"use strict\";\n\nvar conversions = {};\nmodule.exports = conversions;\n\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction evenRound(x) {\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\n        return Math.floor(x);\n    } else {\n        return Math.round(x);\n    }\n}\n\nfunction createNumberConversion(bitLength, typeOpts) {\n    if (!typeOpts.unsigned) {\n        --bitLength;\n    }\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\n    const upperBound = Math.pow(2, bitLength) - 1;\n\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\n\n    return function(V, opts) {\n        if (!opts) opts = {};\n\n        let x = +V;\n\n        if (opts.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw new TypeError(\"Argument is not a finite number\");\n            }\n\n            x = sign(x) * Math.floor(Math.abs(x));\n            if (x < lowerBound || x > upperBound) {\n                throw new TypeError(\"Argument is not in byte range\");\n            }\n\n            return x;\n        }\n\n        if (!isNaN(x) && opts.clamp) {\n            x = evenRound(x);\n\n            if (x < lowerBound) x = lowerBound;\n            if (x > upperBound) x = upperBound;\n            return x;\n        }\n\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n\n        x = sign(x) * Math.floor(Math.abs(x));\n        x = x % moduloVal;\n\n        if (!typeOpts.unsigned && x >= moduloBound) {\n            return x - moduloVal;\n        } else if (typeOpts.unsigned) {\n            if (x < 0) {\n              x += moduloVal;\n            } else if (x === -0) { // don't return negative zero\n              return 0;\n            }\n        }\n\n        return x;\n    }\n}\n\nconversions[\"void\"] = function () {\n    return undefined;\n};\n\nconversions[\"boolean\"] = function (val) {\n    return !!val;\n};\n\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\n\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\n\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\n\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\n\nconversions[\"double\"] = function (V) {\n    const x = +V;\n\n    if (!Number.isFinite(x)) {\n        throw new TypeError(\"Argument is not a finite floating-point value\");\n    }\n\n    return x;\n};\n\nconversions[\"unrestricted double\"] = function (V) {\n    const x = +V;\n\n    if (isNaN(x)) {\n        throw new TypeError(\"Argument is NaN\");\n    }\n\n    return x;\n};\n\n// not quite valid, but good enough for JS\nconversions[\"float\"] = conversions[\"double\"];\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\n\nconversions[\"DOMString\"] = function (V, opts) {\n    if (!opts) opts = {};\n\n    if (opts.treatNullAsEmptyString && V === null) {\n        return \"\";\n    }\n\n    return String(V);\n};\n\nconversions[\"ByteString\"] = function (V, opts) {\n    const x = String(V);\n    let c = undefined;\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n        if (c > 255) {\n            throw new TypeError(\"Argument is not a valid bytestring\");\n        }\n    }\n\n    return x;\n};\n\nconversions[\"USVString\"] = function (V) {\n    const S = String(V);\n    const n = S.length;\n    const U = [];\n    for (let i = 0; i < n; ++i) {\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            if (i === n - 1) {\n                U.push(String.fromCodePoint(0xFFFD));\n            } else {\n                const d = S.charCodeAt(i + 1);\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                    const a = c & 0x3FF;\n                    const b = d & 0x3FF;\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n                    ++i;\n                } else {\n                    U.push(String.fromCodePoint(0xFFFD));\n                }\n            }\n        }\n    }\n\n    return U.join('');\n};\n\nconversions[\"Date\"] = function (V, opts) {\n    if (!(V instanceof Date)) {\n        throw new TypeError(\"Argument is not a Date object\");\n    }\n    if (isNaN(V)) {\n        return undefined;\n    }\n\n    return V;\n};\n\nconversions[\"RegExp\"] = function (V, opts) {\n    if (!(V instanceof RegExp)) {\n        V = new RegExp(V);\n    }\n\n    return V;\n};\n","\"use strict\";\nconst usm = require(\"./url-state-machine\");\n\nexports.implementation = class URLImpl {\n  constructor(constructorArgs) {\n    const url = constructorArgs[0];\n    const base = constructorArgs[1];\n\n    let parsedBase = null;\n    if (base !== undefined) {\n      parsedBase = usm.basicURLParse(base);\n      if (parsedBase === \"failure\") {\n        throw new TypeError(\"Invalid base URL\");\n      }\n    }\n\n    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n\n    // TODO: query stuff\n  }\n\n  get href() {\n    return usm.serializeURL(this._url);\n  }\n\n  set href(v) {\n    const parsedURL = usm.basicURLParse(v);\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n  }\n\n  get origin() {\n    return usm.serializeURLOrigin(this._url);\n  }\n\n  get protocol() {\n    return this._url.scheme + \":\";\n  }\n\n  set protocol(v) {\n    usm.basicURLParse(v + \":\", { url: this._url, stateOverride: \"scheme start\" });\n  }\n\n  get username() {\n    return this._url.username;\n  }\n\n  set username(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setTheUsername(this._url, v);\n  }\n\n  get password() {\n    return this._url.password;\n  }\n\n  set password(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setThePassword(this._url, v);\n  }\n\n  get host() {\n    const url = this._url;\n\n    if (url.host === null) {\n      return \"\";\n    }\n\n    if (url.port === null) {\n      return usm.serializeHost(url.host);\n    }\n\n    return usm.serializeHost(url.host) + \":\" + usm.serializeInteger(url.port);\n  }\n\n  set host(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"host\" });\n  }\n\n  get hostname() {\n    if (this._url.host === null) {\n      return \"\";\n    }\n\n    return usm.serializeHost(this._url.host);\n  }\n\n  set hostname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"hostname\" });\n  }\n\n  get port() {\n    if (this._url.port === null) {\n      return \"\";\n    }\n\n    return usm.serializeInteger(this._url.port);\n  }\n\n  set port(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    if (v === \"\") {\n      this._url.port = null;\n    } else {\n      usm.basicURLParse(v, { url: this._url, stateOverride: \"port\" });\n    }\n  }\n\n  get pathname() {\n    if (this._url.cannotBeABaseURL) {\n      return this._url.path[0];\n    }\n\n    if (this._url.path.length === 0) {\n      return \"\";\n    }\n\n    return \"/\" + this._url.path.join(\"/\");\n  }\n\n  set pathname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    this._url.path = [];\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"path start\" });\n  }\n\n  get search() {\n    if (this._url.query === null || this._url.query === \"\") {\n      return \"\";\n    }\n\n    return \"?\" + this._url.query;\n  }\n\n  set search(v) {\n    // TODO: query stuff\n\n    const url = this._url;\n\n    if (v === \"\") {\n      url.query = null;\n      return;\n    }\n\n    const input = v[0] === \"?\" ? v.substring(1) : v;\n    url.query = \"\";\n    usm.basicURLParse(input, { url, stateOverride: \"query\" });\n  }\n\n  get hash() {\n    if (this._url.fragment === null || this._url.fragment === \"\") {\n      return \"\";\n    }\n\n    return \"#\" + this._url.fragment;\n  }\n\n  set hash(v) {\n    if (v === \"\") {\n      this._url.fragment = null;\n      return;\n    }\n\n    const input = v[0] === \"#\" ? v.substring(1) : v;\n    this._url.fragment = \"\";\n    usm.basicURLParse(input, { url: this._url, stateOverride: \"fragment\" });\n  }\n\n  toJSON() {\n    return this.href;\n  }\n};\n","\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Impl = require(\".//URL-impl.js\");\n\nconst impl = utils.implSymbol;\n\nfunction URL(url) {\n  if (!this || this[impl] || !(this instanceof URL)) {\n    throw new TypeError(\"Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'URL': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"USVString\"](args[1]);\n  }\n\n  module.exports.setup(this, args);\n}\n\nURL.prototype.toJSON = function toJSON() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = arguments[i];\n  }\n  return this[impl].toJSON.apply(this[impl], args);\n};\nObject.defineProperty(URL.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nURL.prototype.toString = function () {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this.href;\n};\n\nObject.defineProperty(URL.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"protocol\", {\n  get() {\n    return this[impl].protocol;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].protocol = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"username\", {\n  get() {\n    return this[impl].username;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].username = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"password\", {\n  get() {\n    return this[impl].password;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].password = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"host\", {\n  get() {\n    return this[impl].host;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].host = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hostname\", {\n  get() {\n    return this[impl].hostname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hostname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"port\", {\n  get() {\n    return this[impl].port;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].port = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"pathname\", {\n  get() {\n    return this[impl].pathname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].pathname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"search\", {\n  get() {\n    return this[impl].search;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].search = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hash\", {\n  get() {\n    return this[impl].hash;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hash = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nmodule.exports = {\n  is(obj) {\n    return !!obj && obj[impl] instanceof Impl.implementation;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(URL.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: URL,\n  expose: {\n    Window: { URL: URL },\n    Worker: { URL: URL }\n  }\n};\n\n","\"use strict\";\n\nexports.URL = require(\"./URL\").interface;\nexports.serializeURL = require(\"./url-state-machine\").serializeURL;\nexports.serializeURLOrigin = require(\"./url-state-machine\").serializeURLOrigin;\nexports.basicURLParse = require(\"./url-state-machine\").basicURLParse;\nexports.setTheUsername = require(\"./url-state-machine\").setTheUsername;\nexports.setThePassword = require(\"./url-state-machine\").setThePassword;\nexports.serializeHost = require(\"./url-state-machine\").serializeHost;\nexports.serializeInteger = require(\"./url-state-machine\").serializeInteger;\nexports.parseURL = require(\"./url-state-machine\").parseURL;\n","\"use strict\";\r\nconst punycode = require(\"punycode\");\r\nconst tr46 = require(\"tr46\");\r\n\r\nconst specialSchemes = {\r\n  ftp: 21,\r\n  file: null,\r\n  gopher: 70,\r\n  http: 80,\r\n  https: 443,\r\n  ws: 80,\r\n  wss: 443\r\n};\r\n\r\nconst failure = Symbol(\"failure\");\r\n\r\nfunction countSymbols(str) {\r\n  return punycode.ucs2.decode(str).length;\r\n}\r\n\r\nfunction at(input, idx) {\r\n  const c = input[idx];\r\n  return isNaN(c) ? undefined : String.fromCodePoint(c);\r\n}\r\n\r\nfunction isASCIIDigit(c) {\r\n  return c >= 0x30 && c <= 0x39;\r\n}\r\n\r\nfunction isASCIIAlpha(c) {\r\n  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);\r\n}\r\n\r\nfunction isASCIIAlphanumeric(c) {\r\n  return isASCIIAlpha(c) || isASCIIDigit(c);\r\n}\r\n\r\nfunction isASCIIHex(c) {\r\n  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);\r\n}\r\n\r\nfunction isSingleDot(buffer) {\r\n  return buffer === \".\" || buffer.toLowerCase() === \"%2e\";\r\n}\r\n\r\nfunction isDoubleDot(buffer) {\r\n  buffer = buffer.toLowerCase();\r\n  return buffer === \"..\" || buffer === \"%2e.\" || buffer === \".%2e\" || buffer === \"%2e%2e\";\r\n}\r\n\r\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\r\n  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);\r\n}\r\n\r\nfunction isWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === \":\" || string[1] === \"|\");\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === \":\";\r\n}\r\n\r\nfunction containsForbiddenHostCodePoint(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|%|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction isSpecialScheme(scheme) {\r\n  return specialSchemes[scheme] !== undefined;\r\n}\r\n\r\nfunction isSpecial(url) {\r\n  return isSpecialScheme(url.scheme);\r\n}\r\n\r\nfunction defaultPort(scheme) {\r\n  return specialSchemes[scheme];\r\n}\r\n\r\nfunction percentEncode(c) {\r\n  let hex = c.toString(16).toUpperCase();\r\n  if (hex.length === 1) {\r\n    hex = \"0\" + hex;\r\n  }\r\n\r\n  return \"%\" + hex;\r\n}\r\n\r\nfunction utf8PercentEncode(c) {\r\n  const buf = new Buffer(c);\r\n\r\n  let str = \"\";\r\n\r\n  for (let i = 0; i < buf.length; ++i) {\r\n    str += percentEncode(buf[i]);\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\nfunction utf8PercentDecode(str) {\r\n  const input = new Buffer(str);\r\n  const output = [];\r\n  for (let i = 0; i < input.length; ++i) {\r\n    if (input[i] !== 37) {\r\n      output.push(input[i]);\r\n    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {\r\n      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));\r\n      i += 2;\r\n    } else {\r\n      output.push(input[i]);\r\n    }\r\n  }\r\n  return new Buffer(output).toString();\r\n}\r\n\r\nfunction isC0ControlPercentEncode(c) {\r\n  return c <= 0x1F || c > 0x7E;\r\n}\r\n\r\nconst extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);\r\nfunction isPathPercentEncode(c) {\r\n  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);\r\n}\r\n\r\nconst extraUserinfoPercentEncodeSet =\r\n  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);\r\nfunction isUserinfoPercentEncode(c) {\r\n  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\r\n}\r\n\r\nfunction percentEncodeChar(c, encodeSetPredicate) {\r\n  const cStr = String.fromCodePoint(c);\r\n\r\n  if (encodeSetPredicate(c)) {\r\n    return utf8PercentEncode(cStr);\r\n  }\r\n\r\n  return cStr;\r\n}\r\n\r\nfunction parseIPv4Number(input) {\r\n  let R = 10;\r\n\r\n  if (input.length >= 2 && input.charAt(0) === \"0\" && input.charAt(1).toLowerCase() === \"x\") {\r\n    input = input.substring(2);\r\n    R = 16;\r\n  } else if (input.length >= 2 && input.charAt(0) === \"0\") {\r\n    input = input.substring(1);\r\n    R = 8;\r\n  }\r\n\r\n  if (input === \"\") {\r\n    return 0;\r\n  }\r\n\r\n  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);\r\n  if (regex.test(input)) {\r\n    return failure;\r\n  }\r\n\r\n  return parseInt(input, R);\r\n}\r\n\r\nfunction parseIPv4(input) {\r\n  const parts = input.split(\".\");\r\n  if (parts[parts.length - 1] === \"\") {\r\n    if (parts.length > 1) {\r\n      parts.pop();\r\n    }\r\n  }\r\n\r\n  if (parts.length > 4) {\r\n    return input;\r\n  }\r\n\r\n  const numbers = [];\r\n  for (const part of parts) {\r\n    if (part === \"\") {\r\n      return input;\r\n    }\r\n    const n = parseIPv4Number(part);\r\n    if (n === failure) {\r\n      return input;\r\n    }\r\n\r\n    numbers.push(n);\r\n  }\r\n\r\n  for (let i = 0; i < numbers.length - 1; ++i) {\r\n    if (numbers[i] > 255) {\r\n      return failure;\r\n    }\r\n  }\r\n  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\r\n    return failure;\r\n  }\r\n\r\n  let ipv4 = numbers.pop();\r\n  let counter = 0;\r\n\r\n  for (const n of numbers) {\r\n    ipv4 += n * Math.pow(256, 3 - counter);\r\n    ++counter;\r\n  }\r\n\r\n  return ipv4;\r\n}\r\n\r\nfunction serializeIPv4(address) {\r\n  let output = \"\";\r\n  let n = address;\r\n\r\n  for (let i = 1; i <= 4; ++i) {\r\n    output = String(n % 256) + output;\r\n    if (i !== 4) {\r\n      output = \".\" + output;\r\n    }\r\n    n = Math.floor(n / 256);\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseIPv6(input) {\r\n  const address = [0, 0, 0, 0, 0, 0, 0, 0];\r\n  let pieceIndex = 0;\r\n  let compress = null;\r\n  let pointer = 0;\r\n\r\n  input = punycode.ucs2.decode(input);\r\n\r\n  if (input[pointer] === 58) {\r\n    if (input[pointer + 1] !== 58) {\r\n      return failure;\r\n    }\r\n\r\n    pointer += 2;\r\n    ++pieceIndex;\r\n    compress = pieceIndex;\r\n  }\r\n\r\n  while (pointer < input.length) {\r\n    if (pieceIndex === 8) {\r\n      return failure;\r\n    }\r\n\r\n    if (input[pointer] === 58) {\r\n      if (compress !== null) {\r\n        return failure;\r\n      }\r\n      ++pointer;\r\n      ++pieceIndex;\r\n      compress = pieceIndex;\r\n      continue;\r\n    }\r\n\r\n    let value = 0;\r\n    let length = 0;\r\n\r\n    while (length < 4 && isASCIIHex(input[pointer])) {\r\n      value = value * 0x10 + parseInt(at(input, pointer), 16);\r\n      ++pointer;\r\n      ++length;\r\n    }\r\n\r\n    if (input[pointer] === 46) {\r\n      if (length === 0) {\r\n        return failure;\r\n      }\r\n\r\n      pointer -= length;\r\n\r\n      if (pieceIndex > 6) {\r\n        return failure;\r\n      }\r\n\r\n      let numbersSeen = 0;\r\n\r\n      while (input[pointer] !== undefined) {\r\n        let ipv4Piece = null;\r\n\r\n        if (numbersSeen > 0) {\r\n          if (input[pointer] === 46 && numbersSeen < 4) {\r\n            ++pointer;\r\n          } else {\r\n            return failure;\r\n          }\r\n        }\r\n\r\n        if (!isASCIIDigit(input[pointer])) {\r\n          return failure;\r\n        }\r\n\r\n        while (isASCIIDigit(input[pointer])) {\r\n          const number = parseInt(at(input, pointer));\r\n          if (ipv4Piece === null) {\r\n            ipv4Piece = number;\r\n          } else if (ipv4Piece === 0) {\r\n            return failure;\r\n          } else {\r\n            ipv4Piece = ipv4Piece * 10 + number;\r\n          }\r\n          if (ipv4Piece > 255) {\r\n            return failure;\r\n          }\r\n          ++pointer;\r\n        }\r\n\r\n        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\r\n\r\n        ++numbersSeen;\r\n\r\n        if (numbersSeen === 2 || numbersSeen === 4) {\r\n          ++pieceIndex;\r\n        }\r\n      }\r\n\r\n      if (numbersSeen !== 4) {\r\n        return failure;\r\n      }\r\n\r\n      break;\r\n    } else if (input[pointer] === 58) {\r\n      ++pointer;\r\n      if (input[pointer] === undefined) {\r\n        return failure;\r\n      }\r\n    } else if (input[pointer] !== undefined) {\r\n      return failure;\r\n    }\r\n\r\n    address[pieceIndex] = value;\r\n    ++pieceIndex;\r\n  }\r\n\r\n  if (compress !== null) {\r\n    let swaps = pieceIndex - compress;\r\n    pieceIndex = 7;\r\n    while (pieceIndex !== 0 && swaps > 0) {\r\n      const temp = address[compress + swaps - 1];\r\n      address[compress + swaps - 1] = address[pieceIndex];\r\n      address[pieceIndex] = temp;\r\n      --pieceIndex;\r\n      --swaps;\r\n    }\r\n  } else if (compress === null && pieceIndex !== 8) {\r\n    return failure;\r\n  }\r\n\r\n  return address;\r\n}\r\n\r\nfunction serializeIPv6(address) {\r\n  let output = \"\";\r\n  const seqResult = findLongestZeroSequence(address);\r\n  const compress = seqResult.idx;\r\n  let ignore0 = false;\r\n\r\n  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {\r\n    if (ignore0 && address[pieceIndex] === 0) {\r\n      continue;\r\n    } else if (ignore0) {\r\n      ignore0 = false;\r\n    }\r\n\r\n    if (compress === pieceIndex) {\r\n      const separator = pieceIndex === 0 ? \"::\" : \":\";\r\n      output += separator;\r\n      ignore0 = true;\r\n      continue;\r\n    }\r\n\r\n    output += address[pieceIndex].toString(16);\r\n\r\n    if (pieceIndex !== 7) {\r\n      output += \":\";\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseHost(input, isSpecialArg) {\r\n  if (input[0] === \"[\") {\r\n    if (input[input.length - 1] !== \"]\") {\r\n      return failure;\r\n    }\r\n\r\n    return parseIPv6(input.substring(1, input.length - 1));\r\n  }\r\n\r\n  if (!isSpecialArg) {\r\n    return parseOpaqueHost(input);\r\n  }\r\n\r\n  const domain = utf8PercentDecode(input);\r\n  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);\r\n  if (asciiDomain === null) {\r\n    return failure;\r\n  }\r\n\r\n  if (containsForbiddenHostCodePoint(asciiDomain)) {\r\n    return failure;\r\n  }\r\n\r\n  const ipv4Host = parseIPv4(asciiDomain);\r\n  if (typeof ipv4Host === \"number\" || ipv4Host === failure) {\r\n    return ipv4Host;\r\n  }\r\n\r\n  return asciiDomain;\r\n}\r\n\r\nfunction parseOpaqueHost(input) {\r\n  if (containsForbiddenHostCodePointExcludingPercent(input)) {\r\n    return failure;\r\n  }\r\n\r\n  let output = \"\";\r\n  const decoded = punycode.ucs2.decode(input);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);\r\n  }\r\n  return output;\r\n}\r\n\r\nfunction findLongestZeroSequence(arr) {\r\n  let maxIdx = null;\r\n  let maxLen = 1; // only find elements > 1\r\n  let currStart = null;\r\n  let currLen = 0;\r\n\r\n  for (let i = 0; i < arr.length; ++i) {\r\n    if (arr[i] !== 0) {\r\n      if (currLen > maxLen) {\r\n        maxIdx = currStart;\r\n        maxLen = currLen;\r\n      }\r\n\r\n      currStart = null;\r\n      currLen = 0;\r\n    } else {\r\n      if (currStart === null) {\r\n        currStart = i;\r\n      }\r\n      ++currLen;\r\n    }\r\n  }\r\n\r\n  // if trailing zeros\r\n  if (currLen > maxLen) {\r\n    maxIdx = currStart;\r\n    maxLen = currLen;\r\n  }\r\n\r\n  return {\r\n    idx: maxIdx,\r\n    len: maxLen\r\n  };\r\n}\r\n\r\nfunction serializeHost(host) {\r\n  if (typeof host === \"number\") {\r\n    return serializeIPv4(host);\r\n  }\r\n\r\n  // IPv6 serializer\r\n  if (host instanceof Array) {\r\n    return \"[\" + serializeIPv6(host) + \"]\";\r\n  }\r\n\r\n  return host;\r\n}\r\n\r\nfunction trimControlChars(url) {\r\n  return url.replace(/^[\\u0000-\\u001F\\u0020]+|[\\u0000-\\u001F\\u0020]+$/g, \"\");\r\n}\r\n\r\nfunction trimTabAndNewline(url) {\r\n  return url.replace(/\\u0009|\\u000A|\\u000D/g, \"\");\r\n}\r\n\r\nfunction shortenPath(url) {\r\n  const path = url.path;\r\n  if (path.length === 0) {\r\n    return;\r\n  }\r\n  if (url.scheme === \"file\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\r\n    return;\r\n  }\r\n\r\n  path.pop();\r\n}\r\n\r\nfunction includesCredentials(url) {\r\n  return url.username !== \"\" || url.password !== \"\";\r\n}\r\n\r\nfunction cannotHaveAUsernamePasswordPort(url) {\r\n  return url.host === null || url.host === \"\" || url.cannotBeABaseURL || url.scheme === \"file\";\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetter(string) {\r\n  return /^[A-Za-z]:$/.test(string);\r\n}\r\n\r\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\r\n  this.pointer = 0;\r\n  this.input = input;\r\n  this.base = base || null;\r\n  this.encodingOverride = encodingOverride || \"utf-8\";\r\n  this.stateOverride = stateOverride;\r\n  this.url = url;\r\n  this.failure = false;\r\n  this.parseError = false;\r\n\r\n  if (!this.url) {\r\n    this.url = {\r\n      scheme: \"\",\r\n      username: \"\",\r\n      password: \"\",\r\n      host: null,\r\n      port: null,\r\n      path: [],\r\n      query: null,\r\n      fragment: null,\r\n\r\n      cannotBeABaseURL: false\r\n    };\r\n\r\n    const res = trimControlChars(this.input);\r\n    if (res !== this.input) {\r\n      this.parseError = true;\r\n    }\r\n    this.input = res;\r\n  }\r\n\r\n  const res = trimTabAndNewline(this.input);\r\n  if (res !== this.input) {\r\n    this.parseError = true;\r\n  }\r\n  this.input = res;\r\n\r\n  this.state = stateOverride || \"scheme start\";\r\n\r\n  this.buffer = \"\";\r\n  this.atFlag = false;\r\n  this.arrFlag = false;\r\n  this.passwordTokenSeenFlag = false;\r\n\r\n  this.input = punycode.ucs2.decode(this.input);\r\n\r\n  for (; this.pointer <= this.input.length; ++this.pointer) {\r\n    const c = this.input[this.pointer];\r\n    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);\r\n\r\n    // exec state machine\r\n    const ret = this[\"parse \" + this.state](c, cStr);\r\n    if (!ret) {\r\n      break; // terminate algorithm\r\n    } else if (ret === failure) {\r\n      this.failure = true;\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nURLStateMachine.prototype[\"parse scheme start\"] = function parseSchemeStart(c, cStr) {\r\n  if (isASCIIAlpha(c)) {\r\n    this.buffer += cStr.toLowerCase();\r\n    this.state = \"scheme\";\r\n  } else if (!this.stateOverride) {\r\n    this.state = \"no scheme\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse scheme\"] = function parseScheme(c, cStr) {\r\n  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {\r\n    this.buffer += cStr.toLowerCase();\r\n  } else if (c === 58) {\r\n    if (this.stateOverride) {\r\n      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \"file\") {\r\n        return false;\r\n      }\r\n\r\n      if (this.url.scheme === \"file\" && (this.url.host === \"\" || this.url.host === null)) {\r\n        return false;\r\n      }\r\n    }\r\n    this.url.scheme = this.buffer;\r\n    this.buffer = \"\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    if (this.url.scheme === \"file\") {\r\n      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {\r\n        this.parseError = true;\r\n      }\r\n      this.state = \"file\";\r\n    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\r\n      this.state = \"special relative or authority\";\r\n    } else if (isSpecial(this.url)) {\r\n      this.state = \"special authority slashes\";\r\n    } else if (this.input[this.pointer + 1] === 47) {\r\n      this.state = \"path or authority\";\r\n      ++this.pointer;\r\n    } else {\r\n      this.url.cannotBeABaseURL = true;\r\n      this.url.path.push(\"\");\r\n      this.state = \"cannot-be-a-base-URL path\";\r\n    }\r\n  } else if (!this.stateOverride) {\r\n    this.buffer = \"\";\r\n    this.state = \"no scheme\";\r\n    this.pointer = -1;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse no scheme\"] = function parseNoScheme(c) {\r\n  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {\r\n    return failure;\r\n  } else if (this.base.cannotBeABaseURL && c === 35) {\r\n    this.url.scheme = this.base.scheme;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.url.cannotBeABaseURL = true;\r\n    this.state = \"fragment\";\r\n  } else if (this.base.scheme === \"file\") {\r\n    this.state = \"file\";\r\n    --this.pointer;\r\n  } else {\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special relative or authority\"] = function parseSpecialRelativeOrAuthority(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path or authority\"] = function parsePathOrAuthority(c) {\r\n  if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative\"] = function parseRelative(c) {\r\n  this.url.scheme = this.base.scheme;\r\n  if (isNaN(c)) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n  } else if (c === 47) {\r\n    this.state = \"relative slash\";\r\n  } else if (c === 63) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (isSpecial(this.url) && c === 92) {\r\n    this.parseError = true;\r\n    this.state = \"relative slash\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice(0, this.base.path.length - 1);\r\n\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative slash\"] = function parseRelativeSlash(c) {\r\n  if (isSpecial(this.url) && (c === 47 || c === 92)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"special authority ignore slashes\";\r\n  } else if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority slashes\"] = function parseSpecialAuthoritySlashes(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"special authority ignore slashes\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority ignore slashes\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\r\n  if (c !== 47 && c !== 92) {\r\n    this.state = \"authority\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse authority\"] = function parseAuthority(c, cStr) {\r\n  if (c === 64) {\r\n    this.parseError = true;\r\n    if (this.atFlag) {\r\n      this.buffer = \"%40\" + this.buffer;\r\n    }\r\n    this.atFlag = true;\r\n\r\n    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\r\n    const len = countSymbols(this.buffer);\r\n    for (let pointer = 0; pointer < len; ++pointer) {\r\n      const codePoint = this.buffer.codePointAt(pointer);\r\n\r\n      if (codePoint === 58 && !this.passwordTokenSeenFlag) {\r\n        this.passwordTokenSeenFlag = true;\r\n        continue;\r\n      }\r\n      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);\r\n      if (this.passwordTokenSeenFlag) {\r\n        this.url.password += encodedCodePoints;\r\n      } else {\r\n        this.url.username += encodedCodePoints;\r\n      }\r\n    }\r\n    this.buffer = \"\";\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    if (this.atFlag && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n    this.pointer -= countSymbols(this.buffer) + 1;\r\n    this.buffer = \"\";\r\n    this.state = \"host\";\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse hostname\"] =\r\nURLStateMachine.prototype[\"parse host\"] = function parseHostName(c, cStr) {\r\n  if (this.stateOverride && this.url.scheme === \"file\") {\r\n    --this.pointer;\r\n    this.state = \"file host\";\r\n  } else if (c === 58 && !this.arrFlag) {\r\n    if (this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"port\";\r\n    if (this.stateOverride === \"hostname\") {\r\n      return false;\r\n    }\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    --this.pointer;\r\n    if (isSpecial(this.url) && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    } else if (this.stateOverride && this.buffer === \"\" &&\r\n               (includesCredentials(this.url) || this.url.port !== null)) {\r\n      this.parseError = true;\r\n      return false;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"path start\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n  } else {\r\n    if (c === 91) {\r\n      this.arrFlag = true;\r\n    } else if (c === 93) {\r\n      this.arrFlag = false;\r\n    }\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse port\"] = function parsePort(c, cStr) {\r\n  if (isASCIIDigit(c)) {\r\n    this.buffer += cStr;\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92) ||\r\n             this.stateOverride) {\r\n    if (this.buffer !== \"\") {\r\n      const port = parseInt(this.buffer);\r\n      if (port > Math.pow(2, 16) - 1) {\r\n        this.parseError = true;\r\n        return failure;\r\n      }\r\n      this.url.port = port === defaultPort(this.url.scheme) ? null : port;\r\n      this.buffer = \"\";\r\n    }\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    this.state = \"path start\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);\r\n\r\nURLStateMachine.prototype[\"parse file\"] = function parseFile(c) {\r\n  this.url.scheme = \"file\";\r\n\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file slash\";\r\n  } else if (this.base !== null && this.base.scheme === \"file\") {\r\n    if (isNaN(c)) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n    } else if (c === 63) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    } else if (c === 35) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    } else {\r\n      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points\r\n          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||\r\n          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points\r\n           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {\r\n        this.url.host = this.base.host;\r\n        this.url.path = this.base.path.slice();\r\n        shortenPath(this.url);\r\n      } else {\r\n        this.parseError = true;\r\n      }\r\n\r\n      this.state = \"path\";\r\n      --this.pointer;\r\n    }\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file slash\"] = function parseFileSlash(c) {\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file host\";\r\n  } else {\r\n    if (this.base !== null && this.base.scheme === \"file\") {\r\n      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {\r\n        this.url.path.push(this.base.path[0]);\r\n      } else {\r\n        this.url.host = this.base.host;\r\n      }\r\n    }\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file host\"] = function parseFileHost(c, cStr) {\r\n  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {\r\n    --this.pointer;\r\n    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\r\n      this.parseError = true;\r\n      this.state = \"path\";\r\n    } else if (this.buffer === \"\") {\r\n      this.url.host = \"\";\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n      this.state = \"path start\";\r\n    } else {\r\n      let host = parseHost(this.buffer, isSpecial(this.url));\r\n      if (host === failure) {\r\n        return failure;\r\n      }\r\n      if (host === \"localhost\") {\r\n        host = \"\";\r\n      }\r\n      this.url.host = host;\r\n\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n\r\n      this.buffer = \"\";\r\n      this.state = \"path start\";\r\n    }\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path start\"] = function parsePathStart(c) {\r\n  if (isSpecial(this.url)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"path\";\r\n\r\n    if (c !== 47 && c !== 92) {\r\n      --this.pointer;\r\n    }\r\n  } else if (!this.stateOverride && c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (!this.stateOverride && c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (c !== undefined) {\r\n    this.state = \"path\";\r\n    if (c !== 47) {\r\n      --this.pointer;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path\"] = function parsePath(c) {\r\n  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||\r\n      (!this.stateOverride && (c === 63 || c === 35))) {\r\n    if (isSpecial(this.url) && c === 92) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (isDoubleDot(this.buffer)) {\r\n      shortenPath(this.url);\r\n      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {\r\n        this.url.path.push(\"\");\r\n      }\r\n    } else if (isSingleDot(this.buffer) && c !== 47 &&\r\n               !(isSpecial(this.url) && c === 92)) {\r\n      this.url.path.push(\"\");\r\n    } else if (!isSingleDot(this.buffer)) {\r\n      if (this.url.scheme === \"file\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\r\n        if (this.url.host !== \"\" && this.url.host !== null) {\r\n          this.parseError = true;\r\n          this.url.host = \"\";\r\n        }\r\n        this.buffer = this.buffer[0] + \":\";\r\n      }\r\n      this.url.path.push(this.buffer);\r\n    }\r\n    this.buffer = \"\";\r\n    if (this.url.scheme === \"file\" && (c === undefined || c === 63 || c === 35)) {\r\n      while (this.url.path.length > 1 && this.url.path[0] === \"\") {\r\n        this.parseError = true;\r\n        this.url.path.shift();\r\n      }\r\n    }\r\n    if (c === 63) {\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    }\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += percentEncodeChar(c, isPathPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse cannot-be-a-base-URL path\"] = function parseCannotBeABaseURLPath(c) {\r\n  if (c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else {\r\n    // TODO: Add: not a URL code point\r\n    if (!isNaN(c) && c !== 37) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (c === 37 &&\r\n        (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n         !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (!isNaN(c)) {\r\n      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse query\"] = function parseQuery(c, cStr) {\r\n  if (isNaN(c) || (!this.stateOverride && c === 35)) {\r\n    if (!isSpecial(this.url) || this.url.scheme === \"ws\" || this.url.scheme === \"wss\") {\r\n      this.encodingOverride = \"utf-8\";\r\n    }\r\n\r\n    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead\r\n    for (let i = 0; i < buffer.length; ++i) {\r\n      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||\r\n          buffer[i] === 0x3C || buffer[i] === 0x3E) {\r\n        this.url.query += percentEncode(buffer[i]);\r\n      } else {\r\n        this.url.query += String.fromCodePoint(buffer[i]);\r\n      }\r\n    }\r\n\r\n    this.buffer = \"\";\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse fragment\"] = function parseFragment(c) {\r\n  if (isNaN(c)) { // do nothing\r\n  } else if (c === 0x0) {\r\n    this.parseError = true;\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction serializeURL(url, excludeFragment) {\r\n  let output = url.scheme + \":\";\r\n  if (url.host !== null) {\r\n    output += \"//\";\r\n\r\n    if (url.username !== \"\" || url.password !== \"\") {\r\n      output += url.username;\r\n      if (url.password !== \"\") {\r\n        output += \":\" + url.password;\r\n      }\r\n      output += \"@\";\r\n    }\r\n\r\n    output += serializeHost(url.host);\r\n\r\n    if (url.port !== null) {\r\n      output += \":\" + url.port;\r\n    }\r\n  } else if (url.host === null && url.scheme === \"file\") {\r\n    output += \"//\";\r\n  }\r\n\r\n  if (url.cannotBeABaseURL) {\r\n    output += url.path[0];\r\n  } else {\r\n    for (const string of url.path) {\r\n      output += \"/\" + string;\r\n    }\r\n  }\r\n\r\n  if (url.query !== null) {\r\n    output += \"?\" + url.query;\r\n  }\r\n\r\n  if (!excludeFragment && url.fragment !== null) {\r\n    output += \"#\" + url.fragment;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction serializeOrigin(tuple) {\r\n  let result = tuple.scheme + \"://\";\r\n  result += serializeHost(tuple.host);\r\n\r\n  if (tuple.port !== null) {\r\n    result += \":\" + tuple.port;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports.serializeURL = serializeURL;\r\n\r\nmodule.exports.serializeURLOrigin = function (url) {\r\n  // https://url.spec.whatwg.org/#concept-url-origin\r\n  switch (url.scheme) {\r\n    case \"blob\":\r\n      try {\r\n        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));\r\n      } catch (e) {\r\n        // serializing an opaque origin returns \"null\"\r\n        return \"null\";\r\n      }\r\n    case \"ftp\":\r\n    case \"gopher\":\r\n    case \"http\":\r\n    case \"https\":\r\n    case \"ws\":\r\n    case \"wss\":\r\n      return serializeOrigin({\r\n        scheme: url.scheme,\r\n        host: url.host,\r\n        port: url.port\r\n      });\r\n    case \"file\":\r\n      // spec says \"exercise to the reader\", chrome says \"file://\"\r\n      return \"file://\";\r\n    default:\r\n      // serializing an opaque origin returns \"null\"\r\n      return \"null\";\r\n  }\r\n};\r\n\r\nmodule.exports.basicURLParse = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\r\n  if (usm.failure) {\r\n    return \"failure\";\r\n  }\r\n\r\n  return usm.url;\r\n};\r\n\r\nmodule.exports.setTheUsername = function (url, username) {\r\n  url.username = \"\";\r\n  const decoded = punycode.ucs2.decode(username);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.setThePassword = function (url, password) {\r\n  url.password = \"\";\r\n  const decoded = punycode.ucs2.decode(password);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.serializeHost = serializeHost;\r\n\r\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\r\n\r\nmodule.exports.serializeInteger = function (integer) {\r\n  return String(integer);\r\n};\r\n\r\nmodule.exports.parseURL = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  // We don't handle blobs, so this just delegates:\r\n  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });\r\n};\r\n","\"use strict\";\n\nmodule.exports.mixin = function mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nmodule.exports.wrapperSymbol = Symbol(\"wrapper\");\nmodule.exports.implSymbol = Symbol(\"impl\");\n\nmodule.exports.wrapperForImpl = function (impl) {\n  return impl[module.exports.wrapperSymbol];\n};\n\nmodule.exports.implForWrapper = function (wrapper) {\n  return wrapper[module.exports.implSymbol];\n};\n\n","module.exports = require(\"node:fs/promises\");","module.exports = require(\"punycode\");","import fetch from 'cross-fetch';\nexport async function getFile(uri) {\n    let buffer;\n    // let response = await fetch(uri)\n    // if (response?.ok){\n    //   buffer = await response.arrayBuffer();\n    // } else {\n    //   console.log(\"No file found \"+ uri)\n    //   return null\n    // }\n    try {\n        const response = await fetch(uri);\n        if (response?.ok) {\n            buffer = await response.arrayBuffer();\n        }\n        else {\n            console.log(\"No file found \" + uri);\n            return null;\n        }\n    }\n    catch (error) {\n        console.error(\"Failed to fetch URI:\", uri, \"\\nError:\", error);\n        return null;\n    }\n    return buffer;\n}\n//# sourceMappingURL=getFile.js.map","import { readFile } from \"node:fs/promises\";\n// import path from 'path';\n// import {fileURLToPath} from 'url';\n// const __filename = fileURLToPath(import.meta.url);\n// const __dirname = path.dirname(__filename);\nexport async function getLocalFile(path) {\n    // let buffer: Buffer;\n    try {\n        const response = await readFile(path);\n        if (response) {\n            return response;\n        }\n        else {\n            return null;\n        }\n        // buffer = await readFile(path);\n    }\n    catch (error) {\n        console.error(\"Failed to read path:\", path, \"\\nError:\", error);\n        return null;\n    }\n}\n//# sourceMappingURL=getLocalFile.js.map","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"stream\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"http\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"url\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"https\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"zlib\");","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport whatwgUrl from 'whatwg-url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString();\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr);\n}\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parseURL(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parseURL(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parseURL(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\nconst URL$1 = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\n\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n\tconst orig = new URL$1(original).hostname;\n\tconst dest = new URL$1(destination).hostname;\n\n\treturn orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nconst isSameProtocol = function isSameProtocol(destination, original) {\n\tconst orig = new URL$1(original).protocol;\n\tconst dest = new URL$1(destination).protocol;\n\n\treturn orig === dest;\n};\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\tdestroyStream(request.body, error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(req, function (err) {\n\t\t\tif (signal && signal.aborted) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (response && response.body) {\n\t\t\t\tdestroyStream(response.body, err);\n\t\t\t}\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (parseInt(process.version.substring(1)) < 14) {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\treq.on('socket', function (s) {\n\t\t\t\ts.addListener('close', function (hadError) {\n\t\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\t\tconst hasDataListener = s.listenerCount('data') > 0;\n\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n\t\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tlet locationURL = null;\n\t\t\t\ttry {\n\t\t\t\t\tlocationURL = location === null ? null : new URL$1(location, request.url).toString();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// error here can only be invalid URL in Location: header\n\t\t\t\t\t// do not throw when options.redirect == manual\n\t\t\t\t\t// let the user extract the errorneous redirect URL\n\t\t\t\t\tif (request.redirect !== 'manual') {\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n\t\t\t\t\t\t\tfor (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n\t\t\t\t\t\t\t\trequestOpts.headers.delete(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\traw.on('end', function () {\n\t\t\t\t\t// some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n\t\t\t\t\tif (!response) {\n\t\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\t\tresolve(response);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tlet socket;\n\n\trequest.on('socket', function (s) {\n\t\tsocket = s;\n\t});\n\n\trequest.on('response', function (response) {\n\t\tconst headers = response.headers;\n\n\t\tif (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {\n\t\t\tresponse.once('close', function (hadError) {\n\t\t\t\t// tests for socket presence, as in some situations the\n\t\t\t\t// the 'socket' event is not triggered for the request\n\t\t\t\t// (happens in deno), avoids `TypeError`\n\t\t\t\t// if a data listener is still present we didn't end cleanly\n\t\t\t\tconst hasDataListener = socket && socket.listenerCount('data') > 0;\n\n\t\t\t\tif (hasDataListener && !hadError) {\n\t\t\t\t\tconst err = new Error('Premature close');\n\t\t\t\t\terr.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\terrorCallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction destroyStream(stream, err) {\n\tif (stream.destroy) {\n\t\tstream.destroy(err);\n\t} else {\n\t\t// node < 8\n\t\tstream.emit('error', err);\n\t\tstream.end();\n\t}\n}\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError, AbortError };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","// import { FITSHeader } from \"./model/FITSHeader.js\"\nimport * as fs from 'fs';\nexport class FITSWriter {\n    static createFITS(fitsParsed) {\n        const headerBytes = this.createHeader(fitsParsed.header);\n        const dataBytes = this.createData(fitsParsed.data, fitsParsed.header);\n        const fitsFile = new Uint8Array(headerBytes.length + dataBytes.length);\n        fitsFile.set(headerBytes, 0);\n        fitsFile.set(dataBytes, headerBytes.length);\n        return fitsFile;\n    }\n    static createHeader(header) {\n        const BLOCK = 2880;\n        const CARD = 80;\n        const MUST_INT = new Set([\"BITPIX\", \"NAXIS\", \"PCOUNT\", \"GCOUNT\"]);\n        const IS_LOGICAL = new Set([\"SIMPLE\", \"EXTEND\"]);\n        const items = header.getItems();\n        function kw(s) {\n            return (s ?? \"\").toUpperCase().padEnd(8, \" \").slice(0, 8);\n        }\n        function card80(s) {\n            return s.length >= CARD ? s.slice(0, CARD) : s.padEnd(CARD, \" \");\n        }\n        // Emit COMMENT/HISTORY as multiple 72-char lines\n        function makeCommentCards(kind, text) {\n            const prefix = kw(kind); // \"COMMENT \" or \"HISTORY \"\n            const width = CARD - prefix.length; // 72\n            const t = (text ?? \"\").toString();\n            if (!t.length)\n                return [card80(prefix)]; // allow empty COMMENT/HISTORY line\n            const out = [];\n            for (let i = 0; i < t.length; i += width) {\n                out.push(card80(prefix + t.slice(i, i + width)));\n            }\n            return out;\n        }\n        function quoteFitsString(s) {\n            const unquoted = s.replace(/^'+|'+$/g, \"\");\n            const escaped = unquoted.replace(/'/g, \"''\");\n            return `'${escaped}'`;\n        }\n        // \"= \" + 20-char value field (or proper string)\n        function valueField20(key, val) {\n            let v = \"\";\n            const K = key.toUpperCase();\n            if (IS_LOGICAL.has(K)) {\n                const tf = (val === true || val === \"T\" || val === \"t\") ? \"T\" : \"F\";\n                return `= ${tf.padStart(20, \" \")}`;\n            }\n            if (MUST_INT.has(K) || /^NAXIS\\d+$/.test(K)) {\n                const n = Number(val);\n                if (!Number.isFinite(n) || !Number.isInteger(n)) {\n                    throw new Error(`FITS header: ${K} must be an integer, got ${val}`);\n                }\n                return `= ${String(n).padStart(20, \" \")}`;\n            }\n            if (typeof val === \"number\") {\n                let s = Number.isInteger(val) ? String(val) : val.toExponential(10).replace(\"e\", \"E\");\n                if (s.length > 20)\n                    s = val.toExponential(8).replace(\"e\", \"E\");\n                return `= ${s.padStart(20, \" \")}`;\n            }\n            if (typeof val === \"string\") {\n                return `= ${quoteFitsString(val)}`; // strings can exceed 20-char field\n            }\n            return \"\";\n        }\n        // Build one keyword card, and (if needed) emit overflow as COMMENT cards\n        function makeKeywordWithComment(key, value, comment) {\n            const K = key.toUpperCase();\n            if (K === \"END\")\n                return [card80(\"END\")];\n            if (K === \"COMMENT\" || K === \"HISTORY\") {\n                const text = (value ?? comment ?? \"\").toString();\n                return makeCommentCards(K, text);\n            }\n            // Normal keyword\n            let base = kw(K) + valueField20(K, value);\n            // Attach trailing comment inside the same card if it fits\n            if (comment && comment.length > 0) {\n                const add = ` / ${comment}`;\n                const spaceLeft = CARD - base.length;\n                if (spaceLeft > 0) {\n                    const inCard = add.slice(0, spaceLeft);\n                    base = (base + inCard);\n                    // spill any overflow into COMMENT cards (strip a leading \" / \" if it didn't fit)\n                    const overflow = add.slice(spaceLeft).replace(/^\\s*\\/\\s*/, \"\");\n                    if (overflow.length > 0) {\n                        return [card80(base), ...makeCommentCards(\"COMMENT\", overflow)];\n                    }\n                }\n                else {\n                    // no room at all; put the whole comment in COMMENT lines\n                    return [card80(base), ...makeCommentCards(\"COMMENT\", comment)];\n                }\n            }\n            return [card80(base)];\n        }\n        // Build all cards with mandatory order first\n        const map = new Map(items.map(it => [it.key.toUpperCase(), it]));\n        const cards = [];\n        const simple = map.get(\"SIMPLE\");\n        if (!simple)\n            throw new Error(\"Missing mandatory SIMPLE card\");\n        cards.push(...makeKeywordWithComment(\"SIMPLE\", simple.value, simple.comment));\n        const bitpix = map.get(\"BITPIX\");\n        if (!bitpix)\n            throw new Error(\"Missing mandatory BITPIX card\");\n        cards.push(...makeKeywordWithComment(\"BITPIX\", bitpix.value, bitpix.comment));\n        const naxis = map.get(\"NAXIS\");\n        if (!naxis)\n            throw new Error(\"Missing mandatory NAXIS card\");\n        const nAxes = Number(naxis.value) || 0;\n        cards.push(...makeKeywordWithComment(\"NAXIS\", nAxes, naxis.comment));\n        for (let i = 1; i <= nAxes; i++) {\n            const ki = `NAXIS${i}`;\n            const it = map.get(ki);\n            if (!it)\n                throw new Error(`Missing mandatory ${ki} card`);\n            cards.push(...makeKeywordWithComment(ki, it.value, it.comment));\n        }\n        const extend = map.get(\"EXTEND\");\n        if (extend)\n            cards.push(...makeKeywordWithComment(\"EXTEND\", extend.value, extend.comment));\n        for (const it of items) {\n            const K = it.key.toUpperCase();\n            if (K === \"SIMPLE\" || K === \"BITPIX\" || K === \"NAXIS\" || /^NAXIS\\d+$/.test(K) || K === \"EXTEND\" || K === \"END\")\n                continue;\n            cards.push(...makeKeywordWithComment(it.key, it.value, it.comment));\n        }\n        // END + pad to 2880\n        cards.push(card80(\"END\"));\n        let headerString = cards.join(\"\");\n        const pad = headerString.length % BLOCK ? BLOCK - (headerString.length % BLOCK) : 0;\n        if (pad)\n            headerString += \" \".repeat(pad);\n        return new TextEncoder().encode(headerString);\n    }\n    static createData(data, header) {\n        // concat\n        const totalLength = data.reduce((s, c) => s + c.length, 0);\n        // OPTIONAL: verify size from BITPIX/NAXIS\n        const bitpix = Math.abs(Number(header.findById(\"BITPIX\")?.value ?? 0));\n        const naxis = Number(header.findById(\"NAXIS\")?.value ?? 0);\n        let elems = 1;\n        for (let k = 1; k <= naxis; k++) {\n            elems *= Number(header.findById(`NAXIS${k}`)?.value ?? 0);\n        }\n        const bytesPerElem = bitpix / 8;\n        const expectedUnpadded = naxis > 0 ? elems * bytesPerElem : 0;\n        if (expectedUnpadded && expectedUnpadded !== totalLength) {\n            throw new Error(`Data length ${totalLength} does not match header expectation ${expectedUnpadded} (BITPIX=${bitpix}, NAXIS=${naxis})`);\n        }\n        // build and pad\n        let dataBytes = new Uint8Array(totalLength);\n        let off = 0;\n        for (const chunk of data) {\n            dataBytes.set(chunk, off);\n            off += chunk.length;\n        }\n        const BLOCK = 2880;\n        const remainder = dataBytes.length % BLOCK;\n        if (remainder) {\n            const pad = BLOCK - remainder;\n            const padded = new Uint8Array(dataBytes.length + pad);\n            padded.set(dataBytes);\n            dataBytes = padded; // zeros already in new space\n        }\n        return dataBytes;\n    }\n    // static typedArrayToURL(fitsParsed: FITSParsed): string {\n    //   const fitsFile = FITSWriter.createFITS(fitsParsed) as Uint8Array;\n    //   const blob = new Blob([fitsFile], { type: \"application/fits\" });\n    //   // console.log(`<html><body><img src='${URL.createObjectURL(b)}'</body></html>`);\n    //   const url = URL.createObjectURL(blob);\n    //   console.log(`Generated FITS file URL: ${url}`);\n    //   return url;\n    // }\n    static writeFITSFile(fitsParsed, filePath) {\n        const fitsFile = this.createFITS(fitsParsed);\n        try {\n            fs.writeFileSync(filePath, fitsFile);\n            console.log(`FITS file written successfully to: ${filePath}`);\n        }\n        catch (error) {\n            console.error(`Error writing FITS file: ${error}`);\n        }\n    }\n}\n// const fitsParsed: FITSParsed = {\n//   header: new FITSHeader(),\n//   data: [new Uint8Array([1, 2, 3]), new Uint8Array([4, 5, 6])]\n// };\n// // Specify the file path\n// const filePath = \"/Users/fabriziogiordano/Desktop/PhD/code/new/FITSParser/output.fits\";\n// // Write the FITS file to the filesystem\n// FITSWriter.writeFITSFile(fitsParsed, filePath);\n//# sourceMappingURL=FITSWriter.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class FITSHeaderItem {\n    _key = \"\";\n    _value = \"\";\n    _comment = \"\";\n    constructor(key, value, comment) {\n        this._key = key;\n        this._value = value;\n        this._comment = comment;\n    }\n    get key() {\n        return this._key;\n    }\n    get comment() {\n        return this._comment;\n    }\n    get value() {\n        return this._value;\n    }\n}\n//# sourceMappingURL=FITSHeaderItem.js.map","import { FITSHeaderItem } from \"./FITSHeaderItem.js\";\nexport class FITSHeaderManager {\n    static SIMPLE = \"SIMPLE\";\n    static BITPIX = \"BITPIX\";\n    static BZERO = \"BZERO\";\n    static BSCALE = \"BSCALE\";\n    static BLANK = \"BLANK\";\n    static NAXIS = \"NAXIS\";\n    static NAXIS1 = \"NAXIS1\";\n    static NAXIS2 = \"NAXIS2\";\n    static DATAMIN = \"DATAMIN\";\n    static DATAMAX = \"DATAMAX\";\n    static CRVAL1 = \"CRVAL1\";\n    static CRVAL2 = \"CRVAL2\";\n    static CTYPE1 = \"CTYPE1\";\n    static CTYPE2 = \"CTYPE2\";\n    static CRPIX1 = \"CRPIX1\";\n    static CRPIX2 = \"CRPIX2\";\n    static ORIGIN = \"ORIGIN\";\n    static COMMENT = \"COMMENT\";\n    items = [];\n    constructor() {\n        this.items[0] = new FITSHeaderItem(FITSHeaderManager.SIMPLE, 'T', '');\n        this.items[1] = new FITSHeaderItem(FITSHeaderManager.BITPIX, '', '');\n        this.items[2] = new FITSHeaderItem(FITSHeaderManager.NAXIS, 2, '');\n        this.items[3] = new FITSHeaderItem(FITSHeaderManager.NAXIS1, '', '');\n        this.items[4] = new FITSHeaderItem(FITSHeaderManager.NAXIS2, '', '');\n    }\n    // insert(item: FITSHeaderItem, position?: number): void {\n    insert(item) {\n        if (item.key === FITSHeaderManager.SIMPLE) {\n            // this.items.splice(0, 0, item);\n            this.items[0] = item;\n        }\n        else if (item.key === FITSHeaderManager.BITPIX) {\n            // this.items.splice(1, 0, item);\n            this.items[1] = item;\n        }\n        else if (item.key === FITSHeaderManager.NAXIS) {\n            // this.items.splice(2, 0, item);\n            this.items[2] = item;\n        }\n        else if (item.key === FITSHeaderManager.NAXIS1) {\n            // this.items.splice(3, 0, item);\n            this.items[3] = item;\n        }\n        else if (item.key === FITSHeaderManager.NAXIS2) {\n            // this.items.splice(4, 0, item);\n            this.items[4] = item;\n        }\n        else {\n            this.items.push(item);\n        }\n        // if (position !== undefined && position >= 0 && position <= this.items.length) {\n        //     this.items.splice(position, 0, item);\n        // } else {\n        //     this.items.push(item);\n        // }\n    }\n    getItems() {\n        return this.items;\n    }\n    remove(key) {\n        this.items = this.items.filter(item => item.key !== key);\n    }\n    findById(key) {\n        const item = this.items.find(item => item.key === key);\n        if (!item) {\n            return null;\n        }\n        return item;\n    }\n}\n//# sourceMappingURL=FITSHeaderManager.js.map","// import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { FITSHeaderManager } from \"./model/FITSHeaderManager.js\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseHeader {\n    static getFITSItemValue(header, key) {\n        const item = header.findById(key);\n        let VALUE = null;\n        if (item) {\n            VALUE = Number(item.value);\n        }\n        return VALUE;\n    }\n    static parse(rawdata) {\n        // only one header block (2880) allowed atm.\n        // TODO handle multiple header blocks\n        // let headerByteData = new Uint8Array(rawdata, 0, 2880);\n        const textDecoder = new TextDecoder('ascii');\n        const headerSize = 2880; // FITS headers are in 2880-byte blocks\n        const headerText = textDecoder.decode(rawdata.slice(0, headerSize));\n        const header = new FITSHeaderManager();\n        const lines = headerText.match(/.{1,80}/g) || [];\n        for (const line of lines) {\n            const key = line.slice(0, 8).trim();\n            let value;\n            let comment = \"\";\n            if (key && key !== 'END') {\n                const rawValue = line.slice(10).trim().split('/')[0].trim();\n                if (isNaN(Number(rawValue))) {\n                    value = rawValue;\n                }\n                else {\n                    value = Number(rawValue);\n                }\n                if (line.includes('/')) {\n                    comment = line.slice(10).trim().split('/')[1].trim();\n                }\n                const item = new FITSHeaderItem(key, value, comment);\n                header.insert(item);\n            }\n        }\n        return header;\n    }\n}\n//# sourceMappingURL=ParseHeader.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseUtils {\n    static getStringAt(data, offset, length) {\n        const chars = [];\n        for (let i = offset, j = 0; i < offset + length; i++, j++) {\n            chars[j] = String.fromCharCode(data.charCodeAt(i) & 0xff);\n        }\n        return chars.join(\"\");\n    }\n    static byteString(n) {\n        if (n < 0 || n > 255 || n % 1 !== 0) {\n            throw new Error(n + \" does not fit in a byte\");\n        }\n        return (\"000000000\" + n.toString(2)).substr(-8);\n    }\n    static parse32bitSinglePrecisionFloatingPoint(byte1, byte2, byte3, byte4) {\n        let long = (((((byte1 << 8) + byte2) << 8) + byte3) << 8) + byte4;\n        if (long < 0)\n            long += 4294967296;\n        const float = (1.0 + (long & 0x007fffff) / 0x0800000) *\n            Math.pow(2, ((long & 0x7f800000) >> 23) - 127);\n        return float;\n    }\n    static convertBlankToBytes(blank, nbytes) {\n        let str = Math.abs(blank).toString(2);\n        while (str.length / 8 < nbytes) {\n            str += \"0\";\n        }\n        const buffer = new ArrayBuffer(nbytes);\n        const uint8 = new Uint8Array(buffer);\n        for (let i = 0; i < nbytes; i++) {\n            uint8[i] = parseInt(str.substr(8 * i, 8 * (i + 1)), 2);\n        }\n        return uint8;\n    }\n    /** https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac */\n    static parseFloatingPointFormat(bytes, ebits, fbits) {\n        // Bytes to bits\n        const bits = [];\n        for (let i = bytes.length; i; i -= 1) {\n            let byte = bytes[i - 1];\n            for (let j = 8; j; j -= 1) {\n                bits.push(byte % 2 ? 1 : 0);\n                byte = byte >> 1;\n            }\n        }\n        bits.reverse();\n        const str = bits.join(\"\");\n        // Unpack sign, exponent, fraction\n        const bias = (1 << (ebits - 1)) - 1;\n        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n        const e = parseInt(str.substring(1, 1 + ebits), 2);\n        const f = parseInt(str.substring(1 + ebits), 2);\n        // Produce number\n        if (e === (1 << ebits) - 1) {\n            return f !== 0 ? null : s * Infinity;\n        }\n        else if (e > 0) {\n            return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));\n        }\n        else if (f !== 0) {\n            return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));\n        }\n        else {\n            return s * 0;\n        }\n    }\n    static generate16bit2sComplement(val) {\n        throw new TypeError(\"not implemented yet\" + val);\n    }\n    static parse16bit2sComplement(byte1, byte2) {\n        const unsigned = (byte1 << 8) | byte2;\n        if (unsigned & 0x8000) {\n            return unsigned | 0xffff0000;\n        }\n        else {\n            return unsigned;\n        }\n    }\n    static parse32bit2sComplement(byte1, byte2, byte3, byte4) {\n        const unsigned = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;\n        const s = (unsigned & 0x80000000) >> 31;\n        let res = unsigned & 0xffffffff;\n        if (s) {\n            res = (~unsigned & 0xffffffff) + 1;\n            return -1 * res;\n        }\n        return res;\n    }\n    /**\n     *\n     * @param {*} data string?\n     * @param {*} offset offset in the data\n     * @returns returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index.\n     */\n    static getByteAt(data, offset) {\n        const dataOffset = 0;\n        return data.charCodeAt(offset + dataOffset) & 0xff;\n    }\n    static extractPixelValue(offset, bytes, bitpix) {\n        let px_val = null; // pixel value\n        // let px_val1, px_val2, px_val3, px_val4;\n        if (bitpix == 8) {\n            px_val = bytes[0];\n        }\n        else if (bitpix == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(bytes[offset], bytes[offset + 1]);\n        }\n        else if (bitpix == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]);\n        }\n        else if (bitpix == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 8, 23);\n        }\n        else if (bitpix == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (bitpix == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n// export default ParseUtils;\n//# sourceMappingURL=ParseUtils.js.map","// \"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n// import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { FITSHeaderManager } from \"./model/FITSHeaderManager.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\nexport class ParsePayload {\n    static computePhysicalMinAndMax(header, rawData) {\n        const BITPIX = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BITPIX);\n        if (BITPIX === null) {\n            return null;\n        }\n        const NAXIS1 = ParseHeader.getFITSItemValue(header, FITSHeaderManager.NAXIS1);\n        if (NAXIS1 === null) {\n            return null;\n        }\n        const NAXIS2 = ParseHeader.getFITSItemValue(header, FITSHeaderManager.NAXIS2);\n        if (NAXIS2 === null) {\n            return null;\n        }\n        const DATAMIN = ParseHeader.getFITSItemValue(header, FITSHeaderManager.DATAMIN);\n        const DATAMAX = ParseHeader.getFITSItemValue(header, FITSHeaderManager.DATAMAX);\n        if (!BITPIX || !NAXIS1 || !NAXIS2) {\n            return null; // return early if invalid data.\n        }\n        if (!DATAMAX || !DATAMIN) {\n            const [min, max] = ParsePayload.computePhysicalValues(rawData, header);\n            if (min && max) {\n                const maxitem = new FITSHeaderItem(\"DATAMAX\", min, \"computed by jsfitsio\");\n                const minitem = new FITSHeaderItem(\"DATAMIN\", max, \"computed by jsfitsio\");\n                header.insert(maxitem);\n                header.insert(minitem);\n            }\n        }\n        const endItem = new FITSHeaderItem('END', \"\", \"\");\n        header.insert(endItem);\n        return header;\n        // TODO: END tag shall be added here\n    }\n    static computePhysicalValues(rawData, header) {\n        const BITPIX = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BITPIX);\n        if (BITPIX === null || isNaN(BITPIX)) {\n            return [null, null];\n        }\n        const BLANK = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BLANK);\n        if (BLANK === null || isNaN(BITPIX)) {\n            return [null, null];\n        }\n        let BZERO = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BZERO);\n        if (BZERO === null) {\n            BZERO = 0;\n        }\n        let BSCALE = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BSCALE);\n        if (BSCALE === null) {\n            BSCALE = 1;\n        }\n        let i = 0;\n        const bytesXelem = Math.abs(BITPIX / 8);\n        const pxLength = rawData.byteLength / bytesXelem;\n        let min = null;\n        let max = null;\n        let physicalblank = null;\n        if (BLANK) {\n            physicalblank = ParsePayload.pixel2physicalValue(BLANK, BSCALE, BZERO);\n        }\n        while (i < pxLength) {\n            let px_val = ParsePayload.extractPixelValue(rawData, bytesXelem * i, BITPIX);\n            if (px_val === null) {\n                i++;\n                continue;\n            }\n            let ph_val = ParsePayload.pixel2physicalValue(px_val, BSCALE, BZERO);\n            if (!min) {\n                min = ph_val;\n            }\n            if (!max) {\n                max = ph_val;\n            }\n            // check this block if it is still applicable\n            if (physicalblank === null || physicalblank !== ph_val) {\n                if (ph_val !== null && (ph_val < min || min === null)) {\n                    min = ph_val;\n                }\n                if (ph_val !== null && (ph_val > max || max === null)) {\n                    max = ph_val;\n                }\n            }\n            i++;\n        }\n        return [min, max];\n    }\n    static pixel2physicalValue(pxval, BSCALE, BZERO) {\n        if (BZERO === null || BSCALE === null) {\n            throw new Error(\"Either BZERO or BSCALE is null\");\n        }\n        return BZERO + BSCALE * pxval;\n    }\n    static extractPixelValue(rawData, offset, BITPIX) {\n        let px_val = null; // pixel value\n        if (BITPIX == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(rawData[offset], rawData[offset + 1]);\n        }\n        else if (BITPIX == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(rawData[offset], rawData[offset + 1], rawData[offset + 2], rawData[offset + 3]);\n        }\n        else if (BITPIX == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(rawData.slice(offset, offset + 4), 8, 23);\n        }\n        else if (BITPIX == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (BITPIX == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(rawData.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n//# sourceMappingURL=ParsePayload.js.map","import { FITSWriter } from \"./FITSWriter.js\";\nimport { ParsePayload } from \"./ParsePayload.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\nimport { FITSHeaderManager } from \"./model/FITSHeaderManager.js\";\nexport class FITSParser {\n    static async loadFITS(url) {\n        try {\n            const uint8data = await FITSParser.getFile(url);\n            if (uint8data?.byteLength) {\n                const fits = FITSParser.processFits(uint8data);\n                return fits;\n            }\n        }\n        catch (error) {\n            console.error(\"Error loading FITS file:\", error);\n        }\n        return null;\n    }\n    static processFits(rawdata) {\n        const header = ParseHeader.parse(rawdata);\n        const headerFinalised = ParsePayload.computePhysicalMinAndMax(header, rawdata);\n        if (headerFinalised == null) {\n            return null;\n        }\n        // Assuming no additional header blocks\n        const dataOffset = 2880;\n        const payloadBuffer = new Uint8Array(rawdata.slice(dataOffset));\n        // --- pad payload to multiple of 2880 ---\n        const paddedPayload = padTo2880(payloadBuffer);\n        const payloadMatrix = FITSParser.createMatrix(paddedPayload, header);\n        return {\n            header: headerFinalised,\n            data: payloadMatrix\n        };\n        // helper\n        function padTo2880(buf) {\n            const remainder = buf.length % 2880;\n            if (remainder === 0)\n                return buf;\n            const padded = new Uint8Array(buf.length + (2880 - remainder));\n            padded.set(buf);\n            // the extra bytes are left as 0 (valid FITS padding)\n            return padded;\n        }\n    }\n    static createMatrix(payload, header) {\n        const NAXIS1 = ParseHeader.getFITSItemValue(header, FITSHeaderManager.NAXIS1);\n        if (NAXIS1 === null) {\n            throw new Error(\"NAXIS1 not defined.\");\n        }\n        const NAXIS2 = ParseHeader.getFITSItemValue(header, FITSHeaderManager.NAXIS2);\n        if (NAXIS2 === null) {\n            throw new Error(\"NAXIS2 not defined.\");\n        }\n        const BITPIX = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BITPIX);\n        if (BITPIX === null) {\n            throw new Error(\"BITPIX not defined.\");\n        }\n        const bytesXelem = Math.abs(BITPIX / 8);\n        // if (payload.length !== NAXIS1 * NAXIS2 * bytesXelem) {\n        //   throw new Error(\"Payload size does not match the expected matrix dimensions.\");\n        // }\n        // const matrix: Array<Uint8Array> = [];\n        const matrix = [];\n        for (let i = 0; i < NAXIS2; i++) {\n            matrix.push(payload.slice(i * NAXIS1 * bytesXelem, (i + 1) * NAXIS1 * bytesXelem));\n        }\n        return matrix;\n    }\n    // static generateFITSForWeb(fitsParsed: FITSParsed) {\n    //   return FITSWriter.typedArrayToURL(fitsParsed)\n    // }\n    static saveFITSLocally(fitsParsed, path) {\n        return FITSWriter.writeFITSFile(fitsParsed, path);\n    }\n    static async getFile(uri) {\n        if (!uri.substring(0, 5).toLowerCase().includes(\"http\")) {\n            const p = await import('./getLocalFile.js');\n            const rawData = await p.getLocalFile(uri);\n            if (rawData?.length) {\n                const uint8 = new Uint8Array(rawData);\n                return uint8;\n            }\n            return new Uint8Array(0);\n        }\n        else {\n            const p = await import('./getFile.js');\n            const rawData = await p.getFile(uri);\n            if (rawData?.byteLength) {\n                const uint8 = new Uint8Array(rawData);\n                return uint8;\n            }\n            return new Uint8Array(0);\n        }\n    }\n}\n// const url = \"http://skies.esac.esa.int/Herschel/normalized/PACS_hips160//Norder8/Dir40000/Npix47180.fits\"\n// FITSParser.loadFITS(url).then((fits) => {\n//   if (fits == null) {\n//     return null\n//   }\n//   const path = \"./fitsTest1.fits\"\n//   console.log(fits.header)\n//   FITSParser.saveFITSLocally(fits, path)\n//   console.log(\"finished\")\n// })\n// // const file = \"/Users/fabriziogiordano/Desktop/PhD/code/new/FITSParser/tests/inputs/empty.fits\"\n// const file = \"/Users/fabriziogiordano/Desktop/PhD/code/new/FITSParser/tests/inputs/Npix43348.fits\"\n// FITSParser.loadFITS(file).then((fits) => {\n//   if (fits == null) {\n//     return null\n//   }\n//   const path = \"./fitsTest2.fits\"\n//   console.log(fits.header)\n//   FITSParser.saveFITSLocally(fits, path)\n//   console.log(\"finished\")\n// })\n//# sourceMappingURL=FITSParser.js.map","import { FITSHeaderManager } from \"jsfitsio\";\n// import { FITSHeaderManager, FITSHeaderItem } from \"jsfitsio\";\n// import { FITSParsed } from \"jsfitsio\";\n// import { AstroCoords } from \"src/model/AstroCoords\";\n// import { ImagePixel } from \"../model/ImagePixel.js\";\nimport { Point } from \"../model/Point.js\";\n// import { FITS } from \"../model/FITS.js\";\nimport { TilesRaDecList2 } from \"./hips/TilesRaDecList2.js\";\nimport { FITS } from \"../model/FITS.js\";\n\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nexport abstract class AbstractProjection {\n\n  public abstract getFITSHeader(): FITSHeaderManager;\n\n  public abstract getCommonFitsHeaderParams(): FITSHeaderManager;\n\n  public abstract setPixelValues(\n    values: TilesRaDecList2,\n    header: FITSHeaderManager,\n  ): FITS;\n\n  public abstract getImageRADecList(\n    center: Point, radius: number,\n    pxsize: number, naxisWidth: number\n  ): TilesRaDecList2;\n\n  public abstract pix2world(i: number, j: number, pxsize: number, minra: number, mindec: number): Point;\n\n  public abstract world2pix(radeclist: TilesRaDecList2): TilesRaDecList2;\n\n  public abstract computeNaxisWidth(radius: number, pxsize: number): number;\n\n  public abstract generateFITSFile(pixelAngSize: number,\n    BITPIX: number,\n    TILE_WIDTH: number,\n    BLANK: number, BZERO: number, BSCALE: number,\n    cRA: number, cDec: number,\n    minValue: number, maxValue: number,\n    raDecWithValues: TilesRaDecList2): FITS\n}\n","export enum NumberType {\n    DEGREES,\n    RADIANS,\n    DECIMAL,\n    HMS,\n    DMS\n}","/**\n * @author Fabrizio Giordano (Fab)\n */\n// import vec3 from 'gl-matrix';\n\nimport { AstroCoords } from \"./AstroCoords.js\";\nimport { CartesianCoords } from \"./CartesianCoords.js\";\nimport { HMSCoords } from \"./HMSCoords.js\";\nimport { NumberType } from \"./NumberType.js\";\nimport { SexagesimalCoords } from \"./SexagesimalCoords.js\";\nimport { SphericalCoords } from \"./SphericalCoords.js\";\n\nfunction Utils(){\n\t\n}\n\nexport function cartesianToSpherical(xyz: CartesianCoords): SphericalCoords{\n\tlet dotXYZ = dot(xyz, xyz);\n\tlet r = Math.sqrt(dotXYZ);\t\n\tlet thetaRad = Math.acos(xyz.z/r);\n\tlet thetaDeg = radToDeg(thetaRad);\n\t// NB: in atan(y/x) is written with params switched atan2(x, y)\n\tlet phiRad = Math.atan2(xyz.y,xyz.x);\n\tlet phiDeg = radToDeg(phiRad);\n\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\treturn {\n\t\tphiDeg: phiDeg, \n\t\tthetaDeg: thetaDeg,\n\t\tphiRad:phiRad,\n\t\tthetaRad: thetaRad\n\t};\n};\n\nexport function sphericalToAstro(phiTheta: SphericalCoords): AstroCoords{\n\tlet raDeg: number;\n\tlet decDeg: number;\n\n\traDeg = phiTheta.phiDeg;\n\tif (raDeg < 0){\n\t\traDeg += 360;\n\t}\n\tdecDeg = 90 - phiTheta.thetaDeg;\n\t\n\treturn {\n\t\t\"raDeg\": raDeg,\n\t\t\"decDeg\": decDeg,\n\t\t\"raRad\": degToRad(raDeg),\n\t\t\"decRad\": degToRad(decDeg)\n\n\t};\n}\n\nexport function astroToSpherical(raDec: AstroCoords): SphericalCoords{\n\t\n\tlet phiDeg: number;\n\tlet thetaDeg: number;\n\n\tphiDeg = raDec.raDeg;\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\t\n\tthetaDeg = 90 - raDec.decDeg;\n\t\n\treturn {\n\t\t\"phiDeg\": phiDeg,\n\t\t\"thetaDeg\": thetaDeg,\n\t\t\"phiRad\": degToRad(phiDeg),\n\t\t\"thetaRad\": degToRad(thetaDeg),\n\t};\n}\n\nexport function sphericalToCartesian(phiTheta: SphericalCoords, r: number): CartesianCoords{\n\tr = (r == undefined) ? 1 : r;\n\tvar x = r * Math.sin(phiTheta.thetaRad) * Math.cos(phiTheta.phiRad);\n\tvar y = r * Math.sin(phiTheta.thetaRad) * Math.sin(phiTheta.phiRad);\n\tvar z = r * Math.cos(phiTheta.thetaRad);\n\n\treturn {\n\t\t\"x\": x, \n\t\t\"y\": y, \n\t\t\"z\": z\n\t};\n};\n\nexport function fillAstro(ra: number, dec: number, unit: NumberType): AstroCoords | null{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"raDeg\": ra,\n\t\t\t\"decDeg\": dec,\n\t\t\t\"raRad\": degToRad(ra),\n\t\t\t\"decRad\": degToRad(dec)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"raRad\": ra,\n\t\t\t\"decRad\": dec,\n\t\t\t\"raDeg\": radToDeg(ra),\n\t\t\t\"decDeg\": radToDeg(dec)\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t\treturn null\n\t}\n\t\n}\n\n\nexport function fillSpherical(phi: number, theta: number, unit: NumberType):  SphericalCoords | null{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"phiDeg\": phi,\n\t\t\t\"thetaDeg\": theta,\n\t\t\t\"phiRad\": degToRad(phi),\n\t\t\t\"thetaRad\": degToRad(theta)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"phiDeg\": radToDeg(phi),\n\t\t\t\"thetaDeg\": radToDeg(theta),\n\t\t\t\"phiRad\": phi,\n\t\t\t\"thetaRad\": theta\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t\treturn null\n\t}\n}\n\nfunction dot(a: CartesianCoords, b: CartesianCoords) : number{\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n\nexport function colorHex2RGB(hexColor: string): [number, number, number] {\n\n//\tconsole.log(hexColor);\n\tvar hex1 = hexColor.substring(1,3);\n\tvar hex2 = hexColor.substring(3,5);\n\tvar hex3 = hexColor.substring(5,7);\n\t\n\tvar dec1 = parseInt(hex1, 16);\n\tvar dec2 = parseInt(hex2, 16);\n\tvar dec3 = parseInt(hex3, 16);\n\t\n\tvar rgb1 = (dec1 / 255).toFixed(2);\n\tvar rgb2 = (dec2 / 255).toFixed(2);\n\tvar rgb3 = (dec3 / 255).toFixed(2);\n\t\n\treturn [parseFloat(rgb1), parseFloat(rgb2), parseFloat(rgb3)];\n\n}\n\nexport function degToRad(degrees: number) : number{\n\treturn (degrees / 180 ) * Math.PI ;\n}\n\nexport function radToDeg(radians: number) : number{\n\treturn radians * 180 / Math.PI;\n}\n\nexport function raDegToHMS(raDeg: number): HMSCoords{\n\t\n\tvar h = Math.floor(raDeg/15);\n\tvar m = Math.floor((raDeg/15 - h) * 60);\n\tvar s = (raDeg/15 - h - m/60) * 3600;\n\t\n\treturn {\n\t\th: h, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nexport function decDegToDMS(decDeg: number): SexagesimalCoords{\n\tvar sign = 1;\n\tif (decDeg < 0){\n\t\tsign = -1;\n\t}\n\t\n\tvar decDeg_abs = Math.abs(decDeg);\n\tvar d = Math.trunc(decDeg_abs);\n\t\n\tvar m = Math.trunc( (decDeg_abs - d) * 60);\n\t\n\tvar s = (decDeg_abs - d - m/60) * 3600;\n\td = d * sign;\n\t\n\treturn {\n\t\td: d, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nfunction dms2DecDeg(decDMS: SexagesimalCoords){\n\tvar sign = Math.sign(decDMS.d);\n\tvar deg = (decDMS.d) + sign * (decDMS.m / 60) + sign * (decDMS.s/3600);\n\treturn deg;\n}\n\nfunction hms2RaDeg(raHMS: HMSCoords){\n\tvar sign = Math.sign(raHMS.h);\n\tvar deg = (raHMS.h + sign * (raHMS.m / 60) + sign * (raHMS.s/3600)) * 15;\n\treturn deg;\n}\n\nfunction worldToModel(xy: [number, number], radius: number): [number, number, number]{\n\tvar x = xy[0];\n\tvar y = xy[1];\n\tvar z = Math.sqrt(radius*radius - xy[0]*xy[0] - xy[1]*xy[1]);\n\treturn [x, y, z];\n}\n\n","/**\n * @author Fabrizio Giordano (Fab77)\n * Enum for coordinate types.\n * @readonly\n * @enum {{name: string, hex: string}}\n */\n\nexport enum CoordsType {\n  CARTESIAN = \"cartesian\",\n  SPHERICAL = \"spherical\",\n  ASTRO = \"astro\"\n}\n","export class Config {\n    static MAX_DECIMALS:number = 12\n}","/**\n * @author Fabrizio Giordano (Fab77)\n */\n\nimport {\n  sphericalToCartesian,\n  cartesianToSpherical,\n  sphericalToAstro,\n  astroToSpherical,\n  fillSpherical,\n  fillAstro\n} from './Utils.js';\nimport { CartesianCoords } from './CartesianCoords.js';\nimport { AstroCoords } from './AstroCoords.js';\nimport { CoordsType } from './CoordsType.js';\nimport { SphericalCoords } from './SphericalCoords.js';\nimport { NumberType } from './NumberType.js';\nimport { Config } from '../Config.js';\n\nconst wrap360 = (deg: number) => ((deg % 360) + 360) % 360;\nconst clampDec = (deg: number) => Math.max(-90, Math.min(90, deg));\n\nexport class Point {\n  private astro!: AstroCoords;\n  private spherical!: SphericalCoords;\n  private cartesian!: CartesianCoords;\n\n  constructor(in_type: CoordsType, unit: NumberType, ...coords: number[]) {\n    if (in_type === CoordsType.CARTESIAN) {\n      // Initialise cartesian first (avoid writing into undefined)\n      this.cartesian = {\n        x: parseFloat(coords[0].toFixed(Config.MAX_DECIMALS)),\n        y: parseFloat(coords[1].toFixed(Config.MAX_DECIMALS)),\n        z: parseFloat(coords[2].toFixed(Config.MAX_DECIMALS))\n      } as CartesianCoords;\n\n      this.spherical = cartesianToSpherical(this.cartesian);\n      this.astro = sphericalToAstro(this.spherical);\n\n    } else if (in_type === CoordsType.ASTRO) {\n      const c = fillAstro(coords[0], coords[1], unit);\n      if (!c) throw new Error('Invalid Astro coordinates');\n\n      this.astro = c;\n      this.spherical = astroToSpherical(this.astro);\n      this.cartesian = sphericalToCartesian(this.spherical, 1.0);\n\n    } else if (in_type === CoordsType.SPHERICAL) {\n      const s = fillSpherical(coords[0], coords[1], unit);\n      if (!s) throw new Error('Invalid Spherical coordinates');\n\n      this.spherical = s;\n      this.cartesian = sphericalToCartesian(this.spherical, 1.0);\n      this.astro = sphericalToAstro(this.spherical);\n\n    } else {\n      throw new Error(`CoordsType ${in_type} not recognised.`);\n    }\n\n    // --- Normalise & keep systems consistent ---\n    // Robust wrap for RA/phi\n    const raWrapped = wrap360(this.astro.raDeg);\n    const phiWrapped = wrap360(this.spherical.phiDeg);\n\n    // Only reassign if changed (avoids unnecessary recompute)\n    if (raWrapped !== this.astro.raDeg) {\n      this.astro.raDeg = raWrapped;\n      // keep spherical/cartesian aligned with astro\n      this.spherical = astroToSpherical(this.astro);\n      this.cartesian = sphericalToCartesian(this.spherical, 1.0);\n    }\n    if (phiWrapped !== this.spherical.phiDeg) {\n      this.spherical.phiDeg = phiWrapped;\n      // keep astro/cartesian aligned with spherical\n      this.cartesian = sphericalToCartesian(this.spherical, 1.0);\n      this.astro = sphericalToAstro(this.spherical);\n    }\n\n    // Clamp Dec defensively and re-sync if it changed\n    const decClamped = clampDec(this.astro.decDeg);\n    if (decClamped !== this.astro.decDeg) {\n      this.astro.decDeg = decClamped;\n      this.spherical = astroToSpherical(this.astro);\n      this.cartesian = sphericalToCartesian(this.spherical, 1.0);\n    }\n  }\n\n  getSpherical() {\n    return this.spherical;\n  }\n\n  getAstro() {\n    return this.astro;\n  }\n\n  getCartesian() {\n    return this.cartesian;\n  }\n}\n","export class MinMaxValue {\n    min: number\n    max: number\n    \n    constructor(min: number, max: number) {\n        this.min = min\n        this.max = max\n    }\n\n    getMinValue() {\n        return this.min\n    }\n    \n    getMaxValue() {\n        return this.max\n    }\n\n}","export class RADecMinMaxCentral {\n    centralRA: number\n    centralDec: number\n    minRA: number\n    minDec: number\n    maxRA: number\n    maxDec: number\n    \n    constructor(centralRA: number, centralDec: number, minRA: number,\n    minDec: number, maxRA: number, maxDec: number) {\n        this.centralDec = centralDec\n        this.centralRA = centralRA\n\n        this.maxDec = maxDec\n        this.maxRA = maxRA\n\n        this.minRA = minRA\n        this.minDec = minDec\n    }\n\n    getMinRA() {\n        return this.minRA\n    }\n    \n    getMinDec() {\n        return this.minDec\n    }\n    \n    getMaxRA() {\n        return this.maxRA\n    }\n    \n    getMaxDec() {\n        return this.maxDec\n    }\n\n    getCentralRA() {\n        return this.centralRA\n    }\n    \n    getCentralDec() {\n        return this.centralDec\n    }\n\n\n    setMinRA(minRA: number) {\n        this.minRA = minRA\n    }\n    \n    setMinDec(minDec: number) {\n        this.minDec = minDec\n    }\n    \n    setMaxRA(maxRA: number) {\n        this.maxRA = maxRA\n    }\n    \n    setMaxDec(maxDec: number) {\n        this.maxDec = maxDec\n    }\n\n    setCentralRA(cRA: number) {\n        this.centralRA = cRA\n    }\n    \n    setCentralDec(cDec: number) {\n        this.centralDec = cDec\n    }\n\n}","import { MinMaxValue } from \"../MinMaxValue.js\"\nimport { RADecMinMaxCentral } from \"../RADecMinMaxCentral.js\"\nimport { ImagePixel } from \"./ImagePixel.js\"\n\nexport class TilesRaDecList2 {\n\n    // hipsOrder: number\n    tileList: Array<number>\n    imagePixelList: ImagePixel[]\n    minPixelValue: number | null = null\n    maxPixelValue: number | null = null\n    BZERO: number | null = null\n    BSCALE: number | null = null\n    BLANK: number | null = null\n\n\n    // constructor(hipsOrder: number) {\n    //     this.hipsOrder = hipsOrder\n    constructor() {\n        this.tileList = []\n        this.imagePixelList = new Array<ImagePixel>()\n    }\n\n    setBZERO(BZERO: number) {\n        this.BZERO = BZERO\n    }\n\n    setBSCALE(BSCALE: number) {\n        this.BSCALE = BSCALE\n    }\n\n    setBLANK(BLANK: number) {\n        this.BLANK = BLANK\n    }\n\n    getBZERO() {\n        return this.BZERO\n    }\n\n    getBSCALE() {\n        return this.BSCALE\n    }\n\n    getBLANK() {\n        return this.BLANK\n    }\n\n    findImagePixel(i: number, j: number) {\n        return this.imagePixelList.find(p => p.i === i && p.j === j) || null;\n    }\n\n    getImagePixelsByTile(tileno: number): ImagePixel[] {\n        return this.imagePixelList.filter(p => p.tileno === tileno);\n    }\n\n    getImagePixelList() {\n        return this.imagePixelList\n    }\n\n    getTilesList() {\n        return this.tileList\n    }\n\n    addImagePixel(imgpx: ImagePixel) {\n        this.imagePixelList.push(imgpx)\n    }\n\n    addTileNumber(tileno: number) {\n        if (!this.tileList.includes(tileno)) {\n            this.tileList.push(tileno)\n        }\n    }\n\n\n    computeRADecMinMaxCentral(): RADecMinMaxCentral | null {\n        if (this.imagePixelList.length === 0) return null;\n\n        // Single pass, skip non-finite values\n        let minRA = Infinity, maxRA = -Infinity;\n        let minDec = Infinity, maxDec = -Infinity;\n\n        for (const p of this.imagePixelList) {\n            if (Number.isFinite(p.ra)) {\n                if (p.ra < minRA) minRA = p.ra;\n                if (p.ra > maxRA) maxRA = p.ra;\n            }\n            if (Number.isFinite(p.dec)) {\n                if (p.dec < minDec) minDec = p.dec;\n                if (p.dec > maxDec) maxDec = p.dec;\n            }\n        }\n\n        // If all values were non-finite, bail out\n        if (!Number.isFinite(minRA) || !Number.isFinite(maxRA) ||\n            !Number.isFinite(minDec) || !Number.isFinite(maxDec)) {\n            return null;\n        }\n\n        const cRA = minRA + (maxRA - minRA) / 2;\n        const cDec = minDec + (maxDec - minDec) / 2;\n\n        return new RADecMinMaxCentral(cRA, cDec, minRA, minDec, maxRA, maxDec);\n    }\n\n    setMinMaxValue(value: number | null) {\n        if (!value) return\n\n        if (!this.minPixelValue) {\n            this.minPixelValue = value\n        } else if (value < this.minPixelValue) {\n            this.minPixelValue = value\n        }\n\n        if (!this.maxPixelValue) {\n            this.maxPixelValue = value\n        } else if (value > this.minPixelValue) {\n            this.maxPixelValue = value\n        }\n    }\n\n    getMinMaxValues() {\n        if (this.minPixelValue && this.maxPixelValue) {\n            return new MinMaxValue(this.minPixelValue, this.maxPixelValue)\n        }\n        return null\n\n    }\n\n}\n","import { ParseUtils } from \"jsfitsio\"\n\nexport class ImagePixel {\n    i: number\n    j: number\n    ra: number\n    dec: number\n    tileno: number | undefined\n    uint8value: Uint8Array | null = null\n    value: number | null = null\n\n    constructor(i: number, j: number, tileno: number | undefined);\n\n    constructor(ra: number, dec: number, tileno: number | undefined);\n\n    constructor(a: number, b: number, tileno: number | undefined) {\n        \n        this.tileno = tileno;\n\n        // Heuristic: if `a` and `b` are integers, treat them as `i` and `j`\n        if (Number.isInteger(a) && Number.isInteger(b)) {\n            this.i = a;\n            this.j = b;\n            this.ra = NaN;\n            this.dec = NaN;\n        } else {\n            this.ra = a;\n            this.dec = b;\n            this.i = -1;\n            this.j = -1;\n        }\n        \n    }\n\n    geti(){\n        return this.i\n    }\n\n    getj(){\n        return this.j\n    }\n    getRADeg(){\n        return this.ra\n    }\n\n    getDecDeg(){\n        return this.dec\n    }\n\n    getUint8Value(){\n        return this.uint8value\n    }\n\n    getValue() {\n        return this.value\n    }\n\n    setValue(value: Uint8Array, bitpix: number){\n        if (this.uint8value == undefined) {\n            const bytesXelem = Math.abs(bitpix / 8);\n            this.uint8value = new Uint8Array(bytesXelem)\n        }\n        this.uint8value = value\n        this.value = ParseUtils.extractPixelValue(0, value, bitpix)\n    }\n\n    setTileNumber(tileno: number) {\n        this.tileno = tileno\n    }\n\n    setij(i:number, j:number){\n        this.i = i\n        this.j = j\n    }\n\n    setRADecDeg(ra:number, dec:number){\n        this.ra = ra\n        this.dec = dec\n    }\n\n}\n","\nimport { FITSHeaderManager } from 'jsfitsio';\n\nexport class FITS {\n\n    private header!: FITSHeaderManager\n    private payload: Uint8Array<ArrayBufferLike>[] = []\n\n    constructor(header: FITSHeaderManager, data: Map<number, Array<Uint8Array>>) {\n        this.header = header\n        this.setData(data)\n    }\n\n    setData(data: Map<number, Array<Uint8Array>>){\n        this.payload = Array.from(data.values()).flatMap(row => row);\n    }\n\n    getHeader() {\n        return this.header\n    }\n    \n    getData() {\n        return this.payload\n    }\n\n\n\n}","// // src/version.ts\n// let ver = typeof __APP_VERSION__ !== 'undefined' ? __APP_VERSION__ : undefined;\n\n// if (!ver && typeof process !== 'undefined' && process.versions?.node) {\n//   // Node runtime: try reading package.json without breaking browser bundles\n//   try {\n//     // Delay import so bundlers can tree-shake this path out\n//     // @ts-ignore\n//     const { createRequire } = await import('node:module');\n//     const req = createRequire(import.meta.url);\n//     ver = req('../package.json').version as string;\n//   } catch {\n//     // ignore\n//   }\n// }\n\n// export const APP_VERSION: string = ver ?? '0.0.0-dev';\n\n\ndeclare const __APP_VERSION__: string;\nexport const APP_VERSION = __APP_VERSION__;","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\n\nimport { FITSParser, FITSHeaderManager, FITSHeaderItem, FITSParsed, ParseUtils } from 'jsfitsio';\n\n\nimport { AbstractProjection } from '../AbstractProjection.js';\nimport { Point } from '../../model/Point.js';\nimport { CoordsType } from '../../model/CoordsType.js';\nimport { NumberType } from '../../model/NumberType.js';\nimport { TilesRaDecList2 } from '../hips/TilesRaDecList2.js';\nimport { ImagePixel } from '../hips/ImagePixel.js';\nimport { FITS } from '../../model/FITS.js';\n\nimport { APP_VERSION } from '../../Version.js'; // adjust path as needed\n\n\n// import { HiPSProp } from '../hips/HiPSProp.js';\n\n\nexport class MercatorProjection extends AbstractProjection {\n\n    minra!: number;\n    mindec!: number;\n    naxis1!: number;\n    naxis2!: number;\n    bitpix!: number\n\n    fitsheader: FITSHeaderManager;\n    pxvalues: Array<Uint8Array>;\n\n    CTYPE1: string = \"'RA---CAR'\";\n    CTYPE2: string = \"'DEC--CAR'\";\n    craDeg!: number;\n    cdecDeg!: number;\n\n    pxsize!: number;\n    pxsize1!: number;\n    pxsize2!: number;\n\n    // _minphysicalval!: number;\n    // _maxphysicalval!: number;\n    _wcsname: string;\n\n    constructor() {\n        super();\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this.pxvalues = new Array<Uint8Array>();\n        this.fitsheader = new FITSHeaderManager();\n    }\n\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n\n        const fits = await FITSParser.loadFITS(infile);\n        if (!fits) {\n            console.error(\"FITS is null\")\n            throw new Error(\"FITS is null\")\n        }\n\n        this.pxvalues = fits.data;\n        this.fitsheader = fits.header;\n        this.naxis1 = Number(fits.header.findById(\"NAXIS1\")?.value)\n        this.naxis2 = Number(fits.header.findById(\"NAXIS2\")?.value)\n\n        this.bitpix = fits.header.findById(\"BITPIX\")?.value as number;\n        this.craDeg = fits.header.findById(\"CRVAL1\")?.value as number;\n        this.cdecDeg = fits.header.findById(\"CRVAL2\")?.value as number;\n\n        const pxsize1 = this.fitsheader.findById(\"CDELT1\")?.value as number;\n        const pxsize2 = this.fitsheader.findById(\"CDELT2\")?.value as number;\n        if (pxsize1 !== pxsize2 || pxsize1 === undefined || pxsize2 === undefined) {\n            throw new Error(\"pxsize1 is not equal to pxsize2\")\n        }\n        this.pxsize = pxsize1;\n\n        this.minra = this.craDeg - this.pxsize * this.naxis1 / 2;\n        if (this.minra < 0) {\n            this.minra += 360;\n        }\n        // this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n        this.mindec = this.cdecDeg - this.pxsize * this.naxis2 / 2;\n\n        return fits;\n\n    }\n\n    getBytePerValue(): number {\n        return Math.abs(this.bitpix / 8);\n    }\n\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        const bzero = Number(fits.header.findById(\"BZERO\")?.value);\n        const bscale = Number(fits.header.findById(\"BSCALE\")?.value);\n        const naxis1 = Number(fits.header.findById(\"NAXIS1\")?.value);\n        const naxis2 = Number(fits.header.findById(\"NAXIS2\")?.value);\n        const bitpix = Number(fits.header.findById(\"BITPIX\")?.value);\n        const bytesXelem = Math.abs(bitpix / 8);\n\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                const pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                if (pixval) {\n                    let physicalVal = bzero + bscale * pixval;\n                    physicalvalues[n2][n1] = physicalVal;\n                }\n\n            }\n        }\n        return physicalvalues;\n    }\n\n\n    prepareHeader(pixelAngSize: number,\n        BITPIX: number,\n        TILE_WIDTH: number,\n        BLANK: number, BZERO: number, BSCALE: number,\n        cRA: number, cDec: number,\n        minValue: number, maxValue: number): FITSHeaderManager {\n\n        const fitsheader = new FITSHeaderManager();\n\n        fitsheader.insert(new FITSHeaderItem(\"SIMPLE\", \"T\", \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"NAXIS1\", TILE_WIDTH, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"NAXIS2\", TILE_WIDTH, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"NAXIS\", 2, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"BITPIX\", BITPIX, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"BLANK\", BLANK, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"BSCALE\", BSCALE, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"BZERO\", BZERO, \"\"));\n\n        fitsheader.insert(new FITSHeaderItem(\"CTYPE1\", this.CTYPE1, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"CTYPE2\", this.CTYPE2, \"\"));\n\n        fitsheader.insert(new FITSHeaderItem(\"CDELT1\", pixelAngSize, \"\")); // ??? Pixel spacing along axis 1 ???\n        fitsheader.insert(new FITSHeaderItem(\"CDELT2\", pixelAngSize, \"\")); // ??? Pixel spacing along axis 2 ???\n        fitsheader.insert(new FITSHeaderItem(\"CRPIX1\", TILE_WIDTH / 2, \"\")); // central/reference pixel i along naxis1\n        fitsheader.insert(new FITSHeaderItem(\"CRPIX2\", TILE_WIDTH / 2, \"\")); // central/reference pixel j along naxis2\n\n        fitsheader.insert(new FITSHeaderItem(\"CRVAL1\", cRA, \"\")); // central/reference pixel RA\n        fitsheader.insert(new FITSHeaderItem(\"CRVAL2\", cDec, \"\")); // central/reference pixel Dec\n\n        const min = BZERO + BSCALE * minValue;\n        const max = BZERO + BSCALE * maxValue;\n        fitsheader.insert(new FITSHeaderItem(\"DATAMIN\", min, \"\")); // min data value\n        fitsheader.insert(new FITSHeaderItem(\"DATAMAX\", max, \"\")); // max data value\n\n\n        fitsheader.insert(new FITSHeaderItem(\"ORIGIN\", `WCSLight v.${APP_VERSION}`, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"COMMENT\", \"WCSLight developed by F.Giordano and Y.Ascasibar\", \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"END\", \"\", \"\"));\n\n        return fitsheader;\n\n    }\n\n\n    // TODO CHECK: there are 4 header related methods!!! prepareHeader, prepareFITSHeader, getCommonFitsHeaderParams and getFITSHeader\n    getFITSHeader(): FITSHeaderManager {\n        return this.fitsheader;\n    }\n    // TODO CHECK: there are 4 header related methods!!! prepareHeader, prepareFITSHeader, getCommonFitsHeaderParams and getFITSHeader\n    getCommonFitsHeaderParams(): FITSHeaderManager {\n        let header = new FITSHeaderManager();\n        for (const item of this.fitsheader.getItems()) {\n            const key = item.key\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n                const value = item.value\n                header.insert(new FITSHeaderItem(key, value, \"\"));\n            }\n        }\n        return header;\n    }\n\n    computeNaxisWidth(radius: number, pxsize: number): number {\n        return Math.ceil(2 * radius / pxsize);\n    }\n\n    getImageRADecList(center: Point, radius: number, pxsize: number, naxisWidth: number): TilesRaDecList2 {\n\n\n        const naxis1 = naxisWidth\n        const naxis2 = naxis1;\n\n        let minra = center.getAstro().raDeg - radius;\n        if (minra < 0) {\n            minra += 360;\n        }\n        const mindec = center.getAstro().decDeg - radius;\n\n        const tilesRaDecList = new TilesRaDecList2()\n\n        // let radeclist: Array<[number, number]> = new Array<[number, number]>();\n\n        // let centralRa, centralDec\n        for (let d = 0; d < naxis2; d++) {\n            for (let r = 0; r < naxis1; r++) {\n                tilesRaDecList.addImagePixel(new ImagePixel(minra + (r * pxsize), mindec + (d * pxsize), undefined))\n                // radeclist.push([minra + (r * pxsize), mindec + (d * pxsize)]);\n            }\n        }\n\n        const centralImgpx = tilesRaDecList.getImagePixelList().length / 2 - 1\n        // let cidx = (naxis2 / 2) * naxis1 + naxis1 / 2;\n        // if (naxis1 % 2 != 0) {\n        //     cidx = Math.floor(radeclist.length / 2);\n        // }\n        // this._craDeg = radeclist[cidx][0];\n        // this._cdecDeg = radeclist[cidx][1];\n\n        // return radeclist\n        return tilesRaDecList\n\n    }\n\n\n\n    /** TODO !!! check and handle RA passing through 360-0 */\n    pix2world(i: number, j: number, pxsize: number, minra: number, mindec: number): Point {\n\n        let ra: number;\n        let dec: number;\n        // ra = i * this._stepra + this._minra;\n        // dec = j * this._stepdec + this._mindec;\n        ra = i * pxsize + minra;\n        dec = j * pxsize + mindec;\n        let p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n        return p;\n        // return [ra, dec];\n\n    }\n\n    setPixelValues(raDecList: TilesRaDecList2, header: FITSHeaderManager): FITS {\n\n        const BITPIX = header.findById(\"BITPIX\")?.value as number;\n        if (!Number.isFinite(BITPIX)) {\n            throw new Error(\"BITPIX not found or invalid in header\");\n        }\n        const bytesPerElem = Math.abs(BITPIX) / 8;\n\n        const width = header.findById(\"NAXIS1\")?.value as number;\n        const height = (header.findById(\"NAXIS2\")?.value as number) ?? width; // fallback if square\n        if (!Number.isFinite(width) || width <= 0) throw new Error(\"NAXIS1 not found or invalid\");\n        if (!Number.isFinite(height) || height <= 0) throw new Error(\"NAXIS2 not found or invalid\");\n\n        const pixels = raDecList.getImagePixelList();\n        if (pixels.length !== width * height) {\n            throw new Error(`Pixel count mismatch: got ${pixels.length}, expected ${width * height}`);\n        }\n\n        // Map<rowIndex, Uint8Array[]>, each row has length = width\n        const pxvalues = new Map<number, Uint8Array[]>();\n        for (let r = 0; r < height; r++) {\n            pxvalues.set(r, new Array<Uint8Array>(width));\n        }\n\n        // Fill in row-major order: for each linear index, compute (row, col)\n        for (let idx = 0; idx < pixels.length; idx++) {\n            const row = Math.floor(idx / width);\n            const col = idx % width;\n\n            const rowArr = pxvalues.get(row)!;\n\n            let u8 = pixels[idx].getUint8Value();\n            if (u8 == null) {\n                // Your pipelines ImagePixel.setValue() should have set this already.\n                // Throwing is safer than inventing packing (FITS expects specific endian/precision).\n                throw new Error(`Pixel (${row},${col}) missing Uint8Array for BITPIX=${BITPIX}`);\n            }\n            if (u8.byteLength !== bytesPerElem) {\n                throw new Error(\n                    `Pixel (${row},${col}) byteLength=${u8.byteLength} != expected ${bytesPerElem} (BITPIX=${BITPIX})`\n                );\n            }\n\n            rowArr[col] = u8;\n            // no need to pxvalues.set(row, rowArr); reference already updated\n        }\n\n        return new FITS(header, pxvalues);\n    }\n\n\n\n\n\n    generateFITSFile(pixelAngSize: number,\n        BITPIX: number,\n        TILE_WIDTH: number,\n        BLANK: number, BZERO: number, BSCALE: number,\n        cRA: number, cDec: number,\n        minValue: number, maxValue: number,\n        raDecWithValues: TilesRaDecList2): FITS {\n\n        const header: FITSHeaderManager = this.prepareHeader(\n            pixelAngSize,\n            BITPIX,\n            TILE_WIDTH,\n            BLANK, BZERO, BSCALE,\n            cRA, cDec,\n            minValue, maxValue)\n        const fits: FITS = this.setPixelValues(raDecWithValues, header)\n        return fits;\n    }\n\n\n    world2pix(raDecList: TilesRaDecList2): TilesRaDecList2 {\n\n        const bytesXvalue = this.getBytePerValue()\n\n        // TODO if I have the this.fitsheader available here, check if I can retrieve this.bitpix, this.pxsize, ... with this.fitsheader\n        // and remove the attributes at object level (with this)\n        const blank = Number(this.fitsheader.findById(\"BLANK\")?.value)\n        const blankBytes = ParseUtils.convertBlankToBytes(blank, bytesXvalue);\n\n        for (let imgPx of raDecList.getImagePixelList()) {\n\n            // console.log(\"raDeclist.getImagePixelList().indexOf(imgPx) \" + raDeclist.getImagePixelList().indexOf(imgPx))\n            const ra = imgPx.getRADeg();\n            const dec = imgPx.getDecDeg();\n\n            const i = Math.floor((ra - this.minra) / this.pxsize);\n            const j = Math.floor((dec - this.mindec) / this.pxsize);\n\n            if (j < 0 || j >= this.naxis2 || i < 0 || i >= this.naxis1) {\n                imgPx.setValue(blankBytes, this.bitpix)\n            } else {\n                const currentValue = this.pxvalues[j].slice(i * bytesXvalue, (i + 1) * bytesXvalue);\n                imgPx.setValue(currentValue, this.bitpix)\n            }\n            raDecList.setMinMaxValue(imgPx.getValue())\n        }\n        return raDecList;\n\n    }\n\n}\n","export class Constants {\n}\n//\tstatic halfpi = Math.PI/2.;\nConstants.halfpi = 1.5707963267948966;\nConstants.inv_halfpi = 2. / Math.PI;\n/** The Constant twopi. */\nConstants.twopi = 2 * Math.PI;\nConstants.inv_twopi = 1. / (2 * Math.PI);\n//# sourceMappingURL=Constants.js.map","export class Zphi {\n    /** Creation from individual components */\n    constructor(z_, phi_) {\n        this.z = z_;\n        this.phi = phi_;\n    }\n    ;\n}\n//# sourceMappingURL=Zphi.js.map","import { Vec3 } from './Vec3.js';\nimport { Zphi } from './Zphi.js';\nexport class Hploc {\n    constructor(ptg) {\n        Hploc.PI4_A = 0.7853981554508209228515625;\n        Hploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\n        Hploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n        Hploc.M_1_PI = 0.3183098861837906715377675267450287;\n        if (ptg) {\n            this.sth = 0.0;\n            this.have_sth = false;\n            this.z = Hploc.cos(ptg.theta);\n            this._phi = ptg.phi;\n            if (Math.abs(this.z) > 0.99) {\n                this.sth = Hploc.sin(ptg.theta);\n                this.have_sth = true;\n            }\n        }\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    ;\n    get phi() {\n        return this._phi;\n    }\n    ;\n    set phi(phi) {\n        this._phi = phi;\n    }\n    ;\n    setSth(sth) {\n        this.sth = sth;\n    }\n    ;\n    toVec3() {\n        var st = this.have_sth ? this.sth : Math.sqrt((1.0 - this.z) * (1.0 + this.z));\n        // var vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);\n        var vector = new Vec3(st * Math.cos(this.phi), st * Math.sin(this.phi), this.z);\n        return vector;\n    }\n    ;\n    toZphi() {\n        return new Zphi(this.z, this.phi);\n    }\n    static sin(d) {\n        let u = d * Hploc.M_1_PI;\n        let q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 4.0 * q;\n        d -= x * Hploc.PI4_A;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 1) != 0) {\n            d = -d;\n        }\n        return this.sincoshelper(d);\n    }\n    ;\n    static cos(d) {\n        //\t\tlet u = d * Hploc.M_1_PI - 0.5;\n        let u = d * Hploc.M_1_PI - 0.5;\n        //\t\tu -= 0.5;\n        let q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 2.0 * q;\n        let t = x * Hploc.PI4_A;\n        d = d - t;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 2) == 0) {\n            d = -d;\n        }\n        return Hploc.sincoshelper(d);\n    }\n    ;\n    static sincoshelper(d) {\n        let s = d * d;\n        let u = -7.97255955009037868891952e-18;\n        u = u * s + 2.81009972710863200091251e-15;\n        u = u * s - 7.64712219118158833288484e-13;\n        u = u * s + 1.60590430605664501629054e-10;\n        u = u * s - 2.50521083763502045810755e-08;\n        u = u * s + 2.75573192239198747630416e-06;\n        u = u * s - 0.000198412698412696162806809;\n        u = u * s + 0.00833333333333332974823815;\n        u = u * s - 0.166666666666666657414808;\n        return s * u * d + d;\n    }\n    ;\n    /** This method calculates the arc sine of x in radians. The return\n    value is in the range [-pi/2, pi/2]. The results may have\n    maximum error of 3 ulps. */\n    static asin(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1 + d) * (1 - d))), d);\n    }\n    ;\n    /** This method calculates the arc cosine of x in radians. The\n        return value is in the range [0, pi]. The results may have\n        maximum error of 3 ulps. */\n    static acos(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.sqrt((1 + d) * (1 - d)), Math.abs(d)), d) + (d < 0 ? Math.PI : 0);\n    }\n    ;\n    static mulsign(x, y) {\n        let sign = Hploc.copySign(1, y);\n        return sign * x;\n    }\n    ;\n    static copySign(magnitude, sign) {\n        return sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);\n        // let finalsign = 1;\n        // if (Object.is(finalsign , -0)){\n        // \tsign = -1;\n        // }else if (Object.is(finalsign , 0)){\n        // \tsign = 1;\n        // }else {\n        // \tsign = Math.sign(finalsign);\n        // }\n        // return finalsign * magnitude;\n    }\n    static atanhelper(s) {\n        let t = s * s;\n        let u = -1.88796008463073496563746e-05;\n        u = u * t + (0.000209850076645816976906797);\n        u = u * t + (-0.00110611831486672482563471);\n        u = u * t + (0.00370026744188713119232403);\n        u = u * t + (-0.00889896195887655491740809);\n        u = u * t + (0.016599329773529201970117);\n        u = u * t + (-0.0254517624932312641616861);\n        u = u * t + (0.0337852580001353069993897);\n        u = u * t + (-0.0407629191276836500001934);\n        u = u * t + (0.0466667150077840625632675);\n        u = u * t + (-0.0523674852303482457616113);\n        u = u * t + (0.0587666392926673580854313);\n        u = u * t + (-0.0666573579361080525984562);\n        u = u * t + (0.0769219538311769618355029);\n        u = u * t + (-0.090908995008245008229153);\n        u = u * t + (0.111111105648261418443745);\n        u = u * t + (-0.14285714266771329383765);\n        u = u * t + (0.199999999996591265594148);\n        u = u * t + (-0.333333333333311110369124);\n        return u * t * s + s;\n    }\n    ;\n    static atan2k(y, x) {\n        let q = 0.;\n        if (x < 0) {\n            x = -x;\n            q = -2.;\n        }\n        if (y > x) {\n            let t = x;\n            x = y;\n            y = -t;\n            q += 1.;\n        }\n        return Hploc.atanhelper(y / x) + q * (Math.PI / 2);\n    }\n    ;\n    /** This method calculates the arc tangent of y/x in radians, using\n    the signs of the two arguments to determine the quadrant of the\n    result. The results may have maximum error of 2 ulps. */\n    static atan2(y, x) {\n        let r = Hploc.atan2k(Math.abs(y), x);\n        r = Hploc.mulsign(r, x);\n        if (Hploc.isinf(x) || x == 0) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI / 2)) : 0);\n        }\n        if (Hploc.isinf(y)) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI * 1 / 4)) : 0);\n        }\n        if (y == 0) {\n            r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);\n        }\n        return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);\n    }\n    ;\n    /** Checks if the argument is a NaN or not. */\n    static isnan(d) {\n        return d != d;\n    }\n    ;\n    /** Checks if the argument is either positive or negative infinity. */\n    static isinf(d) {\n        return Math.abs(d) === +Infinity;\n    }\n    ;\n}\nHploc.PI4_A = 0.7853981554508209228515625;\nHploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\nHploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\nHploc.M_1_PI = 0.3183098861837906715377675267450287;\n//# sourceMappingURL=Hploc.js.map","import { Hploc } from './Hploc.js';\nexport class Pointing {\n    /**\n     *\n     * @param {*} vec3 Vec3.js\n     * @param {*} mirror\n     * @param {*} in_theta radians\n     * @param {*} in_phi radians\n     */\n    constructor(vec3, mirror, in_theta, in_phi) {\n        if (vec3 != null) {\n            this.theta = Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);\n            if (mirror) {\n                this.phi = -Hploc.atan2(vec3.y, vec3.x);\n            }\n            else {\n                this.phi = Hploc.atan2(vec3.y, vec3.x);\n            }\n            if (this.phi < 0.0) {\n                this.phi = this.phi + 2 * Math.PI;\n            }\n            if (this.phi >= 2 * Math.PI) {\n                this.phi = this.phi - 2 * Math.PI;\n            }\n        }\n        else {\n            this.theta = in_theta;\n            this.phi = in_phi;\n        }\n    }\n}\n//# sourceMappingURL=Pointing.js.map","/**\n * Partial porting to Javascript of Vec3.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nimport { Pointing } from './Pointing.js';\nexport class Vec3 {\n    constructor(in_x, in_y, in_z) {\n        if (in_x instanceof Pointing) {\n            let ptg = in_x;\n            let sth = Hploc.sin(ptg.theta);\n            this.x = sth * Hploc.cos(ptg.phi);\n            this.y = sth * Hploc.sin(ptg.phi);\n            this.z = Hploc.cos(ptg.theta);\n        }\n        else {\n            this.x = in_x;\n            this.y = in_y;\n            this.z = in_z;\n        }\n    }\n    getX() {\n        return this.x;\n    }\n    ;\n    getY() {\n        return this.y;\n    }\n    ;\n    getZ() {\n        return this.z;\n    }\n    ;\n    /** Scale the vector by a given factor\n    @param n the scale factor */\n    scale(n) {\n        this.x *= n;\n        this.y *= n;\n        this.z *= n;\n    }\n    ;\n    /** Vector cross product.\n    @param v another vector\n    @return the vector cross product between this vector and {@code v} */\n    cross(v) {\n        return new Vec3(this.y * v.z - v.y * this.z, this.z * v.x - v.z * this.x, this.x * v.y - v.x * this.y);\n    }\n    ;\n    /** Vector addition\n        * @param v the vector to be added\n        * @return addition result */\n    add(v) {\n        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    ;\n    /** Normalize the vector */\n    normalize() {\n        let d = 1. / this.length();\n        this.x *= d;\n        this.y *= d;\n        this.z *= d;\n    }\n    ;\n    /** Return normalized vector */\n    norm() {\n        let d = 1. / this.length();\n        return new Vec3(this.x * d, this.y * d, this.z * d);\n    }\n    ;\n    /** Vector length\n    @return the length of the vector. */\n    length() {\n        return Math.sqrt(this.lengthSquared());\n    }\n    ;\n    /** Squared vector length\n        @return the squared length of the vector. */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    ;\n    /** Computes the dot product of the this vector and {@code v1}.\n     * @param v1 another vector\n     * @return dot product */\n    dot(v1) {\n        return this.x * v1.x + this.y * v1.y + this.z * v1.z;\n    }\n    ;\n    /** Vector subtraction\n     * @param v the vector to be subtracted\n     * @return subtraction result */\n    sub(v) {\n        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    ;\n    /** Angle between two vectors.\n    @param v1 another vector\n    @return the angle in radians between this vector and {@code v1};\n      constrained to the range [0,PI]. */\n    angle(v1) {\n        return Hploc.atan2(this.cross(v1).length(), this.dot(v1));\n    }\n    /** Invert the signs of all components */\n    flip() {\n        this.x *= -1.0;\n        this.y *= -1.0;\n        this.z *= -1.0;\n    }\n    static pointing2Vec3(pointing) {\n        let sth = Hploc.sin(pointing.theta);\n        let x = sth * Hploc.cos(pointing.phi);\n        let y = sth * Hploc.sin(pointing.phi);\n        let z = Hploc.cos(pointing.theta);\n        return new Vec3(x, y, z);\n    }\n    ;\n}\n//# sourceMappingURL=Vec3.js.map","import { Vec3 } from './Vec3.js';\nexport class CircleFinder {\n    /**\n     * @param point: Vec3\n     */\n    constructor(point) {\n        let np = point.length;\n        //HealpixUtils.check(np>=2,\"too few points\");\n        if (!(np >= 2)) {\n            console.log(\"too few points\");\n            return;\n        }\n        this.center = point[0].add(point[1]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 2; i < np; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle(point, i);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q: int\n     */\n    getCircle(point, q) {\n        this.center = point[0].add(point[q]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 1; i < q; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle2(point, i, q);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q1: int\n     * @param q2: int\n     */\n    getCircle2(point, q1, q2) {\n        this.center = point[q1].add(point[q2]);\n        this.center.normalize();\n        this.cosrad = point[q1].dot(this.center);\n        for (let i = 0; i < q1; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.center = (point[q1].sub(point[i])).cross(point[q2].sub(point[i]));\n                this.center.normalize();\n                this.cosrad = point[i].dot(this.center);\n                if (this.cosrad < 0) {\n                    this.center.flip();\n                    this.cosrad = -this.cosrad;\n                }\n            }\n        }\n    }\n    ;\n    getCenter() {\n        return new Vec3(this.center.x, this.center.y, this.center.z);\n    }\n    getCosrad() {\n        return this.cosrad;\n    }\n    ;\n}\n//# sourceMappingURL=CircleFinder.js.map","/**\n * Partial porting to Javascript of Fxyf.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nexport class Fxyf {\n    constructor(x, y, f) {\n        this.fx = x;\n        this.fy = y;\n        this.face = f;\n        // coordinate of the lowest corner of each face\n        this.jrll = new Uint8Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Uint8Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.halfpi = Math.PI / 2.;\n    }\n    toHploc() {\n        let loc = new Hploc();\n        let jr = this.jrll[this.face] - this.fx - this.fy;\n        let nr;\n        if (jr < 1) {\n            nr = jr;\n            let tmp = nr * nr / 3.;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > 3) {\n            nr = 4 - jr;\n            let tmp = nr * nr / 3.;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = 1;\n            loc.z = (2 - jr) * 2.0 / 3.;\n        }\n        let tmp = this.jpll[this.face] * nr + this.fx - this.fy;\n        if (tmp < 0) {\n            tmp += 8;\n        }\n        if (tmp >= 8) {\n            tmp -= 8;\n        }\n        loc.phi = (nr < 1e-15) ? 0 : (0.5 * this.halfpi * tmp) / nr;\n        return loc;\n    }\n    ;\n    toVec3() {\n        return this.toHploc().toVec3();\n    }\n    ;\n}\n//# sourceMappingURL=Fxyf.js.map","export class pstack {\n    /** Creation from individual components */\n    constructor(sz) {\n        this.p = new Array(sz);\n        this.o = new Int32Array(sz);\n        this.s = 0;\n        this.m = 0;\n    }\n    ;\n    /**\n     * @param p long\n     * @param o int\n     */\n    push(p_, o_) {\n        this.p[this.s] = p_;\n        this.o[this.s] = o_;\n        ++this.s;\n    }\n    ;\n    pop() {\n        --this.s;\n    }\n    ;\n    popToMark() {\n        this.s = this.m;\n    }\n    ;\n    size() {\n        return this.s;\n    }\n    ;\n    mark() {\n        this.m = this.s;\n    }\n    ;\n    otop() {\n        return this.o[this.s - 1];\n    }\n    ;\n    ptop() {\n        return this.p[this.s - 1];\n    }\n    ;\n}\n//# sourceMappingURL=pstack.js.map","export class RangeSet {\n    /**\n     * @param int cap: initial capacity\n     */\n    constructor(cap) {\n        if (cap < 0)\n            console.error(\"capacity must be positive\");\n        this.r = new Int32Array(cap << 1);\n        this.sz = 0;\n    }\n    ;\n    /** Append a single-value range to the object.\n    @param val value to append */\n    append(val) {\n        this.append1(val, val + 1);\n    }\n    ;\n    /** Append a range to the object.\n   @param a first long in range\n   @param b one-after-last long in range */\n    append1(a, b) {\n        if (a >= b)\n            return;\n        if ((this.sz > 0) && (a <= this.r[this.sz - 1])) {\n            if (a < this.r[this.sz - 2])\n                console.error(\"bad append operation\");\n            if (b > this.r[this.sz - 1])\n                this.r[this.sz - 1] = b;\n            return;\n        }\n        // this.ensureCapacity(this.sz+2);\n        let cap = this.sz + 2;\n        if (this.r.length < cap) {\n            let newsize = Math.max(2 * this.r.length, cap);\n            let rnew = new Int32Array(newsize);\n            rnew.set(this.r);\n            this.r = rnew;\n        }\n        this.r[this.sz] = a;\n        this.r[this.sz + 1] = b;\n        this.sz += 2;\n    }\n    ;\n    /** Make sure the object can hold at least the given number of entries.\n     * @param cap int\n     * */\n    ensureCapacity(cap) {\n        if (this.r.length < cap)\n            this.resize(Math.max(2 * this.r.length, cap));\n    }\n    ;\n    /**\n     * @param newsize int\n     */\n    resize(newsize) {\n        if (newsize < this.sz)\n            console.error(\"requested array size too small\");\n        if (newsize == this.r.length)\n            return;\n        let rnew = new Int32Array(newsize);\n        let sliced = this.r.slice(0, this.sz + 1);\n        //\t\tthis.arrayCopy(this.r, 0, rnew, 0, this.sz);\n        this.r = sliced;\n    }\n    ;\n}\n//# sourceMappingURL=RangeSet.js.map","/**\n * Partial porting to Javascript of Xyf.java from Healpix3.30\n */\nexport class Xyf {\n    constructor(x, y, f) {\n        this.ix = x;\n        this.iy = y;\n        this.face = f;\n    }\n}\n//# sourceMappingURL=Xyf.js.map","\"use strict\";\nimport { CircleFinder } from \"./CircleFinder.js\";\nimport { Constants } from \"./Constants.js\";\nimport { Fxyf } from \"./Fxyf.js\";\nimport { Hploc } from \"./Hploc.js\";\nimport { Pointing } from \"./Pointing.js\";\nimport { pstack } from \"./pstack.js\";\nimport { RangeSet } from \"./RangeSet.js\";\nimport { Vec3 } from \"./Vec3.js\";\nimport { Xyf } from \"./Xyf.js\";\nimport { Zphi } from \"./Zphi.js\";\n/**\n * Partial porting to Javascript of HealpixBase.java from Healpix3.30\n */\n// import Fxyf from './Fxyf.js';\n// import Hploc from './Hploc.js';\n// import Xyf from './Xyf.js';\n// import Vec3 from './Vec3.js';\n// import Pointing from './Pointing.js';\n// import CircleFinder from './CircleFinder.js';\n// import Zphi from './Zphi.js';\n// import pstack from './pstack.js';\n// import Constants from './Constants.js';\n// import RangeSet from './RangeSet.js';\nexport class Healpix {\n    constructor(nside_in) {\n        this.order_max = 29;\n        this.inv_halfpi = 2.0 / Math.PI;\n        this.twothird = 2.0 / 3.;\n        // console.log(\"twothird \"+this.twothird);\n        // this.ns_max=1L<<order_max;\n        this.ns_max = Math.pow(2, this.order_max);\n        this.ctab = new Uint16Array([\n            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,\n            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,\n            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,\n            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,\n            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,\n            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,\n            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,\n            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,\n            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,\n            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,\n            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,\n            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,\n            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,\n            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,\n            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,\n            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855\n        ]);\n        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,\n            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,\n            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,\n            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,\n            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,\n            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,\n            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,\n            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,\n            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,\n            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,\n            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,\n            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,\n            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,\n            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,\n            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,\n            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,\n            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,\n            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);\n        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);\n        this.facearray = [\n            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),\n            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),\n            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),\n            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]),\n            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),\n            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),\n            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),\n            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),\n            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]) // N\n        ];\n        // questo forse deve essere un UInt8Array. Viene usato da neighbours\n        this.swaparray = [\n            new Int16Array([0, 0, 3]),\n            new Int16Array([0, 0, 6]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([0, 0, 5]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([5, 0, 0]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([6, 0, 0]),\n            new Int16Array([3, 0, 0]) // N\n        ];\n        if (nside_in <= this.ns_max && nside_in > 0) {\n            this.nside = nside_in;\n            this.npface = this.nside * this.nside;\n            this.npix = 12 * this.npface;\n            this.order = this.nside2order(this.nside);\n            this.nl2 = 2 * this.nside;\n            this.nl3 = 3 * this.nside;\n            this.nl4 = 4 * this.nside;\n            this.fact2 = 4.0 / this.npix;\n            this.fact1 = (this.nside << 1) * this.fact2;\n            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap\n            // console.log(\"order: \"+this.order);\n            // console.log(\"nside: \"+this.nside);\n        }\n        this.bn = [];\n        this.mpr = [];\n        this.cmpr = [];\n        this.smpr = [];\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // Uncaught RangeError: Maximum call stack size exceeded\n        // MOVED TO computeBn()\n        //        for (let i=0; i <= this.order_max; ++i) {\n        //        \tthis.bn[i]=new Healpix(1<<i);\n        //        \tthis.mpr[i]=bn[i].maxPixrad();\n        //        \tthis.cmpr[i]=Math.cos(mpr[i]);\n        //        \tthis.smpr[i]=Math.sin(mpr[i]);\n        //        }\n    }\n    computeBn() {\n        for (let i = 0; i <= this.order_max; ++i) {\n            this.bn[i] = new Healpix(1 << i);\n            this.mpr[i] = this.bn[i].maxPixrad();\n            this.cmpr[i] = Hploc.cos(this.mpr[i]);\n            this.smpr[i] = Hploc.sin(this.mpr[i]);\n        }\n    }\n    getNPix() {\n        return this.npix;\n    }\n    ;\n    getBoundaries(pix) {\n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        // console.log(\"PIXEL: \"+pix);\n        // console.log(\"XYF \"+xyf.ix+\" \"+xyf.iy+\" \"+xyf.face);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        // let d = 1.0/(this.nside);\n        // console.log(\"------------------------\");\n        // console.log(\"xc, yc, dc \"+xc+\",\"+ yc+\",\"+ dc);\n        // console.log(\"xc+dc-d, yc+dc, xyf.face, d \"+(xc+dc) +\",\"+ (yc+dc)+\",\"+\n        // xyf.face+\",\"+ d);\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        // console.log(\"Points for npix: \"+pix);\n        // console.log(points);\n        // if (pix > 750){\n        // console.log(\"pix: \"+pix);\n        // console.log(\"dc: \"+dc);\n        // console.log(\"xyf.ix: \"+xyf.ix);\n        // console.log(\"xyf.iy: \"+xyf.iy);\n        // console.log(\"xc: \"+xc);\n        // console.log(\"yc: \"+yc);\n        // console.log(\"d: \"+d);\n        // }\n        return points;\n    }\n    ;\n    /** Returns a set of points along the boundary of the given pixel.\n     * Step 1 gives 4 points on the corners. The first point corresponds\n     * to the northernmost corner, the subsequent points follow the pixel\n     * boundary through west, south and east corners.\n     *\n     * @param pix pixel index number\n     * @param step the number of returned points is 4*step\n     * @return {@link Vec3} for each point\n     */\n    getBoundariesWithStep(pix, step) {\n        // var points = new Array(); \n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        let d = 1.0 / (this.nside * step);\n        for (let i = 0; i < step; i++) {\n            points[i] = new Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();\n            points[i + step] = new Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();\n            points[i + 2 * step] = new Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();\n            points[i + 3 * step] = new Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();\n        }\n        return points;\n    }\n    ;\n    getPointsForXyfNoStep(x, y, face) {\n        let nside = Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    getPointsForXyf(x, y, step, face) {\n        let nside = step * Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    /** Returns the neighboring pixels of ipix.\n    This method works in both RING and NEST schemes, but is\n    considerably faster in the NEST scheme.\n    @param ipix the requested pixel number.\n    @return array with indices of the neighboring pixels.\n      The returned array contains (in this order)\n      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor\n      of ipix. If a neighbor does not exist (this can only happen\n      for the W, N, E and S neighbors), its entry is set to -1. */\n    neighbours(ipix) {\n        let result = new Int32Array(8);\n        let xyf = this.nest2xyf(ipix);\n        let ix = xyf.ix;\n        let iy = xyf.iy;\n        let face_num = xyf.face;\n        var nsm1 = this.nside - 1;\n        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {\n            let fpix = Math.floor(face_num << (2 * this.order));\n            let px0 = this.spread_bits(ix);\n            let py0 = this.spread_bits(iy) << 1;\n            let pxp = this.spread_bits(ix + 1);\n            let pyp = this.spread_bits(iy + 1) << 1;\n            let pxm = this.spread_bits(ix - 1);\n            let pym = this.spread_bits(iy - 1) << 1;\n            result[0] = fpix + pxm + py0;\n            result[1] = fpix + pxm + pyp;\n            result[2] = fpix + px0 + pyp;\n            result[3] = fpix + pxp + pyp;\n            result[4] = fpix + pxp + py0;\n            result[5] = fpix + pxp + pym;\n            result[6] = fpix + px0 + pym;\n            result[7] = fpix + pxm + pym;\n        }\n        else {\n            for (let i = 0; i < 8; ++i) {\n                let x = ix + this.xoffset[i];\n                let y = iy + this.yoffset[i];\n                let nbnum = 4;\n                if (x < 0) {\n                    x += this.nside;\n                    nbnum -= 1;\n                }\n                else if (x >= this.nside) {\n                    x -= this.nside;\n                    nbnum += 1;\n                }\n                if (y < 0) {\n                    y += this.nside;\n                    nbnum -= 3;\n                }\n                else if (y >= this.nside) {\n                    y -= this.nside;\n                    nbnum += 3;\n                }\n                let f = this.facearray[nbnum][face_num];\n                if (f >= 0) {\n                    let bits = this.swaparray[nbnum][face_num >>> 2];\n                    if ((bits & 1) > 0) {\n                        x = Math.floor(this.nside - x - 1);\n                    }\n                    if ((bits & 2) > 0) {\n                        y = Math.floor(this.nside - y - 1);\n                    }\n                    if ((bits & 4) > 0) {\n                        let tint = x;\n                        x = y;\n                        y = tint;\n                    }\n                    result[i] = this.xyf2nest(x, y, f);\n                }\n                else {\n                    result[i] = -1;\n                }\n            }\n        }\n        return result;\n    }\n    ;\n    nside2order(nside) {\n        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);\n    }\n    ;\n    nest2xyf(ipix) {\n        let pix = Math.floor(ipix & (this.npface - 1));\n        let xyf = new Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1), Math.floor((ipix >> (2 * this.order))));\n        return xyf;\n    }\n    ;\n    xyf2nest(ix, iy, face_num) {\n        return Math.floor(face_num << (2 * this.order))\n            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);\n    }\n    ;\n    loc2pix(hploc) {\n        let z = hploc.z;\n        let phi = hploc.phi;\n        let za = Math.abs(z);\n        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0); // in [0,4)\n        let pixNo;\n        if (za <= this.twothird) { // Equatorial region\n            let temp1 = this.nside * (0.5 + tt);\n            let temp2 = this.nside * (z * 0.75);\n            let jp = Math.floor(temp1 - temp2); // index of ascending edge line\n            let jm = Math.floor(temp1 + temp2); // index of descending edge line\n            let ifp = Math.floor(jp >>> this.order); // in {0,4}\n            let ifm = Math.floor(jm >>> this.order);\n            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));\n            let ix = Math.floor(jm & (this.nside - 1));\n            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);\n            pixNo = this.xyf2nest(ix, iy, face_num);\n        }\n        else { // polar region, za > 2/3\n            let ntt = Math.min(3, Math.floor(tt));\n            let tp = tt - ntt;\n            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?\n                this.nside * Math.sqrt(3 * (1 - za)) :\n                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);\n            let jp = Math.floor(tp * tmp); // increasing edge line index\n            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index\n            if (jp >= this.nside) {\n                jp = this.nside - 1; // for points too close to the boundary\n            }\n            if (jm >= this.nside) {\n                jm = this.nside - 1;\n            }\n            if (z >= 0) {\n                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);\n            }\n            else {\n                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);\n            }\n        }\n        return pixNo;\n    }\n    ;\n    /** Returns the normalized 3-vector corresponding to the center of the\n    supplied pixel.\n    @param pix long the requested pixel number.\n    @return the pixel's center coordinates. */\n    pix2vec(pix) {\n        return this.pix2loc(pix).toVec3();\n    }\n    ;\n    /** Returns the Zphi corresponding to the center of the supplied pixel.\n     @param pix the requested pixel number.\n     @return the pixel's center coordinates. */\n    pix2zphi(pix) {\n        return this.pix2loc(pix).toZphi();\n    }\n    /**\n     * @param pix long\n     * @return Hploc\n     */\n    pix2loc(pix) {\n        let loc = new Hploc(undefined);\n        let xyf = this.nest2xyf(pix);\n        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;\n        let nr;\n        if (jr < this.nside) {\n            nr = jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > this.nl3) {\n            nr = this.nl4 - jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = this.nside;\n            loc.z = (this.nl2 - jr) * this.fact1;\n        }\n        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;\n        //      \tassert(tmp<8*nr); // must not happen\n        if (tmp < 0) {\n            tmp += 8 * nr;\n        }\n        loc.phi = (nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp) / nr;\n        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);\n        return loc;\n    }\n    ;\n    ang2pix(ptg, mirror) {\n        return this.loc2pix(new Hploc(ptg));\n    }\n    ;\n    fmodulo(v1, v2) {\n        if (v1 >= 0) {\n            return (v1 < v2) ? v1 : v1 % v2;\n        }\n        var tmp = v1 % v2 + v2;\n        return (tmp === v2) ? 0.0 : tmp;\n    }\n    ;\n    compress_bits(v) {\n        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));\n        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);\n        return compressed;\n    }\n    ;\n    spread_bits(v) {\n        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))\n            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));\n    }\n    ;\n    /**\n     * Returns a range set of pixels that overlap with the convex polygon\n     * defined by the {@code vertex} array.\n     * <p>\n     * This method is more efficient in the RING scheme.\n     * <p>\n     * This method may return some pixels which don't overlap with the polygon\n     * at all. The higher {@code fact} is chosen, the fewer false positives are\n     * returned, at the cost of increased run time.\n     *\n     * @param vertex\n     *            an array containing the vertices of the requested convex\n     *            polygon.\n     * @param fact\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return the requested set of pixel number ranges\n     */\n    queryPolygonInclusive(vertex, fact) {\n        let inclusive = (fact != 0);\n        let nv = vertex.length;\n        //        let ncirc = inclusive ? nv+1 : nv;\n        if (!(nv >= 3)) {\n            console.log(\"not enough vertices in polygon\");\n            return;\n        }\n        let vv = new Array();\n        for (let i = 0; i < nv; ++i) {\n            vv[i] = Vec3.pointing2Vec3(vertex[i]);\n        }\n        let normal = new Array();\n        let flip = 0;\n        let index = 0;\n        let back = false;\n        while (index < vv.length) {\n            let first = vv[index];\n            let medium = null;\n            let last = null;\n            if (index == vv.length - 1) {\n                last = vv[1];\n                medium = vv[0];\n            }\n            else if (index == vv.length - 2) {\n                last = vv[0];\n                medium = vv[index + 1];\n            }\n            else {\n                medium = vv[index + 1];\n                last = vv[index + 2];\n            }\n            normal[index] = first.cross(medium).norm();\n            let hnd = normal[index].dot(last);\n            if (index == 0) {\n                flip = (hnd < 0.) ? -1 : 1;\n                let tmp = new Pointing(first); // TODO not used\n                back = false;\n            }\n            else {\n                let flipThnd = flip * hnd;\n                if (flipThnd < 0) {\n                    let tmp = new Pointing(medium);\n                    vv.splice(index + 1, 1);\n                    normal.splice(index, 1);\n                    back = true;\n                    index -= 1;\n                    continue;\n                }\n                else {\n                    let tmp = new Pointing(first);\n                    back = false;\n                }\n            }\n            normal[index].scale(flip);\n            index += 1;\n        }\n        nv = vv.length;\n        let ncirc = inclusive ? nv + 1 : nv;\n        let rad = new Array(ncirc);\n        rad = rad.fill(Constants.halfpi);\n        //        rad = rad.fill(1.5707963267948966);\n        //        let p = \"1.5707963267948966\";\n        //        rad = rad.fill(parseFloat(p));\n        if (inclusive) {\n            let cf = new CircleFinder(vv);\n            normal[nv] = cf.getCenter();\n            rad[nv] = Hploc.acos(cf.getCosrad());\n        }\n        return this.queryMultiDisc(normal, rad, fact);\n    }\n    ;\n    /**\n     * For NEST schema only\n     *\n     * @param normal:\n     *            Vec3[]\n     * @param rad:\n     *            Float32Array\n     * @param fact:\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return RangeSet the requested set of pixel number ranges\n     */\n    queryMultiDisc(norm, rad, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let nv = norm.length;\n        // HealpixUtils.check(nv==rad.lengt0,\"inconsistent input arrays\");\n        if (!(nv == rad.length)) {\n            console.error(\"inconsistent input arrays\");\n            return;\n        }\n        let res = new RangeSet(4 << 1);\n        // Removed code for Scheme.RING\n        let oplus = 0;\n        if (inclusive) {\n            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {\n                console.error(\"invalid oversampling factor\");\n            }\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = this.order + oplus; // the order up to which we test\n        // TODO: ignore all disks with radius>=pi\n        //        let crlimit = new Float32Array[omax+1][nv][3];\n        let crlimit = new Array(omax + 1);\n        let o;\n        let i;\n        for (o = 0; o <= omax; ++o) { // prepare data at the required orders\n            crlimit[o] = new Array(nv);\n            let dr = this.bn[o].maxPixrad(); // safety distance\n            for (i = 0; i < nv; ++i) {\n                crlimit[o][i] = new Float64Array(3);\n                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Hploc.cos(rad[i] + dr);\n                crlimit[o][i][1] = (o == 0) ? Hploc.cos(rad[i]) : crlimit[0][i][1];\n                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : Hploc.cos(rad[i] - dr);\n            }\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse\n            // order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let o = stk.otop();\n            stk.pop();\n            let pv = this.bn[o].pix2vec(pix);\n            let zone = 3;\n            for (let i = 0; (i < nv) && (zone > 0); ++i) {\n                let crad = pv.dot(norm[i]);\n                for (let iz = 0; iz < zone; ++iz) {\n                    if (crad < crlimit[o][i][iz]) {\n                        zone = iz;\n                    }\n                }\n            }\n            if (zone > 0) {\n                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);\n            }\n        }\n        return res;\n    }\n    ;\n    /** Integer base 2 logarithm.\n    @param arg\n    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.\n    For negative arguments and zero, 0 is returned. */\n    ilog2(arg) {\n        let max = Math.max(arg, 1);\n        return 31 - Math.clz32(max);\n    }\n    ;\n    /** Computes the cosine of the angular distance between two z, phi positions\n      on the unit sphere. */\n    cosdist_zphi(z1, phi1, z2, phi2) {\n        return z1 * z2 + Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));\n    }\n    /**\n     * @param int o\n     * @param int omax\n     * @param int zone\n     * @param RangeSet pixset\n     * @param long pix\n     * @param pstack stk\n     * @param boolean inclusive\n     */\n    check_pixel(o, omax, zone, pixset, pix, stk, inclusive) {\n        if (zone == 0)\n            return;\n        if (o < this.order) {\n            if (zone >= 3) { // output all subpixels\n                let sdist = 2 * (this.order - o); // the \"bit-shift distance\" between map orders\n                pixset.append1(pix << sdist, ((pix + 1) << sdist));\n            }\n            else { // (zone>=1)\n                for (let i = 0; i < 4; ++i) {\n                    stk.push(4 * pix + 3 - i, o + 1); // add children\n                }\n            }\n        }\n        else if (o > this.order) { // this implies that inclusive==true\n            if (zone >= 2) { // pixel center in shape\n                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                stk.popToMark(); // unwind the stack\n            }\n            else { // (zone>=1): pixel center in safety range\n                if (o < omax) { // check sublevels\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                    stk.popToMark(); // unwind the stack\n                }\n            }\n        }\n        else { // o==order\n            if (zone >= 2) {\n                pixset.append(pix);\n            }\n            else if (inclusive) { // and (zone>=1)\n                if (this.order < omax) { // check sublevels\n                    stk.mark(); // remember current stack position\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix); // output the pixel\n                }\n            }\n        }\n    }\n    /** Returns the maximum angular distance between a pixel center and its\n    corners.\n    @return maximum angular distance between a pixel center and its\n      corners. */\n    maxPixrad() {\n        let zphia = new Zphi(2. / 3., Math.PI / this.nl4);\n        let xyz1 = this.convertZphi2xyz(zphia);\n        let va = new Vec3(xyz1[0], xyz1[1], xyz1[2]);\n        let t1 = 1. - 1. / this.nside;\n        t1 *= t1;\n        let zphib = new Zphi(1 - t1 / 3, 0);\n        let xyz2 = this.convertZphi2xyz(zphib);\n        let vb = new Vec3(xyz2[0], xyz2[1], xyz2[2]);\n        return va.angle(vb);\n    }\n    ;\n    /**\n     * this is a workaround replacing the Vec3(Zphi) constructor.\n     */\n    convertZphi2xyz(zphi) {\n        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));\n        let x = sth * Hploc.cos(zphi.phi);\n        let y = sth * Hploc.sin(zphi.phi);\n        let z = zphi.z;\n        return [x, y, z];\n    }\n    ;\n    /** Returns a range set of pixels which overlap with a given disk. <p>\n      This method is more efficient in the RING scheme. <p>\n      This method may return some pixels which don't overlap with\n      the polygon at all. The higher {@code fact} is chosen, the fewer false\n      positives are returned, at the cost of increased run time.\n      @param ptg the angular coordinates of the disk center\n      @param radius the radius (in radians) of the disk\n      @param fact The overlapping test will be done at the resolution\n        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power\n        of 2, else it can be any positive integer. A typical choice would be 4.\n      @return the requested set of pixel number ranges  */\n    queryDiscInclusive(ptg, radius, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let pixset = new RangeSet();\n        if (radius >= Math.PI) { // disk covers the whole sphere\n            pixset.append1(0, this.npix);\n            return pixset;\n        }\n        let oplus = 0;\n        if (inclusive) {\n            // HealpixUtils.check ((1L<<order_max)>=fact,\"invalid oversampling factor\");\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test\n        let vptg = Vec3.pointing2Vec3(ptg);\n        let crpdr = new Array(omax + 1);\n        let crmdr = new Array(omax + 1);\n        let cosrad = Hploc.cos(radius);\n        let sinrad = Hploc.sin(radius);\n        for (let o = 0; o <= omax; o++) { // prepare data at the required orders\n            let dr = this.mpr[o]; // safety distance\n            let cdr = this.cmpr[o];\n            let sdr = this.smpr[o];\n            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;\n            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let curro = stk.otop();\n            stk.pop();\n            let pos = this.bn[curro].pix2zphi(pix);\n            // cosine of angular distance between pixel center and disk center\n            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);\n            if (cangdist > crpdr[curro]) {\n                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);\n                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);\n            }\n        }\n        return pixset;\n    }\n}\n//# sourceMappingURL=Healpix.js.map","export { Constants } from \"./Constants.js\";\nexport { pstack } from \"./pstack.js\";\nexport { CircleFinder } from './CircleFinder.js';\nexport { Fxyf } from './Fxyf.js';\nexport { Healpix } from './Healpix.js';\nexport { Pointing } from './Pointing.js';\nexport { RangeSet } from './RangeSet.js';\nexport { Vec3 } from './Vec3.js';\nexport { Xyf } from './Xyf.js';\nexport { Zphi } from './Zphi.js';\nexport { Hploc } from './Hploc.js';\n//# sourceMappingURL=index.js.map","//HiPSIntermediateProj.ts\nimport { Healpix, Hploc, Pointing } from \"healpixjs\";\nimport { AstroCoords } from \"../../model/AstroCoords.js\";\nimport { HEALPixXYSpace } from \"../../model/HEALPixXYSpace.js\";\nimport { CoordsType } from \"../../model/CoordsType.js\";\nimport { NumberType } from \"../../model/NumberType.js\";\nimport { Point } from \"../../model/Point.js\";\nimport { radToDeg } from \"../../model/Utils.js\";\n\n\nexport class HiPSIntermediateProj {\n\n    static RES_ORDER_0: number = 58.6;\n    static H: number = 4;\n    static K: number = 3;\n    static THETAX: number = Hploc.asin((HiPSIntermediateProj.K - 1) / HiPSIntermediateProj.K);\n\n\n    // static setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n\n    //     let xyGridProj: HEALPixXYSpace = {\n    //         \"min_y\": NaN,\n    //         \"max_y\": NaN,\n    //         \"min_x\": NaN,\n    //         \"max_x\": NaN,\n    //         \"gridPointsDeg\": []\n    //     }\n\n\n    //     let cornersVec3 = hp.getBoundariesWithStep(tileno, 1);\n    //     let pointings = [];\n\n    //     for (let i = 0; i < cornersVec3.length; i++) {\n    //         pointings[i] = new Pointing(cornersVec3[i]);\n    //         if (i >= 1) {\n    //             let a = pointings[i - 1].phi;\n    //             let b = pointings[i].phi;\n    //             // case when RA is just crossing the origin (e.g. 357deg - 3deg)\n    //             if (Math.abs(a - b) > Math.PI) {\n    //                 if (pointings[i - 1].phi < pointings[i].phi) {\n    //                     pointings[i - 1].phi += 2 * Math.PI;\n    //                 } else {\n    //                     pointings[i].phi += 2 * Math.PI;\n    //                 }\n    //             }\n    //         }\n    //     }\n\n    //     for (let j = 0; j < pointings.length; j++) {\n    //         let coThetaRad = pointings[j].theta;\n    //         // HEALPix works with colatitude (0 North Pole, 180 South Pole)\n    //         // converting the colatitude in latitude (dec)\n    //         let decRad = Math.PI / 2 - coThetaRad;\n\n    //         let raRad = pointings[j].phi;\n\n    //         // projection on healpix grid\n    //         // let p = new Point(CoordsType.ASTRO, NumberType.RADIANS, raRad, decRad);\n    //         // let xyDeg = HiPSIntermediateProj.world2intermediate(p.getAstro());\n    //         // Build a tiny AstroCoords inline to avoid Points RA wrap:\n    //         const ac: AstroCoords = {\n    //             raDeg: radToDeg(raRad), raRad,\n    //             decDeg: radToDeg(decRad), decRad\n    //         } as AstroCoords;\n    //         const [xDeg, yDeg] = HiPSIntermediateProj.world2intermediate(ac);  //  no RA re-wrap\n\n    //         xyGridProj.gridPointsDeg[j * 2] = xDeg;\n    //         xyGridProj.gridPointsDeg[j * 2 + 1] = yDeg;\n\n    //         if (isNaN(xyGridProj.max_y) || yDeg > xyGridProj.max_y) {\n    //             xyGridProj.max_y = yDeg;\n    //         }\n    //         if (isNaN(xyGridProj.min_y) || yDeg < xyGridProj.min_y) {\n    //             xyGridProj.min_y = yDeg;\n    //         }\n    //         if (isNaN(xyGridProj.max_x) || xDeg > xyGridProj.max_x) {\n    //             xyGridProj.max_x = xDeg;\n    //         }\n    //         if (isNaN(xyGridProj.min_x) || xDeg < xyGridProj.min_x) {\n    //             xyGridProj.min_x = xDeg;\n    //         }\n\n    //     }\n    //     return xyGridProj;\n    // }\n    static setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n        const xy: HEALPixXYSpace = { min_y: NaN, max_y: NaN, min_x: NaN, max_x: NaN, gridPointsDeg: [] };\n\n        const corners = hp.getBoundariesWithStep(tileno, 1);\n        const pts: Pointing[] = [];\n\n        // 1) enforce  continuity in radians\n        for (let i = 0; i < corners.length; i++) {\n            pts[i] = new Pointing(corners[i]);\n            if (i >= 1) {\n                const a = pts[i - 1].phi, b = pts[i].phi;\n                if (Math.abs(a - b) > Math.PI) {\n                    if (a < b) pts[i - 1].phi += 2 * Math.PI;\n                    else pts[i].phi += 2 * Math.PI;\n                }\n            }\n        }\n\n        // 2) project all boundary samples (WITHOUT Point to avoid RA wrap)\n        const xs: number[] = [];\n        const ys: number[] = [];\n        for (let j = 0; j < pts.length; j++) {\n            const coTheta = pts[j].theta;\n            const decRad = Math.PI / 2 - coTheta;\n            const raRad = pts[j].phi;\n            const ac: AstroCoords = {\n                raDeg: radToDeg(raRad), raRad,\n                decDeg: radToDeg(decRad), decRad\n            } as AstroCoords;\n\n            const [xDeg, yDeg] = HiPSIntermediateProj.world2intermediate(ac);\n            xs.push(xDeg);\n            ys.push(yDeg);\n        }\n\n        // 3) Y-extrema are reliable: set min_y / max_y from them\n        let minY = +Infinity, maxY = -Infinity;\n        for (const y of ys) { if (y < minY) minY = y; if (y > maxY) maxY = y; }\n        const yMid = 0.5 * (minY + maxY);\n\n        // 4) pick ONLY boundary samples near the mid-Y line to find left/right X\n        //    (this avoids sector-hop outliers in X)\n        const tol = Math.max(1e-6, 0.02 * (maxY - minY)); // 2% of Y span\n        let minX = +Infinity, maxX = -Infinity;\n        for (let k = 0; k < xs.length; k++) {\n            if (Math.abs(ys[k] - yMid) <= tol) {\n                if (xs[k] < minX) minX = xs[k];\n                if (xs[k] > maxX) maxX = xs[k];\n            }\n        }\n\n        // Fallback: if the midline filter caught nothing (rare), use a filtered percentile\n        if (!Number.isFinite(minX) || !Number.isFinite(maxX)) {\n            const pairs = xs.map((x, i) => ({ x, y: ys[i] }))\n                .sort((a, b) => Math.abs(a.y - yMid) - Math.abs(b.y - yMid));\n            const take = Math.max(4, Math.floor(pairs.length * 0.1)); // closest 10%\n            minX = +Infinity; maxX = -Infinity;\n            for (let i = 0; i < take; i++) {\n                const x = pairs[i].x;\n                if (x < minX) minX = x;\n                if (x > maxX) maxX = x;\n            }\n        }\n\n        // 5) Save the unmodified projected samples and envelope\n        xy.min_y = minY; xy.max_y = maxY;\n        xy.min_x = minX; xy.max_x = maxX;\n\n        for (let i = 0; i < xs.length; i++) {\n            xy.gridPointsDeg[2 * i] = xs[i];\n            xy.gridPointsDeg[2 * i + 1] = ys[i];\n        }\n\n        return xy;\n    }\n\n\n    // private static unwrapProjectedX(xs: number[], thresholdDeg = 120): number[] {\n    //     if (xs.length === 0) return xs;\n    //     const out = [xs[0]];\n    //     for (let k = 1; k < xs.length; k++) {\n    //         let curr = xs[k];\n    //         const prev = out[k - 1];\n    //         while (curr - prev > thresholdDeg) curr -= 360;\n    //         while (curr - prev < -thresholdDeg) curr += 360;\n    //         out.push(curr);\n    //     }\n    //     // close polygon consistency (last vs first)\n    //     const first = out[0], last = out[out.length - 1];\n    //     if (Math.abs(last - first) > thresholdDeg) {\n    //         out[out.length - 1] += (last > first) ? -360 : 360;\n    //     }\n    //     return out;\n    // }\n\n\n    static world2intermediate(ac: AstroCoords): [number, number] {\n        let x_grid: number = NaN;\n        let y_grid: number = NaN;\n\n        if (Math.abs(ac.decRad) <= HiPSIntermediateProj.THETAX) { // equatorial belts\n            x_grid = ac.raDeg;\n\n            y_grid = Hploc.sin(ac.decRad) * HiPSIntermediateProj.K * 90 / HiPSIntermediateProj.H;\n\n\n        } else if (Math.abs(ac.decRad) > HiPSIntermediateProj.THETAX) { // polar zones\n\n            let raDeg = ac.raDeg;\n\n            let w = 0; // omega\n            if (HiPSIntermediateProj.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0\n                w = 1;\n            }\n\n            let sigma = Math.sqrt(HiPSIntermediateProj.K * (1 - Math.abs(Hploc.sin(ac.decRad))));\n            let phi_c = - 180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSIntermediateProj.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSIntermediateProj.H);\n\n            x_grid = phi_c + (raDeg - phi_c) * sigma;\n            y_grid = (180 / HiPSIntermediateProj.H) * (((HiPSIntermediateProj.K + 1) / 2) - sigma);\n\n            if (ac.decRad < 0) {\n                y_grid *= -1;\n            }\n        }\n\n        return [x_grid, y_grid];\n    }\n\n    static intermediate2pix(x: number, y: number, xyGridProj: HEALPixXYSpace, pxXtile: number): [number, number] {\n\n        const xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);\n        const yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);\n\n        // let i_norm: number;\n        // let j_norm: number;\n        // if ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {\n        //     i_norm = (x + 360 - xyGridProj.min_x) / xInterval;\n        // } else {\n        //     i_norm = (x - xyGridProj.min_x) / xInterval;\n        // }\n        // j_norm = (y - xyGridProj.min_y) / yInterval;\n\n\n        // let i = 0.5 - (i_norm - j_norm);\n        // let j = (i_norm + j_norm) - 0.5;\n\n        // // TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);\n        // // pxXtile\n        // // i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);\n        // // j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);\n        // // return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];\n\n        // i = Math.floor(i * pxXtile);\n        // j = Math.floor(j * pxXtile);\n        // return [i, pxXtile - j - 1];\n\n        // Bring x into [min_x, max_x) considering 360 wrap\n        let xAdj = x;\n        if (xInterval < 360) {\n            if (xyGridProj.min_x < 0 && xAdj > xyGridProj.max_x) xAdj -= 360;\n            if (xyGridProj.max_x > 360 && xAdj < xyGridProj.min_x) xAdj += 360;\n            if (xAdj < xyGridProj.min_x) xAdj += 360;\n            if (xAdj >= xyGridProj.max_x) xAdj -= 360;\n        }\n\n        const i_norm = (xAdj - xyGridProj.min_x) / xInterval;\n        const j_norm = (y - xyGridProj.min_y) / yInterval;\n\n        let i = 0.5 - (i_norm - j_norm);\n        let j = (i_norm + j_norm) - 0.5;\n\n        i = Math.floor(i * pxXtile);\n        j = Math.floor(j * pxXtile);\n        return [i, pxXtile - j - 1];\n    }\n\n    static pix2intermediate(i: number, j: number, xyGridProj: HEALPixXYSpace, naxis1: number, naxis2: number): [number, number] {\n        /**\n                   * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image\n                 * (i_norm,w_pixel) = (1,1) is the upper right corner\n                 * dimamond in figure 1 from \"Mapping on the HEalpix grid\" paper\n                 * (0,0) leftmost corner\n                 * (1,0) upper corner\n                 * (0,1) lowest corner\n                 * (1,1) rightmost corner\n                 * Thanks YAGO! :p\n                 */\n        // let cnaxis1 = HiPSHelper.pxXtile;\n        // let cnaxis2 = HiPSHelper.pxXtile;\n\n        let cnaxis1 = naxis1;\n        let cnaxis2 = naxis2;\n        if (naxis1) {\n            cnaxis1 = naxis1;\n        }\n        if (naxis2) {\n            cnaxis2 = naxis2;\n        }\n        const i_norm = (i + 0.5) / cnaxis1;\n        const j_norm = (j + 0.5) / cnaxis2;\n\n        const xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;\n        const yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;\n        const yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;\n\n        // bi-linear interpolation\n        // const x = xyGridProj.max_x - xInterval * (i_norm + j_norm);\n        const x = xyGridProj.min_x + xInterval * (i_norm + j_norm);\n        const y = yMean - yInterval * (j_norm - i_norm);\n\n        return [x, y];\n    }\n\n    // Ithink here I am passing RA and Dec becasue probably in the xyGridProj I am storing RA and Dec\n    static intermediate2world(x: number, y: number): Point {\n\n        let raDeg: number = NaN\n        let decDeg: number = NaN\n        const Yx = 90 * (HiPSIntermediateProj.K - 1) / HiPSIntermediateProj.H; // = 45 for H=4,K=3\n\n\n\n        if (Math.abs(y) <= Yx) { // equatorial belts\n            // === Equatorial inverse ===\n            //  = x ;  sin(Dec) = y * H / (90 K)\n            // raDeg = x\n            // decDeg = radToDeg(Math.asin((y * HiPSIntermediateProj.H) / (90 * HiPSIntermediateProj.K)))\n            raDeg = x;\n            const s = (y * HiPSIntermediateProj.H) / (90 * HiPSIntermediateProj.K);\n            const sClamped = Math.max(-1, Math.min(1, s));\n            decDeg = radToDeg(Math.asin(sClamped));\n\n        } else { // polar regions\n            // === Polar inverse ===\n            //  = (K+1)/2  |y| H / 180\n            const sigma = (HiPSIntermediateProj.K + 1) / 2 - (Math.abs(y) * HiPSIntermediateProj.H) / 180\n            // Recover z = sin(Dec) with hemisphere from y\n            const zAbs = 1 - (sigma * sigma) / HiPSIntermediateProj.K; // |sin(Dec)|\n            const z = (y >= 0 ? 1 : -1) * zAbs;\n            const zClamped = Math.max(-1, Math.min(1, z));\n            decDeg = radToDeg(Math.asin(zClamped));\n\n            // const thetaRad = Hploc.asin(1 - (sigma * sigma) / HiPSIntermediateProj.K)\n            // let w = 0 // omega\n            // if (HiPSIntermediateProj.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0\n            //     w = 1\n            // }\n\n            //  from hemisphere (use y), or K odd\n            const w = (HiPSIntermediateProj.K % 2 !== 0 || y > 0) ? 1 : 0;  //  use hemisphere from y\n            // Sector centre and RA\n            const x_c = -180 + (2 * Math.floor((x + 180) * HiPSIntermediateProj.H / 360 + (1 - w) / 2) + w) * (180 / HiPSIntermediateProj.H)\n            raDeg = x_c + (x - x_c) / (sigma || 1) // guard =0 at the pole\n            // Optional: wrap RA to [0,360)\n            raDeg = ((raDeg % 360) + 360) % 360;\n\n            // decDeg = radToDeg(thetaRad)\n            // if (y <= 0) {\n            //     decDeg *= -1\n            // }\n        }\n        // return [phiDeg, thetaDeg];\n        // TODO CHECK THIS!\n        // let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);\n        const p = new Point(CoordsType.ASTRO, NumberType.DEGREES, raDeg, decDeg);\n\n        return p;\n    }\n\n}","\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { Healpix } from 'healpixjs';\nimport { Pointing } from \"healpixjs\";\nimport { Hploc } from \"healpixjs\";\n\nimport { radToDeg } from '../model/Utils.js'; // TODO change package\nimport { CoordsType } from \"../model/CoordsType.js\";\nimport { HEALPixXYSpace } from \"../model/HEALPixXYSpace.js\";\nimport { Point } from \"../model/Point.js\";\nimport { NumberType } from '../model/NumberType.js';\nimport { AstroCoords } from \"../model/AstroCoords.js\";\n\nexport class HiPSHelper {\n\n\n\t// static pxXtile: number = 512; // TODO in some cases it is different\n\tstatic DEFAULT_Naxis1_2: number = 512;\n\t// static RES_ORDER_0: number = 58.6 / HiPSHelper.pxXtile;\n\tstatic RES_ORDER_0: number = 58.6;\n\tstatic H: number = 4;\n\tstatic K: number = 3;\n\tstatic THETAX: number = Hploc.asin((HiPSHelper.K - 1) / HiPSHelper.K);\n\t/**\n\t * Table 1 - ref paper HEALPix  a Framework for High Resolution Discretization,\n\t * and Fast Analysis of Data Distributed on the Sphere\n\t * K. M. Gorski1,2, E. Hivon3,4, A. J. Banday5, B. D. Wandelt6,7, F. K. Hansen8, M.\n\t * Reinecke5, M. Bartelman9\n\t */\n\t/**\n\t * \n\t * @param {decimal degrees} pxsize \n\t * @returns {int} nside\n\t */\n\t// static computeHiPSOrder(pxsize: number, pxXtile: number): number {\n\t// \t/**\n\t// \t * with same order k (table 1), HIPS angular resolution is higher of order of 512 (2^9) pixels than \n\t// \t * the HEALPix. This is because each tile in a HiPS is represented by default by 512x512 pixels.\\\n\t// \t * Angular resolution of different HEALPix orders in respect to the order 0, can be calculated this\n\t// \t * way:\n\t// \t * \n\t// \t * \tL(k) = L(0) / 2^k = 58.6 / 2^k\n\t// \t * \n\t// \t * Therefore, in the case of HiPS we need to take into account the extra resolution given by the \n\t// \t * 512x512 (2^9) tiles. In this case the above becomes:\n\t// \t * \t\n\t// \t * \tL(k) = L(0) / (2^k * 2^9) \n\t// \t * \n\t// \t * Though, in order to compute the required order starting from the pxsize desired (in input) we\n\t// \t * need to perform these steps:\n\t// \t * \n\t// \t * \tpxsize = L(k) = L(0) / (2^k * 2^9)\n\t// \t * \t2^k = L(0) / (pxsize * 2^9)\n\t// \t *  k * Log2 2 = Log2 L(0) - Log2 (pxsize * 2^9)\n\t// \t * \tk = Log2 L(0) - Log2 (pxsize * 2^9)\n\t// \t * \n\t// \t */\n\n\n\t// \tlet k = Math.log2( (HiPSHelper.RES_ORDER_0 / pxXtile) / pxsize);\n\t// \t// let k = Math.log2(HiPSHelper.RES_ORDER_0 / (pxXtile * pxsize));\n\t// \tk = Math.round(k);\n\t// \t// let theta0px = HiPSHelper.RES_ORDER_0;\n\t// \t// let k = Math.log2(theta0px) - Math.log2(pxsize * 2**9);\n\t// \t// k = Match.round(k);\n\t// \t// let nside = 2**k;\n\t// \t// return {\n\t// \t//     \"nside\" : nside,\n\t// \t//     \"norder\" : k\n\t// \t// };\n\t// \treturn k;\n\n\t// }\n\n\t// static computeHiPSOrder2(pxsize: number, pxXtile: number): number {\n\t\t\n\t// \tconst k = Math.log2( Math.sqrt(Math.PI/ 3) / ( pxsize * pxXtile) )\n\t// \tconst order = Math.round(k);\n\t// \tconsole.warn(k)\n \n\t// \treturn order;\n\n\t// }\n\n\n\t// based on \"HiPS  Hierarchical Progressive Survey\" IVOA recomandation (formula on table 5)\n\tstatic computeOrder(pxAngSizeDeg: number, pxTileWidth: number): number {\n\t\tconsole.log(`Computing HiPS order having pixel angular size of ${pxAngSizeDeg} in degrees`)\n\t\tconst deg2rad = Math.PI / 180\n\t\tconst pxAngSizeRad = pxAngSizeDeg * deg2rad\n\t\tconsole.log(`pixel angular res in radians ${pxAngSizeRad}`)\n\t\tconst computedOrder = 0.5 * Math.log2 ( Math.PI / (3 * pxAngSizeRad * pxAngSizeRad * pxTileWidth * pxTileWidth) )\n\t\tconsole.log(`Order ${computedOrder}`)\n\t\tif (computedOrder < 0) {\n\t\t\treturn 0\n\t\t}\n\t\treturn Math.floor(computedOrder)\n\t}\n\n\tstatic getHelpixByOrder(order: number): Healpix {\n\t\tconst nside = 2 ** order\n        const healpix = new Healpix(nside)\n\t\treturn healpix\n\t}\n\n\tstatic getHelpixBypxAngSize(pixelAngulaSize: number, TILE_WIDTH: number, hipsMaxOrder: number | null = null): Healpix {\n\t\tlet healpixOrder = HiPSHelper.computeOrder(pixelAngulaSize, TILE_WIDTH)\n\t\tif (hipsMaxOrder && hipsMaxOrder > 0) {\n\t\t\tif (healpixOrder > hipsMaxOrder) {\n\t\t\t\thealpixOrder = hipsMaxOrder\n\t\t\t}\n\t\t}\n        const nside = 2 ** healpixOrder\n        const healpix = new Healpix(nside)\n\t\treturn healpix\n\t}\n\n\t// based on \"HiPS  Hierarchical Progressive Survey\" IVOA recomandation (formula on table 5)\n\tstatic computePxAngularSize(pxTileWidth: number, order: number) {\n\t\tconst computedPxAngSizeRadiant = Math.sqrt( 4 * Math.PI / (12 * (pxTileWidth * (2**order) )**2 ) )\n\t\tconsole.log(`Computing Pixel size with tile of ${pxTileWidth} pixels and order ${order}`)\n\t\tconst rad2deg = 180 / Math.PI\n\t\tconst deg = computedPxAngSizeRadiant * rad2deg\n\t\tconst arcmin = computedPxAngSizeRadiant * rad2deg * 60\n\t\tconst arcsec = computedPxAngSizeRadiant * rad2deg * 3600\n\t\tconsole.log (\"Pixel size in radiant:\" + computedPxAngSizeRadiant)\n\t\tconsole.log (\"Pixel size in degrees:\" + deg)\n\t\tconsole.log (\"Pixel size in arcmin:\" + arcmin)\n\t\tconsole.log (\"Pixel size in arcsec:\" + arcsec)\n\t\treturn {\n\t\t\t\"rad\": computedPxAngSizeRadiant,\n\t\t\t\"deg\": deg,\n\t\t\t\"arcmin\": arcmin,\n\t\t\t\"arcsec\": arcsec\n\t\t}\n\t}\n\n\n\t/**\n\t * Reference: HiPS  Hierarchical Progressive Survey page 11\n\t * pxsize =~ sqrt[4 * PI / (12 * (512 * 2^order)^2)]\n\t * @param {*} order \n\t */\n\tstatic computePxSize(order: number, pxXtile: number): number {\n\t\t// TODO CHECK IT\n\t\t// let pxsize = 1 / (512 * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\tlet pxsize = 1 / (pxXtile * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\treturn pxsize;\n\t}\n\n\t// /**\n\t//  * \n\t//  * @param {Object {ra, dec}} point  decimal degrees\n\t//  * @returns {Object {phi_rad, theta_rad}} in radians\n\t//  */\n\t// static convert2PhiTheta (point: Point) {\n\t// \tlet phitheta_rad = {};\n\t// \tlet phiTheta_deg = HiPSHelper.astroDegToSpherical(point.ra, point.dec);\n\t// \tphitheta_rad.phi_rad = HiPSHelper.degToRad(phiTheta_deg.phi);\n\t//     phitheta_rad.theta_rad = HiPSHelper.degToRad(phiTheta_deg.theta);\n\t// \treturn phitheta_rad;\n\t// }\n\n\t// static astroDegToSphericalRad(raDeg: number, decDeg: number) {\n\t// \tlet phiThetaDeg = HiPSHelper.astroDegToSpherical(raDeg, decDeg);\n\t// \tlet phiThetaRad = {\n\t// \t\tphi_rad: HiPSHelper.degToRad(phiThetaDeg.phi),\n\t// \t\ttheta_rad: HiPSHelper.degToRad(phiThetaDeg.theta)\n\t// \t}\n\t// \treturn phiThetaRad;\n\t// }\n\n\t// static degToRad(degrees: number): number {\n\t// \treturn (degrees / 180 ) * Math.PI ;\n\t// }\n\n\t// static radToDeg(rad: number): number {\n\t// \treturn (rad / Math.PI ) * 180 ;\n\t// }\n\n\t// static astroDegToSpherical(raDeg: number, decDeg: number): Point{\n\n\t// \tlet phiDeg: number;\n\t// \tlet thetaDeg: number;\n\t// \tphiDeg = raDeg;\n\t// \tif (phiDeg < 0){\n\t// \t\tphiDeg += 360;\n\t// \t}\n\n\t// \tthetaDeg = 90 - decDeg;\n\n\t// \treturn {\n\t// \t\tphi: phiDeg,\n\t// \t\ttheta: thetaDeg\n\t// \t};\n\t// }\n\n\t/**\n\t * \n\t * @param {Object {phi_rad, theta_rad}} phiTheta_rad Center of the circle in radians\n\t * @param {decimal} r Radius of the circle in radians\n\t * @returns \n\t */\n\tstatic computeBbox(point: Point, r: number): Pointing[] {\n\n\t\tlet bbox = [];\n\t\tbbox.push(new Pointing(null, false, point.getSpherical().thetaRad - r, point.getSpherical().phiRad - r));\n\t\tbbox.push(new Pointing(null, false, point.getSpherical().thetaRad - r, point.getSpherical().phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.getSpherical().thetaRad + r, point.getSpherical().phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.getSpherical().thetaRad - r, point.getSpherical().phiRad - r));\n\n\t\treturn bbox;\n\t}\n\n\t// static setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n\n\t// \tlet xyGridProj: HEALPixXYSpace = {\n\t// \t\t\"min_y\": NaN,\n\t// \t\t\"max_y\": NaN,\n\t// \t\t\"min_x\": NaN,\n\t// \t\t\"max_x\": NaN,\n\t// \t\t\"gridPointsDeg\": []\n\t// \t}\n\n\n\t// \tlet cornersVec3 = hp.getBoundariesWithStep(tileno, 1);\n\t// \tlet pointings = [];\n\n\t// \tfor (let i = 0; i < cornersVec3.length; i++) {\n\t// \t\tpointings[i] = new Pointing(cornersVec3[i]);\n\t// \t\tif (i >= 1) {\n\t// \t\t\tlet a = pointings[i - 1].phi;\n\t// \t\t\tlet b = pointings[i].phi;\n\t// \t\t\t// case when RA is just crossing the origin (e.g. 357deg - 3deg)\n\t// \t\t\tif (Math.abs(a - b) > Math.PI) {\n\t// \t\t\t\tif (pointings[i - 1].phi < pointings[i].phi) {\n\t// \t\t\t\t\tpointings[i - 1].phi += 2 * Math.PI;\n\t// \t\t\t\t} else {\n\t// \t\t\t\t\tpointings[i].phi += 2 * Math.PI;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \tfor (let j = 0; j < pointings.length; j++) {\n\t// \t\tlet coThetaRad = pointings[j].theta;\n\t// \t\t// HEALPix works with colatitude (0 North Pole, 180 South Pole)\n\t// \t\t// converting the colatitude in latitude (dec)\n\t// \t\tlet decRad = Math.PI / 2 - coThetaRad;\n\n\t// \t\tlet raRad = pointings[j].phi;\n\n\t// \t\t// projection on healpix grid\n\t// \t\tlet p = new Point(CoordsType.ASTRO, NumberType.RADIANS, raRad, decRad);\n\t// \t\tlet xyDeg = HiPSHelper.world2intermediate(p.getAstro());\n\t// \t\txyGridProj.gridPointsDeg[j * 2] = xyDeg[0];\n\t// \t\txyGridProj.gridPointsDeg[j * 2 + 1] = xyDeg[1];\n\n\t// \t\tif (isNaN(xyGridProj.max_y) || xyDeg[1] > xyGridProj.max_y) {\n\t// \t\t\txyGridProj.max_y = xyDeg[1];\n\t// \t\t}\n\t// \t\tif (isNaN(xyGridProj.min_y) || xyDeg[1] < xyGridProj.min_y) {\n\t// \t\t\txyGridProj.min_y = xyDeg[1];\n\t// \t\t}\n\t// \t\tif (isNaN(xyGridProj.max_x) || xyDeg[0] > xyGridProj.max_x) {\n\t// \t\t\txyGridProj.max_x = xyDeg[0];\n\t// \t\t}\n\t// \t\tif (isNaN(xyGridProj.min_x) || xyDeg[0] < xyGridProj.min_x) {\n\t// \t\t\txyGridProj.min_x = xyDeg[0];\n\t// \t\t}\n\n\t// \t}\n\t// \treturn xyGridProj;\n\t// }\n\n\t// static world2intermediate(ac: AstroCoords): [number, number] {\n\n\t// \tlet x_grid: number;\n\t// \tlet y_grid: number;\n\n\t// \tif (Math.abs(ac.decRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t\t\t\n\t// \t\tx_grid = ac.raDeg;\n\t// \t\ty_grid = Hploc.sin(ac.decRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\t// \t\treturn [x_grid, y_grid];\n\n\t// \t} else if (Math.abs(ac.decRad) > HiPSHelper.THETAX) { // polar zones\n\n\t// \t\tconst raDeg = ac.raDeg;\n\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\n\t// \t\tconst sigma = Math.sqrt(HiPSHelper.K * (1 - Math.abs(Hploc.sin(ac.decRad))));\n\t// \t\tconst phi_c = - 180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSHelper.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSHelper.H);\n\n\t// \t\tx_grid = phi_c + (raDeg - phi_c) * sigma;\n\t// \t\ty_grid = (180 / HiPSHelper.H) * (((HiPSHelper.K + 1) / 2) - sigma);\n\n\t// \t\tif (ac.decRad < 0) {\n\t// \t\t\ty_grid *= -1;\n\t// \t\t}\n\t// \t\treturn [x_grid, y_grid]\n\t// \t}\n\n\t// \treturn [NaN, NaN];\n\n\t// }\n\n\t// static world2intermediate(sc: SphericalCoords): [number, number] {\n\t//     let x_grid: number;\n\t// \tlet y_grid: number;\n\n\t// \tif ( Math.abs(sc.thetaRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t// \t\tx_grid = sc.phiDeg;\n\n\t// \t\ty_grid = Hploc.sin(sc.thetaRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t// \t} else if ( Math.abs(sc.thetaRad) > HiPSHelper.THETAX) { // polar zones\n\n\t// \t\tlet phiDeg = sc.phiDeg;\n\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || sc.thetaRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\n\t// \t\tlet sigma = Math.sqrt( HiPSHelper.K * (1 - Math.abs(Hploc.sin(sc.thetaRad)) ) );\n\t// \t\tlet phi_c = - 180 + ( 2 * Math.floor( ((sc.phiRad + 180) * HiPSHelper.H/360) + ((1 - w)/2) ) + w ) * ( 180 / HiPSHelper.H );\n\n\t// \t\tx_grid = phi_c + (phiDeg - phi_c) * sigma;\n\t// \t\ty_grid = (180  / HiPSHelper.H) * ( ((HiPSHelper.K + 1)/2) - sigma);\n\n\t// \t\tif (sc.thetaRad < 0) {\n\t// \t\t\ty_grid *= -1;\n\t// \t\t}\n\t// \t}\n\n\t// \treturn [x_grid, y_grid];\n\n\t// }\n\n\t// static intermediate2pix(x: number, y: number, xyGridProj: HEALPixXYSpace, pxXtile: number): [number, number] {\n\t// \tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);\n\t// \tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);\n\n\t// \tlet i_norm: number;\n\t// \tlet j_norm: number;\n\t// \tif ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {\n\t// \t\ti_norm = (x + 360 - xyGridProj.min_x) / xInterval;\n\t// \t} else {\n\t// \t\ti_norm = (x - xyGridProj.min_x) / xInterval;\n\t// \t}\n\t// \tj_norm = (y - xyGridProj.min_y) / yInterval;\n\n\n\t// \tlet i = 0.5 - (i_norm - j_norm);\n\t// \tlet j = (i_norm + j_norm) - 0.5;\n\n\t// \t// TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);\n\t// \tpxXtile\n\t// \t// i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);\n\t// \t// j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);\n\t// \t// return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];\n\t\t\n\t// \ti = Math.floor(i * pxXtile);\n\t// \tj = Math.floor(j * pxXtile);\n\t// \treturn [i, pxXtile - j - 1];\n\n\n\n\t// }\n\n\n\t// static pix2intermediate(i: number, j: number, xyGridProj: HEALPixXYSpace, naxis1: number, naxis2: number): [number, number] {\n\t// \t/**\n\t// \t   * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image\n\t// \t * (i_norm,w_pixel) = (1,1) is the upper right corner\n\t// \t * dimamond in figure 1 from \"Mapping on the HEalpix grid\" paper\n\t// \t * (0,0) leftmost corner\n\t// \t * (1,0) upper corner\n\t// \t * (0,1) lowest corner\n\t// \t * (1,1) rightmost corner\n\t// \t * Thanks YAGO! :p\n\t// \t */\n\t// \t// let cnaxis1 = HiPSHelper.pxXtile;\n\t// \t// let cnaxis2 = HiPSHelper.pxXtile;\n\n\t// \tlet cnaxis1 = naxis1;\n\t// \tlet cnaxis2 = naxis2;\n\t// \tif (naxis1) {\n\t// \t\tcnaxis1 = naxis1;\n\t// \t}\n\t// \tif (naxis2) {\n\t// \t\tcnaxis2 = naxis2;\n\t// \t}\n\t// \tlet i_norm = (i + 0.5) / cnaxis1;\n\t// \tlet j_norm = (j + 0.5) / cnaxis2;\n\n\t// \tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;\n\t// \tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;\n\t// \tlet yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;\n\n\t// \t// bi-linear interpolation\n\t// \tlet x = xyGridProj.max_x - xInterval * (i_norm + j_norm);\n\t// \tlet y = yMean - yInterval * (j_norm - i_norm);\n\n\t// \treturn [x, y];\n\t// }\n\n\n\t// static intermediate2world(x: number, y: number): Point {\n\n\t// \tlet phiDeg: number;\n\t// \tlet thetaDeg: number;\n\t// \tlet Yx = 90 * (HiPSHelper.K - 1) / HiPSHelper.H;\n\n\n\n\t// \tif (Math.abs(y) <= Yx) { // equatorial belts\n\n\t// \t\tphiDeg = x;\n\t// \t\tthetaDeg = radToDeg(Math.asin((y * HiPSHelper.H) / (90 * HiPSHelper.K)));\n\n\t// \t} else if (Math.abs(y) > Yx) { // polar regions\n\n\t// \t\tlet sigma = (HiPSHelper.K + 1) / 2 - Math.abs(y * HiPSHelper.H) / 180;\n\t// \t\tlet thetaRad = Hploc.asin(1 - (sigma * sigma) / HiPSHelper.K);\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\t// \t\tlet x_c = -180 + (2 * Math.floor((x + 180) * HiPSHelper.H / 360 + (1 - w) / 2) + w) * (180 / HiPSHelper.H);\n\t// \t\tphiDeg = x_c + (x - x_c) / sigma;\n\t// \t\tthetaDeg = radToDeg(thetaRad);\n\t// \t\tif (y <= 0) {\n\t// \t\t\tthetaDeg *= -1;\n\t// \t\t}\n\t// \t}\n\t// \t// return [phiDeg, thetaDeg];\n\t// \t// TODO CHECK THIS!\n\t// \t// let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);\n\t// \tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, phiDeg, thetaDeg);\n\n\t// \treturn p;\n\n\t// }\n\n}\n","export class HiPSProperties {\n\n    static TILE_WIDTH:string = \"hips_tile_width\"\n    static FRAME:string = \"hips_frame\"\n    static ORDER:string = \"hips_order\"\n    static GALACTIC:string = \"galactic\"\n    static SCALE:string = \"hips_pixel_scale\"\n    static BITPIX:string = \"hips_pixel_bitpix\"\n\n\n    private itemMap: Map<string, any> = new Map<string, any>()\n\n    constructor(){}\n\n    addItem(key:string, value:any) {\n        this.itemMap.set(key, value)\n    }\n\n    getItem(key: string){\n        return this.itemMap.get(key)\n    }\n\n    isGalactic(){\n        return this.itemMap.get(HiPSProperties.FRAME) == HiPSProperties.GALACTIC\n    }\n\n}","import { FITSHeaderItem, FITSHeaderManager, FITSParsed, FITSParser, ParseUtils } from \"jsfitsio\"\n\nimport { HiPSIntermediateProj } from \"./HiPSIntermediateProj.js\"\nimport { Healpix, Pointing } from \"healpixjs\"\nimport { HEALPixXYSpace } from \"../../model/HEALPixXYSpace.js\"\nimport { astroToSpherical, fillAstro, radToDeg } from \"../../model/Utils.js\"\nimport { NumberType } from \"../../model/NumberType.js\"\nimport { HiPSHelper } from \"../HiPSHelper.js\"\nimport { HiPSProperties } from \"./HiPSProperties.js\"\nimport { ImagePixel } from \"./ImagePixel.js\"\n\nexport class HiPSFITS {\n\n    private payload: Array<Uint8Array> = []\n    private header!: FITSHeaderManager\n    private tileno!: number\n    private order!: number\n    private tileWidth!: number\n    private healpix!: Healpix\n    private intermediateXYGrid!: HEALPixXYSpace\n    private min: number = NaN\n    private max: number = NaN\n    private static CTYPE1 = \"RA---HPX\"\n    private static CTYPE2 = \"DEC--HPX\"\n    private static NPIX: string = \"NPIX\"\n\n\n    constructor(fitsParsed: FITSParsed | null, tileno: number | null, hipsProp: HiPSProperties | null) {\n\n        if (fitsParsed) {\n            this.initFromFITSParsed(fitsParsed)\n        } else if (!tileno || !hipsProp) {\n            console.error(\"tileno or hipsProp are not defined\")\n            throw new Error(\"tileno or hipsProp are not defined\")\n        } else {\n            this.order = hipsProp.getItem(HiPSProperties.ORDER)\n            const naxis1 = hipsProp.getItem(HiPSProperties.TILE_WIDTH)\n            const naxis2 = hipsProp.getItem(HiPSProperties.TILE_WIDTH)\n            this.tileno = tileno\n            if (naxis1 != naxis2) {\n                console.error(\"NAXIS1 and NAXIS2 do not match.\")\n                throw new Error(\"NAXIS1 and NAXIS2 do not match.\")\n            }\n            this.tileWidth = naxis1\n            this.tileno = tileno\n            this.healpix = HiPSHelper.getHelpixByOrder(this.order)\n            this.intermediateXYGrid = HiPSIntermediateProj.setupByTile(this.tileno, this.healpix)\n\n        }\n\n    }\n\n    initFromUint8Array(imagePixelList: ImagePixel[], fitsHeaderParams: FITSHeaderManager, tileWidth: number) {\n        this.setPayload(imagePixelList, fitsHeaderParams, tileWidth)\n        this.setHeader(fitsHeaderParams)\n    }\n    // initFromUint8Array(raDecList: [number, number][], originalValues: Uint8Array, fitsHeaderParams: FITSHeaderManager) {\n    //     this.setPayload(raDecList, originalValues, fitsHeaderParams)\n    //     this.setHeader(fitsHeaderParams)\n    // }\n\n    getHeader(){\n        return this.header\n    }\n\n    getPayload() {\n        return this.payload\n    }\n\n    initFromFITSParsed(fitsParsed: FITSParsed) {\n\n        this.payload = fitsParsed.data\n\n        this.order = Number(fitsParsed.header.findById(HiPSProperties.ORDER)?.value)\n        const naxis1 = Number(fitsParsed.header.findById(FITSHeaderManager.NAXIS1)?.value)\n        const naxis2 = Number(fitsParsed.header.findById(FITSHeaderManager.NAXIS2)?.value)\n        this.tileno = Number(fitsParsed.header.findById(HiPSFITS.NPIX)?.value)\n\n        if (isNaN(this.order) || isNaN(naxis1) || isNaN(naxis2) || isNaN(this.tileno)) {\n            console.warn(\"ORDER, NAXIS1 or NAXIS2 not defined\")\n            throw new Error(\"ORDER, NAXIS1 or NAXIS2 not defined\")\n        }\n        if (naxis1 != naxis2) {\n            console.error(\"NAXIS1 and NAXIS2 do not match.\")\n            throw new Error(\"NAXIS1 and NAXIS2 do not match.\")\n        }\n        this.tileWidth = naxis1\n        this.computeMinMax(fitsParsed)\n        this.setHeader(fitsParsed.header)\n\n    }\n\n    getTileno() {\n        return this.tileno\n    }\n\n    private computeMinMax(fitsParsed: FITSParsed) {\n\n        const bitpix = Number(fitsParsed.header.findById(FITSHeaderManager.BITPIX)?.value)\n        const bzero = Number(fitsParsed.header.findById(FITSHeaderManager.BZERO)?.value)\n        const bscale = Number(fitsParsed.header.findById(FITSHeaderManager.BSCALE)?.value)\n\n        const bytesXelem = Math.abs(bitpix / 8)\n\n        for (let ridx = 0; ridx < fitsParsed.data.length; ridx++) {\n            const row = fitsParsed.data[ridx]\n            for (let cidx = 0; cidx < row.length; cidx++) {\n                const valpixb = ParseUtils.extractPixelValue(0, this.payload[ridx].slice(cidx * bytesXelem, cidx * bytesXelem + bytesXelem), bitpix)\n                if (valpixb == null) {\n                    continue\n                }\n                const valphysical = bzero + bscale * valpixb;\n                if (valphysical < this.min || isNaN(this.min)) {\n                    this.min = valphysical;\n                } else if (valphysical > this.max || isNaN(this.max)) {\n                    this.max = valphysical;\n                }\n            }\n        }\n    }\n\n    static async downloadFITSFile(path: string) {\n        const fits = await FITSParser.loadFITS(path)\n        if (fits == null) {\n            console.warn(`fits ${path} doesn't exist`)\n            return null\n        }\n        return fits\n    }\n\n\n    getFITS(): FITSParsed {\n        return { header: this.header, data: this.payload }\n    }\n\n    private setPayload(imagePixelList: ImagePixel[], fitsHeaderParams: FITSHeaderManager, tileWidth: number) {\n\n\n        const bitpix = Number(fitsHeaderParams.findById(FITSHeaderManager.BITPIX)?.value)\n        const bzero = Number(fitsHeaderParams.findById(FITSHeaderManager.BZERO)?.value)\n        const bscale = Number(fitsHeaderParams.findById(FITSHeaderManager.BSCALE)?.value)\n\n        const bytesXelem = Math.abs(bitpix / 8)\n        if (!bytesXelem) {\n            console.error(\"BITPIX not defined\")\n            throw new Error(\"BITPIX not defined\")\n        }\n\n        this.payload = new Array(tileWidth)\n        for (let row = 0; row < tileWidth; row++) {\n            this.payload[row] = new Uint8Array(tileWidth * bytesXelem)\n        }\n\n\n        imagePixelList.forEach((imgpx) => {\n\n            const ra = imgpx.getRADeg()\n            const dec = imgpx.getDecDeg()\n            const ac = fillAstro(ra, dec, NumberType.DEGREES)\n            if (ac == null) {\n                console.error(`Error converting ${ra}, ${dec} into AstroCoords object`);\n                return;\n            }\n            const xy = HiPSIntermediateProj.world2intermediate(ac);\n            const [col, row] = HiPSIntermediateProj.intermediate2pix(xy[0], xy[1], this.intermediateXYGrid, tileWidth);\n        \n            if (row < 0 || row >= tileWidth || col < 0 || col >= tileWidth) return;\n\n            const valueBytes = imgpx.getUint8Value();\n            if (!valueBytes) return; // or continue, depending on context\n            \n            for (let b = 0; b < bytesXelem; b++) {\n                this.payload[row][col * bytesXelem + b] = valueBytes[b];\n            }\n\n            const valpixb = ParseUtils.extractPixelValue(0, valueBytes, bitpix);\n            if (valpixb == null) return;\n\n            const valphysical = bzero + bscale * valpixb;\n            if (isNaN(this.min) || valphysical < this.min) this.min = valphysical;\n            if (isNaN(this.max) || valphysical > this.max) this.max = valphysical;\n\n        });\n\n\n    }\n    // private setPayload(raDecList: [number, number][], originalValues: Uint8Array, fitsHeaderParams: FITSHeaderManager) {\n\n\n    //     const bitpix = Number(fitsHeaderParams.findById(FITSHeaderManager.BITPIX)?.value)\n    //     const bzero = Number(fitsHeaderParams.findById(FITSHeaderManager.BZERO)?.value)\n    //     const bscale = Number(fitsHeaderParams.findById(FITSHeaderManager.BSCALE)?.value)\n\n    //     const bytesXelem = Math.abs(bitpix / 8)\n    //     if (!bytesXelem) {\n    //         console.error(\"BITPIX not defined\")\n    //         throw new Error(\"BITPIX not defined\")\n    //     }\n\n    //     this.payload = new Array(this.tileWidth)\n    //     for (let row = 0; row < this.tileWidth; row++) {\n    //         this.payload[row] = new Uint8Array(this.tileWidth * bytesXelem)\n    //     }\n\n\n\n    //     for (let rdidx = 0; rdidx < raDecList.length; rdidx++) {\n\n    //         const [ra, dec] = raDecList[rdidx]\n\n    //         const ac = fillAstro(ra, dec, NumberType.DEGREES)\n    //         if (ac == null) {\n    //             console.error(`Error converting ${ra}, ${dec} into AstroCoords object`)\n    //             continue\n    //         }\n\n    //         const sc = astroToSpherical(ac)\n    //         const ptg = new Pointing(null, false, sc.thetaRad, sc.phiRad)\n    //         const pixtileno: number = this.healpix.ang2pix(ptg)\n    //         if (pixtileno != this.tileno) {\n    //             continue\n    //         }\n\n    //         const xy = HiPSIntermediateProj.world2intermediate(ac);\n    //         let ij = HiPSIntermediateProj.intermediate2pix(xy[0], xy[1], this.intermediateXYGrid, this.tileWidth);\n    //         const col = ij[0];\n    //         const row = ij[1];\n\n    //         for (let b = 0; b < bytesXelem; b++) {\n    //             const byte = originalValues[rdidx * bytesXelem + b];\n    //             this.payload[row][col * bytesXelem + b] = byte\n    //             // TODO check what's nodata!\n    //             // if (nodata.get(\"\" + pixtileno + \"\")) {\n    //             // \tif (byte != 0) {\n    //             // \t\tnodata.set(\"\" + pixtileno + \"\", false);\n    //             // \t}\n    //             // }\n\n    //             const valpixb = ParseUtils.extractPixelValue(0, this.payload[row].slice(col * bytesXelem, col * bytesXelem + bytesXelem), bitpix);\n    //             if (valpixb == null) {\n    //                 continue\n    //             }\n\n    //             const valphysical = bzero + bscale * valpixb;\n    //             if (valphysical < this.min || isNaN(this.min)) {\n    //                 this.min = valphysical;\n    //             } else if (valphysical > this.max || isNaN(this.max)) {\n    //                 this.max = valphysical;\n    //             }\n    //         }\n    //     }\n    // }\n\n    private addMandatoryItemToHeader(key: string, fitsHeaderParams: FITSHeaderManager) {\n        const value = fitsHeaderParams.findById(key)?.value\n        if (value === undefined || value == null) {\n            console.error(`${key} not defined`)\n            throw new Error(key + \" is not defined\")\n        }\n        const item = new FITSHeaderItem(key, value, \"\")\n        this.header.insert(item)\n    }\n\n    private addItemToHeader(key: string, fitsHeaderParams: FITSHeaderManager) {\n        const value = fitsHeaderParams.findById(key)?.value\n        if (value !== undefined || value != null) {\n            const item = new FITSHeaderItem(key, value, \"\")\n            this.header.insert(item)\n        }\n    }\n\n\n\n    private setHeader(fitsHeaderParams: FITSHeaderManager) {\n\n        this.header = new FITSHeaderManager()\n\n        this.addMandatoryItemToHeader(FITSHeaderManager.SIMPLE, fitsHeaderParams)\n        this.addMandatoryItemToHeader(FITSHeaderManager.BITPIX, fitsHeaderParams)\n\n        this.addItemToHeader(FITSHeaderManager.BLANK, fitsHeaderParams)\n        this.addItemToHeader(FITSHeaderManager.BSCALE, fitsHeaderParams)\n        this.addItemToHeader(FITSHeaderManager.BZERO, fitsHeaderParams)\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.NAXIS, Number(2), \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.NAXIS1, Number(this.tileWidth), \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.NAXIS2, Number(this.tileWidth), \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CTYPE1, HiPSFITS.CTYPE1, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CTYPE2, HiPSFITS.CTYPE2, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.DATAMIN, this.min, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.DATAMAX, this.min, \"\"))\n\n        this.header.insert(new FITSHeaderItem(HiPSProperties.ORDER, Number(this.order), \"\"))\n\n        this.header.insert(new FITSHeaderItem(HiPSFITS.NPIX, Number(this.tileno), \"\"))\n\n        const crpix = this.tileno / 2\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CRPIX1, crpix, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CRPIX2, crpix, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.ORIGIN, \"WCSLight v.0.x\", \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.COMMENT, \"\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"))\n\n        let vec3 = this.healpix.pix2vec(this.tileno);\n        let ptg = new Pointing(vec3);\n        let crval1 = radToDeg(ptg.phi);\n        let crval2 = 90 - radToDeg(ptg.theta);\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CRVAL1, crval1, \"\"));\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CRVAL2, crval2, \"\"));\n\n        this.header.insert(new FITSHeaderItem(\"END\", \"\", \"\"))\n\n\n    }\n\n\n}","import { FITSParser } from \"jsfitsio\";\nimport { HiPSFITS } from \"./HiPSFITS.js\";\n\nexport class FITSList{\n    private fitslist: Map<number, HiPSFITS> = new Map()\n\n    constructor(){}\n\n    getFITSList(): Map<number, HiPSFITS>{\n        return this.fitslist\n    }\n\n    getFITS(tileno: number): HiPSFITS | null {\n        const fits = this.fitslist.get(tileno)\n        return fits === undefined ? null : fits\n    }\n\n    async addFITSByURL(url: string) {\n        const fits = await FITSParser.loadFITS(url)\n        const hipsFits = new HiPSFITS(fits, null, null )\n        this.fitslist.set(hipsFits.getTileno(), hipsFits)\n    }\n\n    addFITS(fits: HiPSFITS) {\n        const tileno = fits.getTileno()\n        this.fitslist.set(tileno, fits)\n    }\n}","import { readFile } from \"node:fs/promises\";\nimport { HiPSProperties } from \"./HiPSProperties.js\";\n\n\nexport class HiPSPropManager {\n\n    static async parsePropertyFile(baseURL:string): Promise<HiPSProperties> {\n        let hipsPropText = \"\"\n        if (baseURL.includes(\"http\")) { // HiPS from web\n            hipsPropText = await HiPSPropManager.getPorpertyFromWeb(baseURL)\n        } else { // local HiPS\n            hipsPropText = await HiPSPropManager.getPorpertyFromFS(baseURL)\n        }\n        const hipsProp:HiPSProperties = HiPSPropManager.parseHiPSPropertiesBody(hipsPropText)\n        return hipsProp\n    }\n\n    private static async getPorpertyFromWeb(baseHiPSPath: string): Promise<string> {\n        const response = await fetch(baseHiPSPath + \"/properties\")\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`)\n        } else {\n            const propFile = await response.text()\n            return propFile\n        }\n        // let propFile: string\n        // if (response instanceof ArrayBuffer) {\n        //     const textDecoder = new TextDecoder(\"iso-8859-1\")\n        //     propFile = textDecoder.decode(new Uint8Array(response))\n        // } else {\n        //     propFile = response.toString()\n        // }\n        // return propFile\n    }\n\n    private static async getPorpertyFromFS(baseHiPSPath: string): Promise<string> {\n\n        const propPath = baseHiPSPath + \"/properties\"\n        const rawData: Buffer = await readFile(propPath)\n        const uint8 = new Uint8Array(rawData)\n        const textDecoder = new TextDecoder('ascii')\n        const propFile = textDecoder.decode(uint8);\n\n        return propFile\n    }\n\n    private static parseHiPSPropertiesBody(hipsPropText: string): HiPSProperties {\n        let hipsProp = new HiPSProperties()\n        const txtArr = hipsPropText.split('\\n');\n\n        for (let line of txtArr) {\n            if (!line.includes(\"=\")) {\n                continue;\n            }\n\n            const tokens = line.split(\"=\");\n            if (tokens[1] === undefined) {\n                continue;\n            }\n            const key = tokens[0].trim()\n            const val = tokens[1].trim()\n            let value: string|number = val\n            if (key == HiPSProperties.ORDER || key == HiPSProperties.TILE_WIDTH || key == HiPSProperties.SCALE || key == HiPSProperties.BITPIX) {\n                value = parseInt(val)\n            }\n            hipsProp.addItem(key, value)\n        }\n        return hipsProp\n    }\n}","import { FITSList } from \"./FITSList.js\";\nimport { HiPSProperties } from \"./HiPSProperties.js\"\nimport { HiPSPropManager } from \"./HiPSPropManager.js\";\nimport { Point } from \"../../model/Point.js\";\nimport { Healpix, Pointing, RangeSet } from \"healpixjs\";\nimport { degToRad } from \"../../model/Utils.js\";\nimport { HiPSIntermediateProj } from \"./HiPSIntermediateProj.js\";\nimport { FITSHeaderManager, FITSParser } from \"jsfitsio\";\nimport { HiPSFITS } from \"./HiPSFITS.js\";\nimport { ImagePixel } from \"./ImagePixel.js\";\nimport { HiPSHelper } from \"../HiPSHelper.js\";\nimport { CoordsType } from \"../../model/CoordsType.js\";\nimport { NumberType } from \"../../model/NumberType.js\";\nimport { HEALPixXYSpace } from \"../../model/HEALPixXYSpace.js\";\nimport { TilesRaDecList2 } from \"./TilesRaDecList2.js\";\n\n\n\nexport class HiPSProjection {\n\n    private baseURL: string\n    private healpix: Healpix | null = null\n    private hipsProp: HiPSProperties | null = null\n\n    constructor(baseHiPSPath: string) {\n        this.baseURL = baseHiPSPath\n        this.init()\n        if (this.healpix == null) {\n            console.warn(\"healpix is null\")\n            throw new Error(\"healpix is null\")\n        }\n        if (this.hipsProp == null) {\n            console.warn(\"HiPSProp is null\")\n            throw new Error(\"HiPSProp is null\")\n        }\n    }\n\n    async init() {\n        const hipsProp = await this.parsePropertyFile()\n        const order = hipsProp.getItem(HiPSProperties.ORDER)\n        this.healpix = HiPSHelper.getHelpixByOrder(order)\n    }\n\n    private async parsePropertyFile() {\n        const hipsProp = HiPSPropManager.parsePropertyFile(this.baseURL)\n        return hipsProp\n    }\n\n    static getImageRADecList(center: Point, radiusDeg: number, pixelAngSize: number, TILE_WIDTH: number): TilesRaDecList2 | null {\n\n\n\n        const healpix = HiPSHelper.getHelpixBypxAngSize(pixelAngSize, TILE_WIDTH)\n\n        // let tilesRaDecList2 = new TilesRaDecList2(healpix.order)\n        let tilesRaDecList2 = new TilesRaDecList2()\n\n\n        const ptg = new Pointing(null, false, center.getSpherical().thetaRad, center.getSpherical().phiRad);\n        const radius_rad = degToRad(radiusDeg);\n\n        // ??? with fact 8 the original Java code starts returning the the ptg pixel. with my JS porting only from fact 16\n        const rangeset: RangeSet = healpix.queryDiscInclusive(ptg, radius_rad, 4); // <= check it \n\n        // TODO try to replace tileslist with FITSList!!!\n        // const tileslist: Array<number> = [];\n        for (let p = 0; p < rangeset.r.length; p++) {\n\n            // if (!tileslist.includes(rangeset.r[p]) && rangeset.r[p] != 0) {\n            //     tileslist.push(rangeset.r[p]);\n            // }\n            if (!tilesRaDecList2.getTilesList().includes(rangeset.r[p]) && rangeset.r[p] != 0) {\n                tilesRaDecList2.addTileNumber(rangeset.r[p])\n                // tileslist.push(rangeset.r[p]);\n            }\n\n        }\n\n        const cpix = healpix.ang2pix(ptg);\n        // if (!tileslist.includes(cpix)) {\n        //     tileslist.push(cpix);\n        // }\n        if (!tilesRaDecList2.getTilesList().includes(cpix)) {\n            tilesRaDecList2.getTilesList().push(cpix);\n        }\n\n\n        // let raDecList: Array<[number, number]> = []\n        let minra = center.getAstro().raDeg - radiusDeg;\n        let maxra = center.getAstro().raDeg + radiusDeg;\n        let mindec = center.getAstro().decDeg - radiusDeg;\n        let maxdec = center.getAstro().decDeg + radiusDeg;\n\n        tilesRaDecList2.getTilesList().forEach((tileno: number) => {\n            // tileslist.forEach((tileno: number) => {\n\n            for (let j = 0; j < TILE_WIDTH; j++) {\n                for (let i = 0; i < TILE_WIDTH; i++) {\n\n                    const point: Point | null = HiPSProjection.pix2world(i, j, tileno, healpix, TILE_WIDTH);\n\n                    if (point == null) continue\n                    if (point.getAstro().raDeg < minra || point.getAstro().raDeg > maxra ||\n                        point.getAstro().decDeg < mindec || point.getAstro().decDeg > maxdec) {\n                        continue;\n                    }\n                    tilesRaDecList2.addImagePixel(new ImagePixel(point.getAstro().raDeg, point.getAstro().decDeg, tileno))\n                    // raDecList.push([point.getAstro().raDeg, point.getAstro().decDeg]);\n                }\n            }\n        })\n\n        // const tilesRaDecList = new TilesRaDecList(raDecList, tileslist)\n        // return tilesRaDecList\n        return tilesRaDecList2\n    }\n\n    private static _xyGridCache: Map<string, HEALPixXYSpace> = new Map();\n\n\n    static pix2world(i: number, j: number, tileno: number, healpix: Healpix, TILE_WIDTH: number): Point | null {\n        const order = (healpix as any).order ?? Math.log2((healpix as any).nside); // adapt to your healpixjs\n        const cacheKey = `${order}:${tileno}`;\n\n        let xyGridProj = HiPSProjection._xyGridCache.get(cacheKey);\n        if (!xyGridProj) {\n            xyGridProj = HiPSIntermediateProj.setupByTile(tileno, healpix);\n            const Dx = xyGridProj.max_x - xyGridProj.min_x\n            const Dy = xyGridProj.max_y - xyGridProj.min_y\n            console.log(`deltaX: ${Dx}, deltaY ${Dy} order ${order} tileno ${tileno}`)\n            HiPSProjection._xyGridCache.set(cacheKey, xyGridProj);\n        }\n\n        if (!healpix) return null;\n        // const xyGridProj = HiPSIntermediateProj.setupByTile(tileno, healpix);\n        const [x, y] = HiPSIntermediateProj.pix2intermediate(i, j, xyGridProj, TILE_WIDTH, TILE_WIDTH);\n        if (!Number.isFinite(x) || !Number.isFinite(y)) return null;\n        const p = HiPSIntermediateProj.intermediate2world(x, y);\n        const ra = p.getAstro().raDeg;\n        const dec = p.getAstro().decDeg;\n\n        if (!Number.isFinite(ra) || !Number.isFinite(dec)) return null;\n        return p;\n\n    }\n\n    // static getFITSFiles(inputValues: Uint8Array, tilesRaDecList: TilesRaDecList, fitsHeaderParams: FITSHeaderManager, pixelAngSize: number, TILE_WIDTH?: number): FITSList {\n    static getFITSFiles(tilesRaDecList: TilesRaDecList2, fitsHeaderParams: FITSHeaderManager, pixelAngSize: number, TILE_WIDTH: number): FITSList {\n\n        const healpix = HiPSHelper.getHelpixBypxAngSize(pixelAngSize, TILE_WIDTH)\n\n        let fitsList = new FITSList()\n\n        tilesRaDecList.getTilesList().forEach((tileno: number) => {\n            let hipsProp = new HiPSProperties()\n            hipsProp.addItem(HiPSProperties.ORDER, healpix.order)\n            hipsProp.addItem(HiPSProperties.TILE_WIDTH, TILE_WIDTH)\n            const hipsFits = new HiPSFITS(null, tileno, hipsProp)\n\n            const imagePixelsByTilesNo = tilesRaDecList.getImagePixelsByTile(tileno)\n\n            hipsFits.initFromUint8Array(imagePixelsByTilesNo, fitsHeaderParams, TILE_WIDTH)\n            fitsList.addFITS(hipsFits)\n        })\n        return fitsList\n\n    }\n\n    static async world2pix(radeclist: TilesRaDecList2, hipsOrder: number, isGalactic: boolean, TILE_WIDTH: number, baseHiPSURL: string): Promise<TilesRaDecList2 | null> {\n\n        const healpix = HiPSHelper.getHelpixByOrder(hipsOrder)\n\n        let tileno: number;\n        let prevTileno: number | null = null;\n        /* if HiPS in galactic => convert the full list of (RA, Dec) to Galactic  (l, b) */\n        if (isGalactic) {\n            HiPSProjection.convertToGalactic(radeclist);\n        }\n        let xyGridProj: HEALPixXYSpace | null = null\n\n\n\n        radeclist.getImagePixelList().forEach((imgpx) => {\n            const ra = imgpx.getRADeg()\n            const dec = imgpx.getDecDeg()\n\n            const p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n            const ptg = new Pointing(null, false, p.getSpherical().thetaRad, p.getSpherical().phiRad);\n\n            tileno = healpix.ang2pix(ptg);\n\n            if (prevTileno !== tileno || prevTileno == null) {\n                xyGridProj = HiPSIntermediateProj.setupByTile(tileno, healpix);\n                prevTileno = tileno;\n            }\n            if (xyGridProj) {\n                const xy = HiPSIntermediateProj.world2intermediate(p.getAstro());\n                const ij = HiPSIntermediateProj.intermediate2pix(xy[0], xy[1], xyGridProj, TILE_WIDTH);\n                imgpx.setij(ij[0], ij[1])\n                imgpx.setTileNumber(tileno)\n            }\n            radeclist.addTileNumber(tileno)\n        });\n        let result = await HiPSProjection.getPixelValues(radeclist, baseHiPSURL, hipsOrder)\n        return result\n    }\n\n    // TODO move this to Utils.js\n    static convertToGalactic(radeclist: TilesRaDecList2) {\n        // let finalradeclist: number[][] = [];\n        const deg2rad = Math.PI / 180\n        const rad2deg = 180 / Math.PI\n        const l_NCP = deg2rad * 122.930\n        const d_NGP = deg2rad * 27.1284\n        const a_NGP = deg2rad * 192.8595\n        radeclist.getImagePixelList().forEach((imgpx) => {\n            const ra = imgpx.getRADeg()\n            const dec = imgpx.getDecDeg()\n            const ra_rad = deg2rad * ra\n            const dec_rad = deg2rad * dec\n            // sin(b)\n            const sin_b = Math.sin(d_NGP) * Math.sin(dec_rad) +\n                Math.cos(d_NGP) * Math.cos(dec_rad) * Math.cos(ra_rad - a_NGP);\n            const b = Math.asin(sin_b)\n            const b_deg = b * rad2deg\n\n            // l_NCP - l\n            const lNCP_minus_l = Math.atan((Math.cos(dec_rad) * Math.sin(ra_rad - a_NGP)) /\n                (Math.sin(dec_rad) * Math.cos(d_NGP) - Math.cos(dec_rad) * Math.sin(d_NGP) * Math.cos(ra_rad - a_NGP)));\n            const l = l_NCP - lNCP_minus_l\n            const l_deg = l * rad2deg\n            imgpx.setRADecDeg(l_deg, b_deg)\n            // finalradeclist.push([l_deg, b_deg])\n        });\n        // return finalradeclist;\n    }\n\n    static async getPixelValues(raDecList: TilesRaDecList2, baseHiPSURL: string, hipsOrder: number): Promise<TilesRaDecList2 | null> {\n\n        const tilesset = raDecList.getTilesList()\n        let promises = [];\n\n        for (let hipstileno of tilesset) {\n\n            const dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n            const fitsurl = baseHiPSURL + \"/Norder\" + hipsOrder + \"/Dir\" + dir + \"/Npix\" + hipstileno + \".fits\";\n            console.log(`Identified source file ${fitsurl}`)\n\n            // TODO change the code below to used HiPSFITS and FITSList instead!\n            promises.push(FITSParser.loadFITS(fitsurl).then((fitsParsed) => {\n\n                if (fitsParsed) {\n\n                    const bitpix = Number(fitsParsed.header.findById(\"BITPIX\")?.value)\n                    const naxis1 = Number(fitsParsed.header.findById(\"NAXIS1\")?.value)\n                    const naxis2 = Number(fitsParsed.header.findById(\"NAXIS2\")?.value)\n                    if (!bitpix || !naxis1 || !naxis2) {\n                        console.error(`bitpix: ${bitpix}, naxis1: ${naxis1}, naxis2: ${naxis2} for fits file ${fitsurl}`)\n                        return\n                    }\n                    if (raDecList.getBLANK() == null) {\n                        const blankStr = fitsParsed.header.findById(\"BLANK\")?.value\n                        if (blankStr) {\n                            const blank = Number(blankStr)\n                            if (!isNaN(blank)) {\n                                raDecList.setBLANK(blank)\n                            }\n                        }\n                    }\n                    if (raDecList.getBSCALE() == null) {\n                        const bscaleStr = fitsParsed.header.findById(\"BSCALE\")?.value\n                        if (bscaleStr) {\n                            const bscale = Number(bscaleStr)\n                            if (!isNaN(bscale)) {\n                                raDecList.setBSCALE(bscale)\n                            }\n                        }\n                    }\n                    if (raDecList.getBZERO() == null) {\n                        const bzeroStr = fitsParsed.header.findById(\"BZERO\")?.value\n                        if (bzeroStr) {\n                            const bzero = Number(bzeroStr)\n                            if (!isNaN(bzero)) {\n                                raDecList.setBZERO(bzero)\n                            }\n                        }\n                    }\n\n                    // if (naxis1 * naxis2 * Math.abs(bitpix / 8) != fitsParsed.data.length) {\n                    //     console.error(`fits data length ${fitsParsed.data.length} does not match expected size ${naxis1 * naxis2 * Math.abs(bitpix / 8)} for fits file ${fitsurl}`)\n                    //     return\n                    // }\n\n                    const bytesXelem = Math.abs(bitpix / 8);\n\n                    raDecList.getImagePixelsByTile(hipstileno).forEach((imgpx) => {\n                        const valueBytes = new Uint8Array(bytesXelem);\n                        if (fitsParsed.data[imgpx.getj()] == undefined) {\n                            console.warn(`j index ${imgpx.getj()} is outside the image range 0-${naxis2 - 1} for fits file ${fitsurl}`)\n                            return\n                        }\n                        if ((imgpx.geti() * bytesXelem + bytesXelem) > fitsParsed.data[imgpx.getj()].length) {\n                            console.warn(`i index ${imgpx.geti()} is outside the image range 0-${(fitsParsed.data[imgpx.getj()].length / bytesXelem) - 1} for fits file ${fitsurl}`)\n                            return\n                        }\n                        for (let b = 0; b < bytesXelem; b++) {\n                            valueBytes[b] = fitsParsed.data[imgpx.getj()][imgpx.geti() * bytesXelem + b];\n                        }\n                        imgpx.setValue(valueBytes, bitpix);\n                        raDecList.setMinMaxValue(imgpx.getValue())\n                    })\n                }\n            }));\n        }\n        await Promise.all(promises);\n        if (raDecList.getBSCALE() == null) {\n            raDecList.setBSCALE(1)\n        }\n        if (raDecList.getBZERO() == null) {\n            raDecList.setBZERO(0)\n        }\n        if (raDecList.getBLANK() == null) {\n            raDecList.setBLANK(0)\n        }\n        return raDecList\n    }\n\n}","import { FITS } from \"../../model/FITS.js\"\nimport { AbstractProjection } from \"../AbstractProjection.js\"\nimport { RADecMinMaxCentral } from \"../RADecMinMaxCentral.js\"\n\nexport class CutoutResult {\n    fits: FITS\n    fitsused: string[]\n    projection: AbstractProjection\n    raDecMinMaxCentral: RADecMinMaxCentral\n    pxsize: number\n\n\n    constructor(fits: FITS, fitsused: string[], projection: AbstractProjection, raDecMinMaxCentral: RADecMinMaxCentral, pxsize: number) {\n        this.fits = fits\n        this.fitsused = fitsused\n        this.projection = projection\n        this.raDecMinMaxCentral = raDecMinMaxCentral\n        this.pxsize = pxsize\n    }\n\n}","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nimport { FITSParsed, FITSParser } from 'jsfitsio';\nimport { MercatorProjection } from './projections/mercator/MercatorProjection.js';\nimport { HiPSProjection } from './projections/hips/HiPSProjection.js';\nimport { Point } from './model/Point.js';\nimport { AbstractProjection } from './projections/AbstractProjection.js';\nimport { FITS } from './model/FITS.js';\nimport { FITSList } from './projections/hips/FITSList.js';\nimport { HiPSFITS } from './projections/hips/HiPSFITS.js';\nimport { HiPSPropManager } from './projections/hips/HiPSPropManager.js';\nimport { HiPSProperties } from './projections/hips/HiPSProperties.js';\nimport { HiPSHelper } from './projections/HiPSHelper.js';\nimport { TilesRaDecList2 } from './projections/hips/TilesRaDecList2.js';\nimport { CutoutResult } from './projections/hips/CutoutResult.js';\n\nexport class WCSLight {\n\n    /**\n     * This function receives a FITS and generate a cutout on HiPS FITS.\n     * @param center of the cutout in degrees\n     * @param radius of the cutout in degrees\n     * @param pxsize of the cutout in degrees\n     * @param filePath of the input FITS file\n     * @returns fitsList of FITS in HiPS format\n     */\n    static async fitsCutoutToHiPS(center: Point, radius: number,\n        pxsize: number, filePath: string): Promise<FITSList | null> {\n\n        const HiPS_TILE_WIDTH = 512\n\n        // 0. here is missing the validation/check that the input file used to get the value, contains the center ...\n        \n        // 1. open input fits file and understand the projection and set up in inprojection details like NAXIS1-2, CDELT1-2, CRVAL1-2, minRa and minDec\n        const inProjection = await WCSLight.extractProjectionType(filePath)\n        if (!inProjection) return null\n        // const bitpix = inProjection.getBitpix()\n        \n        // 2. from HiPS output projection, compute the list of RA,Dec and related tileno based on center, radius, pxsize, and tilewidth forced to 512\n        const outTilesRaDecList: TilesRaDecList2|null = HiPSProjection.getImageRADecList(center, radius, pxsize, HiPS_TILE_WIDTH)\n        if (!outTilesRaDecList) {\n            return null\n        }\n\n        // 3. by using the list of RA and Dec on point 2., convert RA,Dec into i,j used in the input projection to get pixel values (try to merge the 2 calls below in one single method)\n        inProjection.world2pix(outTilesRaDecList)\n        // const invalues = await inProjection.getPixValues(tilesRaDecList)\n        \n        // 4. collect the details required to construct the output HiPS projection header \n        // const fitsHeaderParams = inProjection.getCommonFitsHeaderParams();\n\n        // here pass inProjection.getFITSHeader()\n        // 5. generate output HiPS FITS file(s)\n        const fitsFileList = HiPSProjection.getFITSFiles(outTilesRaDecList, inProjection.getFITSHeader(), pxsize, HiPS_TILE_WIDTH);\n        for( let hipsFitsEntry of fitsFileList.getFITSList()) {\n            const tileno = hipsFitsEntry[0]\n            const hipsFits = hipsFitsEntry[1]\n            const data = hipsFits.getPayload()\n            const header = hipsFits.getHeader() \n            const FITS_FILE_PATH = `./hips_${tileno}.fits`\n\n            const fitsParsed = {header: header, data: data}\n            FITSParser.saveFITSLocally(fitsParsed, FITS_FILE_PATH)\n        }\n        return fitsFileList\n        \n    }\n\n    // only MERCATOR supported at the moment\n    static async extractProjectionType(filePath: string): Promise<AbstractProjection | null> {\n        let fits: FITSParsed | null = await FITSParser.loadFITS(filePath)\n        if (!fits) return null\n        \n        const ctype = String(fits.header.findById(\"CTYPE1\")?.value)\n        \n        if (ctype.includes(\"MER\")){\n            let projection = new MercatorProjection()\n            await projection.initFromFile(filePath)\n            return projection\n        }\n        return null\n\n    }\n\n    // TODO: instead of using AbstractProjection, use a constant file with supported projection names\n    static async hipsCutoutToFITS(center: Point, radius: number,\n        pixelAngSize: number, baseHiPSURL: string, outproj: AbstractProjection, hipsOrder: number | null = null ): Promise<CutoutResult | null> {\n        \n        const hipsProp = await HiPSPropManager.parsePropertyFile(baseHiPSURL)\n        const hipsMaxOrder: number = hipsProp.getItem(HiPSProperties.ORDER)\n        const hipsFrame = hipsProp.getItem(HiPSProperties.FRAME)\n        const TILE_WIDTH = hipsProp.getItem(HiPSProperties.TILE_WIDTH)\n        \n\n        let isGalactic: boolean = false\n        if (hipsFrame.toLowerCase() == 'galactic') {\n            isGalactic = true\n        }\n\n        if (!hipsOrder) {\n            const healpix = HiPSHelper.getHelpixBypxAngSize(pixelAngSize, TILE_WIDTH, hipsMaxOrder)\n            hipsOrder = Number(healpix.order)    \n        }\n        \n        /*\n        below how naxis are computed\n        outproj.getImageRADecList -> computeSquaredNaxes -> set naxis1 and naxis2\n        */\n        const naxisWidth: number = outproj.computeNaxisWidth(radius, pixelAngSize)\n        const outRADecList: TilesRaDecList2 = outproj.getImageRADecList(center, radius, pixelAngSize, naxisWidth)\n        if (!outRADecList) return null\n\n\n        const raDecMinMaxCentral = outRADecList.computeRADecMinMaxCentral()\n        if (raDecMinMaxCentral == null) return null\n        const cRA = raDecMinMaxCentral?.getCentralRA()\n        const cDec = raDecMinMaxCentral?.getCentralDec()\n        if (cRA === undefined || cDec === undefined) return null\n        \n        // TODO check if possible to compute in the word2pix, when iterating onver ImagePixels, the min and max value.\n        const raDecWithValues = await HiPSProjection.world2pix(outRADecList, hipsOrder, isGalactic, TILE_WIDTH, baseHiPSURL)\n        if (!raDecWithValues) return null\n        const minValue = raDecWithValues.getMinMaxValues()?.getMinValue()\n        const maxValue = raDecWithValues.getMinMaxValues()?.getMaxValue()\n        if (minValue === undefined || maxValue === undefined) return null\n        \n        /** info required:\n         * SIMPLE  = T                                                                     \n            BITPIX  = -64                                                                   \n            NAXIS   = 2                                                                     \n            NAXIS1  = 512                                                                   \n            NAXIS2  = 512                                                                   \n            BSCALE  = 1                                                                     \n            BZERO   = 0                                                                     \n            CTYPE1  = RA---HPX                                                              \n            CTYPE2  = DEC--HPX                                                              \n            DATAMIN = 0                                                                     \n            DATAMAX = 0                                                                     \n            hips_order= 7                                                                   \n            NPIX    = 113056                                                                \n            CRPIX1  = 56528                                                                 \n            CRPIX2  = 56528                                                                 \n            ORIGIN  = WCSLight v.0.x                                                        \n            COMMENT =  / WCSLight v0.x developed by F.Giordano and Y.Ascasibar              \n            CRVAL1  = 170.15625                                                             \n            CRVAL2  = 18.5243910738658                                                      \n            END                                                                             \n         */\n        // TODO BLANK, BZERO, BSCALE must be taken from the FITS tiles and not from the HiPS metadata.\n        const BLANK = raDecWithValues.getBLANK()\n        const BZERO = raDecWithValues.getBZERO()\n        const BSCALE = raDecWithValues.getBSCALE()\n        if (BLANK === null || BZERO === null || BSCALE === null) return null\n        console.log(`BLANK: ${BLANK}, BZERO: ${BZERO}, BSCALE: ${BSCALE}`)\n\n        // validate BITPIX\n        const BITPIX: number = parseInt(hipsProp.getItem(HiPSProperties.BITPIX))\n        if (BITPIX != 8 && BITPIX != 16 && BITPIX != 32 && BITPIX != -32 && BITPIX != -64) {\n            throw new Error(\"unsupported BITPIX value\")\n        }\n\n        const fits: FITS = outproj.generateFITSFile(\n            pixelAngSize, \n            hipsProp.getItem(HiPSProperties.BITPIX),  \n            naxisWidth, \n            BLANK, BZERO, BSCALE,\n            cRA, cDec,\n            minValue, maxValue, raDecWithValues)\n        \n        console.log(fits)\n\n        const FITS_FILE_PATH = `./cartesian2.fits`\n        const fitsParsed:FITSParsed = {header: fits.getHeader(), data: fits.getData()}\n        FITSParser.saveFITSLocally(fitsParsed, FITS_FILE_PATH)\n\n        let hipsUsed = Array<string>()\n        raDecWithValues.getTilesList().forEach( (hipstileno) => {\n            const dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n            const fitsurl = baseHiPSURL + \"/Norder\" + hipsOrder + \"/Dir\" + dir + \"/Npix\" + hipstileno + \".fits\";\n            hipsUsed.push(fitsurl)\n        })\n\n        const result = new CutoutResult(fits, hipsUsed, outproj, raDecMinMaxCentral, pixelAngSize)\n\n        return result\n    }\n\n    static hipsFITSChangeProjection(): HiPSFITS | null {\n\n        return null\n    }\n\n\n    /**\n     * \n     * @param {*} fitsheader \n     * @param {*} fitsdata \n     * @returns {URL}\n     */\n    // static generateFITS(fitsheader: any, fitsdata: any): string {\n    //     const fitsParsed = {\n    //         header: fitsheader,\n    //         data: fitsdata\n    //     }\n    //     // const blobUrl = FITSParser.generateFITSForWeb(fitsheader, fitsdata);\n    //     const blobUrl = FITSParser.generateFITSForWeb(fitsParsed);\n    //     return blobUrl;\n    // }\n\n\n    static getAvaillableProjections() {\n        return [\"Mercator\", \"HiPS\", \"HEALPix\"];\n    }\n\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\n\nexport class ImagePixel {\n    _i: number;     // int i of input projection\n    _j: number;     // int j of input projection\n    _tileno: number;// int\n    \n    constructor (i: number, j: number, tileno: number = NaN) {\n        this._i = i;\n        this._j = j;\n        this._tileno = tileno;\n    }\n\n    geti() {\n        return this._i;\n    }\n\n    getj() {\n        return this._j;\n    }\n\n    get tileno() {\n        return this._tileno\n    }\n}\n","\nexport {WCSLight} from './WCSLight.js'\n\nexport {AstroCoords} from './model/AstroCoords.js'\nexport {CartesianCoords} from './model/CartesianCoords.js'\nexport {CoordsType} from './model/CoordsType.js'\nexport {CutoutResult} from './model/CutoutResult.js'\nexport {EquatorialCoords} from './model/EquatorialCoords.js'\nexport {GalacticCoords} from './model/GalacticCoords.js'\nexport {HEALPixXYSpace} from './model/HEALPixXYSpace.js'\nexport {HMSCoords} from './model/HMSCoords.js'\nexport {ICoordsFormat} from './model/ICoordsFormat.js'\nexport {ImagePixel} from './model/ImagePixel.js'\nexport {NumberType} from './model/NumberType.js'\nexport {Point} from './model/Point.js'\nexport {SexagesimalCoords} from './model/SexagesimalCoords.js'\nexport {SphericalCoords} from './model/SphericalCoords.js'\nexport { \n    sphericalToCartesian, \n    cartesianToSpherical, \n    sphericalToAstro, \n    fillSpherical,\n    astroToSpherical, \n    degToRad, \n    fillAstro, \n    radToDeg } from './model/Utils.js'\nexport {AbstractProjection} from './projections/AbstractProjection.js'\nexport {HiPSHelper} from './projections/HiPSHelper.js'\nexport {HiPSProjection} from './projections/hips/HiPSProjection.js'\nexport {MercatorProjection} from './projections/mercator/MercatorProjection.js'\n\nexport { HiPSFITS } from './projections/hips/HiPSFITS.js'"],"names":[],"sourceRoot":""}