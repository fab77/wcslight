{"version":3,"file":"wcslight.min.js","mappings":"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","sources":["webpack://wcslight/webpack/universalModuleDefinition","webpack://wcslight/webpack/runtime/load script","webpack://wcslight/webpack/bootstrap","webpack://wcslight/webpack/runtime/define property getters","webpack://wcslight/webpack/runtime/ensure chunk","webpack://wcslight/webpack/runtime/get javascript chunk filename","webpack://wcslight/webpack/runtime/global","webpack://wcslight/webpack/runtime/hasOwnProperty shorthand","webpack://wcslight/webpack/runtime/make namespace object","webpack://wcslight/webpack/runtime/publicPath","webpack://wcslight/webpack/runtime/jsonp chunk loading","webpack://wcslight/./src/model/NumberType.ts","webpack://wcslight/./src/model/CoordsType.ts","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSWriter.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeaderItem.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/model/FITSHeaderManager.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseHeader.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParseUtils.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/ParsePayload.js","webpack://wcslight/./node_modules/jsfitsio/lib-esm/FITSParser.js","webpack://wcslight/./src/projections/AbstractProjection.ts","webpack://wcslight/./src/model/Utils.ts","webpack://wcslight/./src/Config.ts","webpack://wcslight/./src/model/Point.ts","webpack://wcslight/./src/projections/MinMaxValue.ts","webpack://wcslight/./src/projections/RADecMinMaxCentral.ts","webpack://wcslight/./src/projections/hips/TilesRaDecList2.ts","webpack://wcslight/./src/projections/hips/ImagePixel.ts","webpack://wcslight/./src/model/FITS.ts","webpack://wcslight/./src/projections/mercator/MercatorProjection.ts","webpack://wcslight/./node_modules/healpixjs/lib-esm/Constants.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Zphi.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Hploc.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Pointing.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Vec3.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/CircleFinder.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Fxyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/pstack.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/RangeSet.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Xyf.js","webpack://wcslight/./node_modules/healpixjs/lib-esm/Healpix.js","webpack://wcslight/./src/projections/hips/HiPSIntermediateProj.ts","webpack://wcslight/./src/projections/HiPSHelper.ts","webpack://wcslight/./src/projections/hips/HiPSProperties.ts","webpack://wcslight/./src/projections/hips/HiPSFITS.ts","webpack://wcslight/./src/projections/hips/FITSList.ts","webpack://wcslight/./src/projections/hips/HiPSPropManager.ts","webpack://wcslight/./src/projections/hips/HiPSProjection.ts","webpack://wcslight/./src/projections/hips/CutoutResult.ts","webpack://wcslight/./src/WCSLight.ts","webpack://wcslight/./src/model/ImagePixel.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"wcslight\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wcslight\"] = factory();\n\telse\n\t\troot[\"wcslight\"] = factory();\n})(this, () => {\nreturn ","var inProgress = {};\nvar dataWebpackPrefix = \"wcslight:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t434: 0,\n\t992: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = this[\"webpackChunkwcslight\"] = this[\"webpackChunkwcslight\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","export enum NumberType {\n    DEGREES,\n    RADIANS,\n    DECIMAL,\n    HMS,\n    DMS\n}","/**\n * @author Fabrizio Giordano (Fab77)\n * Enum for coordinate types.\n * @readonly\n * @enum {{name: string, hex: string}}\n */\n\nexport enum CoordsType {\n  CARTESIAN = \"cartesian\",\n  SPHERICAL = \"spherical\",\n  ASTRO = \"astro\"\n}\n","// import { FITSHeader } from \"./model/FITSHeader.js\"\nimport * as fs from 'fs';\nexport class FITSWriter {\n    static createFITS(fitsParsed) {\n        const headerBytes = this.createHeader(fitsParsed.header);\n        const dataBytes = this.createData(fitsParsed.data, fitsParsed.header);\n        const fitsFile = new Uint8Array(headerBytes.length + dataBytes.length);\n        fitsFile.set(headerBytes, 0);\n        fitsFile.set(dataBytes, headerBytes.length);\n        return fitsFile;\n    }\n    static createHeader(header) {\n        const BLOCK = 2880;\n        const CARD = 80;\n        const MUST_INT = new Set([\"BITPIX\", \"NAXIS\", \"PCOUNT\", \"GCOUNT\"]);\n        const IS_LOGICAL = new Set([\"SIMPLE\", \"EXTEND\"]);\n        const items = header.getItems();\n        function kw(s) {\n            return (s ?? \"\").toUpperCase().padEnd(8, \" \").slice(0, 8);\n        }\n        function card80(s) {\n            return s.length >= CARD ? s.slice(0, CARD) : s.padEnd(CARD, \" \");\n        }\n        // Emit COMMENT/HISTORY as multiple 72-char lines\n        function makeCommentCards(kind, text) {\n            const prefix = kw(kind); // \"COMMENT \" or \"HISTORY \"\n            const width = CARD - prefix.length; // 72\n            const t = (text ?? \"\").toString();\n            if (!t.length)\n                return [card80(prefix)]; // allow empty COMMENT/HISTORY line\n            const out = [];\n            for (let i = 0; i < t.length; i += width) {\n                out.push(card80(prefix + t.slice(i, i + width)));\n            }\n            return out;\n        }\n        function quoteFitsString(s) {\n            const unquoted = s.replace(/^'+|'+$/g, \"\");\n            const escaped = unquoted.replace(/'/g, \"''\");\n            return `'${escaped}'`;\n        }\n        // \"= \" + 20-char value field (or proper string)\n        function valueField20(key, val) {\n            let v = \"\";\n            const K = key.toUpperCase();\n            if (IS_LOGICAL.has(K)) {\n                const tf = (val === true || val === \"T\" || val === \"t\") ? \"T\" : \"F\";\n                return `= ${tf.padStart(20, \" \")}`;\n            }\n            if (MUST_INT.has(K) || /^NAXIS\\d+$/.test(K)) {\n                const n = Number(val);\n                if (!Number.isFinite(n) || !Number.isInteger(n)) {\n                    throw new Error(`FITS header: ${K} must be an integer, got ${val}`);\n                }\n                return `= ${String(n).padStart(20, \" \")}`;\n            }\n            if (typeof val === \"number\") {\n                let s = Number.isInteger(val) ? String(val) : val.toExponential(10).replace(\"e\", \"E\");\n                if (s.length > 20)\n                    s = val.toExponential(8).replace(\"e\", \"E\");\n                return `= ${s.padStart(20, \" \")}`;\n            }\n            if (typeof val === \"string\") {\n                return `= ${quoteFitsString(val)}`; // strings can exceed 20-char field\n            }\n            return \"\";\n        }\n        // Build one keyword card, and (if needed) emit overflow as COMMENT cards\n        function makeKeywordWithComment(key, value, comment) {\n            const K = key.toUpperCase();\n            if (K === \"END\")\n                return [card80(\"END\")];\n            if (K === \"COMMENT\" || K === \"HISTORY\") {\n                const text = (value ?? comment ?? \"\").toString();\n                return makeCommentCards(K, text);\n            }\n            // Normal keyword\n            let base = kw(K) + valueField20(K, value);\n            // Attach trailing comment inside the same card if it fits\n            if (comment && comment.length > 0) {\n                const add = ` / ${comment}`;\n                const spaceLeft = CARD - base.length;\n                if (spaceLeft > 0) {\n                    const inCard = add.slice(0, spaceLeft);\n                    base = (base + inCard);\n                    // spill any overflow into COMMENT cards (strip a leading \" / \" if it didn't fit)\n                    const overflow = add.slice(spaceLeft).replace(/^\\s*\\/\\s*/, \"\");\n                    if (overflow.length > 0) {\n                        return [card80(base), ...makeCommentCards(\"COMMENT\", overflow)];\n                    }\n                }\n                else {\n                    // no room at all; put the whole comment in COMMENT lines\n                    return [card80(base), ...makeCommentCards(\"COMMENT\", comment)];\n                }\n            }\n            return [card80(base)];\n        }\n        // Build all cards with mandatory order first\n        const map = new Map(items.map(it => [it.key.toUpperCase(), it]));\n        const cards = [];\n        const simple = map.get(\"SIMPLE\");\n        if (!simple)\n            throw new Error(\"Missing mandatory SIMPLE card\");\n        cards.push(...makeKeywordWithComment(\"SIMPLE\", simple.value, simple.comment));\n        const bitpix = map.get(\"BITPIX\");\n        if (!bitpix)\n            throw new Error(\"Missing mandatory BITPIX card\");\n        cards.push(...makeKeywordWithComment(\"BITPIX\", bitpix.value, bitpix.comment));\n        const naxis = map.get(\"NAXIS\");\n        if (!naxis)\n            throw new Error(\"Missing mandatory NAXIS card\");\n        const nAxes = Number(naxis.value) || 0;\n        cards.push(...makeKeywordWithComment(\"NAXIS\", nAxes, naxis.comment));\n        for (let i = 1; i <= nAxes; i++) {\n            const ki = `NAXIS${i}`;\n            const it = map.get(ki);\n            if (!it)\n                throw new Error(`Missing mandatory ${ki} card`);\n            cards.push(...makeKeywordWithComment(ki, it.value, it.comment));\n        }\n        const extend = map.get(\"EXTEND\");\n        if (extend)\n            cards.push(...makeKeywordWithComment(\"EXTEND\", extend.value, extend.comment));\n        for (const it of items) {\n            const K = it.key.toUpperCase();\n            if (K === \"SIMPLE\" || K === \"BITPIX\" || K === \"NAXIS\" || /^NAXIS\\d+$/.test(K) || K === \"EXTEND\" || K === \"END\")\n                continue;\n            cards.push(...makeKeywordWithComment(it.key, it.value, it.comment));\n        }\n        // END + pad to 2880\n        cards.push(card80(\"END\"));\n        let headerString = cards.join(\"\");\n        const pad = headerString.length % BLOCK ? BLOCK - (headerString.length % BLOCK) : 0;\n        if (pad)\n            headerString += \" \".repeat(pad);\n        return new TextEncoder().encode(headerString);\n    }\n    static createData(data, header) {\n        // concat\n        const totalLength = data.reduce((s, c) => s + c.length, 0);\n        // OPTIONAL: verify size from BITPIX/NAXIS\n        const bitpix = Math.abs(Number(header.findById(\"BITPIX\")?.value ?? 0));\n        const naxis = Number(header.findById(\"NAXIS\")?.value ?? 0);\n        let elems = 1;\n        for (let k = 1; k <= naxis; k++) {\n            elems *= Number(header.findById(`NAXIS${k}`)?.value ?? 0);\n        }\n        const bytesPerElem = bitpix / 8;\n        const expectedUnpadded = naxis > 0 ? elems * bytesPerElem : 0;\n        if (expectedUnpadded && expectedUnpadded !== totalLength) {\n            throw new Error(`Data length ${totalLength} does not match header expectation ${expectedUnpadded} (BITPIX=${bitpix}, NAXIS=${naxis})`);\n        }\n        // build and pad\n        let dataBytes = new Uint8Array(totalLength);\n        let off = 0;\n        for (const chunk of data) {\n            dataBytes.set(chunk, off);\n            off += chunk.length;\n        }\n        const BLOCK = 2880;\n        const remainder = dataBytes.length % BLOCK;\n        if (remainder) {\n            const pad = BLOCK - remainder;\n            const padded = new Uint8Array(dataBytes.length + pad);\n            padded.set(dataBytes);\n            dataBytes = padded; // zeros already in new space\n        }\n        return dataBytes;\n    }\n    // static typedArrayToURL(fitsParsed: FITSParsed): string {\n    //   const fitsFile = FITSWriter.createFITS(fitsParsed) as Uint8Array;\n    //   const blob = new Blob([fitsFile], { type: \"application/fits\" });\n    //   // console.log(`<html><body><img src='${URL.createObjectURL(b)}'</body></html>`);\n    //   const url = URL.createObjectURL(blob);\n    //   console.log(`Generated FITS file URL: ${url}`);\n    //   return url;\n    // }\n    static writeFITSFile(fitsParsed, filePath) {\n        const fitsFile = this.createFITS(fitsParsed);\n        try {\n            fs.writeFileSync(filePath, fitsFile);\n            console.log(`FITS file written successfully to: ${filePath}`);\n        }\n        catch (error) {\n            console.error(`Error writing FITS file: ${error}`);\n        }\n    }\n}\n// const fitsParsed: FITSParsed = {\n//   header: new FITSHeader(),\n//   data: [new Uint8Array([1, 2, 3]), new Uint8Array([4, 5, 6])]\n// };\n// // Specify the file path\n// const filePath = \"/Users/fabriziogiordano/Desktop/PhD/code/new/FITSParser/output.fits\";\n// // Write the FITS file to the filesystem\n// FITSWriter.writeFITSFile(fitsParsed, filePath);\n//# sourceMappingURL=FITSWriter.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class FITSHeaderItem {\n    _key = \"\";\n    _value = \"\";\n    _comment = \"\";\n    constructor(key, value, comment) {\n        this._key = key;\n        this._value = value;\n        this._comment = comment;\n    }\n    get key() {\n        return this._key;\n    }\n    get comment() {\n        return this._comment;\n    }\n    get value() {\n        return this._value;\n    }\n}\n//# sourceMappingURL=FITSHeaderItem.js.map","import { FITSHeaderItem } from \"./FITSHeaderItem.js\";\nexport class FITSHeaderManager {\n    static SIMPLE = \"SIMPLE\";\n    static BITPIX = \"BITPIX\";\n    static BZERO = \"BZERO\";\n    static BSCALE = \"BSCALE\";\n    static BLANK = \"BLANK\";\n    static NAXIS = \"NAXIS\";\n    static NAXIS1 = \"NAXIS1\";\n    static NAXIS2 = \"NAXIS2\";\n    static DATAMIN = \"DATAMIN\";\n    static DATAMAX = \"DATAMAX\";\n    static CRVAL1 = \"CRVAL1\";\n    static CRVAL2 = \"CRVAL2\";\n    static CTYPE1 = \"CTYPE1\";\n    static CTYPE2 = \"CTYPE2\";\n    static CRPIX1 = \"CRPIX1\";\n    static CRPIX2 = \"CRPIX2\";\n    static ORIGIN = \"ORIGIN\";\n    static COMMENT = \"COMMENT\";\n    items = [];\n    constructor() {\n        this.items[0] = new FITSHeaderItem(FITSHeaderManager.SIMPLE, 'T', '');\n        this.items[1] = new FITSHeaderItem(FITSHeaderManager.BITPIX, '', '');\n        this.items[2] = new FITSHeaderItem(FITSHeaderManager.NAXIS, 2, '');\n        this.items[3] = new FITSHeaderItem(FITSHeaderManager.NAXIS1, '', '');\n        this.items[4] = new FITSHeaderItem(FITSHeaderManager.NAXIS2, '', '');\n    }\n    // insert(item: FITSHeaderItem, position?: number): void {\n    insert(item) {\n        if (item.key === FITSHeaderManager.SIMPLE) {\n            // this.items.splice(0, 0, item);\n            this.items[0] = item;\n        }\n        else if (item.key === FITSHeaderManager.BITPIX) {\n            // this.items.splice(1, 0, item);\n            this.items[1] = item;\n        }\n        else if (item.key === FITSHeaderManager.NAXIS) {\n            // this.items.splice(2, 0, item);\n            this.items[2] = item;\n        }\n        else if (item.key === FITSHeaderManager.NAXIS1) {\n            // this.items.splice(3, 0, item);\n            this.items[3] = item;\n        }\n        else if (item.key === FITSHeaderManager.NAXIS2) {\n            // this.items.splice(4, 0, item);\n            this.items[4] = item;\n        }\n        else {\n            this.items.push(item);\n        }\n        // if (position !== undefined && position >= 0 && position <= this.items.length) {\n        //     this.items.splice(position, 0, item);\n        // } else {\n        //     this.items.push(item);\n        // }\n    }\n    getItems() {\n        return this.items;\n    }\n    remove(key) {\n        this.items = this.items.filter(item => item.key !== key);\n    }\n    findById(key) {\n        const item = this.items.find(item => item.key === key);\n        if (!item) {\n            return null;\n        }\n        return item;\n    }\n}\n//# sourceMappingURL=FITSHeaderManager.js.map","// import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { FITSHeaderManager } from \"./model/FITSHeaderManager.js\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseHeader {\n    static getFITSItemValue(header, key) {\n        const item = header.findById(key);\n        let VALUE = null;\n        if (item) {\n            VALUE = Number(item.value);\n        }\n        return VALUE;\n    }\n    static parse(rawdata) {\n        // only one header block (2880) allowed atm.\n        // TODO handle multiple header blocks\n        // let headerByteData = new Uint8Array(rawdata, 0, 2880);\n        const textDecoder = new TextDecoder('ascii');\n        const headerSize = 2880; // FITS headers are in 2880-byte blocks\n        const headerText = textDecoder.decode(rawdata.slice(0, headerSize));\n        const header = new FITSHeaderManager();\n        const lines = headerText.match(/.{1,80}/g) || [];\n        for (const line of lines) {\n            const key = line.slice(0, 8).trim();\n            let value;\n            let comment = \"\";\n            if (key && key !== 'END') {\n                const rawValue = line.slice(10).trim().split('/')[0].trim();\n                if (isNaN(Number(rawValue))) {\n                    value = rawValue;\n                }\n                else {\n                    value = Number(rawValue);\n                }\n                if (line.includes('/')) {\n                    comment = line.slice(10).trim().split('/')[1].trim();\n                }\n                const item = new FITSHeaderItem(key, value, comment);\n                header.insert(item);\n            }\n        }\n        return header;\n    }\n}\n//# sourceMappingURL=ParseHeader.js.map","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\nexport class ParseUtils {\n    static getStringAt(data, offset, length) {\n        const chars = [];\n        for (let i = offset, j = 0; i < offset + length; i++, j++) {\n            chars[j] = String.fromCharCode(data.charCodeAt(i) & 0xff);\n        }\n        return chars.join(\"\");\n    }\n    static byteString(n) {\n        if (n < 0 || n > 255 || n % 1 !== 0) {\n            throw new Error(n + \" does not fit in a byte\");\n        }\n        return (\"000000000\" + n.toString(2)).substr(-8);\n    }\n    static parse32bitSinglePrecisionFloatingPoint(byte1, byte2, byte3, byte4) {\n        let long = (((((byte1 << 8) + byte2) << 8) + byte3) << 8) + byte4;\n        if (long < 0)\n            long += 4294967296;\n        const float = (1.0 + (long & 0x007fffff) / 0x0800000) *\n            Math.pow(2, ((long & 0x7f800000) >> 23) - 127);\n        return float;\n    }\n    static convertBlankToBytes(blank, nbytes) {\n        let str = Math.abs(blank).toString(2);\n        while (str.length / 8 < nbytes) {\n            str += \"0\";\n        }\n        const buffer = new ArrayBuffer(nbytes);\n        const uint8 = new Uint8Array(buffer);\n        for (let i = 0; i < nbytes; i++) {\n            uint8[i] = parseInt(str.substr(8 * i, 8 * (i + 1)), 2);\n        }\n        return uint8;\n    }\n    /** https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac */\n    static parseFloatingPointFormat(bytes, ebits, fbits) {\n        // Bytes to bits\n        const bits = [];\n        for (let i = bytes.length; i; i -= 1) {\n            let byte = bytes[i - 1];\n            for (let j = 8; j; j -= 1) {\n                bits.push(byte % 2 ? 1 : 0);\n                byte = byte >> 1;\n            }\n        }\n        bits.reverse();\n        const str = bits.join(\"\");\n        // Unpack sign, exponent, fraction\n        const bias = (1 << (ebits - 1)) - 1;\n        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n        const e = parseInt(str.substring(1, 1 + ebits), 2);\n        const f = parseInt(str.substring(1 + ebits), 2);\n        // Produce number\n        if (e === (1 << ebits) - 1) {\n            return f !== 0 ? null : s * Infinity;\n        }\n        else if (e > 0) {\n            return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));\n        }\n        else if (f !== 0) {\n            return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));\n        }\n        else {\n            return s * 0;\n        }\n    }\n    static generate16bit2sComplement(val) {\n        throw new TypeError(\"not implemented yet\" + val);\n    }\n    static parse16bit2sComplement(byte1, byte2) {\n        const unsigned = (byte1 << 8) | byte2;\n        if (unsigned & 0x8000) {\n            return unsigned | 0xffff0000;\n        }\n        else {\n            return unsigned;\n        }\n    }\n    static parse32bit2sComplement(byte1, byte2, byte3, byte4) {\n        const unsigned = (byte1 << 24) | (byte2 << 16) | (byte3 << 8) | byte4;\n        const s = (unsigned & 0x80000000) >> 31;\n        let res = unsigned & 0xffffffff;\n        if (s) {\n            res = (~unsigned & 0xffffffff) + 1;\n            return -1 * res;\n        }\n        return res;\n    }\n    /**\n     *\n     * @param {*} data string?\n     * @param {*} offset offset in the data\n     * @returns returns an integer between 0 and 65535 representing the UTF-16 code unit at the given index.\n     */\n    static getByteAt(data, offset) {\n        const dataOffset = 0;\n        return data.charCodeAt(offset + dataOffset) & 0xff;\n    }\n    static extractPixelValue(offset, bytes, bitpix) {\n        let px_val = null; // pixel value\n        // let px_val1, px_val2, px_val3, px_val4;\n        if (bitpix == 8) {\n            px_val = bytes[0];\n        }\n        else if (bitpix == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(bytes[offset], bytes[offset + 1]);\n        }\n        else if (bitpix == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(bytes[offset], bytes[offset + 1], bytes[offset + 2], bytes[offset + 3]);\n        }\n        else if (bitpix == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 8, 23);\n        }\n        else if (bitpix == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (bitpix == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(bytes.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n// export default ParseUtils;\n//# sourceMappingURL=ParseUtils.js.map","// \"use strict\";\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/FITSParser\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n// import { FITSHeader } from \"./model/FITSHeader.js\";\nimport { FITSHeaderItem } from \"./model/FITSHeaderItem.js\";\nimport { FITSHeaderManager } from \"./model/FITSHeaderManager.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\nimport { ParseUtils } from \"./ParseUtils.js\";\nexport class ParsePayload {\n    static computePhysicalMinAndMax(header, rawData) {\n        const BITPIX = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BITPIX);\n        if (BITPIX === null) {\n            return null;\n        }\n        const NAXIS1 = ParseHeader.getFITSItemValue(header, FITSHeaderManager.NAXIS1);\n        if (NAXIS1 === null) {\n            return null;\n        }\n        const NAXIS2 = ParseHeader.getFITSItemValue(header, FITSHeaderManager.NAXIS2);\n        if (NAXIS2 === null) {\n            return null;\n        }\n        const DATAMIN = ParseHeader.getFITSItemValue(header, FITSHeaderManager.DATAMIN);\n        const DATAMAX = ParseHeader.getFITSItemValue(header, FITSHeaderManager.DATAMAX);\n        if (!BITPIX || !NAXIS1 || !NAXIS2) {\n            return null; // return early if invalid data.\n        }\n        if (!DATAMAX || !DATAMIN) {\n            const [min, max] = ParsePayload.computePhysicalValues(rawData, header);\n            if (min && max) {\n                const maxitem = new FITSHeaderItem(\"DATAMAX\", min, \"computed by jsfitsio\");\n                const minitem = new FITSHeaderItem(\"DATAMIN\", max, \"computed by jsfitsio\");\n                header.insert(maxitem);\n                header.insert(minitem);\n            }\n        }\n        const endItem = new FITSHeaderItem('END', \"\", \"\");\n        header.insert(endItem);\n        return header;\n        // TODO: END tag shall be added here\n    }\n    static computePhysicalValues(rawData, header) {\n        const BITPIX = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BITPIX);\n        if (BITPIX === null || isNaN(BITPIX)) {\n            return [null, null];\n        }\n        const BLANK = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BLANK);\n        if (BLANK === null || isNaN(BITPIX)) {\n            return [null, null];\n        }\n        let BZERO = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BZERO);\n        if (BZERO === null) {\n            BZERO = 0;\n        }\n        let BSCALE = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BSCALE);\n        if (BSCALE === null) {\n            BSCALE = 1;\n        }\n        let i = 0;\n        const bytesXelem = Math.abs(BITPIX / 8);\n        const pxLength = rawData.byteLength / bytesXelem;\n        let min = null;\n        let max = null;\n        let physicalblank = null;\n        if (BLANK) {\n            physicalblank = ParsePayload.pixel2physicalValue(BLANK, BSCALE, BZERO);\n        }\n        while (i < pxLength) {\n            let px_val = ParsePayload.extractPixelValue(rawData, bytesXelem * i, BITPIX);\n            if (px_val === null) {\n                i++;\n                continue;\n            }\n            let ph_val = ParsePayload.pixel2physicalValue(px_val, BSCALE, BZERO);\n            if (!min) {\n                min = ph_val;\n            }\n            if (!max) {\n                max = ph_val;\n            }\n            // check this block if it is still applicable\n            if (physicalblank === null || physicalblank !== ph_val) {\n                if (ph_val !== null && (ph_val < min || min === null)) {\n                    min = ph_val;\n                }\n                if (ph_val !== null && (ph_val > max || max === null)) {\n                    max = ph_val;\n                }\n            }\n            i++;\n        }\n        return [min, max];\n    }\n    static pixel2physicalValue(pxval, BSCALE, BZERO) {\n        if (BZERO === null || BSCALE === null) {\n            throw new Error(\"Either BZERO or BSCALE is null\");\n        }\n        return BZERO + BSCALE * pxval;\n    }\n    static extractPixelValue(rawData, offset, BITPIX) {\n        let px_val = null; // pixel value\n        if (BITPIX == 16) {\n            // 16-bit 2's complement binary integer\n            px_val = ParseUtils.parse16bit2sComplement(rawData[offset], rawData[offset + 1]);\n        }\n        else if (BITPIX == 32) {\n            // IEEE 754 half precision (float16) ??\n            px_val = ParseUtils.parse32bit2sComplement(rawData[offset], rawData[offset + 1], rawData[offset + 2], rawData[offset + 3]);\n        }\n        else if (BITPIX == -32) {\n            // 32-bit IEEE single-precision floating point\n            // px_val = ParseUtils.parse32bitSinglePrecisionFloatingPoint (this._u8data[offset], this._u8data[offset+1], this._u8data[offset+2], this._u8data[offset+3]);\n            px_val = ParseUtils.parseFloatingPointFormat(rawData.slice(offset, offset + 4), 8, 23);\n        }\n        else if (BITPIX == 64) {\n            // 64-bit 2's complement binary integer\n            throw new Error(\"BITPIX=64 -> 64-bit 2's complement binary integer NOT supported yet.\");\n        }\n        else if (BITPIX == -64) {\n            // 64-bit IEEE double-precision floating point\n            //https://babbage.cs.qc.cuny.edu/ieee-754.old/Decimal.html\n            px_val = ParseUtils.parseFloatingPointFormat(rawData.slice(offset, offset + 8), 11, 52);\n        }\n        return px_val;\n    }\n}\n//# sourceMappingURL=ParsePayload.js.map","import { FITSWriter } from \"./FITSWriter.js\";\nimport { ParsePayload } from \"./ParsePayload.js\";\nimport { ParseHeader } from \"./ParseHeader.js\";\nimport { FITSHeaderManager } from \"./model/FITSHeaderManager.js\";\nexport class FITSParser {\n    static async loadFITS(url) {\n        try {\n            const uint8data = await FITSParser.getFile(url);\n            if (uint8data?.byteLength) {\n                const fits = FITSParser.processFits(uint8data);\n                return fits;\n            }\n        }\n        catch (error) {\n            console.error(\"Error loading FITS file:\", error);\n        }\n        return null;\n    }\n    static processFits(rawdata) {\n        const header = ParseHeader.parse(rawdata);\n        const headerFinalised = ParsePayload.computePhysicalMinAndMax(header, rawdata);\n        if (headerFinalised == null) {\n            return null;\n        }\n        // Assuming no additional header blocks\n        const dataOffset = 2880;\n        const payloadBuffer = new Uint8Array(rawdata.slice(dataOffset));\n        // --- pad payload to multiple of 2880 ---\n        const paddedPayload = padTo2880(payloadBuffer);\n        const payloadMatrix = FITSParser.createMatrix(paddedPayload, header);\n        return {\n            header: headerFinalised,\n            data: payloadMatrix\n        };\n        // helper\n        function padTo2880(buf) {\n            const remainder = buf.length % 2880;\n            if (remainder === 0)\n                return buf;\n            const padded = new Uint8Array(buf.length + (2880 - remainder));\n            padded.set(buf);\n            // the extra bytes are left as 0 (valid FITS padding)\n            return padded;\n        }\n    }\n    static createMatrix(payload, header) {\n        const NAXIS1 = ParseHeader.getFITSItemValue(header, FITSHeaderManager.NAXIS1);\n        if (NAXIS1 === null) {\n            throw new Error(\"NAXIS1 not defined.\");\n        }\n        const NAXIS2 = ParseHeader.getFITSItemValue(header, FITSHeaderManager.NAXIS2);\n        if (NAXIS2 === null) {\n            throw new Error(\"NAXIS2 not defined.\");\n        }\n        const BITPIX = ParseHeader.getFITSItemValue(header, FITSHeaderManager.BITPIX);\n        if (BITPIX === null) {\n            throw new Error(\"BITPIX not defined.\");\n        }\n        const bytesXelem = Math.abs(BITPIX / 8);\n        // if (payload.length !== NAXIS1 * NAXIS2 * bytesXelem) {\n        //   throw new Error(\"Payload size does not match the expected matrix dimensions.\");\n        // }\n        // const matrix: Array<Uint8Array> = [];\n        const matrix = [];\n        for (let i = 0; i < NAXIS2; i++) {\n            matrix.push(payload.slice(i * NAXIS1 * bytesXelem, (i + 1) * NAXIS1 * bytesXelem));\n        }\n        return matrix;\n    }\n    // static generateFITSForWeb(fitsParsed: FITSParsed) {\n    //   return FITSWriter.typedArrayToURL(fitsParsed)\n    // }\n    static saveFITSLocally(fitsParsed, path) {\n        return FITSWriter.writeFITSFile(fitsParsed, path);\n    }\n    static async getFile(uri) {\n        if (!uri.substring(0, 5).toLowerCase().includes(\"http\")) {\n            const p = await import('./getLocalFile.js');\n            const rawData = await p.getLocalFile(uri);\n            if (rawData?.length) {\n                const uint8 = new Uint8Array(rawData);\n                return uint8;\n            }\n            return new Uint8Array(0);\n        }\n        else {\n            const p = await import('./getFile.js');\n            const rawData = await p.getFile(uri);\n            if (rawData?.byteLength) {\n                const uint8 = new Uint8Array(rawData);\n                return uint8;\n            }\n            return new Uint8Array(0);\n        }\n    }\n}\n// const url = \"http://skies.esac.esa.int/Herschel/normalized/PACS_hips160//Norder8/Dir40000/Npix47180.fits\"\n// FITSParser.loadFITS(url).then((fits) => {\n//   if (fits == null) {\n//     return null\n//   }\n//   const path = \"./fitsTest1.fits\"\n//   console.log(fits.header)\n//   FITSParser.saveFITSLocally(fits, path)\n//   console.log(\"finished\")\n// })\n// // const file = \"/Users/fabriziogiordano/Desktop/PhD/code/new/FITSParser/tests/inputs/empty.fits\"\n// const file = \"/Users/fabriziogiordano/Desktop/PhD/code/new/FITSParser/tests/inputs/Npix43348.fits\"\n// FITSParser.loadFITS(file).then((fits) => {\n//   if (fits == null) {\n//     return null\n//   }\n//   const path = \"./fitsTest2.fits\"\n//   console.log(fits.header)\n//   FITSParser.saveFITSLocally(fits, path)\n//   console.log(\"finished\")\n// })\n//# sourceMappingURL=FITSParser.js.map","import { FITSHeaderManager } from \"jsfitsio\";\n// import { FITSHeaderManager, FITSHeaderItem } from \"jsfitsio\";\n// import { FITSParsed } from \"jsfitsio\";\n// import { AstroCoords } from \"src/model/AstroCoords\";\n// import { ImagePixel } from \"../model/ImagePixel.js\";\nimport { Point } from \"../model/Point.js\";\n// import { FITS } from \"../model/FITS.js\";\nimport { TilesRaDecList2 } from \"./hips/TilesRaDecList2.js\";\nimport { FITS } from \"../model/FITS.js\";\n\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n *\n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nexport abstract class AbstractProjection {\n\n  public abstract getFITSHeader(): FITSHeaderManager;\n\n  public abstract getCommonFitsHeaderParams(): FITSHeaderManager;\n\n  public abstract setPixelValues(\n    values: TilesRaDecList2,\n    header: FITSHeaderManager,\n  ): FITS;\n\n  public abstract getImageRADecList(\n    center: Point, radius: number,\n    pxsize: number, naxisWidth: number\n  ): TilesRaDecList2;\n\n  public abstract pix2world(i: number, j: number, pxsize: number, minra: number, mindec: number): Point;\n\n  public abstract world2pix(radeclist: TilesRaDecList2): TilesRaDecList2;\n\n  public abstract computeNaxisWidth(radius: number, pxsize: number): number;\n\n  public abstract generateFITSFile(pixelAngSize: number,\n    BITPIX: number,\n    TILE_WIDTH: number,\n    BLANK: number, BZERO: number, BSCALE: number,\n    cRA: number, cDec: number,\n    minValue: number, maxValue: number,\n    raDecWithValues: TilesRaDecList2): FITS\n}\n","/**\n * @author Fabrizio Giordano (Fab)\n */\n// import vec3 from 'gl-matrix';\n\nimport { AstroCoords } from \"./AstroCoords.js\";\nimport { CartesianCoords } from \"./CartesianCoords.js\";\nimport { HMSCoords } from \"./HMSCoords.js\";\nimport { NumberType } from \"./NumberType.js\";\nimport { SexagesimalCoords } from \"./SexagesimalCoords.js\";\nimport { SphericalCoords } from \"./SphericalCoords.js\";\n\nfunction Utils(){\n\t\n}\n\nexport function cartesianToSpherical(xyz: CartesianCoords): SphericalCoords{\n\tlet dotXYZ = dot(xyz, xyz);\n\tlet r = Math.sqrt(dotXYZ);\t\n\tlet thetaRad = Math.acos(xyz.z/r);\n\tlet thetaDeg = radToDeg(thetaRad);\n\t// NB: in atan(y/x) is written with params switched atan2(x, y)\n\tlet phiRad = Math.atan2(xyz.y,xyz.x);\n\tlet phiDeg = radToDeg(phiRad);\n\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\treturn {\n\t\tphiDeg: phiDeg, \n\t\tthetaDeg: thetaDeg,\n\t\tphiRad:phiRad,\n\t\tthetaRad: thetaRad\n\t};\n};\n\nexport function sphericalToAstro(phiTheta: SphericalCoords): AstroCoords{\n\tlet raDeg: number;\n\tlet decDeg: number;\n\n\traDeg = phiTheta.phiDeg;\n\tif (raDeg < 0){\n\t\traDeg += 360;\n\t}\n\tdecDeg = 90 - phiTheta.thetaDeg;\n\t\n\treturn {\n\t\t\"raDeg\": raDeg,\n\t\t\"decDeg\": decDeg,\n\t\t\"raRad\": degToRad(raDeg),\n\t\t\"decRad\": degToRad(decDeg)\n\n\t};\n}\n\nexport function astroToSpherical(raDec: AstroCoords): SphericalCoords{\n\t\n\tlet phiDeg: number;\n\tlet thetaDeg: number;\n\n\tphiDeg = raDec.raDeg;\n\tif (phiDeg < 0){\n\t\tphiDeg += 360;\n\t}\n\t\n\tthetaDeg = 90 - raDec.decDeg;\n\t\n\treturn {\n\t\t\"phiDeg\": phiDeg,\n\t\t\"thetaDeg\": thetaDeg,\n\t\t\"phiRad\": degToRad(phiDeg),\n\t\t\"thetaRad\": degToRad(thetaDeg),\n\t};\n}\n\nexport function sphericalToCartesian(phiTheta: SphericalCoords, r: number): CartesianCoords{\n\tr = (r == undefined) ? 1 : r;\n\tvar x = r * Math.sin(phiTheta.thetaRad) * Math.cos(phiTheta.phiRad);\n\tvar y = r * Math.sin(phiTheta.thetaRad) * Math.sin(phiTheta.phiRad);\n\tvar z = r * Math.cos(phiTheta.thetaRad);\n\n\treturn {\n\t\t\"x\": x, \n\t\t\"y\": y, \n\t\t\"z\": z\n\t};\n};\n\nexport function fillAstro(ra: number, dec: number, unit: NumberType): AstroCoords | null{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"raDeg\": ra,\n\t\t\t\"decDeg\": dec,\n\t\t\t\"raRad\": degToRad(ra),\n\t\t\t\"decRad\": degToRad(dec)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"raRad\": ra,\n\t\t\t\"decRad\": dec,\n\t\t\t\"raDeg\": radToDeg(ra),\n\t\t\t\"decDeg\": radToDeg(dec)\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t\treturn null\n\t}\n\t\n}\n\n\nexport function fillSpherical(phi: number, theta: number, unit: NumberType):  SphericalCoords | null{\n\tif (unit == NumberType.DEGREES) {\n\t\treturn {\n\t\t\t\"phiDeg\": phi,\n\t\t\t\"thetaDeg\": theta,\n\t\t\t\"phiRad\": degToRad(phi),\n\t\t\t\"thetaRad\": degToRad(theta)\n\t\t}\n\t} else if (unit == NumberType.RADIANS) {\n\t\treturn {\n\t\t\t\"phiDeg\": radToDeg(phi),\n\t\t\t\"thetaDeg\": radToDeg(theta),\n\t\t\t\"phiRad\": phi,\n\t\t\t\"thetaRad\": theta\n\t\t}\n\t} else {\n\t\tconsole.error(\"Wrong operation. NumberType \" + unit + \" not supported\");\n\t\treturn null\n\t}\n}\n\nfunction dot(a: CartesianCoords, b: CartesianCoords) : number{\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n\nexport function colorHex2RGB(hexColor: string): [number, number, number] {\n\n//\tconsole.log(hexColor);\n\tvar hex1 = hexColor.substring(1,3);\n\tvar hex2 = hexColor.substring(3,5);\n\tvar hex3 = hexColor.substring(5,7);\n\t\n\tvar dec1 = parseInt(hex1, 16);\n\tvar dec2 = parseInt(hex2, 16);\n\tvar dec3 = parseInt(hex3, 16);\n\t\n\tvar rgb1 = (dec1 / 255).toFixed(2);\n\tvar rgb2 = (dec2 / 255).toFixed(2);\n\tvar rgb3 = (dec3 / 255).toFixed(2);\n\t\n\treturn [parseFloat(rgb1), parseFloat(rgb2), parseFloat(rgb3)];\n\n}\n\nexport function degToRad(degrees: number) : number{\n\treturn (degrees / 180 ) * Math.PI ;\n}\n\nexport function radToDeg(radians: number) : number{\n\treturn radians * 180 / Math.PI;\n}\n\nexport function raDegToHMS(raDeg: number): HMSCoords{\n\t\n\tvar h = Math.floor(raDeg/15);\n\tvar m = Math.floor((raDeg/15 - h) * 60);\n\tvar s = (raDeg/15 - h - m/60) * 3600;\n\t\n\treturn {\n\t\th: h, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nexport function decDegToDMS(decDeg: number): SexagesimalCoords{\n\tvar sign = 1;\n\tif (decDeg < 0){\n\t\tsign = -1;\n\t}\n\t\n\tvar decDeg_abs = Math.abs(decDeg);\n\tvar d = Math.trunc(decDeg_abs);\n\t\n\tvar m = Math.trunc( (decDeg_abs - d) * 60);\n\t\n\tvar s = (decDeg_abs - d - m/60) * 3600;\n\td = d * sign;\n\t\n\treturn {\n\t\td: d, \n\t\tm: m, \n\t\ts: s\n\t};\n}\n\nfunction dms2DecDeg(decDMS: SexagesimalCoords){\n\tvar sign = Math.sign(decDMS.d);\n\tvar deg = (decDMS.d) + sign * (decDMS.m / 60) + sign * (decDMS.s/3600);\n\treturn deg;\n}\n\nfunction hms2RaDeg(raHMS: HMSCoords){\n\tvar sign = Math.sign(raHMS.h);\n\tvar deg = (raHMS.h + sign * (raHMS.m / 60) + sign * (raHMS.s/3600)) * 15;\n\treturn deg;\n}\n\nfunction worldToModel(xy: [number, number], radius: number): [number, number, number]{\n\tvar x = xy[0];\n\tvar y = xy[1];\n\tvar z = Math.sqrt(radius*radius - xy[0]*xy[0] - xy[1]*xy[1]);\n\treturn [x, y, z];\n}\n\n","export class Config {\n    static MAX_DECIMALS:number = 6\n}","/**\n * @author Fabrizio Giordano (Fab77)\n */\n\nimport {sphericalToCartesian, cartesianToSpherical, sphericalToAstro, astroToSpherical, fillSpherical, fillAstro} from './Utils.js';\nimport { CartesianCoords } from './CartesianCoords.js';\nimport { AstroCoords} from './AstroCoords.js';\nimport { CoordsType } from './CoordsType.js';\nimport { SphericalCoords } from './SphericalCoords.js';\nimport { NumberType } from './NumberType.js';\nimport { Config } from '../Config.js';\n\nexport class Point{\n\n\tprivate astro!: AstroCoords\n\t// equatorial: EquatorialCoords;\n\t// galactic: GalacticCoords;\n\n\tprivate spherical!: SphericalCoords;\n\tprivate cartesian!: CartesianCoords;\n\n\tconstructor(in_type: CoordsType, unit: NumberType, ...coords: Array<number>) {\n\n\t\tif (in_type == CoordsType.CARTESIAN){\n\t\t\tthis.cartesian.x = parseFloat(coords[0].toFixed(Config.MAX_DECIMALS));\n\t\t\tthis.cartesian.y = parseFloat(coords[1].toFixed(Config.MAX_DECIMALS));\n\t\t\tthis.cartesian.z = parseFloat(coords[2].toFixed(Config.MAX_DECIMALS));\n\t\t\tthis.spherical = cartesianToSpherical(this.cartesian);\n\n\t\t\tthis.astro = sphericalToAstro(this.spherical);\n\t\t\t\n\t\t} else if (in_type == CoordsType.ASTRO){\n\t\t\tconst c = fillAstro(coords[0],  coords[1], unit);\n\t\t\tif (c !== null) {\n\t\t\t\tthis.astro = c\n\t\t\t\tthis.spherical = astroToSpherical(this.astro);\n\t\t\t\tthis.cartesian = sphericalToCartesian(this.spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\t}\n\t\t\t\n\t\n\t\t} else if (in_type == CoordsType.SPHERICAL){\n\t\t\tconst s = fillSpherical(coords[0],  coords[1], unit);\n\t\t\tif (s !== null) {\n\t\t\t\tthis.spherical = s\n\t\t\t\tthis.cartesian = sphericalToCartesian(this.spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\t\tthis.astro = sphericalToAstro(this.spherical);\n\t\t\t}\n\t\t} else{\n\t\t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t\t}\n\t\tif (this.spherical.phiDeg > 360) {\n\t\t\tthis.spherical.phiDeg -= 360;\n\t\t}\n\t\tif (this.astro.raDeg > 360) {\n\t\t\tthis.astro.raDeg -= 360;\n\t\t}\n\t}\n\n\n\t// constructor(in_options: ICoordsFormat, in_type: CoordsType){\n\t\t\n\t// \tif (in_type == CoordsType.CARTESIAN){\n\n\t// \t\tthis.cartesian.x = parseFloat((in_options as CartesianCoords).x.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.cartesian.y = parseFloat((in_options as CartesianCoords).y.toFixed(global.MAX_DECIMALS));\n\t// \t\tthis.cartesian.z = parseFloat((in_options as CartesianCoords).z.toFixed(global.MAX_DECIMALS));\n\n\t// \t\tthis.spherical = cartesianToSpherical(this.cartesian);\n\t// \t\tthis.astro = sphericalToAstro(this.spherical);\n\t\t\t\n\t// \t}else if (in_type == CoordsType.ASTRO){\n\t\t\t\n\t// \t\tif ((in_options as AstroCoords).raDeg && (in_options as AstroCoords).decDeg) {\n\t// \t\t\tthis.astro = radegDecdegToAstro((in_options as AstroCoords).raDeg,  (in_options as AstroCoords).decDeg );\n\t// \t\t} else if ((in_options as AstroCoords).raRad && (in_options as AstroCoords).decRad) {\n\t// \t\t\tthis.astro = raradDecradToAstro((in_options as AstroCoords).raRad,  (in_options as AstroCoords).decRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"AstroCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\t// \t\tthis.spherical = astroToSpherical(this.astro);\n\t// \t\tthis.cartesian = sphericalToCartesian(this.spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t\t\t\n\t// \t}else if (in_type == CoordsType.SPHERICAL){\n\n\t// \t\tif ((in_options as SphericalCoords).phiDeg && (in_options as SphericalCoords).thetaDeg) {\n\t// \t\t\tthis.spherical = phidegThetadegToSpherical((in_options as SphericalCoords).phiDeg,  (in_options as SphericalCoords).thetaDeg );\n\t// \t\t} else if ((in_options as SphericalCoords).phiRad && (in_options as SphericalCoords).thetaRad) {\n\t// \t\t\tthis.spherical = phiradThetaradToSpherical((in_options as SphericalCoords).phiRad,  (in_options as SphericalCoords).thetaRad );\n\t// \t\t} else {\n\t// \t\t\tconsole.error(\"SphericalCoords incomplete \"+ in_options );\n\t// \t\t\treturn null;\n\t// \t\t}\n\n\t// \t\tthis.cartesian = sphericalToCartesian(this.spherical, 1.0); // TODO radius shall be taken from global (e.g. HiPS radius in case of HiPS)\n\t// \t\tthis.astro = sphericalToAstro(this.spherical);\n\t\t\t\n\t// \t}else{\n\t// \t\tconsole.error(\"CoordsType \"+in_type+\" not recognised.\");\n\t// \t}\n\t// }\n\n\tgetSpherical() {\n\t\treturn this.spherical;\n\t}\n\n\tgetAstro() {\n\t\treturn this.astro;\n\t}\n\n\tgetCartesian() {\n\t\treturn this.cartesian;\n\t}\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// /** Scale the vector by a given factor\n    // @param n the scale factor */\n\t// scale(n: number): Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*n, this.y*n, this.z*n);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified \n\t// dot(v: Point): number{ \n\t// \treturn this.x*v.x + this.y*v.y + this.z*v.z; \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// cross(v: Point): Point{ \n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.y*v.z - v.y*this.z, this.z*v.x - v.z*this.x, this.x*v.y - v.x*this.y);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// norm() : Point{\n\t// \tlet d = 1./this.length();\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x*d, this.y*d, this.z*d);\n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// length(): number{ \n\t// \treturn Math.sqrt(this.lengthSquared()); \n\t// };\n\t// // taken from Healpixjs->Vec3. //TODO Point and Vec3 should be unified\n\t// lengthSquared(): number{ \n\t// \treturn this.x*this.x + this.y*this.y + this.z*this.z; \n  \t// };\n\n\t// subtract(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x - v.x, this.y - v.y, this.z - v.z);\n\t// }\n\n\t// add(v: Point) : Point{\n\t// \treturn new Point(CoordsType.CARTESIAN, NumberType.DECIMAL, this.x + v.x, this.y + v.y, this.z + v.z);\n\t// }\n\t\n\n\t// get x(){\n\t// \treturn this._x;\n\t// }\n\t\n\t// get y(){\n\t// \treturn this._y;\n\t// }\n\t\n\t// get z(){\n\t// \treturn this._z;\n\t// }\n\t\n\t// get xyz(){\n    //     return this._xyz;\n    // }\n\t\n    // get raDeg(){\n    //     return this._raDeg;\n    // }\n    \n    // get decDeg(){\n    //     return this._decDeg;\n    // }\n    \n    // get raDecDeg(){\n    //     return this._raDecDeg;\n    // }\n    \n    // toADQL(){\n    // \treturn this._raDecDeg[0]+\",\"+this._raDecDeg[1];\n    // }\n    \n    // toString(){\n    // \treturn \"(raDeg, decDeg) => (\"+this._raDecDeg[0]+\",\"+this._raDecDeg[1]+\") (x, y,z) => (\"+this._xyz[0]+\",\"+this._xyz[1]+\",\"+this._xyz[2]+\")\";\n    // }\n}\n\n","export class MinMaxValue {\n    min: number\n    max: number\n    \n    constructor(min: number, max: number) {\n        this.min = min\n        this.max = max\n    }\n\n    getMinValue() {\n        return this.min\n    }\n    \n    getMaxValue() {\n        return this.max\n    }\n\n}","export class RADecMinMaxCentral {\n    centralRA: number\n    centralDec: number\n    minRA: number\n    minDec: number\n    maxRA: number\n    maxDec: number\n    \n    constructor(centralRA: number, centralDec: number, minRA: number,\n    minDec: number, maxRA: number, maxDec: number) {\n        this.centralDec = centralDec\n        this.centralRA = centralRA\n\n        this.maxDec = maxDec\n        this.maxRA = maxRA\n\n        this.minRA = minRA\n        this.minDec = minDec\n    }\n\n    getMinRA() {\n        return this.minRA\n    }\n    \n    getMinDec() {\n        return this.minDec\n    }\n    \n    getMaxRA() {\n        return this.maxRA\n    }\n    \n    getMaxDec() {\n        return this.maxDec\n    }\n\n    getCentralRA() {\n        return this.centralRA\n    }\n    \n    getCentralDec() {\n        return this.centralDec\n    }\n\n\n    setMinRA(minRA: number) {\n        this.minRA = minRA\n    }\n    \n    setMinDec(minDec: number) {\n        this.minDec = minDec\n    }\n    \n    setMaxRA(maxRA: number) {\n        this.maxRA = maxRA\n    }\n    \n    setMaxDec(maxDec: number) {\n        this.maxDec = maxDec\n    }\n\n    setCentralRA(cRA: number) {\n        this.centralRA = cRA\n    }\n    \n    setCentralDec(cDec: number) {\n        this.centralDec = cDec\n    }\n\n}","import { MinMaxValue } from \"../MinMaxValue.js\"\nimport { RADecMinMaxCentral } from \"../RADecMinMaxCentral.js\"\nimport { ImagePixel } from \"./ImagePixel.js\"\n\nexport class TilesRaDecList2 {\n\n    // hipsOrder: number\n    tileList: Array<number>\n    imagePixelList: ImagePixel[]\n    minPixelValue: number | null = null\n    maxPixelValue: number | null = null\n    BZERO: number | null = null\n    BSCALE: number | null = null\n    BLANK: number | null = null\n\n\n    // constructor(hipsOrder: number) {\n    //     this.hipsOrder = hipsOrder\n    constructor() {\n        this.tileList = []\n        this.imagePixelList = new Array<ImagePixel>()\n    }\n\n    setBZERO(BZERO: number) {\n        this.BZERO = BZERO\n    }\n\n    setBSCALE(BSCALE: number) {\n        this.BSCALE = BSCALE\n    }\n\n    setBLANK(BLANK: number) {\n        this.BLANK = BLANK\n    }\n\n    getBZERO() {\n        return this.BZERO\n    }\n\n    getBSCALE() {\n        return this.BSCALE\n    }\n\n    getBLANK() {\n        return this.BLANK\n    }\n\n    findImagePixel(i: number, j: number) {\n        return this.imagePixelList.find(p => p.i === i && p.j === j) || null;\n    }\n\n    getImagePixelsByTile(tileno: number): ImagePixel[] {\n        return this.imagePixelList.filter(p => p.tileno === tileno);\n    }\n\n    getImagePixelList() {\n        return this.imagePixelList\n    }\n\n    getTilesList() {\n        return this.tileList\n    }\n\n    addImagePixel(imgpx: ImagePixel) {\n        this.imagePixelList.push(imgpx)\n    }\n\n    addTileNumber(tileno: number) {\n        if (!this.tileList.includes(tileno)) {\n            this.tileList.push(tileno)\n        }\n    }\n\n\n    computeRADecMinMaxCentral(): RADecMinMaxCentral | null {\n        if (this.imagePixelList.length === 0) return null;\n\n        // Single pass, skip non-finite values\n        let minRA = Infinity, maxRA = -Infinity;\n        let minDec = Infinity, maxDec = -Infinity;\n\n        for (const p of this.imagePixelList) {\n            if (Number.isFinite(p.ra)) {\n                if (p.ra < minRA) minRA = p.ra;\n                if (p.ra > maxRA) maxRA = p.ra;\n            }\n            if (Number.isFinite(p.dec)) {\n                if (p.dec < minDec) minDec = p.dec;\n                if (p.dec > maxDec) maxDec = p.dec;\n            }\n        }\n\n        // If all values were non-finite, bail out\n        if (!Number.isFinite(minRA) || !Number.isFinite(maxRA) ||\n            !Number.isFinite(minDec) || !Number.isFinite(maxDec)) {\n            return null;\n        }\n\n        const cRA = minRA + (maxRA - minRA) / 2;\n        const cDec = minDec + (maxDec - minDec) / 2;\n\n        return new RADecMinMaxCentral(cRA, cDec, minRA, minDec, maxRA, maxDec);\n    }\n\n    setMinMaxValue(value: number | null) {\n        if (!value) return\n\n        if (!this.minPixelValue) {\n            this.minPixelValue = value\n        } else if (value < this.minPixelValue) {\n            this.minPixelValue = value\n        }\n\n        if (!this.maxPixelValue) {\n            this.maxPixelValue = value\n        } else if (value > this.minPixelValue) {\n            this.maxPixelValue = value\n        }\n    }\n\n    getMinMaxValues() {\n        if (this.minPixelValue && this.maxPixelValue) {\n            return new MinMaxValue(this.minPixelValue, this.maxPixelValue)\n        }\n        return null\n\n    }\n\n}\n","import { ParseUtils } from \"jsfitsio\"\n\nexport class ImagePixel {\n    i: number\n    j: number\n    ra: number\n    dec: number\n    tileno: number | undefined\n    uint8value: Uint8Array | null = null\n    value: number | null = null\n\n    constructor(i: number, j: number, tileno: number | undefined);\n\n    constructor(ra: number, dec: number, tileno: number | undefined);\n\n    constructor(a: number, b: number, tileno: number | undefined) {\n        \n        this.tileno = tileno;\n\n        // Heuristic: if `a` and `b` are integers, treat them as `i` and `j`\n        if (Number.isInteger(a) && Number.isInteger(b)) {\n            this.i = a;\n            this.j = b;\n            this.ra = NaN;\n            this.dec = NaN;\n        } else {\n            this.ra = a;\n            this.dec = b;\n            this.i = -1;\n            this.j = -1;\n        }\n        \n    }\n\n    geti(){\n        return this.i\n    }\n\n    getj(){\n        return this.j\n    }\n    getRADeg(){\n        return this.ra\n    }\n\n    getDecDeg(){\n        return this.dec\n    }\n\n    getUint8Value(){\n        return this.uint8value\n    }\n\n    getValue() {\n        return this.value\n    }\n\n    setValue(value: Uint8Array, bitpix: number){\n        if (this.uint8value == undefined) {\n            const bytesXelem = Math.abs(bitpix / 8);\n            this.uint8value = new Uint8Array(bytesXelem)\n        }\n        this.uint8value = value\n        this.value = ParseUtils.extractPixelValue(0, value, bitpix)\n    }\n\n    setTileNumber(tileno: number) {\n        this.tileno = tileno\n    }\n\n    setij(i:number, j:number){\n        this.i = i\n        this.j = j\n    }\n\n    setRADecDeg(ra:number, dec:number){\n        this.ra = ra\n        this.dec = dec\n    }\n\n}\n","\nimport { FITSHeaderManager } from 'jsfitsio';\n\nexport class FITS {\n\n    private header!: FITSHeaderManager\n    private payload: Uint8Array<ArrayBufferLike>[] = []\n\n    constructor(header: FITSHeaderManager, data: Map<number, Array<Uint8Array>>) {\n        this.header = header\n        this.setData(data)\n    }\n\n    setData(data: Map<number, Array<Uint8Array>>){\n        this.payload = Array.from(data.values()).flatMap(row => row);\n    }\n\n    getHeader() {\n        return this.header\n    }\n    \n    getData() {\n        return this.payload\n    }\n\n\n\n}","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\n\nimport { FITSParser, FITSHeaderManager, FITSHeaderItem, FITSParsed, ParseUtils } from 'jsfitsio';\n\n\nimport { AbstractProjection } from '../AbstractProjection.js';\nimport { Point } from '../../model/Point.js';\nimport { CoordsType } from '../../model/CoordsType.js';\nimport { NumberType } from '../../model/NumberType.js';\nimport { TilesRaDecList2 } from '../hips/TilesRaDecList2.js';\nimport { ImagePixel } from '../hips/ImagePixel.js';\nimport { FITS } from '../../model/FITS.js';\n\nimport { APP_VERSION } from '../../Version.js'; // adjust path as needed\n\n\n// import { HiPSProp } from '../hips/HiPSProp.js';\n\n\nexport class MercatorProjection extends AbstractProjection {\n\n    minra!: number;\n    mindec!: number;\n    naxis1!: number;\n    naxis2!: number;\n    bitpix!: number\n\n    fitsheader: FITSHeaderManager;\n    pxvalues: Array<Uint8Array>;\n\n    CTYPE1: string = \"'RA---CAR'\";\n    CTYPE2: string = \"'DEC--CAR'\";\n    craDeg!: number;\n    cdecDeg!: number;\n\n    pxsize!: number;\n    pxsize1!: number;\n    pxsize2!: number;\n\n    // _minphysicalval!: number;\n    // _maxphysicalval!: number;\n    _wcsname: string;\n\n    constructor() {\n        super();\n        this._wcsname = \"MER\"; // TODO check WCS standard and create ENUM\n        this.pxvalues = new Array<Uint8Array>();\n        this.fitsheader = new FITSHeaderManager();\n    }\n\n\n    async initFromFile(infile: string): Promise<FITSParsed> {\n\n        const fits = await FITSParser.loadFITS(infile);\n        if (!fits) {\n            console.error(\"FITS is null\")\n            throw new Error(\"FITS is null\")\n        }\n\n        this.pxvalues = fits.data;\n        this.fitsheader = fits.header;\n        this.naxis1 = Number(fits.header.findById(\"NAXIS1\")?.value)\n        this.naxis2 = Number(fits.header.findById(\"NAXIS2\")?.value)\n\n        this.bitpix = fits.header.findById(\"BITPIX\")?.value as number;\n        this.craDeg = fits.header.findById(\"CRVAL1\")?.value as number;\n        this.cdecDeg = fits.header.findById(\"CRVAL2\")?.value as number;\n\n        const pxsize1 = this.fitsheader.findById(\"CDELT1\")?.value as number;\n        const pxsize2 = this.fitsheader.findById(\"CDELT2\")?.value as number;\n        if (pxsize1 !== pxsize2 || pxsize1 === undefined || pxsize2 === undefined) {\n            throw new Error(\"pxsize1 is not equal to pxsize2\")\n        }\n        this.pxsize = pxsize1;\n\n        this.minra = this.craDeg - this.pxsize * this.naxis1 / 2;\n        if (this.minra < 0) {\n            this.minra += 360;\n        }\n        // this._mindec = this._cdecDeg - this._pxsize2 * this._naxis2 / 2;\n        this.mindec = this.cdecDeg - this.pxsize * this.naxis2 / 2;\n\n        return fits;\n\n    }\n\n    getBytePerValue(): number {\n        return Math.abs(this.bitpix / 8);\n    }\n\n\n    extractPhysicalValues(fits: FITSParsed): number[][] {\n\n        const bzero = Number(fits.header.findById(\"BZERO\")?.value);\n        const bscale = Number(fits.header.findById(\"BSCALE\")?.value);\n        const naxis1 = Number(fits.header.findById(\"NAXIS1\")?.value);\n        const naxis2 = Number(fits.header.findById(\"NAXIS2\")?.value);\n        const bitpix = Number(fits.header.findById(\"BITPIX\")?.value);\n        const bytesXelem = Math.abs(bitpix / 8);\n\n        let physicalvalues: number[][] = new Array<number[]>(naxis2);\n\n        for (let n2 = 0; n2 < naxis2; n2++) {\n            physicalvalues[n2] = new Array<number>(naxis1);\n            for (let n1 = 0; n1 < naxis1; n1++) {\n                const pixval = ParseUtils.extractPixelValue(0, fits.data[n2].slice(n1 * bytesXelem, (n1 + 1) * bytesXelem), bitpix);\n                if (pixval) {\n                    let physicalVal = bzero + bscale * pixval;\n                    physicalvalues[n2][n1] = physicalVal;\n                }\n\n            }\n        }\n        return physicalvalues;\n    }\n\n\n    prepareHeader(pixelAngSize: number,\n        BITPIX: number,\n        TILE_WIDTH: number,\n        BLANK: number, BZERO: number, BSCALE: number,\n        cRA: number, cDec: number,\n        minValue: number, maxValue: number): FITSHeaderManager {\n\n        const fitsheader = new FITSHeaderManager();\n\n        fitsheader.insert(new FITSHeaderItem(\"SIMPLE\", \"T\", \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"NAXIS1\", TILE_WIDTH, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"NAXIS2\", TILE_WIDTH, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"NAXIS\", 2, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"BITPIX\", BITPIX, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"BLANK\", BLANK, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"BSCALE\", BSCALE, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"BZERO\", BZERO, \"\"));\n\n        fitsheader.insert(new FITSHeaderItem(\"CTYPE1\", this.CTYPE1, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"CTYPE2\", this.CTYPE2, \"\"));\n\n        fitsheader.insert(new FITSHeaderItem(\"CDELT1\", pixelAngSize, \"\")); // ??? Pixel spacing along axis 1 ???\n        fitsheader.insert(new FITSHeaderItem(\"CDELT2\", pixelAngSize, \"\")); // ??? Pixel spacing along axis 2 ???\n        fitsheader.insert(new FITSHeaderItem(\"CRPIX1\", TILE_WIDTH / 2, \"\")); // central/reference pixel i along naxis1\n        fitsheader.insert(new FITSHeaderItem(\"CRPIX2\", TILE_WIDTH / 2, \"\")); // central/reference pixel j along naxis2\n\n        fitsheader.insert(new FITSHeaderItem(\"CRVAL1\", cRA, \"\")); // central/reference pixel RA\n        fitsheader.insert(new FITSHeaderItem(\"CRVAL2\", cDec, \"\")); // central/reference pixel Dec\n\n        const min = BZERO + BSCALE * minValue;\n        const max = BZERO + BSCALE * maxValue;\n        fitsheader.insert(new FITSHeaderItem(\"DATAMIN\", min, \"\")); // min data value\n        fitsheader.insert(new FITSHeaderItem(\"DATAMAX\", max, \"\")); // max data value\n\n\n        fitsheader.insert(new FITSHeaderItem(\"ORIGIN\", `WCSLight v.${APP_VERSION}`, \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"COMMENT\", \"WCSLight developed by F.Giordano and Y.Ascasibar\", \"\"));\n        fitsheader.insert(new FITSHeaderItem(\"END\", \"\", \"\"));\n\n        return fitsheader;\n\n    }\n\n\n    // TODO CHECK: there are 4 header related methods!!! prepareHeader, prepareFITSHeader, getCommonFitsHeaderParams and getFITSHeader\n    getFITSHeader(): FITSHeaderManager {\n        return this.fitsheader;\n    }\n    // TODO CHECK: there are 4 header related methods!!! prepareHeader, prepareFITSHeader, getCommonFitsHeaderParams and getFITSHeader\n    getCommonFitsHeaderParams(): FITSHeaderManager {\n        let header = new FITSHeaderManager();\n        for (const item of this.fitsheader.getItems()) {\n            const key = item.key\n            if ([\"SIMPLE\", \"BITPIX\", \"BSCALE\", \"BZERO\", \"BLANK\", \"ORDER\",].includes(key)) {\n                const value = item.value\n                header.insert(new FITSHeaderItem(key, value, \"\"));\n            }\n        }\n        return header;\n    }\n\n    computeNaxisWidth(radius: number, pxsize: number): number {\n        return Math.ceil(2 * radius / pxsize);\n    }\n\n    getImageRADecList(center: Point, radius: number, pxsize: number, naxisWidth: number): TilesRaDecList2 {\n\n\n        const naxis1 = naxisWidth\n        const naxis2 = naxis1;\n\n        let minra = center.getAstro().raDeg - radius;\n        if (minra < 0) {\n            minra += 360;\n        }\n        const mindec = center.getAstro().decDeg - radius;\n\n        const tilesRaDecList = new TilesRaDecList2()\n\n        // let radeclist: Array<[number, number]> = new Array<[number, number]>();\n\n        // let centralRa, centralDec\n        for (let d = 0; d < naxis2; d++) {\n            for (let r = 0; r < naxis1; r++) {\n                tilesRaDecList.addImagePixel(new ImagePixel(minra + (r * pxsize), mindec + (d * pxsize), undefined))\n                // radeclist.push([minra + (r * pxsize), mindec + (d * pxsize)]);\n            }\n        }\n\n        const centralImgpx = tilesRaDecList.getImagePixelList().length / 2 - 1\n        // let cidx = (naxis2 / 2) * naxis1 + naxis1 / 2;\n        // if (naxis1 % 2 != 0) {\n        //     cidx = Math.floor(radeclist.length / 2);\n        // }\n        // this._craDeg = radeclist[cidx][0];\n        // this._cdecDeg = radeclist[cidx][1];\n\n        // return radeclist\n        return tilesRaDecList\n\n    }\n\n\n\n    /** TODO !!! check and handle RA passing through 360-0 */\n    pix2world(i: number, j: number, pxsize: number, minra: number, mindec: number): Point {\n\n        let ra: number;\n        let dec: number;\n        // ra = i * this._stepra + this._minra;\n        // dec = j * this._stepdec + this._mindec;\n        ra = i * pxsize + minra;\n        dec = j * pxsize + mindec;\n        let p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n        return p;\n        // return [ra, dec];\n\n    }\n\n    setPixelValues(raDecList: TilesRaDecList2, header: FITSHeaderManager): FITS {\n\n        const BITPIX = header.findById(\"BITPIX\")?.value as number;\n        if (!Number.isFinite(BITPIX)) {\n            throw new Error(\"BITPIX not found or invalid in header\");\n        }\n        const bytesPerElem = Math.abs(BITPIX) / 8;\n\n        const width = header.findById(\"NAXIS1\")?.value as number;\n        const height = (header.findById(\"NAXIS2\")?.value as number) ?? width; // fallback if square\n        if (!Number.isFinite(width) || width <= 0) throw new Error(\"NAXIS1 not found or invalid\");\n        if (!Number.isFinite(height) || height <= 0) throw new Error(\"NAXIS2 not found or invalid\");\n\n        const pixels = raDecList.getImagePixelList();\n        if (pixels.length !== width * height) {\n            throw new Error(`Pixel count mismatch: got ${pixels.length}, expected ${width * height}`);\n        }\n\n        // Map<rowIndex, Uint8Array[]>, each row has length = width\n        const pxvalues = new Map<number, Uint8Array[]>();\n        for (let r = 0; r < height; r++) {\n            pxvalues.set(r, new Array<Uint8Array>(width));\n        }\n\n        // Fill in row-major order: for each linear index, compute (row, col)\n        for (let idx = 0; idx < pixels.length; idx++) {\n            const row = Math.floor(idx / width);\n            const col = idx % width;\n\n            const rowArr = pxvalues.get(row)!;\n\n            let u8 = pixels[idx].getUint8Value();\n            if (u8 == null) {\n                // Your pipelines ImagePixel.setValue() should have set this already.\n                // Throwing is safer than inventing packing (FITS expects specific endian/precision).\n                throw new Error(`Pixel (${row},${col}) missing Uint8Array for BITPIX=${BITPIX}`);\n            }\n            if (u8.byteLength !== bytesPerElem) {\n                throw new Error(\n                    `Pixel (${row},${col}) byteLength=${u8.byteLength} != expected ${bytesPerElem} (BITPIX=${BITPIX})`\n                );\n            }\n\n            rowArr[col] = u8;\n            // no need to pxvalues.set(row, rowArr); reference already updated\n        }\n\n        return new FITS(header, pxvalues);\n    }\n\n\n\n\n\n    generateFITSFile(pixelAngSize: number,\n        BITPIX: number,\n        TILE_WIDTH: number,\n        BLANK: number, BZERO: number, BSCALE: number,\n        cRA: number, cDec: number,\n        minValue: number, maxValue: number,\n        raDecWithValues: TilesRaDecList2): FITS {\n\n        const header: FITSHeaderManager = this.prepareHeader(\n            pixelAngSize,\n            BITPIX,\n            TILE_WIDTH,\n            BLANK, BZERO, BSCALE,\n            cRA, cDec,\n            minValue, maxValue)\n        const fits: FITS = this.setPixelValues(raDecWithValues, header)\n        return fits;\n    }\n\n\n    world2pix(raDecList: TilesRaDecList2): TilesRaDecList2 {\n\n        const bytesXvalue = this.getBytePerValue()\n\n        // TODO if I have the this.fitsheader available here, check if I can retrieve this.bitpix, this.pxsize, ... with this.fitsheader\n        // and remove the attributes at object level (with this)\n        const blank = Number(this.fitsheader.findById(\"BLANK\")?.value)\n        const blankBytes = ParseUtils.convertBlankToBytes(blank, bytesXvalue);\n\n        for (let imgPx of raDecList.getImagePixelList()) {\n\n            // console.log(\"raDeclist.getImagePixelList().indexOf(imgPx) \" + raDeclist.getImagePixelList().indexOf(imgPx))\n            const ra = imgPx.getRADeg();\n            const dec = imgPx.getDecDeg();\n\n            const i = Math.floor((ra - this.minra) / this.pxsize);\n            const j = Math.floor((dec - this.mindec) / this.pxsize);\n\n            if (j < 0 || j >= this.naxis2 || i < 0 || i >= this.naxis1) {\n                imgPx.setValue(blankBytes, this.bitpix)\n            } else {\n                const currentValue = this.pxvalues[j].slice(i * bytesXvalue, (i + 1) * bytesXvalue);\n                imgPx.setValue(currentValue, this.bitpix)\n            }\n            raDecList.setMinMaxValue(imgPx.getValue())\n        }\n        return raDecList;\n\n    }\n\n}\n","export class Constants {\n}\n//\tstatic halfpi = Math.PI/2.;\nConstants.halfpi = 1.5707963267948966;\nConstants.inv_halfpi = 2. / Math.PI;\n/** The Constant twopi. */\nConstants.twopi = 2 * Math.PI;\nConstants.inv_twopi = 1. / (2 * Math.PI);\n//# sourceMappingURL=Constants.js.map","export class Zphi {\n    /** Creation from individual components */\n    constructor(z_, phi_) {\n        this.z = z_;\n        this.phi = phi_;\n    }\n    ;\n}\n//# sourceMappingURL=Zphi.js.map","import { Vec3 } from './Vec3.js';\nimport { Zphi } from './Zphi.js';\nexport class Hploc {\n    constructor(ptg) {\n        Hploc.PI4_A = 0.7853981554508209228515625;\n        Hploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\n        Hploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\n        Hploc.M_1_PI = 0.3183098861837906715377675267450287;\n        if (ptg) {\n            this.sth = 0.0;\n            this.have_sth = false;\n            this.z = Hploc.cos(ptg.theta);\n            this._phi = ptg.phi;\n            if (Math.abs(this.z) > 0.99) {\n                this.sth = Hploc.sin(ptg.theta);\n                this.have_sth = true;\n            }\n        }\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    ;\n    get phi() {\n        return this._phi;\n    }\n    ;\n    set phi(phi) {\n        this._phi = phi;\n    }\n    ;\n    setSth(sth) {\n        this.sth = sth;\n    }\n    ;\n    toVec3() {\n        var st = this.have_sth ? this.sth : Math.sqrt((1.0 - this.z) * (1.0 + this.z));\n        // var vector = new Vec3(st*Hploc.cos(this.phi),st*Hploc.sin(this.phi),this.z);\n        var vector = new Vec3(st * Math.cos(this.phi), st * Math.sin(this.phi), this.z);\n        return vector;\n    }\n    ;\n    toZphi() {\n        return new Zphi(this.z, this.phi);\n    }\n    static sin(d) {\n        let u = d * Hploc.M_1_PI;\n        let q = Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 4.0 * q;\n        d -= x * Hploc.PI4_A;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 1) != 0) {\n            d = -d;\n        }\n        return this.sincoshelper(d);\n    }\n    ;\n    static cos(d) {\n        //\t\tlet u = d * Hploc.M_1_PI - 0.5;\n        let u = d * Hploc.M_1_PI - 0.5;\n        //\t\tu -= 0.5;\n        let q = 1 + 2 * Math.floor(u < 0 ? u - 0.5 : u + 0.5);\n        let x = 2.0 * q;\n        let t = x * Hploc.PI4_A;\n        d = d - t;\n        d -= x * Hploc.PI4_B;\n        d -= x * Hploc.PI4_C;\n        if ((q & 2) == 0) {\n            d = -d;\n        }\n        return Hploc.sincoshelper(d);\n    }\n    ;\n    static sincoshelper(d) {\n        let s = d * d;\n        let u = -7.97255955009037868891952e-18;\n        u = u * s + 2.81009972710863200091251e-15;\n        u = u * s - 7.64712219118158833288484e-13;\n        u = u * s + 1.60590430605664501629054e-10;\n        u = u * s - 2.50521083763502045810755e-08;\n        u = u * s + 2.75573192239198747630416e-06;\n        u = u * s - 0.000198412698412696162806809;\n        u = u * s + 0.00833333333333332974823815;\n        u = u * s - 0.166666666666666657414808;\n        return s * u * d + d;\n    }\n    ;\n    /** This method calculates the arc sine of x in radians. The return\n    value is in the range [-pi/2, pi/2]. The results may have\n    maximum error of 3 ulps. */\n    static asin(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.abs(d), Math.sqrt((1 + d) * (1 - d))), d);\n    }\n    ;\n    /** This method calculates the arc cosine of x in radians. The\n        return value is in the range [0, pi]. The results may have\n        maximum error of 3 ulps. */\n    static acos(d) {\n        return Hploc.mulsign(Hploc.atan2k(Math.sqrt((1 + d) * (1 - d)), Math.abs(d)), d) + (d < 0 ? Math.PI : 0);\n    }\n    ;\n    static mulsign(x, y) {\n        let sign = Hploc.copySign(1, y);\n        return sign * x;\n    }\n    ;\n    static copySign(magnitude, sign) {\n        return sign < 0 ? -Math.abs(magnitude) : Math.abs(magnitude);\n        // let finalsign = 1;\n        // if (Object.is(finalsign , -0)){\n        // \tsign = -1;\n        // }else if (Object.is(finalsign , 0)){\n        // \tsign = 1;\n        // }else {\n        // \tsign = Math.sign(finalsign);\n        // }\n        // return finalsign * magnitude;\n    }\n    static atanhelper(s) {\n        let t = s * s;\n        let u = -1.88796008463073496563746e-05;\n        u = u * t + (0.000209850076645816976906797);\n        u = u * t + (-0.00110611831486672482563471);\n        u = u * t + (0.00370026744188713119232403);\n        u = u * t + (-0.00889896195887655491740809);\n        u = u * t + (0.016599329773529201970117);\n        u = u * t + (-0.0254517624932312641616861);\n        u = u * t + (0.0337852580001353069993897);\n        u = u * t + (-0.0407629191276836500001934);\n        u = u * t + (0.0466667150077840625632675);\n        u = u * t + (-0.0523674852303482457616113);\n        u = u * t + (0.0587666392926673580854313);\n        u = u * t + (-0.0666573579361080525984562);\n        u = u * t + (0.0769219538311769618355029);\n        u = u * t + (-0.090908995008245008229153);\n        u = u * t + (0.111111105648261418443745);\n        u = u * t + (-0.14285714266771329383765);\n        u = u * t + (0.199999999996591265594148);\n        u = u * t + (-0.333333333333311110369124);\n        return u * t * s + s;\n    }\n    ;\n    static atan2k(y, x) {\n        let q = 0.;\n        if (x < 0) {\n            x = -x;\n            q = -2.;\n        }\n        if (y > x) {\n            let t = x;\n            x = y;\n            y = -t;\n            q += 1.;\n        }\n        return Hploc.atanhelper(y / x) + q * (Math.PI / 2);\n    }\n    ;\n    /** This method calculates the arc tangent of y/x in radians, using\n    the signs of the two arguments to determine the quadrant of the\n    result. The results may have maximum error of 2 ulps. */\n    static atan2(y, x) {\n        let r = Hploc.atan2k(Math.abs(y), x);\n        r = Hploc.mulsign(r, x);\n        if (Hploc.isinf(x) || x == 0) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI / 2)) : 0);\n        }\n        if (Hploc.isinf(y)) {\n            r = Math.PI / 2 - (Hploc.isinf(x) ? (Hploc.copySign(1, x) * (Math.PI * 1 / 4)) : 0);\n        }\n        if (y == 0) {\n            r = (Hploc.copySign(1, x) == -1 ? Math.PI : 0);\n        }\n        return Hploc.isnan(x) || Hploc.isnan(y) ? NaN : Hploc.mulsign(r, y);\n    }\n    ;\n    /** Checks if the argument is a NaN or not. */\n    static isnan(d) {\n        return d != d;\n    }\n    ;\n    /** Checks if the argument is either positive or negative infinity. */\n    static isinf(d) {\n        return Math.abs(d) === +Infinity;\n    }\n    ;\n}\nHploc.PI4_A = 0.7853981554508209228515625;\nHploc.PI4_B = 0.794662735614792836713604629039764404296875e-8;\nHploc.PI4_C = 0.306161699786838294306516483068750264552437361480769e-16;\nHploc.M_1_PI = 0.3183098861837906715377675267450287;\n//# sourceMappingURL=Hploc.js.map","import { Hploc } from './Hploc.js';\nexport class Pointing {\n    /**\n     *\n     * @param {*} vec3 Vec3.js\n     * @param {*} mirror\n     * @param {*} in_theta radians\n     * @param {*} in_phi radians\n     */\n    constructor(vec3, mirror, in_theta, in_phi) {\n        if (vec3 != null) {\n            this.theta = Hploc.atan2(Math.sqrt(vec3.x * vec3.x + vec3.y * vec3.y), vec3.z);\n            if (mirror) {\n                this.phi = -Hploc.atan2(vec3.y, vec3.x);\n            }\n            else {\n                this.phi = Hploc.atan2(vec3.y, vec3.x);\n            }\n            if (this.phi < 0.0) {\n                this.phi = this.phi + 2 * Math.PI;\n            }\n            if (this.phi >= 2 * Math.PI) {\n                this.phi = this.phi - 2 * Math.PI;\n            }\n        }\n        else {\n            this.theta = in_theta;\n            this.phi = in_phi;\n        }\n    }\n}\n//# sourceMappingURL=Pointing.js.map","/**\n * Partial porting to Javascript of Vec3.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nimport { Pointing } from './Pointing.js';\nexport class Vec3 {\n    constructor(in_x, in_y, in_z) {\n        if (in_x instanceof Pointing) {\n            let ptg = in_x;\n            let sth = Hploc.sin(ptg.theta);\n            this.x = sth * Hploc.cos(ptg.phi);\n            this.y = sth * Hploc.sin(ptg.phi);\n            this.z = Hploc.cos(ptg.theta);\n        }\n        else {\n            this.x = in_x;\n            this.y = in_y;\n            this.z = in_z;\n        }\n    }\n    getX() {\n        return this.x;\n    }\n    ;\n    getY() {\n        return this.y;\n    }\n    ;\n    getZ() {\n        return this.z;\n    }\n    ;\n    /** Scale the vector by a given factor\n    @param n the scale factor */\n    scale(n) {\n        this.x *= n;\n        this.y *= n;\n        this.z *= n;\n    }\n    ;\n    /** Vector cross product.\n    @param v another vector\n    @return the vector cross product between this vector and {@code v} */\n    cross(v) {\n        return new Vec3(this.y * v.z - v.y * this.z, this.z * v.x - v.z * this.x, this.x * v.y - v.x * this.y);\n    }\n    ;\n    /** Vector addition\n        * @param v the vector to be added\n        * @return addition result */\n    add(v) {\n        return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    ;\n    /** Normalize the vector */\n    normalize() {\n        let d = 1. / this.length();\n        this.x *= d;\n        this.y *= d;\n        this.z *= d;\n    }\n    ;\n    /** Return normalized vector */\n    norm() {\n        let d = 1. / this.length();\n        return new Vec3(this.x * d, this.y * d, this.z * d);\n    }\n    ;\n    /** Vector length\n    @return the length of the vector. */\n    length() {\n        return Math.sqrt(this.lengthSquared());\n    }\n    ;\n    /** Squared vector length\n        @return the squared length of the vector. */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    ;\n    /** Computes the dot product of the this vector and {@code v1}.\n     * @param v1 another vector\n     * @return dot product */\n    dot(v1) {\n        return this.x * v1.x + this.y * v1.y + this.z * v1.z;\n    }\n    ;\n    /** Vector subtraction\n     * @param v the vector to be subtracted\n     * @return subtraction result */\n    sub(v) {\n        return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    ;\n    /** Angle between two vectors.\n    @param v1 another vector\n    @return the angle in radians between this vector and {@code v1};\n      constrained to the range [0,PI]. */\n    angle(v1) {\n        return Hploc.atan2(this.cross(v1).length(), this.dot(v1));\n    }\n    /** Invert the signs of all components */\n    flip() {\n        this.x *= -1.0;\n        this.y *= -1.0;\n        this.z *= -1.0;\n    }\n    static pointing2Vec3(pointing) {\n        let sth = Hploc.sin(pointing.theta);\n        let x = sth * Hploc.cos(pointing.phi);\n        let y = sth * Hploc.sin(pointing.phi);\n        let z = Hploc.cos(pointing.theta);\n        return new Vec3(x, y, z);\n    }\n    ;\n}\n//# sourceMappingURL=Vec3.js.map","import { Vec3 } from './Vec3.js';\nexport class CircleFinder {\n    /**\n     * @param point: Vec3\n     */\n    constructor(point) {\n        let np = point.length;\n        //HealpixUtils.check(np>=2,\"too few points\");\n        if (!(np >= 2)) {\n            console.log(\"too few points\");\n            return;\n        }\n        this.center = point[0].add(point[1]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 2; i < np; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle(point, i);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q: int\n     */\n    getCircle(point, q) {\n        this.center = point[0].add(point[q]);\n        this.center.normalize();\n        this.cosrad = point[0].dot(this.center);\n        for (let i = 1; i < q; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.getCircle2(point, i, q);\n            }\n        }\n    }\n    ;\n    /**\n     * @parm point: Vec3\n     * @param q1: int\n     * @param q2: int\n     */\n    getCircle2(point, q1, q2) {\n        this.center = point[q1].add(point[q2]);\n        this.center.normalize();\n        this.cosrad = point[q1].dot(this.center);\n        for (let i = 0; i < q1; ++i) {\n            if (point[i].dot(this.center) < this.cosrad) { // point outside the current circle\n                this.center = (point[q1].sub(point[i])).cross(point[q2].sub(point[i]));\n                this.center.normalize();\n                this.cosrad = point[i].dot(this.center);\n                if (this.cosrad < 0) {\n                    this.center.flip();\n                    this.cosrad = -this.cosrad;\n                }\n            }\n        }\n    }\n    ;\n    getCenter() {\n        return new Vec3(this.center.x, this.center.y, this.center.z);\n    }\n    getCosrad() {\n        return this.cosrad;\n    }\n    ;\n}\n//# sourceMappingURL=CircleFinder.js.map","/**\n * Partial porting to Javascript of Fxyf.java from Healpix3.30\n */\nimport { Hploc } from './Hploc.js';\nexport class Fxyf {\n    constructor(x, y, f) {\n        this.fx = x;\n        this.fy = y;\n        this.face = f;\n        // coordinate of the lowest corner of each face\n        this.jrll = new Uint8Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Uint8Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.halfpi = Math.PI / 2.;\n    }\n    toHploc() {\n        let loc = new Hploc();\n        let jr = this.jrll[this.face] - this.fx - this.fy;\n        let nr;\n        if (jr < 1) {\n            nr = jr;\n            let tmp = nr * nr / 3.;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > 3) {\n            nr = 4 - jr;\n            let tmp = nr * nr / 3.;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2.0 - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = 1;\n            loc.z = (2 - jr) * 2.0 / 3.;\n        }\n        let tmp = this.jpll[this.face] * nr + this.fx - this.fy;\n        if (tmp < 0) {\n            tmp += 8;\n        }\n        if (tmp >= 8) {\n            tmp -= 8;\n        }\n        loc.phi = (nr < 1e-15) ? 0 : (0.5 * this.halfpi * tmp) / nr;\n        return loc;\n    }\n    ;\n    toVec3() {\n        return this.toHploc().toVec3();\n    }\n    ;\n}\n//# sourceMappingURL=Fxyf.js.map","export class pstack {\n    /** Creation from individual components */\n    constructor(sz) {\n        this.p = new Array(sz);\n        this.o = new Int32Array(sz);\n        this.s = 0;\n        this.m = 0;\n    }\n    ;\n    /**\n     * @param p long\n     * @param o int\n     */\n    push(p_, o_) {\n        this.p[this.s] = p_;\n        this.o[this.s] = o_;\n        ++this.s;\n    }\n    ;\n    pop() {\n        --this.s;\n    }\n    ;\n    popToMark() {\n        this.s = this.m;\n    }\n    ;\n    size() {\n        return this.s;\n    }\n    ;\n    mark() {\n        this.m = this.s;\n    }\n    ;\n    otop() {\n        return this.o[this.s - 1];\n    }\n    ;\n    ptop() {\n        return this.p[this.s - 1];\n    }\n    ;\n}\n//# sourceMappingURL=pstack.js.map","export class RangeSet {\n    /**\n     * @param int cap: initial capacity\n     */\n    constructor(cap) {\n        if (cap < 0)\n            console.error(\"capacity must be positive\");\n        this.r = new Int32Array(cap << 1);\n        this.sz = 0;\n    }\n    ;\n    /** Append a single-value range to the object.\n    @param val value to append */\n    append(val) {\n        this.append1(val, val + 1);\n    }\n    ;\n    /** Append a range to the object.\n   @param a first long in range\n   @param b one-after-last long in range */\n    append1(a, b) {\n        if (a >= b)\n            return;\n        if ((this.sz > 0) && (a <= this.r[this.sz - 1])) {\n            if (a < this.r[this.sz - 2])\n                console.error(\"bad append operation\");\n            if (b > this.r[this.sz - 1])\n                this.r[this.sz - 1] = b;\n            return;\n        }\n        // this.ensureCapacity(this.sz+2);\n        let cap = this.sz + 2;\n        if (this.r.length < cap) {\n            let newsize = Math.max(2 * this.r.length, cap);\n            let rnew = new Int32Array(newsize);\n            rnew.set(this.r);\n            this.r = rnew;\n        }\n        this.r[this.sz] = a;\n        this.r[this.sz + 1] = b;\n        this.sz += 2;\n    }\n    ;\n    /** Make sure the object can hold at least the given number of entries.\n     * @param cap int\n     * */\n    ensureCapacity(cap) {\n        if (this.r.length < cap)\n            this.resize(Math.max(2 * this.r.length, cap));\n    }\n    ;\n    /**\n     * @param newsize int\n     */\n    resize(newsize) {\n        if (newsize < this.sz)\n            console.error(\"requested array size too small\");\n        if (newsize == this.r.length)\n            return;\n        let rnew = new Int32Array(newsize);\n        let sliced = this.r.slice(0, this.sz + 1);\n        //\t\tthis.arrayCopy(this.r, 0, rnew, 0, this.sz);\n        this.r = sliced;\n    }\n    ;\n}\n//# sourceMappingURL=RangeSet.js.map","/**\n * Partial porting to Javascript of Xyf.java from Healpix3.30\n */\nexport class Xyf {\n    constructor(x, y, f) {\n        this.ix = x;\n        this.iy = y;\n        this.face = f;\n    }\n}\n//# sourceMappingURL=Xyf.js.map","\"use strict\";\nimport { CircleFinder } from \"./CircleFinder.js\";\nimport { Constants } from \"./Constants.js\";\nimport { Fxyf } from \"./Fxyf.js\";\nimport { Hploc } from \"./Hploc.js\";\nimport { Pointing } from \"./Pointing.js\";\nimport { pstack } from \"./pstack.js\";\nimport { RangeSet } from \"./RangeSet.js\";\nimport { Vec3 } from \"./Vec3.js\";\nimport { Xyf } from \"./Xyf.js\";\nimport { Zphi } from \"./Zphi.js\";\n/**\n * Partial porting to Javascript of HealpixBase.java from Healpix3.30\n */\n// import Fxyf from './Fxyf.js';\n// import Hploc from './Hploc.js';\n// import Xyf from './Xyf.js';\n// import Vec3 from './Vec3.js';\n// import Pointing from './Pointing.js';\n// import CircleFinder from './CircleFinder.js';\n// import Zphi from './Zphi.js';\n// import pstack from './pstack.js';\n// import Constants from './Constants.js';\n// import RangeSet from './RangeSet.js';\nexport class Healpix {\n    constructor(nside_in) {\n        this.order_max = 29;\n        this.inv_halfpi = 2.0 / Math.PI;\n        this.twothird = 2.0 / 3.;\n        // console.log(\"twothird \"+this.twothird);\n        // this.ns_max=1L<<order_max;\n        this.ns_max = Math.pow(2, this.order_max);\n        this.ctab = new Uint16Array([\n            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,\n            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,\n            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,\n            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,\n            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,\n            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,\n            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,\n            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,\n            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,\n            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,\n            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,\n            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,\n            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,\n            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,\n            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,\n            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855\n        ]);\n        this.utab = new Uint16Array([0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,\n            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,\n            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,\n            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,\n            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,\n            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,\n            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,\n            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,\n            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,\n            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,\n            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,\n            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,\n            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,\n            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,\n            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,\n            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,\n            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,\n            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845]);\n        this.jrll = new Int16Array([2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]);\n        this.jpll = new Int16Array([1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7]);\n        this.xoffset = new Int16Array([-1, -1, 0, 1, 1, 1, 0, -1]);\n        this.yoffset = new Int16Array([0, 1, 1, 1, 0, -1, -1, -1]);\n        this.facearray = [\n            new Int16Array([8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9]),\n            new Int16Array([5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8]),\n            new Int16Array([-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1]),\n            new Int16Array([4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10]),\n            new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),\n            new Int16Array([1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4]),\n            new Int16Array([-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1]),\n            new Int16Array([3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7]),\n            new Int16Array([2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]) // N\n        ];\n        // questo forse deve essere un UInt8Array. Viene usato da neighbours\n        this.swaparray = [\n            new Int16Array([0, 0, 3]),\n            new Int16Array([0, 0, 6]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([0, 0, 5]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([5, 0, 0]),\n            new Int16Array([0, 0, 0]),\n            new Int16Array([6, 0, 0]),\n            new Int16Array([3, 0, 0]) // N\n        ];\n        if (nside_in <= this.ns_max && nside_in > 0) {\n            this.nside = nside_in;\n            this.npface = this.nside * this.nside;\n            this.npix = 12 * this.npface;\n            this.order = this.nside2order(this.nside);\n            this.nl2 = 2 * this.nside;\n            this.nl3 = 3 * this.nside;\n            this.nl4 = 4 * this.nside;\n            this.fact2 = 4.0 / this.npix;\n            this.fact1 = (this.nside << 1) * this.fact2;\n            this.ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap\n            // console.log(\"order: \"+this.order);\n            // console.log(\"nside: \"+this.nside);\n        }\n        this.bn = [];\n        this.mpr = [];\n        this.cmpr = [];\n        this.smpr = [];\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // TODO INFINITE LOOP!!!!!! FIX ITTTTTTTTTT\n        // Uncaught RangeError: Maximum call stack size exceeded\n        // MOVED TO computeBn()\n        //        for (let i=0; i <= this.order_max; ++i) {\n        //        \tthis.bn[i]=new Healpix(1<<i);\n        //        \tthis.mpr[i]=bn[i].maxPixrad();\n        //        \tthis.cmpr[i]=Math.cos(mpr[i]);\n        //        \tthis.smpr[i]=Math.sin(mpr[i]);\n        //        }\n    }\n    computeBn() {\n        for (let i = 0; i <= this.order_max; ++i) {\n            this.bn[i] = new Healpix(1 << i);\n            this.mpr[i] = this.bn[i].maxPixrad();\n            this.cmpr[i] = Hploc.cos(this.mpr[i]);\n            this.smpr[i] = Hploc.sin(this.mpr[i]);\n        }\n    }\n    getNPix() {\n        return this.npix;\n    }\n    ;\n    getBoundaries(pix) {\n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        // console.log(\"PIXEL: \"+pix);\n        // console.log(\"XYF \"+xyf.ix+\" \"+xyf.iy+\" \"+xyf.face);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        // let d = 1.0/(this.nside);\n        // console.log(\"------------------------\");\n        // console.log(\"xc, yc, dc \"+xc+\",\"+ yc+\",\"+ dc);\n        // console.log(\"xc+dc-d, yc+dc, xyf.face, d \"+(xc+dc) +\",\"+ (yc+dc)+\",\"+\n        // xyf.face+\",\"+ d);\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        // console.log(\"Points for npix: \"+pix);\n        // console.log(points);\n        // if (pix > 750){\n        // console.log(\"pix: \"+pix);\n        // console.log(\"dc: \"+dc);\n        // console.log(\"xyf.ix: \"+xyf.ix);\n        // console.log(\"xyf.iy: \"+xyf.iy);\n        // console.log(\"xc: \"+xc);\n        // console.log(\"yc: \"+yc);\n        // console.log(\"d: \"+d);\n        // }\n        return points;\n    }\n    ;\n    /** Returns a set of points along the boundary of the given pixel.\n     * Step 1 gives 4 points on the corners. The first point corresponds\n     * to the northernmost corner, the subsequent points follow the pixel\n     * boundary through west, south and east corners.\n     *\n     * @param pix pixel index number\n     * @param step the number of returned points is 4*step\n     * @return {@link Vec3} for each point\n     */\n    getBoundariesWithStep(pix, step) {\n        // var points = new Array(); \n        let points = new Array();\n        let xyf = this.nest2xyf(pix);\n        let dc = 0.5 / this.nside;\n        let xc = (xyf.ix + 0.5) / this.nside;\n        let yc = (xyf.iy + 0.5) / this.nside;\n        let d = 1.0 / (this.nside * step);\n        for (let i = 0; i < step; i++) {\n            points[i] = new Fxyf(xc + dc - i * d, yc + dc, xyf.face).toVec3();\n            points[i + step] = new Fxyf(xc - dc, yc + dc - i * d, xyf.face).toVec3();\n            points[i + 2 * step] = new Fxyf(xc - dc + i * d, yc - dc, xyf.face).toVec3();\n            points[i + 3 * step] = new Fxyf(xc + dc, yc - dc + i * d, xyf.face).toVec3();\n        }\n        return points;\n    }\n    ;\n    getPointsForXyfNoStep(x, y, face) {\n        let nside = Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    getPointsForXyf(x, y, step, face) {\n        let nside = step * Math.pow(2, this.order);\n        let points = new Array();\n        let xyf = new Xyf(x, y, face);\n        let dc = 0.5 / nside;\n        let xc = (xyf.ix + 0.5) / nside;\n        let yc = (xyf.iy + 0.5) / nside;\n        points[0] = new Fxyf(xc + dc, yc + dc, xyf.face).toVec3();\n        points[1] = new Fxyf(xc - dc, yc + dc, xyf.face).toVec3();\n        points[2] = new Fxyf(xc - dc, yc - dc, xyf.face).toVec3();\n        points[3] = new Fxyf(xc + dc, yc - dc, xyf.face).toVec3();\n        return points;\n    }\n    /** Returns the neighboring pixels of ipix.\n    This method works in both RING and NEST schemes, but is\n    considerably faster in the NEST scheme.\n    @param ipix the requested pixel number.\n    @return array with indices of the neighboring pixels.\n      The returned array contains (in this order)\n      the pixel numbers of the SW, W, NW, N, NE, E, SE and S neighbor\n      of ipix. If a neighbor does not exist (this can only happen\n      for the W, N, E and S neighbors), its entry is set to -1. */\n    neighbours(ipix) {\n        let result = new Int32Array(8);\n        let xyf = this.nest2xyf(ipix);\n        let ix = xyf.ix;\n        let iy = xyf.iy;\n        let face_num = xyf.face;\n        var nsm1 = this.nside - 1;\n        if ((ix > 0) && (ix < nsm1) && (iy > 0) && (iy < nsm1)) {\n            let fpix = Math.floor(face_num << (2 * this.order));\n            let px0 = this.spread_bits(ix);\n            let py0 = this.spread_bits(iy) << 1;\n            let pxp = this.spread_bits(ix + 1);\n            let pyp = this.spread_bits(iy + 1) << 1;\n            let pxm = this.spread_bits(ix - 1);\n            let pym = this.spread_bits(iy - 1) << 1;\n            result[0] = fpix + pxm + py0;\n            result[1] = fpix + pxm + pyp;\n            result[2] = fpix + px0 + pyp;\n            result[3] = fpix + pxp + pyp;\n            result[4] = fpix + pxp + py0;\n            result[5] = fpix + pxp + pym;\n            result[6] = fpix + px0 + pym;\n            result[7] = fpix + pxm + pym;\n        }\n        else {\n            for (let i = 0; i < 8; ++i) {\n                let x = ix + this.xoffset[i];\n                let y = iy + this.yoffset[i];\n                let nbnum = 4;\n                if (x < 0) {\n                    x += this.nside;\n                    nbnum -= 1;\n                }\n                else if (x >= this.nside) {\n                    x -= this.nside;\n                    nbnum += 1;\n                }\n                if (y < 0) {\n                    y += this.nside;\n                    nbnum -= 3;\n                }\n                else if (y >= this.nside) {\n                    y -= this.nside;\n                    nbnum += 3;\n                }\n                let f = this.facearray[nbnum][face_num];\n                if (f >= 0) {\n                    let bits = this.swaparray[nbnum][face_num >>> 2];\n                    if ((bits & 1) > 0) {\n                        x = Math.floor(this.nside - x - 1);\n                    }\n                    if ((bits & 2) > 0) {\n                        y = Math.floor(this.nside - y - 1);\n                    }\n                    if ((bits & 4) > 0) {\n                        let tint = x;\n                        x = y;\n                        y = tint;\n                    }\n                    result[i] = this.xyf2nest(x, y, f);\n                }\n                else {\n                    result[i] = -1;\n                }\n            }\n        }\n        return result;\n    }\n    ;\n    nside2order(nside) {\n        return ((nside & (nside - 1)) != 0) ? -1 : Math.log2(nside);\n    }\n    ;\n    nest2xyf(ipix) {\n        let pix = Math.floor(ipix & (this.npface - 1));\n        let xyf = new Xyf(this.compress_bits(pix), this.compress_bits(pix >> 1), Math.floor((ipix >> (2 * this.order))));\n        return xyf;\n    }\n    ;\n    xyf2nest(ix, iy, face_num) {\n        return Math.floor(face_num << (2 * this.order))\n            + this.spread_bits(ix) + (this.spread_bits(iy) << 1);\n    }\n    ;\n    loc2pix(hploc) {\n        let z = hploc.z;\n        let phi = hploc.phi;\n        let za = Math.abs(z);\n        let tt = this.fmodulo((phi * this.inv_halfpi), 4.0); // in [0,4)\n        let pixNo;\n        if (za <= this.twothird) { // Equatorial region\n            let temp1 = this.nside * (0.5 + tt);\n            let temp2 = this.nside * (z * 0.75);\n            let jp = Math.floor(temp1 - temp2); // index of ascending edge line\n            let jm = Math.floor(temp1 + temp2); // index of descending edge line\n            let ifp = Math.floor(jp >>> this.order); // in {0,4}\n            let ifm = Math.floor(jm >>> this.order);\n            let face_num = Math.floor((ifp == ifm) ? (ifp | 4) : ((ifp < ifm) ? ifp : (ifm + 8)));\n            let ix = Math.floor(jm & (this.nside - 1));\n            let iy = Math.floor(this.nside - (jp & (this.nside - 1)) - 1);\n            pixNo = this.xyf2nest(ix, iy, face_num);\n        }\n        else { // polar region, za > 2/3\n            let ntt = Math.min(3, Math.floor(tt));\n            let tp = tt - ntt;\n            let tmp = ((za < 0.99) || (!hploc.have_sth)) ?\n                this.nside * Math.sqrt(3 * (1 - za)) :\n                this.nside * hploc.sth / Math.sqrt((1.0 + za) / 3.);\n            let jp = Math.floor(tp * tmp); // increasing edge line index\n            let jm = Math.floor((1.0 - tp) * tmp); // decreasing edge line index\n            if (jp >= this.nside) {\n                jp = this.nside - 1; // for points too close to the boundary\n            }\n            if (jm >= this.nside) {\n                jm = this.nside - 1;\n            }\n            if (z >= 0) {\n                pixNo = this.xyf2nest(Math.floor(this.nside - jm - 1), Math.floor(this.nside - jp - 1), ntt);\n            }\n            else {\n                pixNo = this.xyf2nest(Math.floor(jp), Math.floor(jm), ntt + 8);\n            }\n        }\n        return pixNo;\n    }\n    ;\n    /** Returns the normalized 3-vector corresponding to the center of the\n    supplied pixel.\n    @param pix long the requested pixel number.\n    @return the pixel's center coordinates. */\n    pix2vec(pix) {\n        return this.pix2loc(pix).toVec3();\n    }\n    ;\n    /** Returns the Zphi corresponding to the center of the supplied pixel.\n     @param pix the requested pixel number.\n     @return the pixel's center coordinates. */\n    pix2zphi(pix) {\n        return this.pix2loc(pix).toZphi();\n    }\n    /**\n     * @param pix long\n     * @return Hploc\n     */\n    pix2loc(pix) {\n        let loc = new Hploc(undefined);\n        let xyf = this.nest2xyf(pix);\n        let jr = ((this.jrll[xyf.face]) << this.order) - xyf.ix - xyf.iy - 1;\n        let nr;\n        if (jr < this.nside) {\n            nr = jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = 1 - tmp;\n            if (loc.z > 0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else if (jr > this.nl3) {\n            nr = this.nl4 - jr;\n            let tmp = (nr * nr) * this.fact2;\n            loc.z = tmp - 1;\n            if (loc.z < -0.99) {\n                loc.sth = Math.sqrt(tmp * (2. - tmp));\n                loc.have_sth = true;\n            }\n        }\n        else {\n            nr = this.nside;\n            loc.z = (this.nl2 - jr) * this.fact1;\n        }\n        let tmp = (this.jpll[xyf.face]) * nr + xyf.ix - xyf.iy;\n        //      \tassert(tmp<8*nr); // must not happen\n        if (tmp < 0) {\n            tmp += 8 * nr;\n        }\n        loc.phi = (nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp) / nr;\n        // loc.setPhi((nr == this.nside) ? 0.75 * Constants.halfpi * tmp * this.fact1 : (0.5 * Constants.halfpi * tmp)/nr);\n        return loc;\n    }\n    ;\n    ang2pix(ptg, mirror) {\n        return this.loc2pix(new Hploc(ptg));\n    }\n    ;\n    fmodulo(v1, v2) {\n        if (v1 >= 0) {\n            return (v1 < v2) ? v1 : v1 % v2;\n        }\n        var tmp = v1 % v2 + v2;\n        return (tmp === v2) ? 0.0 : tmp;\n    }\n    ;\n    compress_bits(v) {\n        var raw = Math.floor((v & 0x5555)) | Math.floor(((v & 0x55550000) >>> 15));\n        var compressed = this.ctab[raw & 0xff] | (this.ctab[raw >>> 8] << 4);\n        return compressed;\n    }\n    ;\n    spread_bits(v) {\n        return Math.floor(this.utab[v & 0xff]) | Math.floor((this.utab[(v >>> 8) & 0xff] << 16))\n            | Math.floor((this.utab[(v >>> 16) & 0xff] << 32)) | Math.floor((this.utab[(v >>> 24) & 0xff] << 48));\n    }\n    ;\n    /**\n     * Returns a range set of pixels that overlap with the convex polygon\n     * defined by the {@code vertex} array.\n     * <p>\n     * This method is more efficient in the RING scheme.\n     * <p>\n     * This method may return some pixels which don't overlap with the polygon\n     * at all. The higher {@code fact} is chosen, the fewer false positives are\n     * returned, at the cost of increased run time.\n     *\n     * @param vertex\n     *            an array containing the vertices of the requested convex\n     *            polygon.\n     * @param fact\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return the requested set of pixel number ranges\n     */\n    queryPolygonInclusive(vertex, fact) {\n        let inclusive = (fact != 0);\n        let nv = vertex.length;\n        //        let ncirc = inclusive ? nv+1 : nv;\n        if (!(nv >= 3)) {\n            console.log(\"not enough vertices in polygon\");\n            return;\n        }\n        let vv = new Array();\n        for (let i = 0; i < nv; ++i) {\n            vv[i] = Vec3.pointing2Vec3(vertex[i]);\n        }\n        let normal = new Array();\n        let flip = 0;\n        let index = 0;\n        let back = false;\n        while (index < vv.length) {\n            let first = vv[index];\n            let medium = null;\n            let last = null;\n            if (index == vv.length - 1) {\n                last = vv[1];\n                medium = vv[0];\n            }\n            else if (index == vv.length - 2) {\n                last = vv[0];\n                medium = vv[index + 1];\n            }\n            else {\n                medium = vv[index + 1];\n                last = vv[index + 2];\n            }\n            normal[index] = first.cross(medium).norm();\n            let hnd = normal[index].dot(last);\n            if (index == 0) {\n                flip = (hnd < 0.) ? -1 : 1;\n                let tmp = new Pointing(first); // TODO not used\n                back = false;\n            }\n            else {\n                let flipThnd = flip * hnd;\n                if (flipThnd < 0) {\n                    let tmp = new Pointing(medium);\n                    vv.splice(index + 1, 1);\n                    normal.splice(index, 1);\n                    back = true;\n                    index -= 1;\n                    continue;\n                }\n                else {\n                    let tmp = new Pointing(first);\n                    back = false;\n                }\n            }\n            normal[index].scale(flip);\n            index += 1;\n        }\n        nv = vv.length;\n        let ncirc = inclusive ? nv + 1 : nv;\n        let rad = new Array(ncirc);\n        rad = rad.fill(Constants.halfpi);\n        //        rad = rad.fill(1.5707963267948966);\n        //        let p = \"1.5707963267948966\";\n        //        rad = rad.fill(parseFloat(p));\n        if (inclusive) {\n            let cf = new CircleFinder(vv);\n            normal[nv] = cf.getCenter();\n            rad[nv] = Hploc.acos(cf.getCosrad());\n        }\n        return this.queryMultiDisc(normal, rad, fact);\n    }\n    ;\n    /**\n     * For NEST schema only\n     *\n     * @param normal:\n     *            Vec3[]\n     * @param rad:\n     *            Float32Array\n     * @param fact:\n     *            The overlapping test will be done at the resolution\n     *            {@code fact*nside}. For NESTED ordering, {@code fact} must be\n     *            a power of 2, else it can be any positive integer. A typical\n     *            choice would be 4.\n     * @return RangeSet the requested set of pixel number ranges\n     */\n    queryMultiDisc(norm, rad, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let nv = norm.length;\n        // HealpixUtils.check(nv==rad.lengt0,\"inconsistent input arrays\");\n        if (!(nv == rad.length)) {\n            console.error(\"inconsistent input arrays\");\n            return;\n        }\n        let res = new RangeSet(4 << 1);\n        // Removed code for Scheme.RING\n        let oplus = 0;\n        if (inclusive) {\n            if (!(Math.pow(2, this.order_max - this.order) >= fact)) {\n                console.error(\"invalid oversampling factor\");\n            }\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = this.order + oplus; // the order up to which we test\n        // TODO: ignore all disks with radius>=pi\n        //        let crlimit = new Float32Array[omax+1][nv][3];\n        let crlimit = new Array(omax + 1);\n        let o;\n        let i;\n        for (o = 0; o <= omax; ++o) { // prepare data at the required orders\n            crlimit[o] = new Array(nv);\n            let dr = this.bn[o].maxPixrad(); // safety distance\n            for (i = 0; i < nv; ++i) {\n                crlimit[o][i] = new Float64Array(3);\n                crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Hploc.cos(rad[i] + dr);\n                crlimit[o][i][1] = (o == 0) ? Hploc.cos(rad[i]) : crlimit[0][i][1];\n                crlimit[o][i][2] = (rad[i] - dr < 0.) ? 1. : Hploc.cos(rad[i] - dr);\n            }\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse\n            // order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let o = stk.otop();\n            stk.pop();\n            let pv = this.bn[o].pix2vec(pix);\n            let zone = 3;\n            for (let i = 0; (i < nv) && (zone > 0); ++i) {\n                let crad = pv.dot(norm[i]);\n                for (let iz = 0; iz < zone; ++iz) {\n                    if (crad < crlimit[o][i][iz]) {\n                        zone = iz;\n                    }\n                }\n            }\n            if (zone > 0) {\n                this.check_pixel(o, omax, zone, res, pix, stk, inclusive);\n            }\n        }\n        return res;\n    }\n    ;\n    /** Integer base 2 logarithm.\n    @param arg\n    @return the largest integer {@code n} that fulfills {@code 2^n<=arg}.\n    For negative arguments and zero, 0 is returned. */\n    ilog2(arg) {\n        let max = Math.max(arg, 1);\n        return 31 - Math.clz32(max);\n    }\n    ;\n    /** Computes the cosine of the angular distance between two z, phi positions\n      on the unit sphere. */\n    cosdist_zphi(z1, phi1, z2, phi2) {\n        return z1 * z2 + Hploc.cos(phi1 - phi2) * Math.sqrt((1.0 - z1 * z1) * (1.0 - z2 * z2));\n    }\n    /**\n     * @param int o\n     * @param int omax\n     * @param int zone\n     * @param RangeSet pixset\n     * @param long pix\n     * @param pstack stk\n     * @param boolean inclusive\n     */\n    check_pixel(o, omax, zone, pixset, pix, stk, inclusive) {\n        if (zone == 0)\n            return;\n        if (o < this.order) {\n            if (zone >= 3) { // output all subpixels\n                let sdist = 2 * (this.order - o); // the \"bit-shift distance\" between map orders\n                pixset.append1(pix << sdist, ((pix + 1) << sdist));\n            }\n            else { // (zone>=1)\n                for (let i = 0; i < 4; ++i) {\n                    stk.push(4 * pix + 3 - i, o + 1); // add children\n                }\n            }\n        }\n        else if (o > this.order) { // this implies that inclusive==true\n            if (zone >= 2) { // pixel center in shape\n                pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                stk.popToMark(); // unwind the stack\n            }\n            else { // (zone>=1): pixel center in safety range\n                if (o < omax) { // check sublevels\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix >>> (2 * (o - this.order))); // output the parent pixel at order\n                    stk.popToMark(); // unwind the stack\n                }\n            }\n        }\n        else { // o==order\n            if (zone >= 2) {\n                pixset.append(pix);\n            }\n            else if (inclusive) { // and (zone>=1)\n                if (this.order < omax) { // check sublevels\n                    stk.mark(); // remember current stack position\n                    for (let i = 0; i < 4; ++i) { // add children in reverse order\n                        stk.push(4 * pix + 3 - i, o + 1); // add children\n                    }\n                }\n                else { // at resolution limit\n                    pixset.append(pix); // output the pixel\n                }\n            }\n        }\n    }\n    /** Returns the maximum angular distance between a pixel center and its\n    corners.\n    @return maximum angular distance between a pixel center and its\n      corners. */\n    maxPixrad() {\n        let zphia = new Zphi(2. / 3., Math.PI / this.nl4);\n        let xyz1 = this.convertZphi2xyz(zphia);\n        let va = new Vec3(xyz1[0], xyz1[1], xyz1[2]);\n        let t1 = 1. - 1. / this.nside;\n        t1 *= t1;\n        let zphib = new Zphi(1 - t1 / 3, 0);\n        let xyz2 = this.convertZphi2xyz(zphib);\n        let vb = new Vec3(xyz2[0], xyz2[1], xyz2[2]);\n        return va.angle(vb);\n    }\n    ;\n    /**\n     * this is a workaround replacing the Vec3(Zphi) constructor.\n     */\n    convertZphi2xyz(zphi) {\n        let sth = Math.sqrt((1.0 - zphi.z) * (1.0 + zphi.z));\n        let x = sth * Hploc.cos(zphi.phi);\n        let y = sth * Hploc.sin(zphi.phi);\n        let z = zphi.z;\n        return [x, y, z];\n    }\n    ;\n    /** Returns a range set of pixels which overlap with a given disk. <p>\n      This method is more efficient in the RING scheme. <p>\n      This method may return some pixels which don't overlap with\n      the polygon at all. The higher {@code fact} is chosen, the fewer false\n      positives are returned, at the cost of increased run time.\n      @param ptg the angular coordinates of the disk center\n      @param radius the radius (in radians) of the disk\n      @param fact The overlapping test will be done at the resolution\n        {@code fact*nside}. For NESTED ordering, {@code fact} must be a power\n        of 2, else it can be any positive integer. A typical choice would be 4.\n      @return the requested set of pixel number ranges  */\n    queryDiscInclusive(ptg, radius, fact) {\n        this.computeBn();\n        let inclusive = (fact != 0);\n        let pixset = new RangeSet();\n        if (radius >= Math.PI) { // disk covers the whole sphere\n            pixset.append1(0, this.npix);\n            return pixset;\n        }\n        let oplus = 0;\n        if (inclusive) {\n            // HealpixUtils.check ((1L<<order_max)>=fact,\"invalid oversampling factor\");\n            if (!((fact & (fact - 1)) == 0)) {\n                console.error(\"oversampling factor must be a power of 2\");\n            }\n            oplus = this.ilog2(fact);\n        }\n        let omax = Math.min(this.order_max, this.order + oplus); // the order up to which we test\n        let vptg = Vec3.pointing2Vec3(ptg);\n        let crpdr = new Array(omax + 1);\n        let crmdr = new Array(omax + 1);\n        let cosrad = Hploc.cos(radius);\n        let sinrad = Hploc.sin(radius);\n        for (let o = 0; o <= omax; o++) { // prepare data at the required orders\n            let dr = this.mpr[o]; // safety distance\n            let cdr = this.cmpr[o];\n            let sdr = this.smpr[o];\n            crpdr[o] = (radius + dr > Math.PI) ? -1. : cosrad * cdr - sinrad * sdr;\n            crmdr[o] = (radius - dr < 0.) ? 1. : cosrad * cdr + sinrad * sdr;\n        }\n        let stk = new pstack(12 + 3 * omax);\n        for (let i = 0; i < 12; i++) { // insert the 12 base pixels in reverse order\n            stk.push(11 - i, 0);\n        }\n        while (stk.size() > 0) { // as long as there are pixels on the stack\n            // pop current pixel number and order from the stack\n            let pix = stk.ptop();\n            let curro = stk.otop();\n            stk.pop();\n            let pos = this.bn[curro].pix2zphi(pix);\n            // cosine of angular distance between pixel center and disk center\n            let cangdist = this.cosdist_zphi(vptg.z, ptg.phi, pos.z, pos.phi);\n            if (cangdist > crpdr[curro]) {\n                let zone = (cangdist < cosrad) ? 1 : ((cangdist <= crmdr[curro]) ? 2 : 3);\n                this.check_pixel(curro, omax, zone, pixset, pix, stk, inclusive);\n            }\n        }\n        return pixset;\n    }\n}\n//# sourceMappingURL=Healpix.js.map","import { Healpix, Hploc, Pointing } from \"healpixjs\";\nimport { AstroCoords } from \"../../model/AstroCoords.js\";\nimport { HEALPixXYSpace } from \"../../model/HEALPixXYSpace.js\";\nimport { CoordsType } from \"../../model/CoordsType.js\";\nimport { NumberType } from \"../../model/NumberType.js\";\nimport { Point } from \"../../model/Point.js\";\nimport { radToDeg } from \"../../model/Utils.js\";\n\n\nexport class HiPSIntermediateProj {\n\n    static RES_ORDER_0: number = 58.6;\n    static H: number = 4;\n    static K: number = 3;\n    static THETAX: number = Hploc.asin((HiPSIntermediateProj.K - 1) / HiPSIntermediateProj.K);\n\n\n    static setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n    \n            let xyGridProj: HEALPixXYSpace = {\n                \"min_y\": NaN,\n                \"max_y\": NaN,\n                \"min_x\": NaN,\n                \"max_x\": NaN,\n                \"gridPointsDeg\": []\n            }\n    \n    \n            let cornersVec3 = hp.getBoundariesWithStep(tileno, 1);\n            let pointings = [];\n    \n            for (let i = 0; i < cornersVec3.length; i++) {\n                pointings[i] = new Pointing(cornersVec3[i]);\n                if (i >= 1) {\n                    let a = pointings[i - 1].phi;\n                    let b = pointings[i].phi;\n                    // case when RA is just crossing the origin (e.g. 357deg - 3deg)\n                    if (Math.abs(a - b) > Math.PI) {\n                        if (pointings[i - 1].phi < pointings[i].phi) {\n                            pointings[i - 1].phi += 2 * Math.PI;\n                        } else {\n                            pointings[i].phi += 2 * Math.PI;\n                        }\n                    }\n                }\n            }\n    \n            for (let j = 0; j < pointings.length; j++) {\n                let coThetaRad = pointings[j].theta;\n                // HEALPix works with colatitude (0 North Pole, 180 South Pole)\n                // converting the colatitude in latitude (dec)\n                let decRad = Math.PI / 2 - coThetaRad;\n    \n                let raRad = pointings[j].phi;\n    \n                // projection on healpix grid\n                let p = new Point(CoordsType.ASTRO, NumberType.RADIANS, raRad, decRad);\n                let xyDeg = HiPSIntermediateProj.world2intermediate(p.getAstro());\n                xyGridProj.gridPointsDeg[j * 2] = xyDeg[0];\n                xyGridProj.gridPointsDeg[j * 2 + 1] = xyDeg[1];\n    \n                if (isNaN(xyGridProj.max_y) || xyDeg[1] > xyGridProj.max_y) {\n                    xyGridProj.max_y = xyDeg[1];\n                }\n                if (isNaN(xyGridProj.min_y) || xyDeg[1] < xyGridProj.min_y) {\n                    xyGridProj.min_y = xyDeg[1];\n                }\n                if (isNaN(xyGridProj.max_x) || xyDeg[0] > xyGridProj.max_x) {\n                    xyGridProj.max_x = xyDeg[0];\n                }\n                if (isNaN(xyGridProj.min_x) || xyDeg[0] < xyGridProj.min_x) {\n                    xyGridProj.min_x = xyDeg[0];\n                }\n    \n            }\n            return xyGridProj;\n        }\n\n    static world2intermediate(ac: AstroCoords): [number, number] {\n        let x_grid: number = NaN;\n        let y_grid: number = NaN;\n\n        if (Math.abs(ac.decRad) <= HiPSIntermediateProj.THETAX) { // equatorial belts\n            x_grid = ac.raDeg;\n\n            y_grid = Hploc.sin(ac.decRad) * HiPSIntermediateProj.K * 90 / HiPSIntermediateProj.H;\n\n\n        } else if (Math.abs(ac.decRad) > HiPSIntermediateProj.THETAX) { // polar zones\n\n            let raDeg = ac.raDeg;\n\n            let w = 0; // omega\n            if (HiPSIntermediateProj.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0\n                w = 1;\n            }\n\n            let sigma = Math.sqrt(HiPSIntermediateProj.K * (1 - Math.abs(Hploc.sin(ac.decRad))));\n            let phi_c = - 180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSIntermediateProj.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSIntermediateProj.H);\n\n            x_grid = phi_c + (raDeg - phi_c) * sigma;\n            y_grid = (180 / HiPSIntermediateProj.H) * (((HiPSIntermediateProj.K + 1) / 2) - sigma);\n\n            if (ac.decRad < 0) {\n                y_grid *= -1;\n            }\n        }\n\n        return [x_grid, y_grid];\n    }\n\n    static intermediate2pix(x: number, y: number, xyGridProj: HEALPixXYSpace, pxXtile: number): [number, number] {\n        let xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);\n        let yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);\n\n        let i_norm: number;\n        let j_norm: number;\n        if ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {\n            i_norm = (x + 360 - xyGridProj.min_x) / xInterval;\n        } else {\n            i_norm = (x - xyGridProj.min_x) / xInterval;\n        }\n        j_norm = (y - xyGridProj.min_y) / yInterval;\n\n\n        let i = 0.5 - (i_norm - j_norm);\n        let j = (i_norm + j_norm) - 0.5;\n\n        // TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);\n        // pxXtile\n        // i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);\n        // j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);\n        // return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];\n\n        i = Math.floor(i * pxXtile);\n        j = Math.floor(j * pxXtile);\n        return [i, pxXtile - j - 1];\n    }\n\n    static pix2intermediate(i: number, j: number, xyGridProj: HEALPixXYSpace, naxis1: number, naxis2: number): [number, number] {\n        /**\n                   * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image\n                 * (i_norm,w_pixel) = (1,1) is the upper right corner\n                 * dimamond in figure 1 from \"Mapping on the HEalpix grid\" paper\n                 * (0,0) leftmost corner\n                 * (1,0) upper corner\n                 * (0,1) lowest corner\n                 * (1,1) rightmost corner\n                 * Thanks YAGO! :p\n                 */\n        // let cnaxis1 = HiPSHelper.pxXtile;\n        // let cnaxis2 = HiPSHelper.pxXtile;\n\n        let cnaxis1 = naxis1;\n        let cnaxis2 = naxis2;\n        if (naxis1) {\n            cnaxis1 = naxis1;\n        }\n        if (naxis2) {\n            cnaxis2 = naxis2;\n        }\n        const i_norm = (i + 0.5) / cnaxis1;\n        const j_norm = (j + 0.5) / cnaxis2;\n\n        const xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;\n        const yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;\n        const yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;\n\n        // bi-linear interpolation\n        const x = xyGridProj.max_x - xInterval * (i_norm + j_norm);\n        const y = yMean - yInterval * (j_norm - i_norm);\n\n        return [x, y];\n    }\n\n    static intermediate2world(x: number, y: number): Point {\n        \n        let phiDeg: number = NaN\n        let thetaDeg: number = NaN\n        const Yx = 90 * (HiPSIntermediateProj.K - 1) / HiPSIntermediateProj.H\n\n\n\n        if (Math.abs(y) <= Yx) { // equatorial belts\n\n            phiDeg = x\n            thetaDeg = radToDeg(Math.asin((y * HiPSIntermediateProj.H) / (90 * HiPSIntermediateProj.K)))\n\n        } else if (Math.abs(y) > Yx) { // polar regions\n\n            const sigma = (HiPSIntermediateProj.K + 1) / 2 - Math.abs(y * HiPSIntermediateProj.H) / 180\n            const thetaRad = Hploc.asin(1 - (sigma * sigma) / HiPSIntermediateProj.K)\n            let w = 0 // omega\n            if (HiPSIntermediateProj.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0\n                w = 1\n            }\n            const x_c = -180 + (2 * Math.floor((x + 180) * HiPSIntermediateProj.H / 360 + (1 - w) / 2) + w) * (180 / HiPSIntermediateProj.H)\n            phiDeg = x_c + (x - x_c) / sigma\n            thetaDeg = radToDeg(thetaRad)\n            if (y <= 0) {\n                thetaDeg *= -1\n            }\n        }\n        // return [phiDeg, thetaDeg];\n        // TODO CHECK THIS!\n        // let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);\n        const p = new Point(CoordsType.ASTRO, NumberType.DEGREES, phiDeg, thetaDeg);\n\n        return p;\n    }\n\n}","\n/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\nimport { Healpix } from 'healpixjs';\nimport { Pointing } from \"healpixjs\";\nimport { Hploc } from \"healpixjs\";\n\nimport { radToDeg } from '../model/Utils.js'; // TODO change package\nimport { CoordsType } from \"../model/CoordsType.js\";\nimport { HEALPixXYSpace } from \"../model/HEALPixXYSpace.js\";\nimport { Point } from \"../model/Point.js\";\nimport { NumberType } from '../model/NumberType.js';\nimport { AstroCoords } from \"../model/AstroCoords.js\";\n\nexport class HiPSHelper {\n\n\n\t// static pxXtile: number = 512; // TODO in some cases it is different\n\tstatic DEFAULT_Naxis1_2: number = 512;\n\t// static RES_ORDER_0: number = 58.6 / HiPSHelper.pxXtile;\n\tstatic RES_ORDER_0: number = 58.6;\n\tstatic H: number = 4;\n\tstatic K: number = 3;\n\tstatic THETAX: number = Hploc.asin((HiPSHelper.K - 1) / HiPSHelper.K);\n\t/**\n\t * Table 1 - ref paper HEALPix  a Framework for High Resolution Discretization,\n\t * and Fast Analysis of Data Distributed on the Sphere\n\t * K. M. Gorski1,2, E. Hivon3,4, A. J. Banday5, B. D. Wandelt6,7, F. K. Hansen8, M.\n\t * Reinecke5, M. Bartelman9\n\t */\n\t/**\n\t * \n\t * @param {decimal degrees} pxsize \n\t * @returns {int} nside\n\t */\n\t// static computeHiPSOrder(pxsize: number, pxXtile: number): number {\n\t// \t/**\n\t// \t * with same order k (table 1), HIPS angular resolution is higher of order of 512 (2^9) pixels than \n\t// \t * the HEALPix. This is because each tile in a HiPS is represented by default by 512x512 pixels.\\\n\t// \t * Angular resolution of different HEALPix orders in respect to the order 0, can be calculated this\n\t// \t * way:\n\t// \t * \n\t// \t * \tL(k) = L(0) / 2^k = 58.6 / 2^k\n\t// \t * \n\t// \t * Therefore, in the case of HiPS we need to take into account the extra resolution given by the \n\t// \t * 512x512 (2^9) tiles. In this case the above becomes:\n\t// \t * \t\n\t// \t * \tL(k) = L(0) / (2^k * 2^9) \n\t// \t * \n\t// \t * Though, in order to compute the required order starting from the pxsize desired (in input) we\n\t// \t * need to perform these steps:\n\t// \t * \n\t// \t * \tpxsize = L(k) = L(0) / (2^k * 2^9)\n\t// \t * \t2^k = L(0) / (pxsize * 2^9)\n\t// \t *  k * Log2 2 = Log2 L(0) - Log2 (pxsize * 2^9)\n\t// \t * \tk = Log2 L(0) - Log2 (pxsize * 2^9)\n\t// \t * \n\t// \t */\n\n\n\t// \tlet k = Math.log2( (HiPSHelper.RES_ORDER_0 / pxXtile) / pxsize);\n\t// \t// let k = Math.log2(HiPSHelper.RES_ORDER_0 / (pxXtile * pxsize));\n\t// \tk = Math.round(k);\n\t// \t// let theta0px = HiPSHelper.RES_ORDER_0;\n\t// \t// let k = Math.log2(theta0px) - Math.log2(pxsize * 2**9);\n\t// \t// k = Match.round(k);\n\t// \t// let nside = 2**k;\n\t// \t// return {\n\t// \t//     \"nside\" : nside,\n\t// \t//     \"norder\" : k\n\t// \t// };\n\t// \treturn k;\n\n\t// }\n\n\t// static computeHiPSOrder2(pxsize: number, pxXtile: number): number {\n\t\t\n\t// \tconst k = Math.log2( Math.sqrt(Math.PI/ 3) / ( pxsize * pxXtile) )\n\t// \tconst order = Math.round(k);\n\t// \tconsole.warn(k)\n \n\t// \treturn order;\n\n\t// }\n\n\n\t// based on \"HiPS  Hierarchical Progressive Survey\" IVOA recomandation (formula on table 5)\n\tstatic computeOrder(pxAngSizeDeg: number, pxTileWidth: number): number {\n\t\tconsole.log(`Computing HiPS order having pixel angular size of ${pxAngSizeDeg} in degrees`)\n\t\tconst deg2rad = Math.PI / 180\n\t\tconst pxAngSizeRad = pxAngSizeDeg * deg2rad\n\t\tconsole.log(`pixel angular res in radians ${pxAngSizeRad}`)\n\t\tconst computedOrder = 0.5 * Math.log2 ( Math.PI / (3 * pxAngSizeRad * pxAngSizeRad * pxTileWidth * pxTileWidth) )\n\t\tconsole.log(`Order ${computedOrder}`)\n\t\tif (computedOrder < 0) {\n\t\t\treturn 0\n\t\t}\n\t\treturn Math.floor(computedOrder)\n\t}\n\n\tstatic getHelpixByOrder(order: number): Healpix {\n\t\tconst nside = 2 ** order\n        const healpix = new Healpix(nside)\n\t\treturn healpix\n\t}\n\n\tstatic getHelpixBypxAngSize(pixelAngulaSize: number, TILE_WIDTH: number, hipsMaxOrder: number | null = null): Healpix {\n\t\tlet healpixOrder = HiPSHelper.computeOrder(pixelAngulaSize, TILE_WIDTH)\n\t\tif (hipsMaxOrder && hipsMaxOrder > 0) {\n\t\t\tif (healpixOrder > hipsMaxOrder) {\n\t\t\t\thealpixOrder = hipsMaxOrder\n\t\t\t}\n\t\t}\n        const nside = 2 ** healpixOrder\n        const healpix = new Healpix(nside)\n\t\treturn healpix\n\t}\n\n\t// based on \"HiPS  Hierarchical Progressive Survey\" IVOA recomandation (formula on table 5)\n\tstatic computePxAngularSize(pxTileWidth: number, order: number) {\n\t\tconst computedPxAngSizeRadiant = Math.sqrt( 4 * Math.PI / (12 * (pxTileWidth * (2**order) )**2 ) )\n\t\tconsole.log(`Computing Pixel size with tile of ${pxTileWidth} pixels and order ${order}`)\n\t\tconst rad2deg = 180 / Math.PI\n\t\tconst deg = computedPxAngSizeRadiant * rad2deg\n\t\tconst arcmin = computedPxAngSizeRadiant * rad2deg * 60\n\t\tconst arcsec = computedPxAngSizeRadiant * rad2deg * 3600\n\t\tconsole.log (\"Pixel size in radiant:\" + computedPxAngSizeRadiant)\n\t\tconsole.log (\"Pixel size in degrees:\" + deg)\n\t\tconsole.log (\"Pixel size in arcmin:\" + arcmin)\n\t\tconsole.log (\"Pixel size in arcsec:\" + arcsec)\n\t\treturn {\n\t\t\t\"rad\": computedPxAngSizeRadiant,\n\t\t\t\"deg\": deg,\n\t\t\t\"arcmin\": arcmin,\n\t\t\t\"arcsec\": arcsec\n\t\t}\n\t}\n\n\n\t/**\n\t * Reference: HiPS  Hierarchical Progressive Survey page 11\n\t * pxsize =~ sqrt[4 * PI / (12 * (512 * 2^order)^2)]\n\t * @param {*} order \n\t */\n\tstatic computePxSize(order: number, pxXtile: number): number {\n\t\t// TODO CHECK IT\n\t\t// let pxsize = 1 / (512 * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\tlet pxsize = 1 / (pxXtile * 2 ** order) * Math.sqrt(Math.PI / 3);\n\t\treturn pxsize;\n\t}\n\n\t// /**\n\t//  * \n\t//  * @param {Object {ra, dec}} point  decimal degrees\n\t//  * @returns {Object {phi_rad, theta_rad}} in radians\n\t//  */\n\t// static convert2PhiTheta (point: Point) {\n\t// \tlet phitheta_rad = {};\n\t// \tlet phiTheta_deg = HiPSHelper.astroDegToSpherical(point.ra, point.dec);\n\t// \tphitheta_rad.phi_rad = HiPSHelper.degToRad(phiTheta_deg.phi);\n\t//     phitheta_rad.theta_rad = HiPSHelper.degToRad(phiTheta_deg.theta);\n\t// \treturn phitheta_rad;\n\t// }\n\n\t// static astroDegToSphericalRad(raDeg: number, decDeg: number) {\n\t// \tlet phiThetaDeg = HiPSHelper.astroDegToSpherical(raDeg, decDeg);\n\t// \tlet phiThetaRad = {\n\t// \t\tphi_rad: HiPSHelper.degToRad(phiThetaDeg.phi),\n\t// \t\ttheta_rad: HiPSHelper.degToRad(phiThetaDeg.theta)\n\t// \t}\n\t// \treturn phiThetaRad;\n\t// }\n\n\t// static degToRad(degrees: number): number {\n\t// \treturn (degrees / 180 ) * Math.PI ;\n\t// }\n\n\t// static radToDeg(rad: number): number {\n\t// \treturn (rad / Math.PI ) * 180 ;\n\t// }\n\n\t// static astroDegToSpherical(raDeg: number, decDeg: number): Point{\n\n\t// \tlet phiDeg: number;\n\t// \tlet thetaDeg: number;\n\t// \tphiDeg = raDeg;\n\t// \tif (phiDeg < 0){\n\t// \t\tphiDeg += 360;\n\t// \t}\n\n\t// \tthetaDeg = 90 - decDeg;\n\n\t// \treturn {\n\t// \t\tphi: phiDeg,\n\t// \t\ttheta: thetaDeg\n\t// \t};\n\t// }\n\n\t/**\n\t * \n\t * @param {Object {phi_rad, theta_rad}} phiTheta_rad Center of the circle in radians\n\t * @param {decimal} r Radius of the circle in radians\n\t * @returns \n\t */\n\tstatic computeBbox(point: Point, r: number): Pointing[] {\n\n\t\tlet bbox = [];\n\t\tbbox.push(new Pointing(null, false, point.getSpherical().thetaRad - r, point.getSpherical().phiRad - r));\n\t\tbbox.push(new Pointing(null, false, point.getSpherical().thetaRad - r, point.getSpherical().phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.getSpherical().thetaRad + r, point.getSpherical().phiRad + r));\n\t\tbbox.push(new Pointing(null, false, point.getSpherical().thetaRad - r, point.getSpherical().phiRad - r));\n\n\t\treturn bbox;\n\t}\n\n\t// static setupByTile(tileno: number, hp: Healpix): HEALPixXYSpace {\n\n\t// \tlet xyGridProj: HEALPixXYSpace = {\n\t// \t\t\"min_y\": NaN,\n\t// \t\t\"max_y\": NaN,\n\t// \t\t\"min_x\": NaN,\n\t// \t\t\"max_x\": NaN,\n\t// \t\t\"gridPointsDeg\": []\n\t// \t}\n\n\n\t// \tlet cornersVec3 = hp.getBoundariesWithStep(tileno, 1);\n\t// \tlet pointings = [];\n\n\t// \tfor (let i = 0; i < cornersVec3.length; i++) {\n\t// \t\tpointings[i] = new Pointing(cornersVec3[i]);\n\t// \t\tif (i >= 1) {\n\t// \t\t\tlet a = pointings[i - 1].phi;\n\t// \t\t\tlet b = pointings[i].phi;\n\t// \t\t\t// case when RA is just crossing the origin (e.g. 357deg - 3deg)\n\t// \t\t\tif (Math.abs(a - b) > Math.PI) {\n\t// \t\t\t\tif (pointings[i - 1].phi < pointings[i].phi) {\n\t// \t\t\t\t\tpointings[i - 1].phi += 2 * Math.PI;\n\t// \t\t\t\t} else {\n\t// \t\t\t\t\tpointings[i].phi += 2 * Math.PI;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \tfor (let j = 0; j < pointings.length; j++) {\n\t// \t\tlet coThetaRad = pointings[j].theta;\n\t// \t\t// HEALPix works with colatitude (0 North Pole, 180 South Pole)\n\t// \t\t// converting the colatitude in latitude (dec)\n\t// \t\tlet decRad = Math.PI / 2 - coThetaRad;\n\n\t// \t\tlet raRad = pointings[j].phi;\n\n\t// \t\t// projection on healpix grid\n\t// \t\tlet p = new Point(CoordsType.ASTRO, NumberType.RADIANS, raRad, decRad);\n\t// \t\tlet xyDeg = HiPSHelper.world2intermediate(p.getAstro());\n\t// \t\txyGridProj.gridPointsDeg[j * 2] = xyDeg[0];\n\t// \t\txyGridProj.gridPointsDeg[j * 2 + 1] = xyDeg[1];\n\n\t// \t\tif (isNaN(xyGridProj.max_y) || xyDeg[1] > xyGridProj.max_y) {\n\t// \t\t\txyGridProj.max_y = xyDeg[1];\n\t// \t\t}\n\t// \t\tif (isNaN(xyGridProj.min_y) || xyDeg[1] < xyGridProj.min_y) {\n\t// \t\t\txyGridProj.min_y = xyDeg[1];\n\t// \t\t}\n\t// \t\tif (isNaN(xyGridProj.max_x) || xyDeg[0] > xyGridProj.max_x) {\n\t// \t\t\txyGridProj.max_x = xyDeg[0];\n\t// \t\t}\n\t// \t\tif (isNaN(xyGridProj.min_x) || xyDeg[0] < xyGridProj.min_x) {\n\t// \t\t\txyGridProj.min_x = xyDeg[0];\n\t// \t\t}\n\n\t// \t}\n\t// \treturn xyGridProj;\n\t// }\n\n\t// static world2intermediate(ac: AstroCoords): [number, number] {\n\n\t// \tlet x_grid: number;\n\t// \tlet y_grid: number;\n\n\t// \tif (Math.abs(ac.decRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t\t\t\n\t// \t\tx_grid = ac.raDeg;\n\t// \t\ty_grid = Hploc.sin(ac.decRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\t// \t\treturn [x_grid, y_grid];\n\n\t// \t} else if (Math.abs(ac.decRad) > HiPSHelper.THETAX) { // polar zones\n\n\t// \t\tconst raDeg = ac.raDeg;\n\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || ac.decRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\n\t// \t\tconst sigma = Math.sqrt(HiPSHelper.K * (1 - Math.abs(Hploc.sin(ac.decRad))));\n\t// \t\tconst phi_c = - 180 + (2 * Math.floor(((ac.raDeg + 180) * HiPSHelper.H / 360) + ((1 - w) / 2)) + w) * (180 / HiPSHelper.H);\n\n\t// \t\tx_grid = phi_c + (raDeg - phi_c) * sigma;\n\t// \t\ty_grid = (180 / HiPSHelper.H) * (((HiPSHelper.K + 1) / 2) - sigma);\n\n\t// \t\tif (ac.decRad < 0) {\n\t// \t\t\ty_grid *= -1;\n\t// \t\t}\n\t// \t\treturn [x_grid, y_grid]\n\t// \t}\n\n\t// \treturn [NaN, NaN];\n\n\t// }\n\n\t// static world2intermediate(sc: SphericalCoords): [number, number] {\n\t//     let x_grid: number;\n\t// \tlet y_grid: number;\n\n\t// \tif ( Math.abs(sc.thetaRad) <= HiPSHelper.THETAX) { // equatorial belts\n\t// \t\tx_grid = sc.phiDeg;\n\n\t// \t\ty_grid = Hploc.sin(sc.thetaRad) * HiPSHelper.K * 90 / HiPSHelper.H;\n\n\n\t// \t} else if ( Math.abs(sc.thetaRad) > HiPSHelper.THETAX) { // polar zones\n\n\t// \t\tlet phiDeg = sc.phiDeg;\n\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || sc.thetaRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\n\t// \t\tlet sigma = Math.sqrt( HiPSHelper.K * (1 - Math.abs(Hploc.sin(sc.thetaRad)) ) );\n\t// \t\tlet phi_c = - 180 + ( 2 * Math.floor( ((sc.phiRad + 180) * HiPSHelper.H/360) + ((1 - w)/2) ) + w ) * ( 180 / HiPSHelper.H );\n\n\t// \t\tx_grid = phi_c + (phiDeg - phi_c) * sigma;\n\t// \t\ty_grid = (180  / HiPSHelper.H) * ( ((HiPSHelper.K + 1)/2) - sigma);\n\n\t// \t\tif (sc.thetaRad < 0) {\n\t// \t\t\ty_grid *= -1;\n\t// \t\t}\n\t// \t}\n\n\t// \treturn [x_grid, y_grid];\n\n\t// }\n\n\t// static intermediate2pix(x: number, y: number, xyGridProj: HEALPixXYSpace, pxXtile: number): [number, number] {\n\t// \tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x);\n\t// \tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y);\n\n\t// \tlet i_norm: number;\n\t// \tlet j_norm: number;\n\t// \tif ((xyGridProj.min_x > 360 || xyGridProj.max_x > 360) && x < xyGridProj.min_x) {\n\t// \t\ti_norm = (x + 360 - xyGridProj.min_x) / xInterval;\n\t// \t} else {\n\t// \t\ti_norm = (x - xyGridProj.min_x) / xInterval;\n\t// \t}\n\t// \tj_norm = (y - xyGridProj.min_y) / yInterval;\n\n\n\t// \tlet i = 0.5 - (i_norm - j_norm);\n\t// \tlet j = (i_norm + j_norm) - 0.5;\n\n\t// \t// TODO CHECK THE FOLLOWING. BEFORE IT WAS i = Math.floor(i * HiPSHelper.pxXtile);\n\t// \tpxXtile\n\t// \t// i = Math.floor(i * HiPSHelper.DEFAULT_Naxis1_2);\n\t// \t// j = Math.floor(j * HiPSHelper.DEFAULT_Naxis1_2);\n\t// \t// return [i, HiPSHelper.DEFAULT_Naxis1_2 - j - 1];\n\t\t\n\t// \ti = Math.floor(i * pxXtile);\n\t// \tj = Math.floor(j * pxXtile);\n\t// \treturn [i, pxXtile - j - 1];\n\n\n\n\t// }\n\n\n\t// static pix2intermediate(i: number, j: number, xyGridProj: HEALPixXYSpace, naxis1: number, naxis2: number): [number, number] {\n\t// \t/**\n\t// \t   * (i_norm,w_pixel) = (0,0) correspond to the lower-left corner of the facet in the image\n\t// \t * (i_norm,w_pixel) = (1,1) is the upper right corner\n\t// \t * dimamond in figure 1 from \"Mapping on the HEalpix grid\" paper\n\t// \t * (0,0) leftmost corner\n\t// \t * (1,0) upper corner\n\t// \t * (0,1) lowest corner\n\t// \t * (1,1) rightmost corner\n\t// \t * Thanks YAGO! :p\n\t// \t */\n\t// \t// let cnaxis1 = HiPSHelper.pxXtile;\n\t// \t// let cnaxis2 = HiPSHelper.pxXtile;\n\n\t// \tlet cnaxis1 = naxis1;\n\t// \tlet cnaxis2 = naxis2;\n\t// \tif (naxis1) {\n\t// \t\tcnaxis1 = naxis1;\n\t// \t}\n\t// \tif (naxis2) {\n\t// \t\tcnaxis2 = naxis2;\n\t// \t}\n\t// \tlet i_norm = (i + 0.5) / cnaxis1;\n\t// \tlet j_norm = (j + 0.5) / cnaxis2;\n\n\t// \tlet xInterval = Math.abs(xyGridProj.max_x - xyGridProj.min_x) / 2.0;\n\t// \tlet yInterval = Math.abs(xyGridProj.max_y - xyGridProj.min_y) / 2.0;\n\t// \tlet yMean = (xyGridProj.max_y + xyGridProj.min_y) / 2.0;\n\n\t// \t// bi-linear interpolation\n\t// \tlet x = xyGridProj.max_x - xInterval * (i_norm + j_norm);\n\t// \tlet y = yMean - yInterval * (j_norm - i_norm);\n\n\t// \treturn [x, y];\n\t// }\n\n\n\t// static intermediate2world(x: number, y: number): Point {\n\n\t// \tlet phiDeg: number;\n\t// \tlet thetaDeg: number;\n\t// \tlet Yx = 90 * (HiPSHelper.K - 1) / HiPSHelper.H;\n\n\n\n\t// \tif (Math.abs(y) <= Yx) { // equatorial belts\n\n\t// \t\tphiDeg = x;\n\t// \t\tthetaDeg = radToDeg(Math.asin((y * HiPSHelper.H) / (90 * HiPSHelper.K)));\n\n\t// \t} else if (Math.abs(y) > Yx) { // polar regions\n\n\t// \t\tlet sigma = (HiPSHelper.K + 1) / 2 - Math.abs(y * HiPSHelper.H) / 180;\n\t// \t\tlet thetaRad = Hploc.asin(1 - (sigma * sigma) / HiPSHelper.K);\n\t// \t\tlet w = 0; // omega\n\t// \t\tif (HiPSHelper.K % 2 !== 0 || thetaRad > 0) { // K odd or thetax > 0\n\t// \t\t\tw = 1;\n\t// \t\t}\n\t// \t\tlet x_c = -180 + (2 * Math.floor((x + 180) * HiPSHelper.H / 360 + (1 - w) / 2) + w) * (180 / HiPSHelper.H);\n\t// \t\tphiDeg = x_c + (x - x_c) / sigma;\n\t// \t\tthetaDeg = radToDeg(thetaRad);\n\t// \t\tif (y <= 0) {\n\t// \t\t\tthetaDeg *= -1;\n\t// \t\t}\n\t// \t}\n\t// \t// return [phiDeg, thetaDeg];\n\t// \t// TODO CHECK THIS!\n\t// \t// let p = new Point(CoordsType.SPHERICAL, NumberType.DEGREES, phiDeg, thetaDeg);\n\t// \tlet p = new Point(CoordsType.ASTRO, NumberType.DEGREES, phiDeg, thetaDeg);\n\n\t// \treturn p;\n\n\t// }\n\n}\n","export class HiPSProperties {\n\n    static TILE_WIDTH:string = \"hips_tile_width\"\n    static FRAME:string = \"hips_frame\"\n    static ORDER:string = \"hips_order\"\n    static GALACTIC:string = \"galactic\"\n    static SCALE:string = \"hips_pixel_scale\"\n    static BITPIX:string = \"hips_pixel_bitpix\"\n\n\n    private itemMap: Map<string, any> = new Map<string, any>()\n\n    constructor(){}\n\n    addItem(key:string, value:any) {\n        this.itemMap.set(key, value)\n    }\n\n    getItem(key: string){\n        return this.itemMap.get(key)\n    }\n\n    isGalactic(){\n        return this.itemMap.get(HiPSProperties.FRAME) == HiPSProperties.GALACTIC\n    }\n\n}","import { FITSHeaderItem, FITSHeaderManager, FITSParsed, FITSParser, ParseUtils } from \"jsfitsio\"\n\nimport { HiPSIntermediateProj } from \"./HiPSIntermediateProj.js\"\nimport { Healpix, Pointing } from \"healpixjs\"\nimport { HEALPixXYSpace } from \"../../model/HEALPixXYSpace.js\"\nimport { astroToSpherical, fillAstro, radToDeg } from \"../../model/Utils.js\"\nimport { NumberType } from \"../../model/NumberType.js\"\nimport { HiPSHelper } from \"../HiPSHelper.js\"\nimport { HiPSProperties } from \"./HiPSProperties.js\"\nimport { ImagePixel } from \"./ImagePixel.js\"\n\nexport class HiPSFITS {\n\n    private payload: Array<Uint8Array> = []\n    private header!: FITSHeaderManager\n    private tileno!: number\n    private order!: number\n    private tileWidth!: number\n    private healpix!: Healpix\n    private intermediateXYGrid!: HEALPixXYSpace\n    private min: number = NaN\n    private max: number = NaN\n    private static CTYPE1 = \"RA---HPX\"\n    private static CTYPE2 = \"DEC--HPX\"\n    private static NPIX: string = \"NPIX\"\n\n\n    constructor(fitsParsed: FITSParsed | null, tileno: number | null, hipsProp: HiPSProperties | null) {\n\n        if (fitsParsed) {\n            this.initFromFITSParsed(fitsParsed)\n        } else if (!tileno || !hipsProp) {\n            console.error(\"tileno or hipsProp are not defined\")\n            throw new Error(\"tileno or hipsProp are not defined\")\n        } else {\n            this.order = hipsProp.getItem(HiPSProperties.ORDER)\n            const naxis1 = hipsProp.getItem(HiPSProperties.TILE_WIDTH)\n            const naxis2 = hipsProp.getItem(HiPSProperties.TILE_WIDTH)\n            this.tileno = tileno\n            if (naxis1 != naxis2) {\n                console.error(\"NAXIS1 and NAXIS2 do not match.\")\n                throw new Error(\"NAXIS1 and NAXIS2 do not match.\")\n            }\n            this.tileWidth = naxis1\n            this.tileno = tileno\n            this.healpix = HiPSHelper.getHelpixByOrder(this.order)\n            this.intermediateXYGrid = HiPSIntermediateProj.setupByTile(this.tileno, this.healpix)\n\n        }\n\n    }\n\n    initFromUint8Array(imagePixelList: ImagePixel[], fitsHeaderParams: FITSHeaderManager, tileWidth: number) {\n        this.setPayload(imagePixelList, fitsHeaderParams, tileWidth)\n        this.setHeader(fitsHeaderParams)\n    }\n    // initFromUint8Array(raDecList: [number, number][], originalValues: Uint8Array, fitsHeaderParams: FITSHeaderManager) {\n    //     this.setPayload(raDecList, originalValues, fitsHeaderParams)\n    //     this.setHeader(fitsHeaderParams)\n    // }\n\n    getHeader(){\n        return this.header\n    }\n\n    getPayload() {\n        return this.payload\n    }\n\n    initFromFITSParsed(fitsParsed: FITSParsed) {\n\n        this.payload = fitsParsed.data\n\n        this.order = Number(fitsParsed.header.findById(HiPSProperties.ORDER)?.value)\n        const naxis1 = Number(fitsParsed.header.findById(FITSHeaderManager.NAXIS1)?.value)\n        const naxis2 = Number(fitsParsed.header.findById(FITSHeaderManager.NAXIS2)?.value)\n        this.tileno = Number(fitsParsed.header.findById(HiPSFITS.NPIX)?.value)\n\n        if (isNaN(this.order) || isNaN(naxis1) || isNaN(naxis2) || isNaN(this.tileno)) {\n            console.warn(\"ORDER, NAXIS1 or NAXIS2 not defined\")\n            throw new Error(\"ORDER, NAXIS1 or NAXIS2 not defined\")\n        }\n        if (naxis1 != naxis2) {\n            console.error(\"NAXIS1 and NAXIS2 do not match.\")\n            throw new Error(\"NAXIS1 and NAXIS2 do not match.\")\n        }\n        this.tileWidth = naxis1\n        this.computeMinMax(fitsParsed)\n        this.setHeader(fitsParsed.header)\n\n    }\n\n    getTileno() {\n        return this.tileno\n    }\n\n    private computeMinMax(fitsParsed: FITSParsed) {\n\n        const bitpix = Number(fitsParsed.header.findById(FITSHeaderManager.BITPIX)?.value)\n        const bzero = Number(fitsParsed.header.findById(FITSHeaderManager.BZERO)?.value)\n        const bscale = Number(fitsParsed.header.findById(FITSHeaderManager.BSCALE)?.value)\n\n        const bytesXelem = Math.abs(bitpix / 8)\n\n        for (let ridx = 0; ridx < fitsParsed.data.length; ridx++) {\n            const row = fitsParsed.data[ridx]\n            for (let cidx = 0; cidx < row.length; cidx++) {\n                const valpixb = ParseUtils.extractPixelValue(0, this.payload[ridx].slice(cidx * bytesXelem, cidx * bytesXelem + bytesXelem), bitpix)\n                if (valpixb == null) {\n                    continue\n                }\n                const valphysical = bzero + bscale * valpixb;\n                if (valphysical < this.min || isNaN(this.min)) {\n                    this.min = valphysical;\n                } else if (valphysical > this.max || isNaN(this.max)) {\n                    this.max = valphysical;\n                }\n            }\n        }\n    }\n\n    static async downloadFITSFile(path: string) {\n        const fits = await FITSParser.loadFITS(path)\n        if (fits == null) {\n            console.warn(`fits ${path} doesn't exist`)\n            return null\n        }\n        return fits\n    }\n\n\n    getFITS(): FITSParsed {\n        return { header: this.header, data: this.payload }\n    }\n\n    private setPayload(imagePixelList: ImagePixel[], fitsHeaderParams: FITSHeaderManager, tileWidth: number) {\n\n\n        const bitpix = Number(fitsHeaderParams.findById(FITSHeaderManager.BITPIX)?.value)\n        const bzero = Number(fitsHeaderParams.findById(FITSHeaderManager.BZERO)?.value)\n        const bscale = Number(fitsHeaderParams.findById(FITSHeaderManager.BSCALE)?.value)\n\n        const bytesXelem = Math.abs(bitpix / 8)\n        if (!bytesXelem) {\n            console.error(\"BITPIX not defined\")\n            throw new Error(\"BITPIX not defined\")\n        }\n\n        this.payload = new Array(tileWidth)\n        for (let row = 0; row < tileWidth; row++) {\n            this.payload[row] = new Uint8Array(tileWidth * bytesXelem)\n        }\n\n\n        imagePixelList.forEach((imgpx) => {\n\n            const ra = imgpx.getRADeg()\n            const dec = imgpx.getDecDeg()\n            const ac = fillAstro(ra, dec, NumberType.DEGREES)\n            if (ac == null) {\n                console.error(`Error converting ${ra}, ${dec} into AstroCoords object`);\n                return;\n            }\n            const xy = HiPSIntermediateProj.world2intermediate(ac);\n            const [col, row] = HiPSIntermediateProj.intermediate2pix(xy[0], xy[1], this.intermediateXYGrid, tileWidth);\n        \n            if (row < 0 || row >= tileWidth || col < 0 || col >= tileWidth) return;\n\n            const valueBytes = imgpx.getUint8Value();\n            if (!valueBytes) return; // or continue, depending on context\n            \n            for (let b = 0; b < bytesXelem; b++) {\n                this.payload[row][col * bytesXelem + b] = valueBytes[b];\n            }\n\n            const valpixb = ParseUtils.extractPixelValue(0, valueBytes, bitpix);\n            if (valpixb == null) return;\n\n            const valphysical = bzero + bscale * valpixb;\n            if (isNaN(this.min) || valphysical < this.min) this.min = valphysical;\n            if (isNaN(this.max) || valphysical > this.max) this.max = valphysical;\n\n        });\n\n\n    }\n    // private setPayload(raDecList: [number, number][], originalValues: Uint8Array, fitsHeaderParams: FITSHeaderManager) {\n\n\n    //     const bitpix = Number(fitsHeaderParams.findById(FITSHeaderManager.BITPIX)?.value)\n    //     const bzero = Number(fitsHeaderParams.findById(FITSHeaderManager.BZERO)?.value)\n    //     const bscale = Number(fitsHeaderParams.findById(FITSHeaderManager.BSCALE)?.value)\n\n    //     const bytesXelem = Math.abs(bitpix / 8)\n    //     if (!bytesXelem) {\n    //         console.error(\"BITPIX not defined\")\n    //         throw new Error(\"BITPIX not defined\")\n    //     }\n\n    //     this.payload = new Array(this.tileWidth)\n    //     for (let row = 0; row < this.tileWidth; row++) {\n    //         this.payload[row] = new Uint8Array(this.tileWidth * bytesXelem)\n    //     }\n\n\n\n    //     for (let rdidx = 0; rdidx < raDecList.length; rdidx++) {\n\n    //         const [ra, dec] = raDecList[rdidx]\n\n    //         const ac = fillAstro(ra, dec, NumberType.DEGREES)\n    //         if (ac == null) {\n    //             console.error(`Error converting ${ra}, ${dec} into AstroCoords object`)\n    //             continue\n    //         }\n\n    //         const sc = astroToSpherical(ac)\n    //         const ptg = new Pointing(null, false, sc.thetaRad, sc.phiRad)\n    //         const pixtileno: number = this.healpix.ang2pix(ptg)\n    //         if (pixtileno != this.tileno) {\n    //             continue\n    //         }\n\n    //         const xy = HiPSIntermediateProj.world2intermediate(ac);\n    //         let ij = HiPSIntermediateProj.intermediate2pix(xy[0], xy[1], this.intermediateXYGrid, this.tileWidth);\n    //         const col = ij[0];\n    //         const row = ij[1];\n\n    //         for (let b = 0; b < bytesXelem; b++) {\n    //             const byte = originalValues[rdidx * bytesXelem + b];\n    //             this.payload[row][col * bytesXelem + b] = byte\n    //             // TODO check what's nodata!\n    //             // if (nodata.get(\"\" + pixtileno + \"\")) {\n    //             // \tif (byte != 0) {\n    //             // \t\tnodata.set(\"\" + pixtileno + \"\", false);\n    //             // \t}\n    //             // }\n\n    //             const valpixb = ParseUtils.extractPixelValue(0, this.payload[row].slice(col * bytesXelem, col * bytesXelem + bytesXelem), bitpix);\n    //             if (valpixb == null) {\n    //                 continue\n    //             }\n\n    //             const valphysical = bzero + bscale * valpixb;\n    //             if (valphysical < this.min || isNaN(this.min)) {\n    //                 this.min = valphysical;\n    //             } else if (valphysical > this.max || isNaN(this.max)) {\n    //                 this.max = valphysical;\n    //             }\n    //         }\n    //     }\n    // }\n\n    private addMandatoryItemToHeader(key: string, fitsHeaderParams: FITSHeaderManager) {\n        const value = fitsHeaderParams.findById(key)?.value\n        if (value === undefined || value == null) {\n            console.error(`${key} not defined`)\n            throw new Error(key + \" is not defined\")\n        }\n        const item = new FITSHeaderItem(key, value, \"\")\n        this.header.insert(item)\n    }\n\n    private addItemToHeader(key: string, fitsHeaderParams: FITSHeaderManager) {\n        const value = fitsHeaderParams.findById(key)?.value\n        if (value !== undefined || value != null) {\n            const item = new FITSHeaderItem(key, value, \"\")\n            this.header.insert(item)\n        }\n    }\n\n\n\n    private setHeader(fitsHeaderParams: FITSHeaderManager) {\n\n        this.header = new FITSHeaderManager()\n\n        this.addMandatoryItemToHeader(FITSHeaderManager.SIMPLE, fitsHeaderParams)\n        this.addMandatoryItemToHeader(FITSHeaderManager.BITPIX, fitsHeaderParams)\n\n        this.addItemToHeader(FITSHeaderManager.BLANK, fitsHeaderParams)\n        this.addItemToHeader(FITSHeaderManager.BSCALE, fitsHeaderParams)\n        this.addItemToHeader(FITSHeaderManager.BZERO, fitsHeaderParams)\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.NAXIS, Number(2), \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.NAXIS1, Number(this.tileWidth), \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.NAXIS2, Number(this.tileWidth), \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CTYPE1, HiPSFITS.CTYPE1, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CTYPE2, HiPSFITS.CTYPE2, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.DATAMIN, this.min, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.DATAMAX, this.min, \"\"))\n\n        this.header.insert(new FITSHeaderItem(HiPSProperties.ORDER, Number(this.order), \"\"))\n\n        this.header.insert(new FITSHeaderItem(HiPSFITS.NPIX, Number(this.tileno), \"\"))\n\n        const crpix = this.tileno / 2\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CRPIX1, crpix, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CRPIX2, crpix, \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.ORIGIN, \"WCSLight v.0.x\", \"\"))\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.COMMENT, \"\", \"WCSLight v0.x developed by F.Giordano and Y.Ascasibar\"))\n\n        let vec3 = this.healpix.pix2vec(this.tileno);\n        let ptg = new Pointing(vec3);\n        let crval1 = radToDeg(ptg.phi);\n        let crval2 = 90 - radToDeg(ptg.theta);\n\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CRVAL1, crval1, \"\"));\n        this.header.insert(new FITSHeaderItem(FITSHeaderManager.CRVAL2, crval2, \"\"));\n\n        this.header.insert(new FITSHeaderItem(\"END\", \"\", \"\"))\n\n\n    }\n\n\n}","import { FITSParser } from \"jsfitsio\";\nimport { HiPSFITS } from \"./HiPSFITS.js\";\n\nexport class FITSList{\n    private fitslist: Map<number, HiPSFITS> = new Map()\n\n    constructor(){}\n\n    getFITSList(): Map<number, HiPSFITS>{\n        return this.fitslist\n    }\n\n    getFITS(tileno: number): HiPSFITS | null {\n        const fits = this.fitslist.get(tileno)\n        return fits === undefined ? null : fits\n    }\n\n    async addFITSByURL(url: string) {\n        const fits = await FITSParser.loadFITS(url)\n        const hipsFits = new HiPSFITS(fits, null, null )\n        this.fitslist.set(hipsFits.getTileno(), hipsFits)\n    }\n\n    addFITS(fits: HiPSFITS) {\n        const tileno = fits.getTileno()\n        this.fitslist.set(tileno, fits)\n    }\n}","import { readFile } from \"node:fs/promises\";\nimport { HiPSProperties } from \"./HiPSProperties.js\";\n\n\nexport class HiPSPropManager {\n\n    static async parsePropertyFile(baseURL:string): Promise<HiPSProperties> {\n        let hipsPropText = \"\"\n        if (baseURL.includes(\"http\")) { // HiPS from web\n            hipsPropText = await HiPSPropManager.getPorpertyFromWeb(baseURL)\n        } else { // local HiPS\n            hipsPropText = await HiPSPropManager.getPorpertyFromFS(baseURL)\n        }\n        const hipsProp:HiPSProperties = HiPSPropManager.parseHiPSPropertiesBody(hipsPropText)\n        return hipsProp\n    }\n\n    private static async getPorpertyFromWeb(baseHiPSPath: string): Promise<string> {\n        const response = await fetch(baseHiPSPath + \"/properties\")\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`)\n        } else {\n            const propFile = await response.text()\n            return propFile\n        }\n        // let propFile: string\n        // if (response instanceof ArrayBuffer) {\n        //     const textDecoder = new TextDecoder(\"iso-8859-1\")\n        //     propFile = textDecoder.decode(new Uint8Array(response))\n        // } else {\n        //     propFile = response.toString()\n        // }\n        // return propFile\n    }\n\n    private static async getPorpertyFromFS(baseHiPSPath: string): Promise<string> {\n\n        const propPath = baseHiPSPath + \"/properties\"\n        const rawData: Buffer = await readFile(propPath)\n        const uint8 = new Uint8Array(rawData)\n        const textDecoder = new TextDecoder('ascii')\n        const propFile = textDecoder.decode(uint8);\n\n        return propFile\n    }\n\n    private static parseHiPSPropertiesBody(hipsPropText: string): HiPSProperties {\n        let hipsProp = new HiPSProperties()\n        const txtArr = hipsPropText.split('\\n');\n\n        for (let line of txtArr) {\n            if (!line.includes(\"=\")) {\n                continue;\n            }\n\n            const tokens = line.split(\"=\");\n            if (tokens[1] === undefined) {\n                continue;\n            }\n            const key = tokens[0].trim()\n            const val = tokens[1].trim()\n            let value: string|number = val\n            if (key == HiPSProperties.ORDER || key == HiPSProperties.TILE_WIDTH || key == HiPSProperties.SCALE || key == HiPSProperties.BITPIX) {\n                value = parseInt(val)\n            }\n            hipsProp.addItem(key, value)\n        }\n        return hipsProp\n    }\n}","import { FITSList } from \"./FITSList.js\";\nimport { HiPSProperties } from \"./HiPSProperties.js\"\nimport { HiPSPropManager } from \"./HiPSPropManager.js\";\nimport { Point } from \"../../model/Point.js\";\nimport { Healpix, Pointing, RangeSet } from \"healpixjs\";\nimport { degToRad } from \"../../model/Utils.js\";\nimport { HiPSIntermediateProj } from \"./HiPSIntermediateProj.js\";\nimport { FITSHeaderManager, FITSParser } from \"jsfitsio\";\nimport { HiPSFITS } from \"./HiPSFITS.js\";\nimport { ImagePixel } from \"./ImagePixel.js\";\nimport { HiPSHelper } from \"../HiPSHelper.js\";\nimport { CoordsType } from \"../../model/CoordsType.js\";\nimport { NumberType } from \"../../model/NumberType.js\";\nimport { HEALPixXYSpace } from \"../../model/HEALPixXYSpace.js\";\nimport { TilesRaDecList2 } from \"./TilesRaDecList2.js\";\n\n\n\nexport class HiPSProjection {\n\n    private baseURL: string\n    private healpix: Healpix | null = null\n    private hipsProp: HiPSProperties | null = null\n\n    constructor(baseHiPSPath: string) {\n        this.baseURL = baseHiPSPath\n        this.init()\n        if (this.healpix == null) {\n            console.warn(\"healpix is null\")\n            throw new Error(\"healpix is null\")\n        }\n        if (this.hipsProp == null) {\n            console.warn(\"HiPSProp is null\")\n            throw new Error(\"HiPSProp is null\")\n        }\n    }\n\n    async init() {\n        const hipsProp = await this.parsePropertyFile()\n        const order = hipsProp.getItem(HiPSProperties.ORDER)\n        this.healpix = HiPSHelper.getHelpixByOrder(order)\n    }\n\n    private async parsePropertyFile() {\n        const hipsProp = HiPSPropManager.parsePropertyFile(this.baseURL)\n        return hipsProp\n    }\n\n    static getImageRADecList(center: Point, radiusDeg: number, pixelAngSize: number, TILE_WIDTH: number): TilesRaDecList2 | null {\n\n\n\n        const healpix = HiPSHelper.getHelpixBypxAngSize(pixelAngSize, TILE_WIDTH)\n\n        // let tilesRaDecList2 = new TilesRaDecList2(healpix.order)\n        let tilesRaDecList2 = new TilesRaDecList2()\n\n\n        const ptg = new Pointing(null, false, center.getSpherical().thetaRad, center.getSpherical().phiRad);\n        const radius_rad = degToRad(radiusDeg);\n\n        // ??? with fact 8 the original Java code starts returning the the ptg pixel. with my JS porting only from fact 16\n        const rangeset: RangeSet = healpix.queryDiscInclusive(ptg, radius_rad, 4); // <= check it \n\n        // TODO try to replace tileslist with FITSList!!!\n        // const tileslist: Array<number> = [];\n        for (let p = 0; p < rangeset.r.length; p++) {\n\n            // if (!tileslist.includes(rangeset.r[p]) && rangeset.r[p] != 0) {\n            //     tileslist.push(rangeset.r[p]);\n            // }\n            if (!tilesRaDecList2.getTilesList().includes(rangeset.r[p]) && rangeset.r[p] != 0) {\n                tilesRaDecList2.addTileNumber(rangeset.r[p])\n                // tileslist.push(rangeset.r[p]);\n            }\n\n        }\n\n        const cpix = healpix.ang2pix(ptg);\n        // if (!tileslist.includes(cpix)) {\n        //     tileslist.push(cpix);\n        // }\n        if (!tilesRaDecList2.getTilesList().includes(cpix)) {\n            tilesRaDecList2.getTilesList().push(cpix);\n        }\n\n\n        // let raDecList: Array<[number, number]> = []\n        let minra = center.getAstro().raDeg - radiusDeg;\n        let maxra = center.getAstro().raDeg + radiusDeg;\n        let mindec = center.getAstro().decDeg - radiusDeg;\n        let maxdec = center.getAstro().decDeg + radiusDeg;\n\n        tilesRaDecList2.getTilesList().forEach((tileno: number) => {\n            // tileslist.forEach((tileno: number) => {\n\n            for (let j = 0; j < TILE_WIDTH; j++) {\n                for (let i = 0; i < TILE_WIDTH; i++) {\n\n                    const point: Point | null = HiPSProjection.pix2world(i, j, tileno, healpix, TILE_WIDTH);\n\n                    if (point == null) continue\n                    if (point.getAstro().raDeg < minra || point.getAstro().raDeg > maxra ||\n                        point.getAstro().decDeg < mindec || point.getAstro().decDeg > maxdec) {\n                        continue;\n                    }\n                    tilesRaDecList2.addImagePixel(new ImagePixel(point.getAstro().raDeg, point.getAstro().decDeg, tileno))\n                    // raDecList.push([point.getAstro().raDeg, point.getAstro().decDeg]);\n                }\n            }\n        })\n\n        // const tilesRaDecList = new TilesRaDecList(raDecList, tileslist)\n        // return tilesRaDecList\n        return tilesRaDecList2\n    }\n\n    static pix2world(i: number, j: number, tileno: number, healpix: Healpix, TILE_WIDTH: number): Point | null {\n\n        let p = null\n        if (healpix) {\n            const xyGridProj = HiPSIntermediateProj.setupByTile(tileno, healpix);\n            let xy = HiPSIntermediateProj.pix2intermediate(i, j, xyGridProj, TILE_WIDTH, TILE_WIDTH);\n            // TODO CHECK BELOW before it was only which is supposed to be wrong since intermediate2world returns SphericalCoords, not AstroCoords\n            /**  \n            let raDecDeg = HiPSHelper.intermediate2world(xy[0], xy[1]);\n            if (raDecDeg[0] > 360){\n                raDecDeg[0] -= 360;\n            }\n            return raDecDeg;\n            */\n            p = HiPSIntermediateProj.intermediate2world(xy[0], xy[1]);\n            // if (p.spherical.phiDeg > 360){\n            // \tsc.phiDeg -= 360;\n            // }\n        } else {\n            throw new Error(\"Healpix not set.\"); // or handle the issue as per your use case\n        }\n\n\n        return p;\n    }\n\n    // static getFITSFiles(inputValues: Uint8Array, tilesRaDecList: TilesRaDecList, fitsHeaderParams: FITSHeaderManager, pixelAngSize: number, TILE_WIDTH?: number): FITSList {\n    static getFITSFiles(tilesRaDecList: TilesRaDecList2, fitsHeaderParams: FITSHeaderManager, pixelAngSize: number, TILE_WIDTH: number): FITSList {\n\n        const healpix = HiPSHelper.getHelpixBypxAngSize(pixelAngSize, TILE_WIDTH)\n\n        let fitsList = new FITSList()\n\n        tilesRaDecList.getTilesList().forEach((tileno: number) => {\n            let hipsProp = new HiPSProperties()\n            hipsProp.addItem(HiPSProperties.ORDER, healpix.order)\n            hipsProp.addItem(HiPSProperties.TILE_WIDTH, TILE_WIDTH)\n            const hipsFits = new HiPSFITS(null, tileno, hipsProp)\n\n            const imagePixelsByTilesNo = tilesRaDecList.getImagePixelsByTile(tileno)\n\n            hipsFits.initFromUint8Array(imagePixelsByTilesNo, fitsHeaderParams, TILE_WIDTH)\n            fitsList.addFITS(hipsFits)\n        })\n        return fitsList\n\n    }\n\n    static async world2pix(radeclist:  TilesRaDecList2, hipsOrder: number, isGalactic: boolean, TILE_WIDTH: number, baseHiPSURL: string): Promise<TilesRaDecList2 | null> {\n\n        const healpix = HiPSHelper.getHelpixByOrder(hipsOrder)\n\n        let tileno: number;\n        let prevTileno: number | null = null;\n        /* if HiPS in galactic => convert the full list of (RA, Dec) to Galactic  (l, b) */\n        if (isGalactic) {\n            HiPSProjection.convertToGalactic(radeclist);\n        }\n        let xyGridProj: HEALPixXYSpace | null = null\n\n\n\n        radeclist.getImagePixelList().forEach((imgpx) => {\n            const ra = imgpx.getRADeg()\n            const dec = imgpx.getDecDeg()\n\n            const p = new Point(CoordsType.ASTRO, NumberType.DEGREES, ra, dec);\n            const ptg = new Pointing(null, false, p.getSpherical().thetaRad, p.getSpherical().phiRad);\n\n            tileno = healpix.ang2pix(ptg);\n\n            if (prevTileno !== tileno || prevTileno == null) {\n                xyGridProj = HiPSIntermediateProj.setupByTile(tileno, healpix);\n                prevTileno = tileno;\n            }\n            if (xyGridProj) {\n                const xy = HiPSIntermediateProj.world2intermediate(p.getAstro());\n                const ij = HiPSIntermediateProj.intermediate2pix(xy[0], xy[1], xyGridProj, TILE_WIDTH);\n                imgpx.setij(ij[0], ij[1])\n                imgpx.setTileNumber(tileno)\n            }\n            radeclist.addTileNumber(tileno)\n        });\n        let result = await HiPSProjection.getPixelValues(radeclist, baseHiPSURL, hipsOrder)\n        return result\n    }\n\n    // TODO move this to Utils.js\n    static convertToGalactic(radeclist: TilesRaDecList2) {\n        // let finalradeclist: number[][] = [];\n        const deg2rad = Math.PI / 180\n        const rad2deg = 180 / Math.PI\n        const l_NCP = deg2rad * 122.930\n        const d_NGP = deg2rad * 27.1284\n        const a_NGP = deg2rad * 192.8595\n        radeclist.getImagePixelList().forEach( (imgpx) => {\n            const ra = imgpx.getRADeg()\n            const dec = imgpx.getDecDeg()\n            const ra_rad = deg2rad * ra\n            const dec_rad = deg2rad * dec\n            // sin(b)\n            const sin_b = Math.sin(d_NGP) * Math.sin(dec_rad) +\n                Math.cos(d_NGP) * Math.cos(dec_rad) * Math.cos(ra_rad - a_NGP);\n            const b = Math.asin(sin_b)\n            const b_deg = b * rad2deg\n\n            // l_NCP - l\n            const lNCP_minus_l = Math.atan((Math.cos(dec_rad) * Math.sin(ra_rad - a_NGP)) /\n                (Math.sin(dec_rad) * Math.cos(d_NGP) - Math.cos(dec_rad) * Math.sin(d_NGP) * Math.cos(ra_rad - a_NGP)));\n            const l = l_NCP - lNCP_minus_l\n            const l_deg = l * rad2deg\n            imgpx.setRADecDeg(l_deg, b_deg)\n            // finalradeclist.push([l_deg, b_deg])\n        });\n        // return finalradeclist;\n    }\n\n    static async getPixelValues(raDecList: TilesRaDecList2, baseHiPSURL: string, hipsOrder: number): Promise<TilesRaDecList2 | null> {\n\n        const tilesset = raDecList.getTilesList()\n        let promises = [];\n        \n        for (let hipstileno of tilesset) {\n\n            const dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n            const fitsurl = baseHiPSURL + \"/Norder\" + hipsOrder + \"/Dir\" + dir + \"/Npix\" + hipstileno + \".fits\";\n            console.log(`Identified source file ${fitsurl}`)\n\n            // TODO change the code below to used HiPSFITS and FITSList instead!\n            promises.push(FITSParser.loadFITS(fitsurl).then((fitsParsed) => {\n\n                if (fitsParsed) {\n\n                    const bitpix = Number(fitsParsed.header.findById(\"BITPIX\")?.value)\n                    const naxis1 = Number(fitsParsed.header.findById(\"NAXIS1\")?.value)\n                    const naxis2 = Number(fitsParsed.header.findById(\"NAXIS2\")?.value)\n                    if (!bitpix || !naxis1 || !naxis2) {\n                        console.error(`bitpix: ${bitpix}, naxis1: ${naxis1}, naxis2: ${naxis2} for fits file ${fitsurl}`)\n                        return\n                    }\n                    if (raDecList.getBLANK() == null) {\n                        const blankStr = fitsParsed.header.findById(\"BLANK\")?.value\n                        if (blankStr) {\n                            const blank = Number(blankStr)\n                            if (!isNaN(blank)) {\n                                raDecList.setBLANK(blank)\n                            }\n                        }\n                    }\n                    if (raDecList.getBSCALE() == null) {\n                        const bscaleStr = fitsParsed.header.findById(\"BSCALE\")?.value\n                        if (bscaleStr) {\n                            const bscale = Number(bscaleStr)\n                            if (!isNaN(bscale)) {\n                                raDecList.setBSCALE(bscale)\n                            }\n                        }\n                    }\n                    if (raDecList.getBZERO() == null) {\n                        const bzeroStr = fitsParsed.header.findById(\"BZERO\")?.value\n                        if (bzeroStr) {\n                            const bzero = Number(bzeroStr)\n                            if (!isNaN(bzero)) {\n                                raDecList.setBZERO(bzero)\n                            }\n                        }\n                    }\n\n                    // if (naxis1 * naxis2 * Math.abs(bitpix / 8) != fitsParsed.data.length) {\n                    //     console.error(`fits data length ${fitsParsed.data.length} does not match expected size ${naxis1 * naxis2 * Math.abs(bitpix / 8)} for fits file ${fitsurl}`)\n                    //     return\n                    // }\n\n                    const bytesXelem = Math.abs(bitpix / 8);\n\n                    raDecList.getImagePixelsByTile(hipstileno).forEach((imgpx) => {\n                        const valueBytes = new Uint8Array(bytesXelem);\n                        if (fitsParsed.data[imgpx.getj()] == undefined) {\n                            console.warn(`j index ${imgpx.getj()} is outside the image range 0-${naxis2 - 1} for fits file ${fitsurl}`)\n                            return\n                        }\n                        if ((imgpx.geti() * bytesXelem + bytesXelem) > fitsParsed.data[imgpx.getj()].length) {\n                            console.warn(`i index ${imgpx.geti()} is outside the image range 0-${(fitsParsed.data[imgpx.getj()].length / bytesXelem) - 1} for fits file ${fitsurl}`)\n                            return\n                        }\n                        for (let b = 0; b < bytesXelem; b++) {\n                            valueBytes[b] = fitsParsed.data[imgpx.getj()][imgpx.geti() * bytesXelem + b];\n                        }\n                        imgpx.setValue(valueBytes, bitpix);\n                        raDecList.setMinMaxValue(imgpx.getValue())\n                    })\n                }\n            }));\n        }\n        await Promise.all(promises);\n        if (raDecList.getBSCALE() == null) {\n            raDecList.setBSCALE(1)\n        }\n        if (raDecList.getBZERO() == null) {\n            raDecList.setBZERO(0)\n        }\n        if (raDecList.getBLANK() == null) {\n            raDecList.setBLANK(0)\n        }\n        return raDecList\n    }\n\n}","import { FITS } from \"../../model/FITS.js\"\nimport { AbstractProjection } from \"../AbstractProjection.js\"\nimport { RADecMinMaxCentral } from \"../RADecMinMaxCentral.js\"\n\nexport class CutoutResult {\n    fits: FITS\n    fitsused: string[]\n    projection: AbstractProjection\n    raDecMinMaxCentral: RADecMinMaxCentral\n    pxsize: number\n\n\n    constructor(fits: FITS, fitsused: string[], projection: AbstractProjection, raDecMinMaxCentral: RADecMinMaxCentral, pxsize: number) {\n        this.fits = fits\n        this.fitsused = fitsused\n        this.projection = projection\n        this.raDecMinMaxCentral = raDecMinMaxCentral\n        this.pxsize = pxsize\n    }\n\n}","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\nimport { FITSParsed, FITSParser } from 'jsfitsio';\nimport { MercatorProjection } from './projections/mercator/MercatorProjection.js';\nimport { HiPSProjection } from './projections/hips/HiPSProjection.js';\nimport { Point } from './model/Point.js';\nimport { AbstractProjection } from './projections/AbstractProjection.js';\nimport { FITS } from './model/FITS.js';\nimport { FITSList } from './projections/hips/FITSList.js';\nimport { HiPSFITS } from './projections/hips/HiPSFITS.js';\nimport { HiPSPropManager } from './projections/hips/HiPSPropManager.js';\nimport { HiPSProperties } from './projections/hips/HiPSProperties.js';\nimport { HiPSHelper } from './projections/HiPSHelper.js';\nimport { TilesRaDecList2 } from './projections/hips/TilesRaDecList2.js';\nimport { CutoutResult } from './projections/hips/CutoutResult.js';\n\nexport class WCSLight {\n\n    /**\n     * This function receives a FITS and generate a cutout on HiPS FITS.\n     * @param center of the cutout in degrees\n     * @param radius of the cutout in degrees\n     * @param pxsize of the cutout in degrees\n     * @param filePath of the input FITS file\n     * @returns fitsList of FITS in HiPS format\n     */\n    static async fitsCutoutToHiPS(center: Point, radius: number,\n        pxsize: number, filePath: string): Promise<FITSList | null> {\n\n        const HiPS_TILE_WIDTH = 512\n\n        // 0. here is missing the validation/check that the input file used to get the value, contains the center ...\n        \n        // 1. open input fits file and understand the projection and set up in inprojection details like NAXIS1-2, CDELT1-2, CRVAL1-2, minRa and minDec\n        const inProjection = await WCSLight.extractProjectionType(filePath)\n        if (!inProjection) return null\n        // const bitpix = inProjection.getBitpix()\n        \n        // 2. from HiPS output projection, compute the list of RA,Dec and related tileno based on center, radius, pxsize, and tilewidth forced to 512\n        const outTilesRaDecList: TilesRaDecList2|null = HiPSProjection.getImageRADecList(center, radius, pxsize, HiPS_TILE_WIDTH)\n        if (!outTilesRaDecList) {\n            return null\n        }\n\n        // 3. by using the list of RA and Dec on point 2., convert RA,Dec into i,j used in the input projection to get pixel values (try to merge the 2 calls below in one single method)\n        inProjection.world2pix(outTilesRaDecList)\n        // const invalues = await inProjection.getPixValues(tilesRaDecList)\n        \n        // 4. collect the details required to construct the output HiPS projection header \n        // const fitsHeaderParams = inProjection.getCommonFitsHeaderParams();\n\n        // here pass inProjection.getFITSHeader()\n        // 5. generate output HiPS FITS file(s)\n        const fitsFileList = HiPSProjection.getFITSFiles(outTilesRaDecList, inProjection.getFITSHeader(), pxsize, HiPS_TILE_WIDTH);\n        for( let hipsFitsEntry of fitsFileList.getFITSList()) {\n            const tileno = hipsFitsEntry[0]\n            const hipsFits = hipsFitsEntry[1]\n            const data = hipsFits.getPayload()\n            const header = hipsFits.getHeader() \n            const FITS_FILE_PATH = `./hips_${tileno}.fits`\n\n            const fitsParsed = {header: header, data: data}\n            FITSParser.saveFITSLocally(fitsParsed, FITS_FILE_PATH)\n        }\n        return fitsFileList\n        \n    }\n\n    // only MERCATOR supported at the moment\n    static async extractProjectionType(filePath: string): Promise<AbstractProjection | null> {\n        let fits: FITSParsed | null = await FITSParser.loadFITS(filePath)\n        if (!fits) return null\n        \n        const ctype = String(fits.header.findById(\"CTYPE1\")?.value)\n        \n        if (ctype.includes(\"MER\")){\n            let projection = new MercatorProjection()\n            await projection.initFromFile(filePath)\n            return projection\n        }\n        return null\n\n    }\n\n    // TODO: instead of using AbstractProjection, use a constant file with supported projection names\n    static async hipsCutoutToFITS(center: Point, radius: number,\n        pixelAngSize: number, baseHiPSURL: string, outproj: AbstractProjection, hipsOrder: number | null = null ): Promise<CutoutResult | null> {\n        \n        const hipsProp = await HiPSPropManager.parsePropertyFile(baseHiPSURL)\n        const hipsMaxOrder: number = hipsProp.getItem(HiPSProperties.ORDER)\n        const hipsFrame = hipsProp.getItem(HiPSProperties.FRAME)\n        const TILE_WIDTH = hipsProp.getItem(HiPSProperties.TILE_WIDTH)\n        \n\n        let isGalactic: boolean = false\n        if (hipsFrame.toLowerCase() == 'galactic') {\n            isGalactic = true\n        }\n\n        if (!hipsOrder) {\n            const healpix = HiPSHelper.getHelpixBypxAngSize(pixelAngSize, TILE_WIDTH, hipsMaxOrder)\n            hipsOrder = Number(healpix.order)    \n        }\n        \n        /*\n        below how naxis are computed\n        outproj.getImageRADecList -> computeSquaredNaxes -> set naxis1 and naxis2\n        */\n        const naxisWidth: number = outproj.computeNaxisWidth(radius, pixelAngSize)\n        const outRADecList: TilesRaDecList2 = outproj.getImageRADecList(center, radius, pixelAngSize, naxisWidth)\n        if (!outRADecList) return null\n\n\n        const raDecMinMaxCentral = outRADecList.computeRADecMinMaxCentral()\n        if (raDecMinMaxCentral == null) return null\n        const cRA = raDecMinMaxCentral?.getCentralRA()\n        const cDec = raDecMinMaxCentral?.getCentralDec()\n        if (cRA === undefined || cDec === undefined) return null\n        \n        // TODO check if possible to compute in the word2pix, when iterating onver ImagePixels, the min and max value.\n        const raDecWithValues = await HiPSProjection.world2pix(outRADecList, hipsOrder, isGalactic, TILE_WIDTH, baseHiPSURL)\n        if (!raDecWithValues) return null\n        const minValue = raDecWithValues.getMinMaxValues()?.getMinValue()\n        const maxValue = raDecWithValues.getMinMaxValues()?.getMaxValue()\n        if (minValue === undefined || maxValue === undefined) return null\n        \n        /** info required:\n         * SIMPLE  = T                                                                     \n            BITPIX  = -64                                                                   \n            NAXIS   = 2                                                                     \n            NAXIS1  = 512                                                                   \n            NAXIS2  = 512                                                                   \n            BSCALE  = 1                                                                     \n            BZERO   = 0                                                                     \n            CTYPE1  = RA---HPX                                                              \n            CTYPE2  = DEC--HPX                                                              \n            DATAMIN = 0                                                                     \n            DATAMAX = 0                                                                     \n            hips_order= 7                                                                   \n            NPIX    = 113056                                                                \n            CRPIX1  = 56528                                                                 \n            CRPIX2  = 56528                                                                 \n            ORIGIN  = WCSLight v.0.x                                                        \n            COMMENT =  / WCSLight v0.x developed by F.Giordano and Y.Ascasibar              \n            CRVAL1  = 170.15625                                                             \n            CRVAL2  = 18.5243910738658                                                      \n            END                                                                             \n         */\n        // TODO BLANK, BZERO, BSCALE must be taken from the FITS tiles and not from the HiPS metadata.\n        const BLANK = raDecWithValues.getBLANK()\n        const BZERO = raDecWithValues.getBZERO()\n        const BSCALE = raDecWithValues.getBSCALE()\n        if (BLANK === null || BZERO === null || BSCALE === null) return null\n        console.log(`BLANK: ${BLANK}, BZERO: ${BZERO}, BSCALE: ${BSCALE}`)\n\n        // validate BITPIX\n        const BITPIX: number = parseInt(hipsProp.getItem(HiPSProperties.BITPIX))\n        if (BITPIX != 8 && BITPIX != 16 && BITPIX != 32 && BITPIX != -32 && BITPIX != -64) {\n            throw new Error(\"unsupported BITPIX value\")\n        }\n\n        const fits: FITS = outproj.generateFITSFile(\n            pixelAngSize, \n            hipsProp.getItem(HiPSProperties.BITPIX),  \n            naxisWidth, \n            BLANK, BZERO, BSCALE,\n            cRA, cDec,\n            minValue, maxValue, raDecWithValues)\n        \n        console.log(fits)\n\n        const FITS_FILE_PATH = `./cartesian2.fits`\n        const fitsParsed:FITSParsed = {header: fits.getHeader(), data: fits.getData()}\n        FITSParser.saveFITSLocally(fitsParsed, FITS_FILE_PATH)\n\n        let hipsUsed = Array<string>()\n        raDecWithValues.getTilesList().forEach( (hipstileno) => {\n            const dir = Math.floor(hipstileno / 10000) * 10000; // as per HiPS recomendation REC-HIPS-1.0-20170519 \n            const fitsurl = baseHiPSURL + \"/Norder\" + hipsOrder + \"/Dir\" + dir + \"/Npix\" + hipstileno + \".fits\";\n            hipsUsed.push(fitsurl)\n        })\n\n        const result = new CutoutResult(fits, hipsUsed, outproj, raDecMinMaxCentral, pixelAngSize)\n\n        return result\n    }\n\n    static hipsFITSChangeProjection(): HiPSFITS | null {\n\n        return null\n    }\n\n\n    /**\n     * \n     * @param {*} fitsheader \n     * @param {*} fitsdata \n     * @returns {URL}\n     */\n    // static generateFITS(fitsheader: any, fitsdata: any): string {\n    //     const fitsParsed = {\n    //         header: fitsheader,\n    //         data: fitsdata\n    //     }\n    //     // const blobUrl = FITSParser.generateFITSForWeb(fitsheader, fitsdata);\n    //     const blobUrl = FITSParser.generateFITSForWeb(fitsParsed);\n    //     return blobUrl;\n    // }\n\n\n    static getAvaillableProjections() {\n        return [\"Mercator\", \"HiPS\", \"HEALPix\"];\n    }\n\n}\n","/**\n * Summary. (bla bla bla)\n *\n * Description. (bla bla bla)\n * \n * @link   github https://github.com/fab77/wcslight\n * @author Fabrizio Giordano <fabriziogiordano77@gmail.com>\n */\n\n\n\nexport class ImagePixel {\n    _i: number;     // int i of input projection\n    _j: number;     // int j of input projection\n    _tileno: number;// int\n    \n    constructor (i: number, j: number, tileno: number = NaN) {\n        this._i = i;\n        this._j = j;\n        this._tileno = tileno;\n    }\n\n    geti() {\n        return this._i;\n    }\n\n    getj() {\n        return this._j;\n    }\n\n    get tileno() {\n        return this._tileno\n    }\n}\n"],"names":["root","factory","exports","module","define","amd","this","inProgress","dataWebpackPrefix","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","m","d","definition","key","o","Object","defineProperty","enumerable","get","f","e","chunkId","Promise","all","keys","reduce","promises","u","g","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","call","l","url","done","push","script","needAttach","scripts","document","getElementsByTagName","i","length","s","getAttribute","createElement","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","event","onerror","onload","clearTimeout","doneFns","parentNode","removeChild","forEach","fn","setTimeout","bind","type","target","head","appendChild","r","Symbol","toStringTag","value","scriptUrl","importScripts","location","currentScript","test","Error","replace","p","installedChunks","j","installedChunkData","promise","resolve","reject","error","errorType","realSrc","message","name","request","webpackJsonpCallback","parentChunkLoadingFunction","data","chunkIds","moreModules","runtime","some","id","chunkLoadingGlobal","NumberType","CoordsType","FITSWriter","createFITS","fitsParsed","headerBytes","createHeader","header","dataBytes","createData","fitsFile","Uint8Array","set","BLOCK","MUST_INT","Set","IS_LOGICAL","items","getItems","kw","toUpperCase","padEnd","slice","card80","makeCommentCards","kind","text","prefix","width","t","toString","out","makeKeywordWithComment","comment","K","base","val","has","padStart","n","Number","isFinite","isInteger","String","toExponential","valueField20","add","spaceLeft","overflow","map","Map","it","cards","simple","bitpix","naxis","nAxes","ki","extend","headerString","join","pad","repeat","TextEncoder","encode","totalLength","c","Math","abs","findById","elems","k","expectedUnpadded","off","chunk","remainder","padded","writeFITSFile","filePath","console","log","FITSHeaderItem","_key","_value","_comment","constructor","FITSHeaderManager","static","SIMPLE","BITPIX","NAXIS","NAXIS1","NAXIS2","insert","item","remove","filter","find","ParseHeader","getFITSItemValue","VALUE","parse","rawdata","headerText","TextDecoder","decode","lines","match","line","trim","rawValue","split","isNaN","includes","ParseUtils","getStringAt","offset","chars","fromCharCode","charCodeAt","byteString","substr","parse32bitSinglePrecisionFloatingPoint","byte1","byte2","byte3","byte4","long","pow","convertBlankToBytes","blank","nbytes","str","buffer","ArrayBuffer","uint8","parseInt","parseFloatingPointFormat","bytes","ebits","fbits","bits","byte","reverse","bias","substring","Infinity","generate16bit2sComplement","TypeError","parse16bit2sComplement","unsigned","parse32bit2sComplement","res","getByteAt","extractPixelValue","px_val","ParsePayload","computePhysicalMinAndMax","rawData","DATAMIN","DATAMAX","min","max","computePhysicalValues","maxitem","minitem","endItem","BLANK","BZERO","BSCALE","bytesXelem","pxLength","byteLength","physicalblank","pixel2physicalValue","ph_val","pxval","FITSParser","loadFITS","uint8data","getFile","processFits","headerFinalised","paddedPayload","buf","padTo2880","createMatrix","payload","matrix","saveFITSLocally","path","uri","toLowerCase","getLocalFile","AbstractProjection","cartesianToSpherical","xyz","dotXYZ","b","a","x","y","z","sqrt","thetaRad","acos","thetaDeg","radToDeg","phiRad","atan2","phiDeg","sphericalToAstro","phiTheta","raDeg","decDeg","degToRad","astroToSpherical","raDec","sphericalToCartesian","sin","cos","fillAstro","ra","dec","unit","DEGREES","RADIANS","fillSpherical","phi","theta","degrees","PI","radians","Config","Point","astro","spherical","cartesian","in_type","coords","CARTESIAN","parseFloat","toFixed","MAX_DECIMALS","ASTRO","SPHERICAL","getSpherical","getAstro","getCartesian","MinMaxValue","getMinValue","getMaxValue","RADecMinMaxCentral","centralRA","centralDec","minRA","minDec","maxRA","maxDec","getMinRA","getMinDec","getMaxRA","getMaxDec","getCentralRA","getCentralDec","setMinRA","setMinDec","setMaxRA","setMaxDec","setCentralRA","cRA","setCentralDec","cDec","TilesRaDecList2","tileList","imagePixelList","minPixelValue","maxPixelValue","Array","setBZERO","setBSCALE","setBLANK","getBZERO","getBSCALE","getBLANK","findImagePixel","getImagePixelsByTile","tileno","getImagePixelList","getTilesList","addImagePixel","imgpx","addTileNumber","computeRADecMinMaxCentral","setMinMaxValue","getMinMaxValues","ImagePixel","uint8value","NaN","geti","getj","getRADeg","getDecDeg","getUint8Value","getValue","setValue","setTileNumber","setij","setRADecDeg","FITS","setData","from","values","flatMap","row","getHeader","getData","MercatorProjection","minra","mindec","naxis1","naxis2","fitsheader","pxvalues","CTYPE1","CTYPE2","craDeg","cdecDeg","pxsize","pxsize1","pxsize2","_wcsname","super","initFromFile","infile","fits","getBytePerValue","extractPhysicalValues","bzero","bscale","physicalvalues","n2","n1","pixval","physicalVal","prepareHeader","pixelAngSize","TILE_WIDTH","minValue","maxValue","getFITSHeader","getCommonFitsHeaderParams","computeNaxisWidth","radius","ceil","getImageRADecList","center","naxisWidth","tilesRaDecList","pix2world","setPixelValues","raDecList","bytesPerElem","height","pixels","idx","floor","col","rowArr","u8","generateFITSFile","raDecWithValues","world2pix","bytesXvalue","blankBytes","imgPx","currentValue","Constants","halfpi","inv_halfpi","twopi","inv_twopi","Zphi","z_","phi_","Hploc","ptg","PI4_A","PI4_B","PI4_C","M_1_PI","sth","have_sth","_phi","setZ","setSth","toVec3","st","Vec3","toZphi","q","sincoshelper","asin","mulsign","atan2k","copySign","magnitude","sign","atanhelper","isinf","isnan","Pointing","vec3","mirror","in_theta","in_phi","in_x","in_y","in_z","getX","getY","getZ","scale","cross","v","normalize","norm","lengthSquared","dot","v1","sub","angle","flip","pointing2Vec3","pointing","CircleFinder","point","np","cosrad","getCircle","getCircle2","q1","q2","getCenter","getCosrad","Fxyf","fx","fy","face","jrll","jpll","toHploc","nr","loc","jr","tmp","pstack","sz","Int32Array","p_","o_","pop","popToMark","size","mark","otop","ptop","RangeSet","cap","append","append1","newsize","rnew","ensureCapacity","resize","sliced","Xyf","ix","iy","Healpix","nside_in","order_max","twothird","ns_max","ctab","Uint16Array","utab","Int16Array","xoffset","yoffset","facearray","swaparray","nside","npface","npix","order","nside2order","nl2","nl3","nl4","fact2","fact1","ncap","bn","mpr","cmpr","smpr","computeBn","maxPixrad","getNPix","getBoundaries","pix","points","xyf","nest2xyf","dc","xc","yc","getBoundariesWithStep","step","getPointsForXyfNoStep","getPointsForXyf","neighbours","ipix","result","face_num","nsm1","fpix","px0","spread_bits","py0","pxp","pyp","pxm","pym","nbnum","tint","xyf2nest","log2","compress_bits","loc2pix","hploc","pixNo","za","tt","fmodulo","temp1","temp2","jp","jm","ifp","ifm","ntt","tp","pix2vec","pix2loc","pix2zphi","ang2pix","v2","raw","queryPolygonInclusive","vertex","fact","inclusive","nv","vv","normal","index","back","first","medium","last","hnd","splice","rad","fill","cf","queryMultiDisc","oplus","ilog2","omax","crlimit","dr","Float64Array","stk","pv","zone","crad","iz","check_pixel","arg","clz32","cosdist_zphi","z1","phi1","z2","phi2","pixset","sdist","zphia","xyz1","convertZphi2xyz","va","t1","zphib","xyz2","vb","zphi","queryDiscInclusive","vptg","crpdr","crmdr","sinrad","cdr","sdr","curro","pos","cangdist","HiPSIntermediateProj","setupByTile","hp","xyGridProj","cornersVec3","pointings","coThetaRad","decRad","raRad","xyDeg","world2intermediate","gridPointsDeg","max_y","min_y","max_x","min_x","ac","x_grid","y_grid","THETAX","H","w","sigma","phi_c","intermediate2pix","pxXtile","i_norm","j_norm","xInterval","yInterval","pix2intermediate","cnaxis1","cnaxis2","yMean","intermediate2world","Yx","x_c","HiPSHelper","computeOrder","pxAngSizeDeg","pxTileWidth","pxAngSizeRad","computedOrder","getHelpixByOrder","getHelpixBypxAngSize","pixelAngulaSize","hipsMaxOrder","healpixOrder","computePxAngularSize","computedPxAngSizeRadiant","rad2deg","deg","arcmin","arcsec","computePxSize","computeBbox","bbox","HiPSProperties","itemMap","addItem","getItem","isGalactic","FRAME","GALACTIC","HiPSFITS","tileWidth","healpix","intermediateXYGrid","hipsProp","initFromFITSParsed","ORDER","initFromUint8Array","fitsHeaderParams","setPayload","setHeader","getPayload","NPIX","warn","computeMinMax","getTileno","ridx","cidx","valpixb","valphysical","downloadFITSFile","getFITS","xy","valueBytes","addMandatoryItemToHeader","addItemToHeader","crpix","CRPIX1","CRPIX2","ORIGIN","COMMENT","crval1","crval2","CRVAL1","CRVAL2","FITSList","fitslist","getFITSList","addFITSByURL","hipsFits","addFITS","HiPSPropManager","parsePropertyFile","baseURL","hipsPropText","getPorpertyFromWeb","getPorpertyFromFS","parseHiPSPropertiesBody","baseHiPSPath","response","fetch","ok","status","propPath","readFile","txtArr","tokens","SCALE","HiPSProjection","init","radiusDeg","tilesRaDecList2","radius_rad","rangeset","cpix","maxra","maxdec","getFITSFiles","fitsList","imagePixelsByTilesNo","radeclist","hipsOrder","baseHiPSURL","prevTileno","convertToGalactic","ij","getPixelValues","deg2rad","l_NCP","d_NGP","a_NGP","ra_rad","dec_rad","sin_b","b_deg","lNCP_minus_l","atan","l_deg","tilesset","hipstileno","fitsurl","then","blankStr","bscaleStr","bzeroStr","CutoutResult","fitsused","projection","raDecMinMaxCentral","WCSLight","fitsCutoutToHiPS","inProjection","extractProjectionType","outTilesRaDecList","fitsFileList","hipsFitsEntry","FITS_FILE_PATH","hipsCutoutToFITS","outproj","hipsFrame","outRADecList","hipsUsed","dir","hipsFITSChangeProjection","getAvaillableProjections","_i","_j","_tileno"],"sourceRoot":""}